Component Schema Flights Example
--------------------------------

The following set of examples illustrates how to take an ObjectStore
database application and package it into a component that can be
included into a larger application. Each example is based on an application 
called Flights that stores information that could be used by an 
airline reservations program, for example.

The four examples are:

   Non-Component Schema Flight example, statically linked.  
   This example is simply linked to all the object files
   and uses a regular application schema.

   The Flight example, statically linked with the flight_cs component.
   Because the flight_cs component is statically linked to
   the executable, the component is implicitly loaded when
   the application starts.

   The Flight example, dynamically linked with the flights_cs component.
   This example uses explicit runtime DLL loading of the
   flight_cs component.

   The Flight example, dynamically linked with the flights_cs2 component.
   This example uses explicit run-time DLL loading of the
   flight_cs2 component.

Each Flight example uses the following four classes for persistent
database storage:

   Flight
   Plane
   String
   Person

A transient class, FlightMenu, is also used by each Flight example.

Note: On Solaris2, a dynamic load library (DLL) is commonly called 
"Shared Library" or "Shared Object" and by default has a '.so' file 
extension.  On Win32 platforms, the dynamic load library is 
simply called "DLL" and has a default '.dll' file extension.

To demonstrate the component schema feature the Flight, Plane, String, 
Person, and FlightMenu classes are grouped into a 
separate dynamic load library named 'flight_cs.[so|dll]'.  

This DLL contains all of the object code for the classes listed above
as well as the component schema object code generated by ossg. There is
also made a second DLL called 'flight_cs2.[so|dll],' which is the
same as 'flight_cs' but has the automated component schema load/unload
reporting disabled and sets the component schema info name.  The
DLL 'flight_cs2' demonstrates how to manually control the loading 
and unloading of the component schema. 


Files Used by the Example Programs
==================================

Here is a list of the files in this directory:

   main.cpp  - Main for the 'Flights' application
   fmenu.cpp and fmenu.hh  - Code for 'FlightMenu' class.
   flight.cpp and flight.hh  - Code for 'Flight' class.
   plane.cpp and plane.hh  - Code for 'Plane' class.
   person.cpp and person.hh  - Code for 'Person' class.
   string.cpp and string.hh  - Code for 'String' class.
   force_vfts.cpp  - Code to force compiler to instantiate virtual 
                     function tables 
   common.hh  - Some common definitions.
   makefile  - Makefile for unix platforms.
   desktop.mak  - Makefile for Win32 platforms.
   schema.cpp  - Normal schema source file.
   comp_schema.cpp  - Schema source files for flight_cs component schema.
   comp_schema2.cpp  - Schema source files for flight_cs2 component schema.
   readme  - this file.


Building the Example Programs
=============================

Running 'make all' will build the 'flight_cs' DLL, named flight_cs.so or 
flight_cs.dll, and the  'flight_cs2' DLL, named flight_cs2.so or 
flight_cs2.dll and the following executables:

   flights  - Non-Component Schema Flight example, statically linked.  
   
   flights2 - Flight example, statically linked with the flight_cs component.
   
   flights3 - Flight example, dynamically linked with flights_cs component.
   
   flights4 - Flight example, dynamically linked with flights_cs2 component.
   
Note that the preceding files will have the extension .exe on Windows
systems, and no file extension on Unix systems. 

The entry point to the flight_cs and flight_cs2 component is a C function 
called  'flight_db_component', which takes the name of the database as its 
only argument.  All of the examples set a function pointer to this 
function and simply call it to use the component.  For the statically linked 
cases, the linker resolves this function reference.  For the dynamically 
loaded case, a dynamic symbol name lookup function is used after the
DLL is loaded. 

The transient class 'FlightMenu' is used by all the flights examples for 
the ascii menu and user interface processing. 


Running the Example Programs
============================

1. Before running any of the programs be sure the example directory
   (that is, the directory in which you build the examples) is included 
   in your shared library path. For Solaris systems, this is 
   done with the LD_LIBRARY_PATH environment variable. For Windows
   systems, this is done automatically.

   An example for Solaris systems running C shell:

     SETENV LD_LIBRARY_PATH `pwd`:${LD_LIBRARY_PATH}

2. To run any of the examples, use a command line of this form: 

      flightsn database-name.db 

   For example, on a Unix system the following is a valid command:

      flights2 foo.db 

3. When the program is executed, the following menu appears:

 
    FLIGHT MENU 
    _______________________
 
     1.      ...Populate Database...
     2.      ...Show All Flights...
     3.      ...Add Flight...
     4.      ...Get Flight...
     5.      ...Book a Passenger...
     6.      ...Find Flights On A Particular Route...
     7.      ...Find Flights With Big Enough Planes...
     8.      ...Exit And Close Database...
 
 
              Please enter choice (1,2,3,4,5,6,7,or 8):

4. As a first step in using the application, select menu item 1 to
   populate the database. A random set of Flights data is filled in 
   after you specify at the prompt how many flights the database can
   have. Select menu item 2 to see what flights are currently described
   and menu item 8 when you want to exit the program.




