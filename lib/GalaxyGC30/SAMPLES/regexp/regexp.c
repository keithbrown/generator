/* $Id: regexp.c,v 1.1 1995/03/31 21:46:17 robert Exp $
 *
 * The following Sample Code is provided for your reference purposes in
 * connection with your use of the Galaxy Application Environment (TM) software
 * product which you have licensed from Visix Software, Inc. ("Visix").
 * The Sample code is provided to you without any warranty of any kind
 * whatsoever and you agree to be responsible for the use and/or incorporation
 * of the Sample Code into any software product you develop. You agree to fully
 * and completely indemnify and hold Visix harmless from any and all loss,
 * claim, liability or damages with respect to your use of the Sample Code.  
 *
 * Subject to the foregoing, you are permitted to copy, modify, and distribute
 * the Sample Code for any purpose and without fee, provided that (i) a
 * copyright notice in the in the form of "Copyright 1992,93,94,95 Visix
 * Software Inc., 11440 Commerce Park Drive, Reston, VA  22091. All Rights
 * Reserved" appears in all copies, (ii) both the copyright notice and this
 * permission notice appear in supporting documentation and (iii) you are a
 * valid licensee of Galaxy Application Environment.
 */

/****************************************************************************
 * executable:    regexp
 * .c files:      regexp.c
 * resource file: regexp.vr
 *
 * This program can be used to test simple regular expressions directly.
 *
 * This demo consists of a single dialog.  It has a pattern field to enter
 * the regular expression and a target field to enter the string that gets
 * searched.  The result and the value of any tagged segments are placed
 * in output text fields.  There are also toggle items to set whether the
 * search is case sensitive or proceeds from the end of the target string.
 *
 ****************************************************************************/

#ifndef vportINCLUDED
#include <vport.h> /* for v*HEADER */
#endif

/* ANSI headers */
#include vstdlibHEADER
			/* for exit(), EXIT_ codes */

/* Galaxy headers */
#include vprefHEADER
#include vnameHEADER
#include veventHEADER
#include vresourceHEADER
#include vregexpHEADER
#include vnumHEADER
#include vapplicationHEADER
#include vdialogHEADER
#include vbuttonHEADER
#include vtextitemHEADER
#include vcontrolHEADER
#include vcomboHEADER


/* forward references */
static void shutdownMain (void);
static void dialogNoteProc (vdialog *dialog, vevent *event);
static void searchNoteProc (vbutton *button, vevent *event);
static void quitNoteProc (vbutton *button, vevent *event);


/* Constants (generated by vre) */

enum {
	_generated_CaseSensitive,
	_generated_Segment0,
	_generated_Segment1,
	_generated_Segment2,
	_generated_Segment3,
	_generated_Segment4,
	_generated_Segment5,
	_generated_Segment6,
	_generated_Segment7,
	_generated_Segment8,
	_generated_Segment9,
	_generated_ResultLabel,
	_generated_SearchButton,
	_generated_Backwards,
	_generated_Label2,
	_generated_Label3,
	_generated_Label4,
	_generated_Label5,
	_generated_Label6,
	_generated_Label7,
	_generated_Label8,
	_generated_Label9,
	_generated_Dialog,
	_generated_Quit,
	_generated_Label1,
	_generated_Label0,
	_generated_RegexpLabel,
	_generated_Target,
	_generated_TargetLabel,
	_generated_Result,
	_generated_Regexp,
	_generatedCOUNT
};


#define generated_CaseSensitive		 _generatedPredefs[_generated_CaseSensitive]
#define generated_Segment0		 _generatedPredefs[_generated_Segment0]
#define generated_Segment1		 _generatedPredefs[_generated_Segment1]
#define generated_Segment2		 _generatedPredefs[_generated_Segment2]
#define generated_Segment3		 _generatedPredefs[_generated_Segment3]
#define generated_Segment4		 _generatedPredefs[_generated_Segment4]
#define generated_Segment5		 _generatedPredefs[_generated_Segment5]
#define generated_Segment6		 _generatedPredefs[_generated_Segment6]
#define generated_Segment7		 _generatedPredefs[_generated_Segment7]
#define generated_Segment8		 _generatedPredefs[_generated_Segment8]
#define generated_Segment9		 _generatedPredefs[_generated_Segment9]
#define generated_ResultLabel		 _generatedPredefs[_generated_ResultLabel]
#define generated_SearchButton		 _generatedPredefs[_generated_SearchButton]
#define generated_Backwards		 _generatedPredefs[_generated_Backwards]
#define generated_Label2		 _generatedPredefs[_generated_Label2]
#define generated_Label3		 _generatedPredefs[_generated_Label3]
#define generated_Label4		 _generatedPredefs[_generated_Label4]
#define generated_Label5		 _generatedPredefs[_generated_Label5]
#define generated_Label6		 _generatedPredefs[_generated_Label6]
#define generated_Label7		 _generatedPredefs[_generated_Label7]
#define generated_Label8		 _generatedPredefs[_generated_Label8]
#define generated_Label9		 _generatedPredefs[_generated_Label9]
#define generated_Dialog		 _generatedPredefs[_generated_Dialog]
#define generated_Quit		 _generatedPredefs[_generated_Quit]
#define generated_Label1		 _generatedPredefs[_generated_Label1]
#define generated_Label0		 _generatedPredefs[_generated_Label0]
#define generated_RegexpLabel		 _generatedPredefs[_generated_RegexpLabel]
#define generated_Target		 _generatedPredefs[_generated_Target]
#define generated_TargetLabel		 _generatedPredefs[_generated_TargetLabel]
#define generated_Result		 _generatedPredefs[_generated_Result]
#define generated_Regexp		 _generatedPredefs[_generated_Regexp]


const vname	 *_generatedPredefs[_generatedCOUNT];
static const char	 *_generated_predefStrings[] = {
	"CaseSensitive",
	"Segment0",
	"Segment1",
	"Segment2",
	"Segment3",
	"Segment4",
	"Segment5",
	"Segment6",
	"Segment7",
	"Segment8",
	"Segment9",
	"ResultLabel",
	"SearchButton",
	"Backwards",
	"Label2",
	"Label3",
	"Label4",
	"Label5",
	"Label6",
	"Label7",
	"Label8",
	"Label9",
	"Dialog",
	"Quit",
	"Label1",
	"Label0",
	"RegexpLabel",
	"Target",
	"TargetLabel",
	"Result",
	"Regexp"
};


/* Note - this function, generatedInternNames(), was generated by vre */
void generatedInternNames() 
{
	register int	i;

	for ( i = 0; i < _generatedCOUNT; i++ ) 
		_generatedPredefs[i]
		  = vnameInternGlobalLiteral( _generated_predefStrings[i] );
}


/*
 * Initial test strings
 */

static const char *cannedRegexps[] = {
	"[\\-\\+]?[0-9]*\\.?[0-9]*",	/* should match floating point */
					/* numbers with opt everything */
	"[\\-\\+]?[0-9]*\\.[0-9]*",	/* force the decimal point */
	"[\\-\\+]?[0-9]*\\.*[0-9]*",	/* zero or more decimal points */
	"a*.*b*",			/* something simple */
	"a+b+",				/* even simpler */
	"^a+b+$",			/* try anchors */
	NULL
};

static const char *cannedStrings[] = {
	"123",
	"123.",
	"1234.5",
	"1234.5678",
	"123..",
	"123.45",
	"-123....4",
	"-.",
	"-",
	"-1",
	"a",
	"ab",
	"acb",
	"aaa",
	"b",
	"aabb",
	"aaaaacb",
	"aaaaabbbbb",
	"ababab",
	NULL
};



/*********
 * main()
 *
 * The main program for our simpleCalc example.
 *
 **********/
int main (int argc, char **argv)
{
  vdialog     *dialog;
  vbutton     *button;
  vresource    resource;
  vcombo      *regexpCombo, *targetCombo;
  const char  **canned;

  /* Initialize Galaxy */
  vprefSetArgs(argc, argv);

  vresourceStartup();
  vregexpStartup();
  vnumStartup();
  vapplicationStartup();
  vdialogStartup();
  vbuttonStartup();
  vtextitemStartup();
  vcontrolStartup();
  vcomboStartup();

  /* call the function generated by vre to intern all dialog item tags */
  generatedInternNames();

  /*
   * Load the dialog from the application resource file.
   */

  resource = vresourceGet (vapplicationGetResources (vapplicationGetCurrent()),
			   generated_Dialog);
  dialog = vdialogLoad (resource);
  vdialogSetNotify (dialog, dialogNoteProc);

  /*
   * Find the buttons and attach their notifies.
   */

  button = (vbutton *) vdialogFindItem (dialog, generated_SearchButton);
  vbuttonSetNotify (button, searchNoteProc);
  
  button = (vbutton *) vdialogFindItem (dialog, generated_Quit);
  vbuttonSetNotify (button, quitNoteProc);
  
  /*
   * Attach some canned strings to the combos.
   */

  regexpCombo = (vcombo *)vdialogFindItem(dialog, generated_Regexp);
  canned = cannedRegexps;
  while (*canned != NULL)
    vcomboAppendTextScribed(regexpCombo, vcharScribeLiteral(*(canned++)));

  targetCombo = (vcombo *)vdialogFindItem(dialog, generated_Target);
  canned = cannedStrings;
  while (*canned != NULL)
    vcomboAppendTextScribed(targetCombo, vcharScribeLiteral(*(canned++)));

  /* Open the dialog */
  vwindowPlace(vdialogGetWindow(dialog), vwindowGetRoot(), 
	       vrectPLACE_CENTER, vrectPLACE_CENTER);
  vdialogOpen (dialog);

  /* Enter the event loop */
  veventProcess ();

  /* Return the dialog's resources to the system */
  vdialogDestroy (dialog);

  exit (EXIT_SUCCESS);
  return EXIT_FAILURE;

}


/*********
 *  shutdownMain()
 *
 *  Stop things.
 *
 **********/
static void shutdownMain()
{

  veventStopProcessing();

}


/*********
 *  dialogNoteProc()
 *
 *  The dialog notification procedure gets called whenever any 
 *  major event applies to the dialog as a whole.  We need to
 *  look for the event which tells us that the dialog has
 *  closed.
 *
 **********/
static void dialogNoteProc (vdialog *dialog, vevent *event)
{
  int      et;

  et = veventGetType (event);
  
  if (et == veventWINDOW_STATE && veventIsClose (event))
    shutdownMain ();

}


/*********
 *  quitNoteProc
 *
 *  This button notification procedure gets called whenever the user
 *  presses the Quit button. Quit.
 *
 **********/
static void quitNoteProc (vbutton *button, vevent *event)
{
  shutdownMain();
}


/*********
 *  searchNoteProc
 *
 *  This button notification procedure gets called whenever the user
 *  presses the Search button. Do the regular expression search and put
 *  the product in the visual result box.
 *
 **********/
static void searchNoteProc (vbutton *button, vevent *event)
{
  int        i;
  vdialog   *dialog;
  int        resultLen;
  vcombo    *regexpCombo, *targetCombo;
  vtextitem *resultItem;
  vscribe   *volatile resultAsScribe;
  vchar     *result;
  vregexp   * volatile regexp;
  vstr      *string;
  vcontrol  *caseToggle, *backwardsToggle;
  vtextitem *segmentText[10];
  vbool	     backwards;
  size_t     len;

  dialog =  vdialogDetermineItemDialog (vbuttonGetItem (button));
  regexpCombo = (vcombo *)vdialogFindItem(dialog, generated_Regexp);
  targetCombo = (vcombo *)vdialogFindItem(dialog, generated_Target);
  resultItem = (vtextitem *)vdialogFindItem(dialog, generated_Result);
  caseToggle = (vcontrol *)vdialogFindItem(dialog, generated_CaseSensitive);
  backwardsToggle = (vcontrol *)vdialogFindItem(dialog, generated_Backwards);

  segmentText[0] = (vtextitem *)vdialogFindItem(dialog, generated_Segment0);
  segmentText[1] = (vtextitem *)vdialogFindItem(dialog, generated_Segment1);
  segmentText[2] = (vtextitem *)vdialogFindItem(dialog, generated_Segment2);
  segmentText[3] = (vtextitem *)vdialogFindItem(dialog, generated_Segment3);
  segmentText[4] = (vtextitem *)vdialogFindItem(dialog, generated_Segment4);
  segmentText[5] = (vtextitem *)vdialogFindItem(dialog, generated_Segment5);
  segmentText[6] = (vtextitem *)vdialogFindItem(dialog, generated_Segment6);
  segmentText[7] = (vtextitem *)vdialogFindItem(dialog, generated_Segment7);
  segmentText[8] = (vtextitem *)vdialogFindItem(dialog, generated_Segment8);
  segmentText[9] = (vtextitem *)vdialogFindItem(dialog, generated_Segment9);

  vexWITH_HANDLING
  {
    regexp = vregexpCreateScribed(vcomboGetTextScribed(regexpCombo));
  }
  vexON_EXCEPTION
    {
      regexp = NULL;
    }
  vexEND_HANDLING;

  backwards = vcontrolGetValue(backwardsToggle);

  if (regexp != NULL)
    {
      vregexpSetCaseSensitive(regexp, vcontrolGetValue(caseToggle));
      vregexpSetDirection(regexp,
			  backwards ? vregexpBACKWARD : vregexpFORWARD);
    }

  string = vcomboGetTextAsString(targetCombo);
  len = vcharLength(string);

  if (regexp == NULL)
    resultAsScribe = vcharScribeLiteral("Bad regexp.\n");
  else if ((result = vregexpSearch(regexp, backwards ? string + len : string,
				   len, &resultLen)) != NULL)
    resultAsScribe = vscribeScribeMulti(vnumScribeInt(result - string),
					vcharScribeLiteral(", "),
					vnumScribeInt(resultLen),
					vcharScribeLiteral(": "),
					vcharSizedScribe(result, resultLen),
					NULL);
  else
    resultAsScribe = vcharScribeLiteral("No match.\n");

  vtextitemSetTextScribed(resultItem, resultAsScribe);

  for (i = 0; i < 10; i++)
    {
      if (regexp != NULL
	  && (result = vregexpGetSegment(regexp, i)) != NULL)
	resultAsScribe = vcharScribe(result);
      else
	resultAsScribe = vcharScribeLiteral("   <null>");

      vtextitemSetTextScribed(segmentText[i], resultAsScribe);
    }

  if (regexp != NULL)
    vregexpDestroy(regexp);

  vstrDestroy(string);
}


