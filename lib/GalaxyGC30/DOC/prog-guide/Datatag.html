<HTML>
<HEAD>
<TITLE>Datatag</TITLE>
</HEAD>

<BODY background="graphics/bg.gif" BGCOLOR="#FFFFFF" TEXT="#000000">

<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0">
	<TR>
		<!-- Margin Banner -->
		<TD WIDTH="130"><CENTER><IMG SRC="graphics/logo.gif">
		<IMG WIDTH="130" SRC="graphics/trans.gif"></CENTER></TD>
		<!-- Margin Spacer -->
		<TD ROWSPAN="2" WIDTH="20">
		<IMG WIDTH="20" SRC="graphics/trans.gif"><P></TD>
	
	
		<!-- Title block: DOCUMENT TITLE GOES HERE -->
		<TD VALIGN=TOP><BR>
		     <H1>Datatag</H1>
		     <BR>
		</TD>

	</TR><TR>
	
		<!-- Navigation Icons & Related Topics -->
		<TD WIDTH="130" VALIGN="TOP" ALIGN="LEFT"> 
		
		<CENTER>
		<BR>
		<IMG WIDTH=6 HEIGHT=21 SRC="graphics/trans.gif">
		
	
  		<!-- These are the Navigation buttons -->
		<A HREF="DAS.html"><IMG WIDTH=24 HEIGHT=31 BORDER=0 SRC="graphics/left.gif"></A>
		<A HREF="index.html"><IMG WIDTH=22 HEIGHT=33 BORDER=0 SRC="graphics/up.gif"></A>
		<A HREF="Date.html"><IMG WIDTH=24 HEIGHT=31 BORDER=0 SRC="graphics/right.gif"></A>

		
		<IMG WIDTH=6 HEIGHT=21 SRC="graphics/trans.gif">
		<BR>
  </CENTER>
		</TD>
	
		<!-- Text Area -->
		<TD VALIGN="TOP" ROWSPAN="2">
			<BR>
			
<!---------------------------------->
<!-- Begin actual manual material -->
<!---------------------------------->

 
<A NAME="3204"></A>
The <EM><B>Datatag </B></EM>class allows you to create and manipulate application data descriptions called <EM><B>datatags</B></EM>. A datatag is an object that describes the structure and contents of a piece of application data. Datatags are principally used to layer a Representation class API on top of any application-defined data structure. This allows the application data to be efficiently converted to other representations that are unfamiliar or hidden from the application.<P>
Datatags are also used for storing data structure definitions in resource files. This allows an application that wants to share its data with other applications to describe the structure and contents of the data in a portable way.<P>
The Datatag class uses Representation class concepts and functions extensively. Familiarity with the Representation class will greatly assist you in understanding the Datatag class.<P>
<A NAME="5460"><H2> Datatags</H2></A>
A datatag corresponds to a type definition in a programming language. To understand datatags it is worthwhile to recognize the characteristics of type definitions and how they are mirrored by various portions of the Datatag class.<P>
A type definition in a programming language is a description of the contents and conceptual layout of a piece of application data. A programming language type definition can be one of a set of primitive type definitions or a compound definition built from both primitive type definitions and other compound definitions. Many language type definitions can also be named using language primitives such as the <TT>typedef</TT> declaration in C.<P>
The coding conventions for many languages suggest that related type definitions can be collected together in a module separate from the code module. This allows the sharing of type definitions among code modules.<P>
The Datatag class parallels programming language type definitions in several ways. Just as programming languages provide primitive type definitions, the Datatag class defines a set of primitive datatags. <A HREF="Datatag.html#5518">Table 11</A> lists Datatag class methods that return primitive datatags corresponding to common primitive types.<P>

<TABLE BORDER="3">

<CAPTION><A NAME="5471"><I>Table 11.  Datatag class type definitions 
</I><P>
</CAPTION>

<tr><th><B>Datatag class Function
</B></th><th><B> Type Definition
</B></th>
<tr><td><TT><B>vdatatagGetByte
</B></TT></td><td>8-bit signed scalar
</td></tr>
<tr><td><TT><B>vdatatagGetUnsignedByte
</B></TT></td><td>8-bit unsigned scalar
</td></tr>
<tr><td><TT><B>vdatatagGetShort
</B></TT></td><td>16-bit signed scalar
</td></tr>
<tr><td><TT><B>vdatatagGetUnsignedShort
</B></TT></td><td>16-bit unsigned scalar
</td></tr>
<tr><td><TT><B>vdatatagGetInteger
</B></TT></td><td>32-bit signed scalar
</td></tr>
<tr><td><TT><B>vdatatagGetUnsignedInteger
</B></TT></td><td>32-bit unsigned scalar
</td></tr>
<tr><td><TT><B>vdatatagGetSingleFloat
</B></TT></td><td>single-precision float
</td></tr>
<tr><td><TT><B>vdatatagGetDoubleFloat
</B></TT></td><td>double-precision float
</td></tr>


</TABLE>

<TABLE>

<TR><TD>

</TABLE>
<P>
Since Galaxy defines a number of other data types that are "primitive" to Galaxy applications, there are datatags that correspond to these data types. <A HREF="Datatag.html#5578">Table 12</A> lists Datatag class methods that return primitive datatags corresponding to Galaxy primitive types.<P>

<TABLE BORDER="3">

<CAPTION><A NAME="5526"><I>Table 12.  Datatag class type definitions (Galaxy types)
</I><P>
</CAPTION>

<tr><th><B>Datatag class Function
</B></th><th><B>Galaxy Type Definition
</B></th>
<tr><td>vdatatagGetBoolean
</td><td><TT>vbool
</TT></td></tr>
<tr><td>vdatatagGetCharacter
</td><td><TT>vchar
</TT></td></tr>
<tr><td>vdatatagGetFixed
</td><td><TT>vfixed
</TT></td></tr>
<tr><td>vdatatagGetLonglong
</td><td><TT>vlonglong
</TT></td></tr>
<tr><td>vdatatagGetUnsignedlonglong
</td><td><TT>vlonglong
</TT></td></tr>
<tr><td>vdatatagGetString
</td><td><TT>vchar *
</TT></td></tr>
<tr><td>vdatatagGetTag
</td><td><TT>const vname *
</TT></td></tr>
<tr><td>vdatatagGetDatatag
</td><td><TT>vdatatag *
</TT></td></tr>
<tr><td>vdatatagGetScrap
</td><td><TT>vscrap *
</TT></td></tr>


</TABLE>

<TABLE>

<TR><TD>

</TABLE>
<P>
Note that <TT><B>Get</B></TT> functions return predefined datatags rather than create new instances of them.<P>
As with type definitions in programming languages, datatags are meant to be shared by many modules. Consequently, the primitive datatag types are owned by the Datatag class module and shared by all applications using the Datatag class.<P>
In most programming languages, type definitions can also express how data is stored, such as in fixed-size arrays, pointers, and opaque data blocks. <A HREF="Datatag.html#6300">Table 13</A> lists the Datatag class functions that can be used to describe similar constructs with datatags.<P>

<TABLE BORDER="3">

<CAPTION><A NAME="5590"><I>Table 13.  Storage Types created by the Datatag class
</I><P>
</CAPTION>

<tr><th><B>Datatag
</B></th><th><B>Storage Types
</B></th>
<tr><td>vdatatagCreateDict
</td><td><TT>vdict
</TT></td></tr>
<tr><td>vdatatagCreatePointer
</td><td>pointer
</td></tr>
<tr><td>vdatatagCreateArray
</td><td>variable-length array
</td></tr>
<tr><td>vdatatagCreateSizedArray
</td><td>fixed-length array
</td></tr>
<tr><td>vdatatagGetOpaque
</td><td>variable-length opaque
</td></tr>
<tr><td>vdatatagCreateSizedOpaque
</td><td>fixed-length opaque
</td></tr>
<tr><td>vdatatagCreateCompound
</td><td>structure
</td></tr>


</TABLE>

<TABLE>

<TR><TD>

</TABLE>
<P>
With the exception of <TT><B>GetOpaque</B></TT>, these functions create new datatags instead of returning predefined datatags. This is because each of these storage types requires extra information in order to be useful. For example, an array cannot be fully defined without the type definition for the elements in the array; a fixed-size array is not fully defined if the number of elements in the array is not specified. Various functions are available for setting the information needed to complete these storage-related type definitions.<P>
<A NAME="3358"><H2>  Key Functionality</H2></A>
<A HREF="Datatag.html#5643">Example 16</A> shows how to create a datatag that describes a fixed-size array of 77 double-precision floating point values.<P>
<A NAME="5643"><I>Example 16.  Creating a datatag for a fixed-size array
</I><P>
<PRE><UL>{
   vdatatag *larry;

   larry = vdatatagCreateSizedArray();
   vdatatagSetSizedArrayCount(larry, 77);
   vdatatagSetSizedArrayDatatag(larry,
                                vdatatagGetDoubleFloat());
   // ...
   vdatatagDestroy(larry);
}

</UL></PRE><A HREF="Datatag.html#5667">Example 17</A> shows how to create a datatag that describes a pointer to a <TT>vlonglong</TT>.<P>
<A NAME="5667"><I>Example 17.  Creating a datatag describing a pointer
</I><P>
<PRE><UL>{
   vdatatag *moe;

   moe = vdatatagCreatePointer();
   vdatatagSetPointerDatatag(moe, vdatatagGetLonglong());
   // ...
   vdatatagDestroy(moe);
}

</UL></PRE><A HREF="Datatag.html#5688">Example 18</A> shows how to create a datatag that describes a dictionary containing an unsigned byte, a tag, and a string.<P>
<A NAME="5688"><I>Example 18.  Creating a datatag describing a dictionary
</I><P>
<PRE><UL>{
   const vname *huey, *dewey, *louie;
   vdatatag    *curly;

   huey  = vnameInternGlobalLiteral("happy");
   dewey = vnameInternGlobalLiteral("fun");
   louie = vnameInternGlobalLiteral("ball");

   curly = vdatatagCreateDict();
   vdatatagSetDictElementDatatag(curly, huey,
                                 vdatatagGetUnsignedByte());
   vdatatagSetDictElementDatatag(curly, dewey,
                                 vdatatagGetTag());
   vdatatagSetDictElementDatatag(curly, louie,
                                 vdatatagGetString());
   // ...
   vdatatagDestroy(curly);
}

</UL></PRE>The Datatag class can also be used to describe data structures defined by an application. For example, the application-defined data structure shown in <A HREF="Datatag.html#5730">Example 19</A> can be described by the datatag shown in <A HREF="Datatag.html#5738">Example 20</A>.<P>
<A NAME="5730"><I>Example 19.  Data structure defined by an application
</I><P>
<PRE><UL>struct myStruct {
   short      first;
   vlonglong  second;
   double     third;
   vfixed     fourth;
};

</UL></PRE><A NAME="5738"><I>Example 20.  Corresponding datatag for an application-defined data structure
</I><P>
<PRE><UL>{
   vdatatag *chimp;

   chimp = vdatatagCreateCompound();
   vdatatagConstructCompound(chimp, vdatatagGetShort(),
                             vdatatagGetLonglong(),
                             vdatatagGetDoubleFloat(),
                             vdatatagGetFixed(),
                             NULL);
   // ...
   vdatatagDestroy(chimp);
}

</UL></PRE>The type and order of appearance of datatags in the compound datatag must correspond exactly to the structure it describes; if an element differs or is out of order, an attempt to use the datatag later in a conversion may produce unpredictable results.<P>
<A NAME="5767"><H2> Datatag Lists</H2></A>
<EM><B>Datatag lists</B></EM> are a support type for datatags manipulated by the Datatag class; they provide a convenient method for organizing and manipulating sets of datatags when the order of the datatags is important. For example, a compound datatag that describes a structure must express not only the contents of the structure but also some idea of its organization. An ordered list of datatags is a convenient way of doing this. Datatag lists are also useful for describing an argument list to a function.<P>
The Datatag class provides methods for appending, inserting, deleting, and accessing elements in a list of datatags.<P>
<UL><B><I>NOTE:</I></B> Placing a datatag in a datatag list does not pass ownership of the datatag to 
the datatag list. Consequently, a datatag in a datatag list is not destroyed 
when the datatag list is destroyed. This is because datatags are meant to be 
shared; they should only be destroyed when they are no longer referenced.
<P>
</UL><A HREF="Datatag.html#5776">Example 21</A> shows how to use the datatag list from a compound datatag to describe a structure containing a float, an unsigned short, a fixed-point value, and an array of 11 boolean values.<P>
<A NAME="5776"><I>Example 21.  Using a datatag list to describe a structure
</I><P>
<PRE><UL>{
   vdatatag     *laurel, *hardy;
   vdatatagList *list;

   laurel = vdatatagCreateSizedArray();
   vdatatagSetSizedArrayCount(laurel, 11);
   vdatatagSetSizedArrayDatatag(laurel,
                                vdatatagGetBoolean());

   hardy = vdatatagCreateCompound();
   list  = vdatatagGetCompoundDatatagList(hardy);

   vdatatagAppendList(list, vdatatagGetSingleFloat());
   vdatatagAppendList(list, vdatatagGetUnsignedShort());
   vdatatagAppendList(list, vdatatagGetFixed());
   vdatatagAppendList(list, laurel);
   // ...
   vdatatagDestroy(laurel);
   vdatatagDestroy(hardy);
}

</UL></PRE><A NAME="5816"><H2> Datatag Groups</H2></A>
Many programming languages provide a means for separating type definitions used by a code module from the code module itself. This allows type definitions to be shared with other code modules. These type definitions are usually collected into groups that are related in some way. (For example, C and C++ programs typically collect their type definitions in shared header files.)<P>
The Datatag class provides a corresponding scheme by collecting related datatags into a single container called a <EM><B>datatag group</B></EM>. A datatag group is a support type that provides storage management, naming, and resource manipulation on a collective basis for all datatags stored in a datatag group.<P>
<A HREF="Datatag.html#5823">Example 22</A> shows how to add a pointer datatag to a datatag group.<P>
<A NAME="5823"><I>Example 22.  Adding a datatag to a datatag group
</I><P>
<PRE><UL>{
   vdatatagGroup *group;
   vdatatag      *ptr;

   ptr = vdatatagCreatePointer();
   vdatatagSetPointerDatatag(ptr, vdatatagGetLonglong());

   group = vdatatagCreateGroup();
   vdatatagSetGroupName(group,
                        vnameInternGlobalLiteral("myGroup"));
   vdatatagAddToGroup(group,
                      vnameInternGlobalLiteral("myPtr"), ptr);
}

</UL></PRE>Datatags are given names when they are added to a group so they can be retrieved by name from the group at a later time. Unlike adding a datatag to a datatag list, adding a datatag to a datatag group passes ownership of the datatag to the datatag group. Ownership is passed to the group so large groups of related datatags can be manipulated collectively. For example, storing a datatag group in a resource also stores, in the same resource, the definition of each datatag in the group.<P>
Consequently, when a datatag group is loaded from a resource, all the datatags that were in the group when it was stored are now available for use. Also, when a datatag group is destroyed, all datatags in the group are also destroyed; this provides a convenient way to add and remove a large group of related datatags to an application without having to keep track of each datatag individually.<P>
Each datatag added to a datatag group is given a name. <A HREF="Datatag.html#5854">Example 23</A> shows how to look up a datatag in a group.<P>
<A NAME="5854"><I>Example 23.  Looking up a datatag in a datatag group
</I><P>
<PRE><UL>void myFindRemoveReturn(vdatatagGroup *group,
                        const vname *name)
{
   vdatatag *dtag;

   dtag = vdatatagLookupInGroup(group, name);
   if (dtag != NULL)
   {
      vdatatagRemoveFromGroup(group, vdatatagGetName(dtag));
      vdatatagDestroy(dtag);
   }
}

</UL></PRE><UL><B><I>NOTE:</I></B> Looking up a datatag in a group does not pass ownership of the datatag back 
to the application; in this sense it is similar to the functions used to get the 
predefined primitive datatags. Removing a datatag from a datatag group, on 
the other hand, does pass ownership of the datatag back to the application.
<P>
</UL>Before storing datatag groups in a resource, they must be given a name using <TT><B>SetGroupName</B></TT>. If an attempt is made to store an unnamed datatag group in a resource, an exception is generated. <A HREF="Datatag.html#5887">Example 24</A> shows how to name a datatag group.<P>
<A NAME="5887"><I>Example 24.  Naming a datatag group
</I><P>
<PRE><UL>{
   vdatatagGroup group;

   vdatatagInitGroup(&amp;group);
   vdatatagSetGroupName(&amp;group,
                        vnameInternGlobalLiteral("chimp"));
   // ...
}

</UL></PRE>Naming datatag groups is encouraged because it allows them to be stored in resources, and also registers them with the Datatag class. All named datatag groups are destroyed by the Datatag class when the application shuts down. Only datatag groups that are named are automatically destroyed.<P>
When storing a datatag group in a resource, care must be taken when a datatag in the group references a datatag in another group. <A HREF="Datatag.html#5908">Example 25</A> generates an exception in an attempt to store the group <TT>group</TT> in a resource. This is because the datatag <TT>moe</TT>, added to <TT>group</TT>, refers to the datatag <TT>larry</TT>, which is not a member of any group.<P>
<A NAME="5908"><I>Example 25.  Storing a datatag group (incorrectly) in a resource
</I><P>
<PRE><UL>void myStoreGroup(vdatatagGroup *group, vresource res)
{
   vdatatag *larry, *moe;

   larry = vdatatagCreateSizedArray();
   vdatatagSetSizedArrayCount(larry, 42);
   vdatatagSetSizedArrayDatatag(larry, vdatatagGetTag());

   moe = vdatatagCreatePointer();
   vdatatagSetPointerDatatag(moe, larry);

   vdatatagAddToGroup(group,
                      vnameInternGlobalLiteral("moe"), moe);

   /* the following generates an exception */
   vdatatagStoreGroup(group, res);
}

</UL></PRE>This example is similar to a code module that includes a header file referring to a data structure definition stored in another header file that has not yet been included. In the case of a programming language, a compiler error results; in this case an exception is generated. To prevent generating an exception, add the datatag <TT>larry</TT> to the datatag group before storing the group in the resource.<P>
<A NAME="5943"><H2> Datatag Scraps</H2></A>
The Representation class defines a set of abstract classes that provide a consistent interface to conceptually similar data types that might be stored with dissimilar physical representations. Objects that exhibit a Representation class interface are commonly referred to as <EM><B>scraps</B></EM>.<P>
A <EM><B>datatag scrap</B></EM> is an object that layers a Representation class interface over any piece of application data that can be described with a datatag. The Datatag class defines a base datatag scrap class as well as a number of primitive datatag scrap classes that provide default conversion behavior for each of the primitive datatags.<P>
A datatag scrap is formed from a fully defined datatag and one or more pieces of application data. It is typically used as a source or a destination scrap for a call to a function that converts to or from the application data representation (such as the <TT><B>vscrapConvert</B></TT> function). Datatag scraps can be created "by value" or "by reference."<P>
A datatag scrap created by value is formed using one of the <TT><B>ScrapFromValue</B></TT> entry points, and is suitable for use as a source scrap during scrap conversion. When created by value, datatag scraps are formed from a datatag and one or more pieces of previously initialized application data.<P>
A datatag scrap created by reference is formed using one of the <TT><B>ScrapFromReference</B></TT> entry points, and is suitable for use as a destination scrap during scrap conversion. When created by reference, datatag scraps are formed from a datatag and one or more pieces of uninitialized application data.<P>
<A HREF="Datatag.html#5963">Example 26</A> shows how to make a datatag scrap using an application data value stored as an integer:<P>
<A NAME="5963"><I>Example 26.  Making a scrap around an application data variable
</I><P>
<PRE><UL>{
   vscrap *scrap;
   int spam;

   spam = 42;
   scrap = vdatatagScrapFromValue(vdatatagGetInteger(),
                                  spam);
   // ...
   vscrapDestroy(scrap);
}

</UL></PRE><UL><B><I>NOTE:</I></B> Destroying the scrap does not destroy the application data item or the 
datatag.
<P>
</UL><A HREF="Datatag.html#5990">Example 27</A> shows how to convert an application's string variable into a resource using the Datatag class.<P>
<A NAME="5990"><I>Example 27.  Making a scrap from a string variable
</I><P>
<PRE><UL>void myConvertToResource(vchar *string, vresource res,
                         const vname *name)
{
   vscrap *scrap;

   scrap = vdatatagScrapFromValue(vdatatagGetString(),
                                  string);
   vresourceSetScrap(res, name, scrap);
   // ...
}

</UL></PRE>You can use the Resource class to get the same result as <A HREF="Datatag.html#5990">Example 27</A>. However, as the application data becomes larger and more complex, using the Resource class to store each element individually can become extremely tedious and error prone. Using datatags to control scrap conversion greatly simplifies the process.<P>
Datatag scraps are also used to convert data stored in foreign representations into data structures defined by the application. <A HREF="Datatag.html#6022">Example 28</A> shows how to convert an array of floats stored in a resource into an array allocated by the application.<P>
<A NAME="6022"><I>Example 28.  Converting data into defined data structures 
</I><P>
<PRE><UL>void myConvertFromResource(vresource res, const vname *name)
{
   vscrap   *scrap, *resscrap;
   float     array[10];
   vdatatag *dtag;

   dtag = vdatatagCreateSizedArray();
   vdatatagSetSizedArrayCount(dtag, 10);
   vdatatagSetSizedArrayDatatag(dtag,
                                vdatatagGetSingleFloat());

   scrap = vdatatagScrapFromReference(dtag, array);

   resscrap = vresourceGetScrap(res, name);
   vscrapConvert(resscrap, scrap);
   vscrapDestroy(resscrap);
   vscrapDestroy(scrap);
}

</UL></PRE>Note that <A HREF="Datatag.html#6022">Example 28</A> uses <TT><B>ScrapFromReference</B></TT> rather than a <TT><B>ScrapFromValue</B></TT>. Here, we are using the datatag scrap as a destination for conversion rather than as a source. The general rule is that datatag scraps to be used as the source for a conversion are formed using <TT><B>ScrapFromValue</B></TT> functions; datatag scraps used as the destination of a conversion are formed using <TT><B>ScrapFromReference</B></TT> functions.<P>
In some cases, more than one application data item is needed to fully specify the application data to be converted. <A HREF="Datatag.html#6069">Example 29</A> shows how to create a datatag scrap around a variable-length array.<P>
<A NAME="6069"><I>Example 29.  Creating a scrap from a variable-length array
</I><P>
<PRE><UL>void myStoreShortArray(vresource res, const vname *name,
                       short *array, int count)
{
   vdatatag *dtag;
   vscrap *scrap;

   dtag = vdatatagCreateArray();
   vdatatagSetArrayDatatag(dtag, vdatatagGetShort());

   scrap = vdatatagScrapFromValue(dtag, count, array);
   vresourceSetScrap(res, name, scrap);
   vdatatagDestroy(dtag);
}

</UL></PRE>There are also functions available for converting lists of application data items into scraps. <A HREF="Datatag.html#6102">Example 30</A> shows how to create a scrap from an integer, a tag, a fixed-point value, and a double.<P>
<A NAME="6102"><I>Example 30.  Converting lists of application data items
</I><P>
<PRE><UL>void myConvertList(int scalar, const vname *name,
                   vfixed fix, double dbl)
{
   vdatatagList list;
   vscrap *scrap;

   vdatatagInitList(&amp;list);
   vdatatagAppendList(&amp;list, vdatatagGetInteger());
   vdatatagAppendList(&amp;list, vdatatagGetTag());
   vdatatagAppendList(&amp;list, vdatatagGetFixed());
   vdatatagAppendList(&amp;list, vdatatagGetDoubleFloat());

   scrap = vdatatagScrapFromListValues(&amp;list, scalar,
                                       name, fix, dbl);
   // ...
   vdatatagDestroyList(&amp;list);
   vscrapDestroy(scrap);
}

</UL></PRE>The scrap produced in <A HREF="Datatag.html#6102">Example 30</A> is from a compound scrap class that references each application data item as a scrap element.<P>
When using datatag scraps you should be careful of the scope in which the datatag scrap is used. Since the actual data item is not owned by the scrap but rather by the application, the scrap is only valid as long as the application data item is valid.<P>
A common mistake is to make a datatag scrap using an automatic variable in a function and then attempt to return the scrap as a result. This fails because the automatic variable used to create the scrap is only valid within the function where it is defined.<P>
Datatag scraps can also allocate storage for items of variable length and type. <A HREF="Datatag.html#6150">Example 31</A> shows how to convert an array resource into an application data item without knowing the size of the array to begin with.<P>
<A NAME="6150"><I>Example 31.  Using datatag scraps to allocate storage of variable length
</I><P>
<PRE><UL>void myGetVariableArray(vresource res, const vname *name)
{
   vscrap   *scrap, *resscrap;
   vdatatag *dtag;
   double   *array;
   int       x, count;

   dtag = vdatatagCreateArray();
   vdatatagSetArrayDatatag(dtag, vdatatagGetDoubleFloat());

   scrap = vdatatagScrapFromReference(dtag, &amp;count, &amp;array);

   resscrap = vesourceGetScrap(res, name);
   vscrapConvert(resscrap, scrap);
   vscrapDestroy(resscrap);
   vscrapDestroy(scrap);

   for (x=0; x&lt;count; x++)
     vdebugInform("Element %d, value %10.4f n",
                  x, array[x]);

   vdatatagDestroy(dtag);
   vmemFree(array);
}

</UL></PRE>In <A HREF="Datatag.html#6150">Example 31</A>, the size of the array is determined during the conversion process and returned in the variable <TT>count</TT>. Storage for the elements of the array is allocated by the scrap; ownership of the storage is passed back to the application. Since arrays are allocated storage with <TT><B>vmemAlloc</B></TT>, the application must free the storage with <TT><B>vmemFree</B></TT>.<P>
The Datatag class can describe and convert actual data structures defined by an application. <A HREF="Datatag.html#6220">Example 33</A> shows how to create a scrap that can be used to convert an application's data structure (from <A HREF="Datatag.html#6211">Example 32</A>) into a different data representation.<P>
<A NAME="6211"><I>Example 32.  Application data structure to be converted
</I><P>
<PRE><UL>typedef struct {
   short      first;
   vlonglong  second;
   double     third;
   vfixed     fourth;
} myStruct;

</UL></PRE><A NAME="6220"><I>Example 33.  Converting an application's data structure into a different data representation
</I><P>
<PRE><UL>vscrap *myCreateStructScrap(myStruct *ptr)
{
   vdatatag *dtag;
   vscrap   *scrap;

   dtag = vdatatagCreateCompound();

   vdatatagConstructCompound(dtag, vdatatagGetShort(),
                             vdatatagGetLonglong(),
                             vdatatagGetDoubleFloat(),
                             vdatatagGetFixed(),
                             NULL);

   scrap = vdatatagScrapFromValue(dtag, ptr);
   return(scrap);
}

</UL></PRE><A NAME="3368"><H1> Specialized Use</H1></A>
This section discusses how to write and use a datatag scrap class defined by the application. Since the Datatag class provides scrap classes that perform conversion for all predefined datatags, only application programmers that want to extend the base set of scrap classes need to refer to this section. The material presented here makes extensive use of concepts presented in the Representation class, and the Instance and Delegator class definitions from the Class Manager. For more information on these concepts, refer to the Representation and the Class chapters.<P>
The most common use of the Datatag class is to convert application data structures into representations defined by other software subsystems. The operations performed on an application data structure during conversion to or from a foreign data representation are defined by the various predefined datatag scrap classes assigned to each of the predefined datatags. The scrap class assigned to a datatag can be retrieved through a call to <TT><B>GetScrapKind</B></TT>, and can be set through a call to <TT><B>SetScrapKind</B></TT>.The scrap class for each of the predefined datatags is set by the Datatag class and cannot be changed by the application programmer; this ensures that the core datatags always behave the same across all Galaxy applications.<P>
The Datatag class provides a large set of predefined datatag scrap classes covering the majority of application data structures that an application may want to manipulate. However, the Datatag class is not limited to converting to the predefined data types. Applications that want to perform extra operations on their data structures during the conversion process can extend the base set of Datatag class scrap classes by defining their own scrap classes to provide extra semantics.<P>
The sample code section shows an example of a datatag scrap class written specifically to convert the Galaxy <TT>vrect</TT> data structure.<P>
<UL><B><I>NOTE:</I></B> The <TT>vrect</TT> structure can also be converted using the default Compound 
datatag and scrap class; the example is intended to illustrate how to define 
new scrap classes.
<P>
</UL>The <TT>vrect</TT> structure is a C data structure defined as follows:<P>
<PRE><UL>struct vrect {
   short   x, y;
   short   w, h;
};

</UL></PRE>Before continuing, we must make a few decisions. We must first select which abstract scrap class most closely fits the data structure we are trying to convert. In this case, the Compound scrap class most closely fits the <TT>myRect</TT> structure, since it has more than one sub-element, but the number of elements cannot change. We next need to determine which pieces need to be written for the scrap to operate correctly. The Representation class provides a wide range of implementation options for creating scraps; the approach taken here is by no means the only one.<P>
The example uses the <TT>vdelegator</TT> class methods to implement the Compound scrap class behavior. This has a number of benefits. Most importantly, since the default vscrap<TT>IMPORT</TT> and vscrap<TT>EXPORT</TT> methods are not overridden, it is likely that the resulting scrap can interact correctly with other scraps that implement the Compound scrap class. The <TT>vrect</TT> scrap class is therefore implemented using two classes.<P>
The top object in the delegate tree is a subclass of the default <TT>vdatatagScrap</TT> class. This object implements the methods needed to manage storage allocation and initialization for the application data structure that this scrap eventually converts. The second object (referred to as the delegate object) implements the behavior of the scrap class that our scrap exports to and imports from. In this case, it is an object of the Compound scrap class. The delegate tree is defined by the vdelegator<TT>NEXT_DELEGATE</TT> method overridden in the top level <TT>vdatatagScrap</TT> class.<P>
There are actually three classes defined in this implementation of the <TT>vrect </TT>datatag scrap class. The abstract Compound scrap class requires that an iterator class be defined that can iterate over each element in the Compound scrap. Therefore, the third class defined is a subclass of the class returned by <TT><B>GetDefaultCompoundIteratorClass</B></TT>. <P>
<A NAME="4428"><H2> Sample Code</H2></A>
Complete source code demonstrating some of the concepts presented in this chapter is available in your Galaxy distribution in the <TT>samples/docsamps</TT> directory. Of particular note is the <TT>exrect</TT> sample that demonstrates how to create a new datatag scrap class.<P>
<P>



<!---------------------------------->
<!--  End actual manual material  -->
<!---------------------------------->
			
		</TD>
		
	</TR>
	<TR>
   		<!-- Textural Navigation Area -->	
		<TD WIDTH="130" VALIGN="BOTTOM">
	
		<FONT SIZE=-1>

  		<A HREF="DAS.html">Previous Chapter</A> | 
		<A HREF="Date.html">Next Chapter</A> <BR>
		<A HREF="index.html">Table of Contents</A> <BR>
		<A HREF="../index.html">Help Map</A> <BR>

		
		<P>
		Need help? <A HREF="../contact-visix.html">Contact Visix</A>.
		<P>
		<A HREF="../copyright.html">Copyright 1996-97</A>, <BR>
		<A HREF="http://www.visix.com/">Visix Software Inc.</A>
		</FONT>
		</TD>
	</TR>
</TABLE>

</BODY>
</HTML>
