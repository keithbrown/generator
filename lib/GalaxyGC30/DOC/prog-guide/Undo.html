<HTML>
<HEAD>
<TITLE>Undo</TITLE>
</HEAD>

<BODY background="graphics/bg.gif" BGCOLOR="#FFFFFF" TEXT="#000000">

<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0">
	<TR>
		<!-- Margin Banner -->
		<TD WIDTH="130"><CENTER><IMG SRC="graphics/logo.gif">
		<IMG WIDTH="130" SRC="graphics/trans.gif"></CENTER></TD>
		<!-- Margin Spacer -->
		<TD ROWSPAN="2" WIDTH="20">
		<IMG WIDTH="20" SRC="graphics/trans.gif"><P></TD>
	
	
		<!-- Title block: DOCUMENT TITLE GOES HERE -->
		<TD VALIGN=TOP><BR>
		     <H1>Undo</H1>
		     <BR>
		</TD>

	</TR><TR>
	
		<!-- Navigation Icons & Related Topics -->
		<TD WIDTH="130" VALIGN="TOP" ALIGN="LEFT"> 
		
		<CENTER>
		<BR>
		<IMG WIDTH=6 HEIGHT=21 SRC="graphics/trans.gif">
		
	
  		<!-- These are the Navigation buttons -->
		<A HREF="Tree_List.html"><IMG WIDTH=24 HEIGHT=31 BORDER=0 SRC="graphics/left.gif"></A>
		<A HREF="index.html"><IMG WIDTH=22 HEIGHT=33 BORDER=0 SRC="graphics/up.gif"></A>
		<A HREF="URL.html"><IMG WIDTH=24 HEIGHT=31 BORDER=0 SRC="graphics/right.gif"></A>

		
		<IMG WIDTH=6 HEIGHT=21 SRC="graphics/trans.gif">
		<BR>
  </CENTER>
		</TD>
	
		<!-- Text Area -->
		<TD VALIGN="TOP" ROWSPAN="2">
			<BR>
			
<!---------------------------------->
<!-- Begin actual manual material -->
<!---------------------------------->

 
<A NAME="3204"></A>
The <EM><B>Undo</B></EM> class provides a framework for implementing undo and redo features in your application. It supports either the traditional last action undo/redo, or unlimited multi-level undo/redo, with an arbitrarily large number of levels.<P>
The Undo class defines a basic class, called <TT>vundoAction</TT>, that is used to represent every undoable action that occurs. Objects of this class (or a subclass of the class) are able to do, undo, and redo the actions they represent.<P>
Also provided are several ways to organize these actions. A <TT>vundoActionList</TT> is a special vundoAction that contains a list of other vundoActions. These can be used to combine simple actions to make more complex ones.<P>
Multi-level undo is supported with the <TT>vundoLog</TT> object. This object is used to record the <TT>vundoAction</TT>s that occur and keep track of which ones are done and undone. A <TT>vundoLog</TT> will also generate commands for you that will automatically handle the Undo and Redo Menus in your application.<P>
<A NAME="3358"><H2>  Key Functionality</H2></A>
Implementing undo in an application is not a trivial task. It is easier to do if it is included in your application design, rather than being forced into an existing application. In the latter case, you may have to redesign parts of your application to allow actions to be undoable.<P>
<A NAME="4231"><H2> Generating vundoActions</H2></A>
To implement undo with the Undo class, you must create a vundoAction object for each action in your application that is to be made undoable. The vundoAction class is defined by the Undo class, but you normally have to subclass it for the actions generated by your application.<P>
A basic <TT>vundoAction</TT> has two attributes: its name and its state. The name is a description of the vundoAction's effect, which appears in the Undo or Redo menu item when the action can be undone or redone. The state keeps track of whether the action has either never been done, or was last done or undone. When you create subclasses of <TT>vundoAction</TT>, you will most likely add more attributes to keep track of data specific to the action that occurred.<P>
The two most important methods of an action are the <TT>vundoACT</TT> method and the <TT>vundoDESTROY</TT> method. The <TT>vundoACT</TT> method gets called when the action is supposed to do, undo, or redo itself. When you override the <TT>vundoACT</TT><TT><B></B></TT> method, you should check the action's current state to decide whether to do, undo, or redo the action. The <TT>vundoDESTROY</TT> method gets called when the action is being destroyed and thus can no longer be done or undone. You should use this method to destroy any information you have allocated and stored in the action. You may also use the <TT>vundoDESTROY</TT> method to "finalize" an action that was performed only in a temporary way by the action's vundoACT method.<P>
One way to create appropriately subclassed actions is to subclass vundoAction for each type of action that the user can perform. For each such subclass, you add any fields to the object that are needed to remember the action, override the <TT>vundoACT</TT> method to undo and redo the action, and set the vundoNAME class variable for the class to be the text you want to appear in the Undo/Redo Menu, minus the word "Undo" or "Redo." You should also override the <TT>vundoDESTROY</TT> method if any of the new fields point to data that must be freed when the action is destroyed.<P>
Another way to generate the appropriate undo actions is to make a single subclass of <TT>vundoAction</TT> that can do or undo any of the undoable actions your application can generate. You can then generate an instance of this class for each action performed. If you do this, you probably want to override the <TT>vundoGET_NAME</TT> method to retrieve the action name from the instance's data fields, rather than retrieving it directly from the class. This lets the name be different for each instance of the class, rather than constant across the class.<P>
You may also find it convenient to define some actions in terms of a combination of other, simpler actions. An easy way to do this is to use a <TT>vundoActionList</TT> to contain the simpler actions. Because <TT>vundoActionList</TT> is a subclass of <TT>vundoAction</TT>, the action list itself can be used directly as the <TT>vundoAction</TT> for the compound action. Another way to accomplish this is to explicitly store <TT>vundoAction</TT>s in your own subclass of vundoAction and simply call those actions' <TT>vundoACT</TT> methods when your subclass's <TT>vundoACT</TT> method is called. This may be more efficient than using <TT>vundoActionList</TT> if you have a fixed set of subactions that occur during an action.<P>
If you have a large and complicated application, you may prefer to combine these approaches. You can generate vundoActions on a per-module basis and then combine these actions into the top-level actions that represent user actions. You should be careful, however, that you do not generate too many vundoActions per user action and use memory unnecessarily, especially if you are keeping track of multi-level undo information.<P>
One good way to implement undo is to separate the data and views in your application. (Refer to the Domain, Text, and List chapters for examples of this.) You can then create an "undo observer" for your data object. This observer just watches changes to the data and generates a vundoAction for each change that occurs. It accumulates all of the actions it generates in a vundoActionList, which is stored with the data itself.<P>
Thus, after you perform an arbitrarily complex operation on the data, you can retrieve the action list that the undo observer has accumulated, name the list something appropriate to the top-level action that occurred, and install the action list in your undo log. Remember to make sure the undo observer's current action list is reset so you will not get the same actions more than once. Both the Domain class and the Text class have built-in support for undo observers. You can refer to them for more specific information.<P>
<A NAME="4252"><H2> Implementing Undo</H2></A>
Once your application generates the proper vundoActions, implementing undo is easy. If an application has only single-level undo, it should just remember the last <TT>vundoAction</TT> generated and use that action directly when the user selects the Undo/Redo Menu. (For single-level undo, a single menu item is generally used for both commands, as only one is available at any given time.) When a new action is generated, the old action is merely destroyed and replaced by the new action. In addition, if the user changes the document in a way that is not undoable by the application, the application can just destroy the last action, not replace it with anything, and disable the Undo menu item until another undoable action occurs.<P>
If you want to support multi-level undo in your application, create a <TT>vundoLog</TT> object and add the top-level <TT>vundoAction</TT>s to the log as they occur. If your application uses commands, you can tell the undo log to install Undo and Redo commands in your command space, and the Undo class will take care of handling the menus and keeping their titles and enabled state up to date according to the actions you record in the log. (Refer to the Command class for more information about commands in general.) If your application does not use commands, entry points are provided so you can handle the menus and set their state yourself.<P>
To reliably use multi-level undo, the actions stored in the undo log must provide a continuous change log of the data being edited. Any non-undoable changes made to the data may destroy the context in which the actions stored in the log were performed and should be avoided. For instance, consider the following sequence of actions: create an object (undoable), modify it (undoable), delete it (non-undoable). If we now try to undo, we will be modifying an object that no longer exists. There are two solutions to the problem: either make the delete undoable (which would undelete the object before modifying it) or flush the undo log before performing the non-undoable delete.<P>
When implementing undo, you must also decide how many undo logs (or undo actions, if you have only single-level undo) your application should keep. For example, when the user selects the Undo menu item, is the last change made to a particular section undone, or the last change to a particular document, or the last change made anywhere in the application? If your application has a notion of a document, keeping a separate undo log for each document is generally appropriate. Also, because there is typically one Undo menu item per window, it is good for the menu item to undo the last change made in the window. Finally, it is important that the data be tracked independently in each log, so that changes to one do not affect another. In some applications, the preceding rules may be contradictory; in the end, the right approach depends on your particular application.<P>
If an undo log is used to record all changes made to a document, you can use the log as a method to tell if the document needs to be saved or not. You "mark" the log whenever you save the document, and then you can just check whether or not the log is in its "marked" state to indicate whether or not changes have been made to the document. Using this method, if the user saves the document, makes a series of changes, and then undoes them all, the log is put back in its "marked" state, and you know that the document does not need to be saved.<P>
You should use this information to determine the enabled state of the Save menu item for the document. If you are not using commands, you are responsible for checking the saved state of the undo log and updating your Save menu appropriately. If you are using commands, the Undo class will cause the Save command to be automatically re-queried when the saved state of the log changes. However, you are still responsible for providing the results of the query from your Save command. (Refer to the Command chapter for more information about querying commands.)<P>
<A NAME="4263"><H2> Undo Examples</H2></A>
To illustrate proper use of the Undo class, a sample object type called an <TT>intarray</TT>, (a dynamic array of integers), is used. Assume that the following routines have been written:<P>
<PRE><UL>intarray *intarrayCreate(void);
// Creates an empty intarray.

void intarrayDestroy(intarray *a);
// Destroys an intarray.

void intarrayAppend(intarray *a, int newElement);
// Increases the array size by one, adding the new element to the end.

void intarrayTrim(intarray *a);
// Decreases the array size by one, removing the last element.

int intarrayGetSize(intarray *a);
// Returns the number of elements in the array.

int intarrayGetElement(intarray *a, int index);
// Returns the value of the specified element.

</UL></PRE>The examples will make some of these actions undoable.<P>
The first step is to determine how to generate the <TT>vundoAction</TT>s. Galaxy follows a few conventions, which you are encouraged to adopt. If there is an undoable version of an entry point, it follows the same interface as the normal, non-undoable function, but it takes an extra parameter (a <TT>vundoAction **</TT>) that is set by the function call to the appropriate vundoAction, which will undo and redo the effects of the function call. This variation of the function call has the modifier "Undoable" appended to the original function name.<P>
<UL><B><I>NOTE:</I></B> In some cases, a <TT>vundoAction</TT> may be directly generated in response to a 
user event rather than as a result of a function call. In such cases, you can 
specify a notify function that is called when such <TT>vundoAction</TT>s are 
generated, so you can install them in your application's vundoLog or do 
whatever else is appropriate. For example, the Domain class has an Undo 
notify procedure for a domain view that gets called when the user drags or 
selects objects with the mouse in that domain view.
<P>
</UL>Start by writing the function <TT>intarrayCreateUndoable</TT>. The first step is to define the <TT>vundoAction</TT> subclass for the action that will be produced. Because you do not need to add any methods to the vundoAction class, and you will not have to subclass from this new class, you can simply define a structure for the object type, reproduce <TT>vundoAction</TT>, and set up your new methods for the new subclass. You can skip writing a new CLASS macro and defining a new class type.<P>
<PRE><UL>typedef struct {
   vundoAction  action;
   intarray    *a;
} intarrayCreation;

vundoActionClass *intarrayCreationClass = NULL;

</UL></PRE>You will write the code to initialize the class a bit later. First, write a new method for <TT>vundoACT</TT>.<P>
<PRE><UL>void intarrayActCreation(vundoAction *action)
{
   /*
    * Figure out whether to do, undo,
    * or redo based on the action's state
    */
   switch (vundoGetActionState(action))
   {
    case vundoNEW:

      /* Do action for the first time */
      ((intarrayCreation *) action)-&gt;a = intarrayCreate();
      break;

    case vundoDONE:

      /* action needs to be undone */
      break;

    case vundoUNDONE:
      /* action needs to be redone */
      break;
   }
   vclassSendSuper(intarrayCreationClass, vundoACT, (action));
}

</UL></PRE>Note that when you undo and redo the creation, no actual work is performed. The main reason for this is that you want the array to have the same memory address, even after an undo and a redo, so that if something (like a future undo action) points to the array, the pointer remains valid. For this strategy to work, however, you must write a <TT>vundoDESTROY</TT> method that actually does destroy the new array if the action ultimately remains undone.<P>
<PRE><UL>void intarrayDestroyCreation(vundoAction *action)
{
   /* only destroy the intarray if the action was undone in the end */
   if (vundoGetActionState(action) == vundoUNDONE)
     intarrayDestroy(((intarrayCreation *)action)-&gt;a);

   vclassSendSuper(intarrayCreationClass, vundoDESTROY, (action));
}

</UL></PRE>Now that you have defined your new <TT>vundoACT</TT> and <TT>vundoDESTROY</TT> methods, you can write intarrayCreateUndoable. Because this function is the only place where objects of the intarrayCreation class are generated, you can do the class initialization in the function.<P>
<PRE><UL>intarray *intarrayCreateUndoable(vundoAction **action)
{
   if (intarrayCreationClass == NULL)
   {
      intarrayCreationClass =

        vclassReproduce(vundoGetDefaultActionClass());
      vclassSetObjectSize(intarrayCreationClass,
                          sizeof(intarrayCreation));
      vclassSet(intarrayCreationClass, vundoACT,
                intarrayActCreation);
      vclassSet(intarrayCreationClass, vundoDESTROY,
                intarrayDestroyCreation);
      vclassSet(intarrayCreationClass, vundoNAME,
                vstrCloneScribed(vcharScribeLiteral(("Create"))));
   }

   *action = vundoCreateActionOfClass(intarrayCreationClass);

   vundoActAction(*action);

   return ((intarrayCreation *) action)-&gt;a;
}

</UL></PRE>Note that <TT><B>vundoActAction</B></TT> is called on the new object after it is created. This performs the initial creation and advances the state of the action from <TT>vundoNEW</TT> to <TT>vundoDONE</TT>. An action representing some undoable action should always be returned in the <TT>vundoDONE</TT> state.<P>
An alternate strategy for the above code would have been to call <TT>intarrayCreate</TT> directly from <TT>intarrayCreateUndoable</TT> (after creating the action), rather than from <TT>intarrayActCreation</TT>. If you do this, you do not have to override the <TT>vundoACT</TT> method at all.<P>
As you can see, it took a fair amount of work to write <TT>intarrayCreateUndoable</TT>, a function to generate a very simple action. In general, you will not want to implement undo at such a low level in your program, for several reasons. First, you want to minimize the number of "Undoable" entry points, because they are more difficult to write than ordinary entry points. Second, you want to minimize the amount of memory used for each top-level undoable action, which in general means minimizing the total number of actions used to make the top-level action. Therefore, it is best to implement undo at as high a level as possible in your program.<P>
<TT>intarrayAppendUndoable</TT> is implemented in <A HREF="Undo.html#4443">Example 167</A>.<P>
<A NAME="4443"><I>Example 167.  The intarrayAppendUndoable function
</I><P>
<PRE><UL>typedef struct {
   vundoAction  action;
   intarray    *a;
   int          element;
} intarrayAppending;

vundoActionClass *intarrayAppendingClass = NULL;

void intarrayActAppending(vundoAction *action)
{
   intarrayAppending *p = (intarrayAppending *) action;

   switch (vundoGetActionState(action) == vundoDONE)
   {
    case vundoNEW:
    case vundoUNDONE:
      intarrayAppend(p-&gt;a, p-&gt;element);
      break;

    case vundoDONE:
      intarrayTrim(p-&gt;a);
      break;
   }

   vclassSendSuper(intarrayAppendingClass, vundoACT, (action));
}


void intarrayAppendUndoable(intarray *a, int element,
                            vundoAction **action)
{
   intarrayAppending *p;

   if (intarrayAppendingClass == NULL)
   {
      intarrayAppendingClass =
        vclassReproduce(vundoGetDefaultActionClass());

      vclassSetObjectSize(intarrayAppendingClass,
                          sizeof(intarrayAppending));
      vclassSet(intarrayAppendingClass, vundoACT,
                intarrayActAppending);
      vclassSet(intarrayAppendingClass, vundoNAME,
                vstrCloneScribed(vcharScribeLiteral(("Append"))));
   }

   *action = vundoCreateActionOfClass(intarrayAppendingClass);

   p = (intarrayAppending *) *action;

   p-&gt;a = a;
   p-&gt;element = element;

   vundoActAction(*action);
}

</UL></PRE>In this example, the action actually is undone and redone when the <TT>vundoACT</TT> method is called, because in this case the action is easily reversible. Note that you do not have to override the <TT>vundoDESTROY</TT> method in this action, because you do not have anything allocated in the subclass that needs to be destroyed.<P>
The next undoable function, intarrayMergeUndoable (<A HREF="Undo.html#4561">Example 168</A>), takes two <TT>intarrays</TT> and creates a third from them that contains the elements from both of the original arrays concatenated together. To implement this function, a <TT>vundoActionList</TT> is used rather than define a new type of action. This method is not the most efficient way to implement the undoable merge, but it will serve as an example of using a <TT>vundoActionList</TT>.<P>
<A NAME="4561"><I>Example 168.  Using vundoActionList to undo an action
</I><P>
<PRE><UL>intarray *intarrayMergeUndoable(intarray *a1, intarray *a2,
                                vundoAction **action)
{
   intarray         *newArray;
   vundoActionList          *list;
   vundoAction         *subaction;
   int                    i, n;

   *action = (vundoAction *) list = vundoCreateActionList();

   vundoSetActionListName(list, vnameInternGlobalLiteral("Merge"));

   newArray = intarrayCreateUndoable(&amp;subaction);
   vundoAddActionListAction(list, subaction);

   n = intarrayGetSize(a1); for (i=0; i&lt;n; i++) {
      intarrayAppendUndoable(newArray, intarrayGetElement(a1, i),
                             &amp;subaction);

      vundoAddActionListAction(list, subaction);
   }

   n = intarrayGetSize(a2);
   for (i=0; i&lt;n; i++)
   {
      intarrayAppendUndoable(newArray, intarrayGetElement(a2, i),
                             &amp;subaction);
      vundoAddActionListAction(list, subaction);
   }

   vundoActActionList(list);
   return newArray;
}

</UL></PRE>Note that you call <TT><B>vundoActActionList</B></TT> after adding all of the actions to this list, which were already <TT>DONE</TT>. Thus, this call served only to advance the action list itself into the <TT>DONE</TT> state.<P>
<A NAME="4641"><I>Example 169.  Single-level undo
</I><P>
Now explore how to use the above functions to implement single-level undo. First, create a global variable that will hold the most recent undoable action (it is assumed that there is only one "thread" of undoable actions happening).<P>
<PRE><UL>   vundoAction *lastAction = NULL;

</UL></PRE>Because you have only single step undo, there is only one Undo menu item. You need to set up its title and enabled state with the following code.<P>
<PRE><UL>   vmenuSetItemTitleScribed(undoMenuItem,
                            vundoScribeAction(lastAction));

   if (lastAction == NULL)
     vmenuDisableItem(undoMenuItem);
   else
     vmenuEnableItem(undoMenuItem);

</UL></PRE>Initially, the menu reads "Undo" and is dimmed. Now assume that the user has done something that has caused you to create an array named array. You then execute the following code segment:<P>
<PRE><UL>   vundoAction *action;
   intarray    *array = intarrayCreate();

   if (lastAction != NULL)
     vundoDestroyAction(action);

   lastAction = action;

</UL></PRE>This creates the array and sets up the action thus generated to be our new undoable action (the old action is discarded). You can then set up the Undo Menu state again (as above). The Undo Menu now reads "Undo Create" and is enabled.<P>
Now, if the user picks the Undo Menu, the following call causes the action to be undone.<P>
<PRE><UL>   vundoActAction(lastAction);

</UL></PRE>(Note that in this case, no action on the array is taken, although the state of the action is changed to <TT>vundoUNDONE</TT>.) If you update the state of the menu item again, it will read "Redo Create" and will still be enabled.<P>
Now, the user picks the menu again:<P>
<PRE><UL>   vundoActAction(lastAction);

</UL></PRE>This causes the action to be redone (which simply changes the state of the action to <TT>vundoDONE</TT>). The menu now reads "Undo Create" again and is enabled. Next, the user does something that causes us to append the number <TT>5</TT> to the array.<P>
<PRE><UL>   intarrayAppend(array, 5);

   if (lastAction != NULL)
     vundoDestroyAction(action);

   lastAction = action;

</UL></PRE>This destroys the last action and installs the new action. Note that destroying the old action did not destroy the array, because the action was in the <TT>DONE</TT> state. The Undo Menu is now enabled and labeled "Undo Append."<P>
Finally, assume something was done to the array that was not undoable. The code is:<P>
<PRE><UL>   if (lastAction != NULL)
     vundoDestroyAction(action);

   lastAction = NULL;

</UL></PRE>After updating, the Undo Menu again reads "Undo" and is disabled.<P>
<A NAME="4696"><I>Example 170.  Multi-level undo
</I><P>
Here is the same sequence, but with multi-level undo instead of single level. First, we need to create an undo log:<P>
<PRE><UL>   vundoLog *log;
   log = vundoCreateLog();

</UL></PRE>Because you are using multi-level undo, there are two menu items: Undo and Redo. You need to handle both of them.<P>
If you are using commands in your application, call the following to tell the Undo class to install Undo and Redo commands for the given log in your command space.<P>
<PRE><UL>   vundoInstallLogCommands(log, myCommandSpace);

</UL></PRE>These commands automatically take care of any interface items in the object hierarchy associated with the command space that have the tag "Undo" or "Redo" (these are the default names; you can change them if you want). The log undoes and redoes the appropriate actions when the objects are activated, and the objects' titles and states are updated automatically as the actions in the undo log change.<P>
If your application does not use commands, you will have to handle the Undo and Redo Menus yourself. To initially set them up, call:<P>
<PRE><UL>   vmenuSetItemTitleScribed(undoMenuItem, vundoScribeLogUndoAction(log));

   vmenuSetItemTitleScribed(redoMenuItem, vundoScribeLogRedoAction(log));

   if (vundoGetLogUndoAction(log) == NULL)
     vmenuDisableItem(undoMenuItem);
   else
     vmenuEnableItem(undoMenuItem);
   if (vundoGetLogRedoAction(log) == NULL)
     vmenuDisableItem(redoMenuItem);
   else
     vmenuEnableItem(redoMenuItem);

</UL></PRE>In either case, the Undo Menu reads "Undo" and is disabled; the Redo Menu reads "Redo" and is disabled. The user then causes an array to be created:<P>
<PRE><UL>   vundoAction *action;

   array = intarrayCreate();
   vundoAddLogAction(log, action);

</UL></PRE>If you have commands installed, the titles and states of both menus are automatically updated appropriately. If not, you have to set up the menus again. In either case, the Redo Menu stays the same, but the Undo Menu now reads "Undo Create" and is enabled.<P>
The user then chooses Undo. Again, if commands are installed, the log is automatically told to undo the appropriate action. If not, you have to do this yourself:<P>
<PRE><UL>   vundoUndoLog(log);

</UL></PRE>After the menus are updated (either manually or automatically), the Undo Menu is now dimmed and reads "Undo", while the Redo Menu is enabled and reads "Redo Create."<P>
The user chooses Redo, and either the command causes the action to be redone, or you call:<P>
<PRE><UL>   vundoRedoLog(log);

</UL></PRE>You are now back in the state you were after the create. The user now appends <TT>5</TT> to the array:<P>
<PRE><UL>   intarrayAppend(array, 5);
   vundoAddLogAction(log, action);

</UL></PRE>After updating, the menus read "Undo Append" (enabled) and "Redo" (disabled). Note that the original creation action was not destroyed and is still stored in the undo log. If the user picks Undo again:<P>
<PRE><UL>   vundoUndoLog(log);

</UL></PRE>The menus are updated; they read "Undo Create" and "Redo Append." The array is now empty again. Now suppose the user appends another element, say <TT>10</TT>:<P>
<PRE><UL>   intarrayAppend(array, 10);
   vundoAddLogAction(log, action);

</UL></PRE>This causes all <TT>UNDONE</TT> actions in the log (namely, the previous append action) to be destroyed. The new action is entered after the last <TT>DONE</TT> action (the create action in this case). After updating, the menus read "Undo Append" and "Redo" (disabled).<P>
<P>



<!---------------------------------->
<!--  End actual manual material  -->
<!---------------------------------->
			
		</TD>
		
	</TR>
	<TR>
   		<!-- Textural Navigation Area -->	
		<TD WIDTH="130" VALIGN="BOTTOM">
	
		<FONT SIZE=-1>

  		<A HREF="Tree_List.html">Previous Chapter</A> | 
		<A HREF="URL.html">Next Chapter</A> <BR>
		<A HREF="index.html">Table of Contents</A> <BR>
		<A HREF="../index.html">Help Map</A> <BR>

		
		<P>
		Need help? <A HREF="../contact-visix.html">Contact Visix</A>.
		<P>
		<A HREF="../copyright.html">Copyright 1996-97</A>, <BR>
		<A HREF="http://www.visix.com/">Visix Software Inc.</A>
		</FONT>
		</TD>
	</TR>
</TABLE>

</BODY>
</HTML>
