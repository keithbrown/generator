<HTML>
  <HEAD>
<!--[[HEADING]]-->
<title>vfs prefix</title><!--[[/HEADING]]-->
  </HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<A NAME="Top"><IMG SRC="../graphics/trans.gif" WIDTH=2 HEIGHT=2></A><BR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">

		<TD>
		<CENTER>
		<A HREF="../index.html">
		<IMG SRC="../graphics/logo.gif" BORDER=0></A>
		</CENTER>
		</TD>

	        <TD VALIGN=TOP>
	        <BR><H1>
<!--[[TITLE]]-->
vfs prefix<!--[[/TITLE]]-->
	        </H1><BR>
		</TD>
      
	</TR>

</TABLE>

<HR>

<BR>

<!--[[PREAMBLE]]-->
<TABLE>
<TR>
<TD><A HREF="vfs-x.html#section_DataType">Types</A> [67]</TD>
<TD><A HREF="vfs-x.html#section_Function">Functions</A> [268]</TD>
<TD></TD>
<TD><A HREF="vfs-x.html#section_Constant">Constants</A> [43]</TD>
<TD><A HREF="vfs-x.html#section_Macro">Macros</A> [2]</TD>
</TR>
</TABLE>
<!--[[/PREAMBLE]]-->

<!--[[CONTENT]]-->

<P>
<A NAME="section_DataType"><HR>
<CENTER><H2>Types</H2></CENTER></A><P>
<A NAME="vfsAccessException"><HR><H4>vfsAccessException</H4></A>
<PRE>
        typedef ... <B>vfsAccessException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsAccessexception"><HR><H4>vfsAccessexception</H4></A>
<PRE>
        typedef ... <B>vfsAccessexception</B>;
</PRE>

<DL><DD>
Generated when you do not have permission to carry out a
specific operation on a file or directory. For example,
<CODE><A HREF="vfs-x.html#vfsChangeMode"><CODE>vfsChangeMode</CODE></A></CODE> can fail if you do not have the
access permissions to change the file's mode. (You may not
be the owner of the file.)
</DD></DL>
<P>
<A NAME="vfsDir"><HR><H4>vfsDir</H4></A>
<PRE>
        typedef ... <B>vfsDir</B>;
</PRE>

<DL><DD>
Describes the structure of a directory opened by the file
system manager. This structure is normally used to read the
contents of a directory. It maintains a pointer to the next
directory entry to be read. The <SAMP>vfsDir</SAMP>
structure should never be manipulated directly by Galaxy
client programs. It is used strictly as an argument to
functions such as <CODE><A HREF="vfs-x.html#vfsReadDir"><CODE>vfsReadDir</CODE></A></CODE> and is
initialized by <CODE><A HREF="vfs-x.html#vfsOpenDir"><CODE>vfsOpenDir</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsDirClass"><HR><H4>vfsDirClass</H4></A>
<PRE>
        typedef ... <B>vfsDirClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vfsDir</CODE>. Classes declared with this type contain the same
set of methods and variables as the default directory class, but the
behavior of methods and the contents of variables may vary. This class
type is derived from <CODE><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsDirNameException"><HR><H4>vfsDirNameException</H4></A>
<PRE>
        typedef ... <B>vfsDirNameException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsDirNameexception"><HR><H4>vfsDirNameexception</H4></A>
<PRE>
        typedef ... <B>vfsDirNameexception</B>;
</PRE>

<DL><DD>
Generated when a service is requested for a directory that
does not exist.
</DD></DL>
<P>
<A NAME="vfsException"><HR><H4>vfsException</H4></A>
<PRE>
        typedef ... <B>vfsException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsExistsException"><HR><H4>vfsExistsException</H4></A>
<PRE>
        typedef ... <B>vfsExistsException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsExistsexception"><HR><H4>vfsExistsexception</H4></A>
<PRE>
        typedef ... <B>vfsExistsexception</B>;
</PRE>

<DL><DD>
Generated when a File System Manager operation that would
create a file or directory, such as
<CODE><A HREF="vfs-x.html#vfsMakeDir"><CODE>vfsMakeDir</CODE></A></CODE>, <CODE><A HREF="vfs-x.html#vfsCreateFile"><CODE>vfsCreateFile</CODE></A></CODE>, or
<CODE><A HREF="vfs-x.html#vfsLink"><CODE>vfsLink</CODE></A></CODE>, is attempted for a file or directory
that already exists.
</DD></DL>
<P>
<A NAME="vfsFile"><HR><H4>vfsFile</H4></A>
<PRE>
        typedef ... <B>vfsFile</B>;
</PRE>

<DL><DD>
Describes the structure of a file opened by the file system
manager. It is initialized by the function
<CODE><A HREF="vfs-x.html#vfsOpenFile"><CODE>vfsOpenFile</CODE></A></CODE> and is passed (as one of the following arguments) to
file manipulation routines.

<ul>
<li><CODE><A HREF="vfs-x.html#vfsReadFile"><CODE>vfsReadFile</CODE></A></CODE> 
<li><CODE><A HREF="vfs-x.html#vfsWriteFile"><CODE>vfsWriteFile</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsSeekFile"><CODE>vfsSeekFile</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsGetFilePos"><CODE>vfsGetFilePos</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsCloseFile"><CODE>vfsCloseFile</CODE></A></CODE> 
</ul>

<P>
It tracks information such as
the system-specific handle to the file and the current
location pointer in the file. The <SAMP>vfsFile</SAMP>
structure should never be examined or manipulated directly
by Galaxy client programs.
</DD></DL>
<P>
<A NAME="vfsFileClass"><HR><H4>vfsFileClass</H4></A>
<PRE>
        typedef ... <B>vfsFileClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vfsFile</CODE>. Classes declared with this type contain the same
set of methods and variables as the default file class, but the
behavior of methods and the contents of variables may vary. This class
type is derived from <CODE><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsFileNameException"><HR><H4>vfsFileNameException</H4></A>
<PRE>
        typedef ... <B>vfsFileNameException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsFileNameexception"><HR><H4>vfsFileNameexception</H4></A>
<PRE>
        typedef ... <B>vfsFileNameexception</B>;
</PRE>

<DL><DD>
Generated when a service is requested for a file that does
not exist.
</DD></DL>
<P>
<A NAME="vfsFileSeekException"><HR><H4>vfsFileSeekException</H4></A>
<PRE>
        typedef ... <B>vfsFileSeekException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsFileSeekexception"><HR><H4>vfsFileSeekexception</H4></A>
<PRE>
        typedef ... <B>vfsFileSeekexception</B>;
</PRE>

<DL><DD>
Generated when an error occurs attempting to change the
offset pointer to a file, device, socket, or stream. This
is usually generated when attempts are made to seek to a
point before the physical beginning or end of the file.
(Note that it is legal on some systems to seek beyond the
end of the file to write data. This creates a ``sparse''
file that only stores the data actually written but appears
to be the correct size.) <CODE>vfsFileSeekexception</CODE>
exceptions are also generated when attempts are made to
seek on devices and special files (for example, named
pipes) that do not support such operations.
</DD></DL>
<P>
<A NAME="vfsFileType"><HR><H4>vfsFileType</H4></A>
<PRE>
        typedef ... <B>vfsFileType</B>;
</PRE>

<DL><DD>
Denotes the file type of a file. This is used for file
systems that support intrinsic file typing.
  <P>
Traditional file systems typically store information such
as file names and location information. However, some file
systems store information about the file contents in system
data structures. Using system data structures to store
information about the contents of a file is referred to as
``intrinsic file typing''. This type is passed to
<CODE><A HREF="vfs-x.html#vfsSetFileType"><CODE>vfsSetFileType</CODE></A></CODE> and returned from
<CODE><A HREF="vfs-x.html#vfsGetFileType"><CODE>vfsGetFileType</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsGroupId"><HR><H4>vfsGroupId</H4></A>
<PRE>
        typedef ... <B>vfsGroupId</B>;
</PRE>

<DL><DD>
Describes the numeric identifier for the group associated
with a file or directory. The <CODE><A HREF="vfs-x.html#vfsGetGroupId"><CODE>vfsGetGroupId</CODE></A></CODE>
and <CODE><A HREF="vfs-x.html#vfsChangeGroup"><CODE>vfsChangeGroup</CODE></A></CODE> functions are provided by
the File System Manager to get the group ID from a properly
initialized <SAMP><A HREF="vfs-x.html#vfsInfo"><CODE>vfsInfo</CODE></A></SAMP> object, and to change the
group ID for a path respectively.
</DD></DL>
<P>
<A NAME="vfsIOException"><HR><H4>vfsIOException</H4></A>
<PRE>
        typedef ... <B>vfsIOException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsIOexception"><HR><H4>vfsIOexception</H4></A>
<PRE>
        typedef ... <B>vfsIOexception</B>;
</PRE>

<DL><DD>
Generated when an input/output error is encountered by the
operating system or the Galaxy client program. Usually
associated with a read or write operation that failed due
to system I/O problems. These exceptions are relatively
rare and generally occur when attempts are made to read or
write information to devices/files that are not able to
accept the requested operation. (For example, attempts to
write on a named pipe that no other process has open for
reading returns a <CODE><A HREF="vfs-x.html#vfsWriteexception"><CODE>vfsWriteexception</CODE></A></CODE>
exception.) They can also occur when trying to write to a
read-only file or device (for example, a CD-ROM) or when
there is a physical failure of an I/O device (for example,
a disk controller is defective).
  <P>
The <CODE>vfsIOexception</CODE> ``class'' has the following
``subclasses:'' 

<ul>
<li><CODE><A HREF="vfs-x.html#vfsReadexception"><CODE>vfsReadexception</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsWriteexception"><CODE>vfsWriteexception</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsReadOnlyexception"><CODE>vfsReadOnlyexception</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsFileSeekexception"><CODE>vfsFileSeekexception</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsLockexception"><CODE>vfsLockexception</CODE></A></CODE>
</ul>
</DD></DL>
<P>
<A NAME="vfsInfo"><HR><H4>vfsInfo</H4></A>
<PRE>
        typedef ... <B>vfsInfo</B>;
</PRE>

<DL><DD>
Describes the structure containing such information as the
file or directory's type (for example, link, regular file,
directory, and so on), size, permission modes, group ID,
user ID, creation time, modification time, and other
attributes (for example, whether the file is hidden).
    <P>
The <CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE> and
<CODE><A HREF="vfs-x.html#vfsGetLinkInfo"><CODE>vfsGetLinkInfo</CODE></A></CODE> functions are provided by the
File System Manager to initialize the <SAMP>vfsInfo</SAMP>
structure. Functions such as <CODE><A HREF="vfs-x.html#vfsGetMode"><CODE>vfsGetMode</CODE></A></CODE> and
<CODE><A HREF="vfs-x.html#vfsGetSize"><CODE>vfsGetSize</CODE></A></CODE> retrieve all client-relevant
information contained in the structure.
</DD></DL>
<P>
<A NAME="vfsInfoClass"><HR><H4>vfsInfoClass</H4></A>
<PRE>
        typedef ... <B>vfsInfoClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vfsInfo</CODE>. Classes declared with this type
contain the same set of methods and variables as the default
file information class, but the behavior of methods and the
contents of variables may vary. This class type is derived
from <CODE><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsInterruptException"><HR><H4>vfsInterruptException</H4></A>
<PRE>
        typedef ... <B>vfsInterruptException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsInterruptexception"><HR><H4>vfsInterruptexception</H4></A>
<PRE>
        typedef ... <B>vfsInterruptexception</B>;
</PRE>

<DL><DD>
Generated when a system call is interrupted by an
asynchronous signal. In most cases this means an I/O
operation was interrupted before it could begin.
</DD></DL>
<P>
<A NAME="vfsIsDirException"><HR><H4>vfsIsDirException</H4></A>
<PRE>
        typedef ... <B>vfsIsDirException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsIsDirexception"><HR><H4>vfsIsDirexception</H4></A>
<PRE>
        typedef ... <B>vfsIsDirexception</B>;
</PRE>

<DL><DD>
Generated in several different cases when arguments to File
System Manager functions are directories and should have
been files, or an operation cannot be performed on a
directory because of a given file system or operating
system state. For example, attempting to remove a directory
using <CODE><A HREF="vfs-x.html#vfsRemove"><CODE>vfsRemove</CODE></A></CODE> that is an active mount point
for a volume or file system generates a
<CODE>vfsIsDirexception</CODE> exception.
</DD></DL>
<P>
<A NAME="vfsLockException"><HR><H4>vfsLockException</H4></A>
<PRE>
        typedef ... <B>vfsLockException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsLockexception"><HR><H4>vfsLockexception</H4></A>
<PRE>
        typedef ... <B>vfsLockexception</B>;
</PRE>

<DL><DD>
Generated when an error occurs attempting to lock/unlock a
file or portion of a file. Most often generated when a lock
request causes a system deadlock attempting to lock a
particular file segment.
</DD></DL>
<P>
<A NAME="vfsMaxFilesException"><HR><H4>vfsMaxFilesException</H4></A>
<PRE>
        typedef ... <B>vfsMaxFilesException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsMaxFilesexception"><HR><H4>vfsMaxFilesexception</H4></A>
<PRE>
        typedef ... <B>vfsMaxFilesexception</B>;
</PRE>

<DL><DD>
Generated when the operating system or the current process
has no more available slots for open files. (While the File
System Manager caching mechanism internally controls table
entries for active files to avoid this exception, it can
still be generated in rare cases.)
</DD></DL>
<P>
<A NAME="vfsMaxLinksException"><HR><H4>vfsMaxLinksException</H4></A>
<PRE>
        typedef ... <B>vfsMaxLinksException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsMaxLinksexception"><HR><H4>vfsMaxLinksexception</H4></A>
<PRE>
        typedef ... <B>vfsMaxLinksexception</B>;
</PRE>

<DL><DD>
Generated when the operating system has reached the maximum
number of symbolic links or aliases it can resolve to get
to the requested file or directory. This case arises when
links point to other links and the operating system gives
up resolving them after a given number has been resolved.
</DD></DL>
<P>
<A NAME="vfsMaxLocksException"><HR><H4>vfsMaxLocksException</H4></A>
<PRE>
        typedef ... <B>vfsMaxLocksException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsMaxLocksexception"><HR><H4>vfsMaxLocksexception</H4></A>
<PRE>
        typedef ... <B>vfsMaxLocksexception</B>;
</PRE>

<DL><DD>
Generated when a lock operation will cause the operating
system to exceed its limit of lock table entries for the
target file. Note that this exception can be generated by
both locking and unlocking operations (see
<CODE><A HREF="vfs-x.html#vfsLockFileRange"><CODE>vfsLockFileRange</CODE></A></CODE> and
<CODE><A HREF="vfs-x.html#vfsUnlockFileRange"><CODE>vfsUnlockFileRange</CODE></A></CODE>).
</DD></DL>
<P>
<A NAME="vfsMaxNameException"><HR><H4>vfsMaxNameException</H4></A>
<PRE>
        typedef ... <B>vfsMaxNameException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsMaxNameexception"><HR><H4>vfsMaxNameexception</H4></A>
<PRE>
        typedef ... <B>vfsMaxNameexception</B>;
</PRE>

<DL><DD>
Generated when a file or directory name (or component of a
path such as ``/dir/<I>name_too_long</I>/dir/filename'') is
longer than the limit set by the operating system or file
system in use. The File System Manager defines the constant
<CODE>vfsMAXIMUM_NAME_LEN</CODE> to be equal to the
operating system's maximum name length.
</DD></DL>
<P>
<A NAME="vfsMaxPathException"><HR><H4>vfsMaxPathException</H4></A>
<PRE>
        typedef ... <B>vfsMaxPathException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsMaxPathexception"><HR><H4>vfsMaxPathexception</H4></A>
<PRE>
        typedef ... <B>vfsMaxPathexception</B>;
</PRE>

<DL><DD>
Generated when a path (including separator characters when
applicable) is longer than the limit set by the operating
system or file system in use. The File System Manager
defines the constant <CODE>vfsMAXIMUM_PATH_LEN</CODE> to be
equal to the operating system's maximum path length.
</DD></DL>
<P>
<A NAME="vfsMode"><HR><H4>vfsMode</H4></A>
<PRE>
        typedef ... <B>vfsMode</B>;
</PRE>

<DL><DD>
Contains flags that define user access permissions for a
file or directory and is used by
<CODE><A HREF="vfs-x.html#vfsChangeMode"><CODE>vfsChangeMode</CODE></A></CODE>, <CODE><A HREF="vfs-x.html#vfsMakeDir"><CODE>vfsMakeDir</CODE></A></CODE>, and
<CODE><A HREF="vfs-x.html#vfsCreateFile"><CODE>vfsCreateFile</CODE></A></CODE> to set the access privileges of
a directory or file. Each file or directory has three
different groups of associated permissions: for the owner,
for the group to which the owner belongs, and for everyone
else. Three types of permissions can be assigned: read
access, write access, and execute access. The permissions
described by <SAMP>vfsMode</SAMP> only have an effect on
systems that support the concept of file access/ownership
for multiple users.
  <P>
The following constants can be inclusively ORed to create
the appropriate permissions:

<DL>
<DT><CODE>vfsOWNER_READ</CODE>
<DD>Read for owner.

<DT><CODE>vfsOWNER_WRITE</CODE>
<DD>Write for owner.

<DT><CODE>vfsOWNER_EXECUTE</CODE>
<DD>File-execution for owner.

<DT><CODE>vfsOWNER_PERMISSIONS_MASK</CODE>
<DD>Read, write, and execute for owner.

<DT><CODE>vfsGROUP_READ</CODE>
<DD>Read for owner's group.

<DT><CODE>vfsGROUP_WRITE</CODE>
<DD>Write for owner's group.

<DT><CODE>vfsGROUP_EXECUTE</CODE>
<DD>File-execution for owner's group.

<DT><CODE>vfsGROUP_PERMISSIONS_MASK</CODE>
<DD>Read, write, and execute for owner's group.

<DT><CODE>vfsOTHER_READ</CODE>
<DD>Read for others.

<DT><CODE>vfsOTHER_WRITE</CODE>
<DD>Write for others.

<DT><CODE>vfsOTHER_EXECUTE</CODE>
<DD>File-execution for others.

<DT><CODE>vfsOTHER_PERMISSIONS_MASK</CODE>
<DD>Read, write, and execute for others.
</DL>

<P>
As an example, the following code fragment changes the
current permission mask for an existing file to give the
owner of the file read, write, and execute access and give
the members of the group to which the owner belongs only
read access.
  <P>
Sample Code: Changing a File's Permission Mask

<BLOCKQUOTE>
<PRE>

<A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A>    *existingFile;

<A HREF="vfs-x.html#vfsChangeMode"><CODE>vfsChangeMode</CODE></A>(existingFile, (vfsOWNER_PERMISSIONS_MASK |
vfsGROUP_READ));

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsNameException"><HR><H4>vfsNameException</H4></A>
<PRE>
        typedef ... <B>vfsNameException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsNameexception"><HR><H4>vfsNameexception</H4></A>
<PRE>
        typedef ... <B>vfsNameexception</B>;
</PRE>

<DL><DD>
Generated when a component of a path does not exist. This
exception is generated when <I>any</I> path component is
nonexistent, not just the target file or directory. For
example, if the directory <CODE>Galaxy</CODE> did not
exist, the following pathnames used as arguments to any
File System Manager I/O function would generate an
exception from the <CODE>vfsNameexception</CODE> class:
  <P>
<CODE>Galaxy</CODE>
  <P>
<SAMP>/dir/<CODE>Galaxy</CODE></SAMP>
  <P>
<SAMP>/dir/<CODE>Galaxy</CODE>/src/vfs/vfstest.c</SAMP>
  <P>
The <CODE>vfsNameexception</CODE> ``class'' has two
``subclasses:'' <CODE><A HREF="vfs-x.html#vfsDirNameexception"><CODE>vfsDirNameexception</CODE></A></CODE> and
<CODE><A HREF="vfs-x.html#vfsFileNameexception"><CODE>vfsFileNameexception</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsNoMemoryException"><HR><H4>vfsNoMemoryException</H4></A>
<PRE>
        typedef ... <B>vfsNoMemoryException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsNoMemoryexception"><HR><H4>vfsNoMemoryexception</H4></A>
<PRE>
        typedef ... <B>vfsNoMemoryexception</B>;
</PRE>

<DL><DD>
Generated when there is not enough physical memory to
perform a file system operation. This exception is
currently generated only on DOS/Windows systems.
</DD></DL>
<P>
<A NAME="vfsNoSpaceException"><HR><H4>vfsNoSpaceException</H4></A>
<PRE>
        typedef ... <B>vfsNoSpaceException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsNoSpaceexception"><HR><H4>vfsNoSpaceexception</H4></A>
<PRE>
        typedef ... <B>vfsNoSpaceexception</B>;
</PRE>

<DL><DD>
Generated when there is not enough space left on a volume
to perform the operation. It is also generated when disk
quotas for the user running the Galaxy client process are
exceeded.
</DD></DL>
<P>
<A NAME="vfsNotEmptyException"><HR><H4>vfsNotEmptyException</H4></A>
<PRE>
        typedef ... <B>vfsNotEmptyException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsNotEmptyexception"><HR><H4>vfsNotEmptyexception</H4></A>
<PRE>
        typedef ... <B>vfsNotEmptyexception</B>;
</PRE>

<DL><DD>
Generated when an attempt is made to remove a directory or
folder that is not empty. A directory or folder is
considered empty when it contains no other entries for
files or directories other than references to the current
and parent directory/folder.
</DD></DL>
<P>
<A NAME="vfsPath"><HR><H4>vfsPath</H4></A>
<PRE>
        typedef ... <B>vfsPath</B>;
</PRE>

<DL><DD>
Describes to the operating system the hierarchical route
leading to a particular file or directory. A
<B><I>path</I></B> consists of at least a directory name
and may contain any of the following optional elements: a
volume, multiple directories, and/or a file name. Paths are
stored by the File System Manager as private structures
that are subject to change in future releases.
    <P>
For documentation purposes, pathnames are referred to using
the slash `<SAMP>/</SAMP>' character as a path separator
and to indicate full paths if the pathname is preceded with
the slash. (This is equivalent to the DOS backslash
character `<SAMP>\\</SAMP>'.) The <SAMP>vfsPath</SAMP>
structure should never be manipulated directly by Galaxy
client programs. Functions are provided by the File System
Manager to get and set all client-relevant information
contained in the <SAMP>vfsPath</SAMP> structure.
</DD></DL>
<P>
<A NAME="vfsPathClass"><HR><H4>vfsPathClass</H4></A>
<PRE>
        typedef ... <B>vfsPathClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vfsPath</CODE>. Classes declared with this type contain the same
set of methods and variables as the default path class, but the
behavior of methods and the contents of variables may vary. This class
type is derived from <CODE><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsReadException"><HR><H4>vfsReadException</H4></A>
<PRE>
        typedef ... <B>vfsReadException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsReadOnlyException"><HR><H4>vfsReadOnlyException</H4></A>
<PRE>
        typedef ... <B>vfsReadOnlyException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsReadOnlyexception"><HR><H4>vfsReadOnlyexception</H4></A>
<PRE>
        typedef ... <B>vfsReadOnlyexception</B>;
</PRE>

<DL><DD>
Generated when an error occurs attempting to write to a
file, device, socket, or stream that can only be read. Some
of the situations that generate a
<CODE>vfsReadOnlyexception</CODE> exception include
attempts to write to a file that is open for reading only,
writing to a read-only file system or volume, or writing to
a read-only device like a CD-ROM or a write-protected
diskette.
</DD></DL>
<P>
<A NAME="vfsReadexception"><HR><H4>vfsReadexception</H4></A>
<PRE>
        typedef ... <B>vfsReadexception</B>;
</PRE>

<DL><DD>
Generated when an I/O error occurs attempting to read a
file, network connection, device, socket, or stream. Other
problems that generate a <CODE>vfsReadexception</CODE>
exception include attempting a read on a file marked for
non-blocking I/O that has no data ready to be read, and
reading a UNIX stream when the message waiting is not a
data message.
</DD></DL>
<P>
<A NAME="vfsRequestException"><HR><H4>vfsRequestException</H4></A>
<PRE>
        typedef ... <B>vfsRequestException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsRequestexception"><HR><H4>vfsRequestexception</H4></A>
<PRE>
        typedef ... <B>vfsRequestexception</B>;
</PRE>

<DL><DD>
Generated when an illegal request is generated by a Galaxy
client program (or user). The
<CODE>vfsRequestexception</CODE> has the following
subclasses: 

<ul>
<li><CODE><A HREF="vfs-x.html#vfsIsDirexception"><CODE>vfsIsDirexception</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsAccessexception"><CODE>vfsAccessexception</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsExistsexception"><CODE>vfsExistsexception</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsNotEmptyexception"><CODE>vfsNotEmptyexception</CODE></A></CODE>
</ul>
</DD></DL>
<P>
<A NAME="vfsSystemException"><HR><H4>vfsSystemException</H4></A>
<PRE>
        typedef ... <B>vfsSystemException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsSystemMaxException"><HR><H4>vfsSystemMaxException</H4></A>
<PRE>
        typedef ... <B>vfsSystemMaxException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsSystemMaxexception"><HR><H4>vfsSystemMaxexception</H4></A>
<PRE>
        typedef ... <B>vfsSystemMaxexception</B>;
</PRE>

<DL><DD>
Generated when a File System Manager request would cause
the operating system to exceed a given internal resource
maximum. <CODE>vfsSystemMaxexception</CODE> has a number of
subclasses that deal with specific types of operating
system resources: 

<ul>
<li><CODE><A HREF="vfs-x.html#vfsNoSpaceexception"><CODE>vfsNoSpaceexception</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsNoMemoryexception"><CODE>vfsNoMemoryexception</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsMaxFilesexception"><CODE>vfsMaxFilesexception</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsMaxPathexception"><CODE>vfsMaxPathexception</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsMaxNameexception"><CODE>vfsMaxNameexception</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsMaxLinksexception"><CODE>vfsMaxLinksexception</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsMaxLocksexception"><CODE>vfsMaxLocksexception</CODE></A></CODE>
</ul>
</DD></DL>
<P>
<A NAME="vfsSystemexception"><HR><H4>vfsSystemexception</H4></A>
<PRE>
        typedef ... <B>vfsSystemexception</B>;
</PRE>

<DL><DD>
Generated when a problem occurs with the operating system
or the current process environment.
<CODE>vfsSystemexception</CODE> is used when the operating
system imposes limitations on the Galaxy client program.
(Operating systems return errors when their internal tables
for processes, files, and so on are full or when the Galaxy
client requests resources that are not available to the OS
or to the current process.)
  <P>
The <CODE>vfsSystemexception</CODE> ``class'' has the
following two ``subclasses:''
<CODE><A HREF="vfs-x.html#vfsInterruptexception"><CODE>vfsInterruptexception</CODE></A></CODE> and
<CODE><A HREF="vfs-x.html#vfsSystemMaxexception"><CODE>vfsSystemMaxexception</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsType"><HR><H4>vfsType</H4></A>
<PRE>
        typedef ... <B>vfsType</B>;
</PRE>

<DL><DD>
Indicates the type of a File System Manager path. It is
used by <CODE><A HREF="vfs-x.html#vfsGetPathType"><CODE>vfsGetPathType</CODE></A></CODE> and
<CODE><A HREF="vfs-x.html#vfsBuildPath"><CODE>vfsBuildPath</CODE></A></CODE> to get and set a path type. When
a Galaxy client program builds a path using functions other
than <CODE><A HREF="vfs-x.html#vfsBuildPath"><CODE>vfsBuildPath</CODE></A></CODE>, the File System Manager
automatically determines the type of the path.
Understanding a path's correct type is critical to the
operation of the File System Manager's cache. Path types
can be one of the following values:

<DL>
<DT><CODE>vfsPATH_TYPE_FULL</CODE>
<DD>Denotes a full path that begins at the root volume in
the form `` <SAMP>/dir/dir/filename</SAMP>.'' 

<DT><CODE>vfsPATH_TYPE_RELATIVE</CODE> 
<DD>Denotes a path that is
relative to another directory. For instance,
``<SAMP>../dir/filename</SAMP>'' would describe a path that
is relative to the parent directory or folder. Note that
<SAMP>vfsPATH_TYPE_RELATIVE</SAMP> is used only for file
and directory pathnames that <I>begin</I> with a relative
reference. Paths such as
``<SAMP>/dir/dir/../filename</SAMP>'' would be considered a
full pathname even though they contain relative references.

<DT><CODE>vfsPATH_TYPE_NAME</CODE>
<DD>Denotes a file or directory name only, for example,
``<SAMP>filename</SAMP> .'' This case is treated internally
by the File System Manager as a special type of relative
path because it is relative to the directory that contains
it. 
</DL>
</DD></DL>
<P>
<A NAME="vfsUserId"><HR><H4>vfsUserId</H4></A>
<PRE>
        typedef ... <B>vfsUserId</B>;
</PRE>

<DL><DD>
Describes the numeric identifier for the user (owner)
associated with a file or directory. The
<CODE><A HREF="vfs-x.html#vfsGetUserId"><CODE>vfsGetUserId</CODE></A></CODE> and <CODE><A HREF="vfs-x.html#vfsChangeOwner"><CODE>vfsChangeOwner</CODE></A></CODE>
functions are provided by the File System Manager to get
the user Id from a properly initialized
<SAMP><A HREF="vfs-x.html#vfsInfo"><CODE>vfsInfo</CODE></A></SAMP> object, and to change the user ID for
a path respectively.
</DD></DL>
<P>
<A NAME="vfsVolume"><HR><H4>vfsVolume</H4></A>
<PRE>
        typedef ... <B>vfsVolume</B>;
</PRE>

<DL><DD>
Describes any formatted storage medium that contains files. 
A <B><I>volume</I></B> can reference various media, such
as a floppy disk, CD-ROM, or a hard disk partition. 
Depending upon the operating system, a volume has a name
and sometimes an identification number to uniquely identify
it. The <SAMP>vfsVolume</SAMP> structure should never be
manipulated directly by Galaxy client programs. Functions
are provided by the File System Manager to get and set all
client-relevant information contained in the structure.
</DD></DL>
<P>
<A NAME="vfsVolumeClass"><HR><H4>vfsVolumeClass</H4></A>
<PRE>
        typedef ... <B>vfsVolumeClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vfsVolume</CODE>. Classes declared with this type contain the same
set of methods and variables as the default volume class, but the
behavior of methods and the contents of variables may vary. This class
type is derived from <CODE><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsVolumeIterator"><HR><H4>vfsVolumeIterator</H4></A>
<PRE>
        typedef ... <B>vfsVolumeIterator</B>;
</PRE>

<DL><DD>
Denotes an abstract pointer object used to iterate over all
file system volumes known to the operating system.
</DD></DL>
<P>
<A NAME="vfsVolumeListIterator"><HR><H4>vfsVolumeListIterator</H4></A>
<PRE>
        typedef ... <B>vfsVolumeListIterator</B>;
</PRE>

<DL><DD>
An abstract pointer object used to iterate over all file
system volumes known to the operating system.
</DD></DL>
<P>
<A NAME="vfsVolumeRef"><HR><H4>vfsVolumeRef</H4></A>
<PRE>
        typedef ... <B>vfsVolumeRef</B>;
</PRE>

<DL><DD>
Describes the numeric reference number for a given file
system volume. This number is used by certain calls within
DOS and other operating systems to refer to a particular
volume. Under DOS the logical drive indicators A through Z
are mapped automatically to a volume reference number of 1
through 26 (that is, A == 1, ..., Z == 26).
</DD></DL>
<P>
<A NAME="vfsWriteException"><HR><H4>vfsWriteException</H4></A>
<PRE>
        typedef ... <B>vfsWriteException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsWriteexception"><HR><H4>vfsWriteexception</H4></A>
<PRE>
        typedef ... <B>vfsWriteexception</B>;
</PRE>

<DL><DD>
Generated when an error occurs attempting to write to a
file, device, socket, or stream. Other problems that can
potentially generate a <CODE>vfsWriteexception</CODE>
exception include attempts to write to a file marked for
non-blocking I/O when no data can be written immediately,
and attempting a write to a device that goes off line
before or during the write operation.
</DD></DL>
<P>
<A NAME="section_Function"><HR>
<CENTER><H2>Functions</H2></CENTER></A><P>
<A NAME="vfsAccess"><HR><H4>vfsAccess</H4></A>
<PRE>
        vbool <B>vfsAccess</B>(
                const vfsPath * path,
                int accessMode);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the access mode(s) specified
in <SAMP>accessMode</SAMP> are defined for the path,
<SAMP>FALSE</SAMP> if not. The <SAMP>accessMode</SAMP>
parameter can be created by inclusive ORing any of the
following values:

<DL>
<DT><CODE>vfsCAN_READ</CODE>
<DD>Read permission allowed. 

<DT><CODE>vfsCAN_WRITE</CODE>
<DD>Write permission allowed. (Note that in most operating
systems, a directory marked as writable only allows you to
create files in it and write into the files that you have
created. Attempts to open the directory itself for writing
will probably fail.) 

<DT><CODE>vfsCAN_EXECUTE</CODE>
<DD>Execute permission allowed. (Note that this only
returns whether the user has <I>permission</I> to execute
the file. It does not guarantee that it can be executed if
it is not in the correct format. Also, under UNIX, execute
access for a directory means you can read the contents of
any file in the directory, and you can change your working
directory to that directory. Execute access must be set
under UNIX to have access to the files in any directory.) 

<DT><CODE>vfsFILE_EXISTS</CODE>
<DD><SAMP>path</SAMP> exists at the designated place. 
</DL>

<P>
Under UNIX, <CODE>vfsAccess</CODE> is effective for normal
programs as well as <SAMP>setuid</SAMP> and
<SAMP>setgid</SAMP> programs. If a program is running as a
<SAMP>setuid/setgid</SAMP> executable, the <I>effective</I>
user/group ID is used to make the requested access
tests.

<P>

Sample Code: Using <CODE>vfsAccess</CODE>

<BLOCKQUOTE>
<PRE>

<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>        *testPath;

<A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A>        *nameStr;

/*
 * Find out if we have read and write access
 * to the file "test" in the current directory.
 */
testPath                = vfsCloneWorkingDir();
nameStr                = <A HREF="vstr-x.html#vstrCloneScribed"><CODE>vstrCloneScribed</CODE></A>( <A HREF="vchar-x.html#vcharScribeLiteral"><CODE>vcharScribeLiteral</CODE></A>( "test" )
);
<A HREF="vfs-x.html#vfsAppendPath"><CODE>vfsAppendPath</CODE></A>(testPath, nameStr, NULL);
if (vfsAccess(testPath, (vfsCAN_READ | vfsCAN_WRITE)))
  /* We can read and write 'test' */
else
  /* Can't read or write (or both) to 'test' */
<A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A>(testPath);
<A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A>(nameStr);

</PRE>
</BLOCKQUOTE>
 
<P>
Exceptions:

<DL>
<DT><SAMP>vexArgNullexception</SAMP>
<DD>Generated if the path <SAMP>path</SAMP> is a
<SAMP>NULL</SAMP> pointer.</B> 

<DT><SAMP>vexArgexception</SAMP>
<DD>Generated if the path <SAMP>path</SAMP> points outside
the process's address space (a condition not always
guaranteed to be caught), or <SAMP>accessMode</SAMP> is not
a legal value. 

<DT><SAMP><A HREF="vfs-x.html#vfsMaxPathexception"><CODE>vfsMaxPathexception</CODE></A></SAMP>
<DD>Generated if the total number of characters in the path
<SAMP>path</SAMP> (including its members and the required
system format path separators) is beyond the system limit
as defined in <SAMP>vfsMAXIMUM_PATH_LEN</SAMP>. Also
generated when one of the path members exceeds
<SAMP>vfsMAXIMUM_NAME_LEN</SAMP> characters. 

<DT><SAMP><A HREF="vfs-x.html#vfsMaxLinksexception"><CODE>vfsMaxLinksexception</CODE></A></SAMP>
<DD>Generated if the path cannot be resolved by the
operating system because it contains too many symbolic link
or alias references. (Check if there is a symbolic link
``loop'' where the chain of symbolic links is ultimately
self-referential.) 

<DT><SAMP><A HREF="vfs-x.html#vfsIOexception"><CODE>vfsIOexception</CODE></A></SAMP>
<DD>Generated if a low-level operating system I/O error
occurred attempting to access the file or directory pointed
to by the path <SAMP>path</SAMP>. 
</DL>
</DD></DL>
<P>
<A NAME="vfsAllowCachingForFile"><HR><H4>vfsAllowCachingForFile</H4></A>
<PRE>
        void <B>vfsAllowCachingForFile</B>(
                vfsFile * file,
                vbool allowCaching);
</PRE>

<DL><DD>
Sets the internal File System Manager caching status for
the file. If the value of <SAMP>allowCaching</SAMP> is
<SAMP>TRUE</SAMP>, The file is included in the list of open
files that may be temporarily closed by the File System
Manager's caching mechanism to preserve operating system
file table entries. If the value of
<SAMP>allowCaching</SAMP> is <SAMP>FALSE</SAMP>, the File
System Manager leaves this file open until it is explicitly
closed using <CODE><A HREF="vfs-x.html#vfsCloseFile"><CODE>vfsCloseFile</CODE></A></CODE>.
<P>
Explicitly ``protecting'' a file from the File System
Manager's caching mechanism guarantees that file pointers
and file descriptors used for file I/O by external C
library functions are always be the same. It is also
possible on multi-process operating systems for the File
System Manager to close a file temporarily to scavenge its
file table entry and fail to re-open it for the next I/O
operation because the file's permission mode has been
changed or it was removed entirely.
    <P>
The <CODE><A HREF="vfs-x.html#vfsOpenFile"><CODE>vfsOpenFile</CODE></A></CODE> open mode flag
<SAMP>vfsOPEN_NOT_CACHED</SAMP> also explicitly disallows
caching for the target file.
</DD></DL>
<P>
<A NAME="vfsAppendPath"><HR><H4>vfsAppendPath</H4></A>
<PRE>
        void <B>vfsAppendPath</B>(
                vfsPath * path,
                const vchar * element,
                ... arg3);
</PRE>

<DL><DD>
Appends any number of new path components to the end of the
path <SAMP>path</SAMP>. <SAMP>element</SAMP> is the first
of one or many path elements in an argument list that must
be terminated by a <SAMP>NULL</SAMP> pointer.
<P>
The path component arguments are cloned, so it is possible
to use pointers to, or scribe, shared strings as arguments
to <CODE>vfsAppendPath</CODE> and
<CODE><A HREF="vfs-x.html#vfsAppendPathScribed"><CODE>vfsAppendPathScribed</CODE></A></CODE>. For example,
<CODE>vfsAppendPath</CODE> <SAMP>(path, <A HREF="vfs-x.html#vfsGetAppName"><CODE>vfsGetAppName</CODE></A>(),
NULL)</SAMP> would append the application's name to the end
of <SAMP>path</SAMP>. It would not destroy the shared
string referenced by <CODE><A HREF="vfs-x.html#vfsGetAppName"><CODE>vfsGetAppName</CODE></A></CODE> when a
<CODE><A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A></CODE> call is made to destroy
<SAMP>path</SAMP>. Scribes passed to
<CODE><A HREF="vfs-x.html#vfsAppendPathScribed"><CODE>vfsAppendPathScribed</CODE></A></CODE> are automatically
destroyed.
  <P>
You must terminate the argument list for both of these
functions with a <SAMP>NULL</SAMP> pointer because it marks
the end of a variable list of arguments.
</DD></DL>
<P>
<A NAME="vfsAppendPathScribed"><HR><H4>vfsAppendPathScribed</H4></A>
<PRE>
        void <B>vfsAppendPathScribed</B>(
                vfsPath * path,
                vscribe * scribe,
                ... arg3);
</PRE>

<DL><DD>
Appends any number of new path components to the end of the
path <SAMP>path</SAMP>. <SAMP>scribe</SAMP> is the first
argument in a <SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP> scribe argument list that
must be terminated by a <SAMP>NULL</SAMP> pointer.
  <P>
The path component arguments are cloned, so it is possible
to use pointers to, or scribe, shared strings as arguments
to <CODE>vfsAppendPath</CODE> and
<CODE>vfsAppendPathScribed</CODE>. For example,
<CODE>vfsAppendPath</CODE><SAMP>(path, <A HREF="vfs-x.html#vfsGetAppName"><CODE>vfsGetAppName</CODE></A>(),
NULL)</SAMP> would append the application's name to the end
of <SAMP>path</SAMP>. It would not destroy the shared
string referenced by <CODE><A HREF="vfs-x.html#vfsGetAppName"><CODE>vfsGetAppName</CODE></A></CODE> when a
<CODE><A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A></CODE> call is made to destroy
<SAMP>path</SAMP>. Scribes passed to
<CODE>vfsAppendPathScribed</CODE> are automatically
destroyed.
  <P>
You must terminate the argument list for both of these
functions with a <SAMP>NULL</SAMP> pointer because it marks
the end of a variable list of arguments.
  <P>
Sample Code: Using <CODE>vfsAppendPath</CODE>

<BLOCKQUOTE>
<PRE>

/*
 * Code fragment to append the directory 'dir' and the file name
 * 'file' to a copy of the current working directory.
 */

<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>    *path;

<A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A>     *dirStr,
        *fileStr;

dirStr = <A HREF="vstr-x.html#vstrCloneScribed"><CODE>vstrCloneScribed</CODE></A>( <A HREF="vchar-x.html#vcharScribeLiteral"><CODE>vcharScribeLiteral</CODE></A>( "dir" ) );
nameStr = <A HREF="vstr-x.html#vstrCloneScribed"><CODE>vstrCloneScribed</CODE></A>( <A HREF="vchar-x.html#vcharScribeLiteral"><CODE>vcharScribeLiteral</CODE></A>( "file" ) );
path  = vfsCloneWorkingDir();
vfsAppendPath(path, dirStr, fileStr, NULL);
<A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A>(dirStr);
<A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A>(nameStr);

/*
 * Accomplish the same effect using vfsAppendPathScribed().
 */

<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>    *path;
path = vfsCloneWorkingDir();
vfsAppendPathScribed(path, <A HREF="vchar-x.html#vcharScribeLiteral"><CODE>vcharScribeLiteral</CODE></A>("dir"),
                <A HREF="vchar-x.html#vcharScribeLiteral"><CODE>vcharScribeLiteral</CODE></A>("file"), NULL);

</PRE>
</BLOCKQUOTE>
 
<P>
Exceptions are as follows:

<DL>
<DT><SAMP>vexArgNullexception</SAMP>
<DD>Generated if either the path is a <SAMP>NULL</SAMP>
pointer or the first component argument in
<CODE>vfsAppendPath</CODE> or
<CODE>vfsAppendPathScribed</CODE> is a <SAMP>NULL</SAMP>
pointer. 

<DT><SAMP>vexArgexception</SAMP>
<DD>Generated if <SAMP>scribe</SAMP> points to a scribe
that does not write out a <SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP> string. 
</DL>
</DD></DL>
<P>
<A NAME="vfsBuildPath"><HR><H4>vfsBuildPath</H4></A>
<PRE>
        vfsPath * <B>vfsBuildPath</B>(
                vfsType type,
                const vchar * element,
                ... arg3);
</PRE>

<DL><DD>
Returns a dynamically allocated path built from a variable
list of components. <SAMP>element</SAMP> is the first
<SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP> string component argument to be followed
by any number of additional components. The last argument
to <CODE><A HREF="vfs-x.html#vfsBuildPathScribed"><CODE>vfsBuildPathScribed</CODE></A></CODE> must be
<SAMP>NULL</SAMP> to end the argument list.
<P>
<SAMP>type</SAMP> can have one of the following values:

<DL>
<DT><CODE>vfsPATH_TYPE_FULL</CODE>
<DD>Denotes a full path that begins at the root volume in
the form `` <SAMP>/dir/dir/filename</SAMP>.'' 

<DT><CODE>vfsPATH_TYPE_RELATIVE</CODE>
<DD>Denotes a path that is relative to another directory.
For instance, ``<SAMP>../dir/filename</SAMP>'' would
describe a path that is relative to the parent directory or
folder. Note that <SAMP>vfsPATH_TYPE_RELATIVE</SAMP> is
used only for file and directory pathnames that
<I>begin</I> with a relative reference. For example,
``<SAMP>/dir/dir2/../filename</SAMP>'' would be considered
a full pathname. 

<DT><CODE>vfsPATH_TYPE_NAME</CODE>
<DD>Denotes a file or directory name only, for example,
``<SAMP>filename</SAMP> .'' This is generally treated
internally by the File System Manager as a special type of
relative path, because it is relative to the directory that
contains it. 
</DL>

<P>
The path component arguments are cloned by both functions
when the new path is constructed, so it is possible to use
pointers to, or scribe, shared strings as arguments to
<CODE>vfsBuildPath</CODE> and
<CODE><A HREF="vfs-x.html#vfsBuildPathScribed"><CODE>vfsBuildPathScribed</CODE></A></CODE>. For example:
<SAMP>vfsBuildPath(vfsPATH_TYPE_NAME, <A HREF="vfs-x.html#vfsGetAppName"><CODE>vfsGetAppName</CODE></A>(),
NULL)</SAMP> would build a path using the current
application name. It would not destroy the shared string
referenced by <CODE><A HREF="vfs-x.html#vfsGetAppName"><CODE>vfsGetAppName</CODE></A></CODE> when a
<CODE><A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A></CODE> call is made to destroy
<SAMP>path</SAMP>. Scribes passed to
<CODE><A HREF="vfs-x.html#vfsAppendPathScribed"><CODE>vfsAppendPathScribed</CODE></A></CODE> are automatically
destroyed.
<P>
<CODE>vfsBuildPath</CODE> and
<CODE><A HREF="vfs-x.html#vfsBuildPathScribed"><CODE>vfsBuildPathScribed</CODE></A></CODE> return a dynamically
allocated path that can be destroyed by
<CODE><A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A></CODE>.

<P>
A path to the root directory can be created if the first
component argument to either function is <SAMP>NULL</SAMP>
and <SAMP>type</SAMP> is
<SAMP>vfsPATH_TYPE_FULL</SAMP>.
<P>
Sample Code: Using <CODE>vfsBuildPath</CODE>

<BLOCKQUOTE>
<PRE>

/*
 * Build a full pathname to "/directory/filename"
 */
<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>    *path;
<A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A>    dir[vfsMAXIMUM_NAME_LEN + 1],    /* Use stack to avoid
dynamic
                         
allocation/deallocation  */
    file[vfsMAXIMUM_NAME_LEN + 1];

<A HREF="vchar-x.html#vcharCopyFromLiteral"><CODE>vcharCopyFromLiteral</CODE></A>("directory", dir);
<A HREF="vchar-x.html#vcharCopyFromLiteral"><CODE>vcharCopyFromLiteral</CODE></A>("filename", file);
path = vfsBuildPath(vfsPATH_TYPE_FULL, dir, file, NULL);

/*
 * Accomplish the same task using <A HREF="vfs-x.html#vfsBuildPathScribed"><CODE>vfsBuildPathScribed</CODE></A>()
 */

<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>    *path;

path = vfsBuildPath(vfsPATH_TYPE_FULL, <A HREF="vchar-x.html#vcharScribeLiteral"><CODE>vcharScribeLiteral</CODE></A>("directory"),
                      
<A HREF="vchar-x.html#vcharScribeLiteral"><CODE>vcharScribeLiteral</CODE></A>("filename"), NULL);

</PRE>
</BLOCKQUOTE>
 
<P>
Exceptions include:
 
<DL>
<DT><SAMP>vexArgexception</SAMP>
<DD>Generated if <SAMP>type</SAMP> is not a legal value or
if <SAMP>componentScribe</SAMP> points to a scribe that
does not write out <SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP> strings. 

<DT><SAMP>vexArgNullexception</SAMP>
<DD>Generated if the first path component is
<SAMP>NULL</SAMP> and <SAMP>type</SAMP> is not
<SAMP>vfsPATH_TYPE_FULL</SAMP> (that is, you can create an
empty root path but not an empty name or relative path). 
</DL>
</DD></DL>
<P>
<A NAME="vfsBuildPathScribed"><HR><H4>vfsBuildPathScribed</H4></A>
<PRE>
        vfsPath * <B>vfsBuildPathScribed</B>(
                vfsType type,
                vscribe * scribe,
                ... arg3);
</PRE>

<DL><DD>
Returns a dynamically allocated path built from a variable
list of components. <SAMP>scribe</SAMP> is the first
<SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP> scribe argument to be followed by any
number of scribes that write out <SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP>
strings. The last argument to
<CODE>vfsBuildPathScribed</CODE> must be <SAMP>NULL</SAMP>
to end the argument list.
<P>
<SAMP>type</SAMP> can have one of the following values:

<DL>
<DT><CODE>vfsPATH_TYPE_FULL</CODE>
<DD>Denotes a full path that begins at the root volume in
the form ``<SAMP>/dir/dir/filename</SAMP>.'' 

<DT><CODE>vfsPATH_TYPE_RELATIVE</CODE>
<DD>Denotes a path that is relative to another directory.
For instance, ``<SAMP>../dir/filename</SAMP>'' would
describe a path that is relative to the parent directory or
folder. Note that <SAMP>vfsPATH_TYPE_RELATIVE</SAMP> is
used only for file and directory pathnames that
<I>begin</I> with a relative reference. For example,
``<SAMP>/dir/dir2/../filename</SAMP>'' would be considered
a full pathname. 

<DT><CODE>vfsPATH_TYPE_NAME</CODE>
<DD>Denotes a file or directory name only, for example,
``<SAMP>filename</SAMP> .'' This is generally treated
internally by the File System Manager as a special type of
relative path, because it is relative to the directory that
contains it. 
</DL>

<P>
The path component arguments are cloned by both functions
when the new path is constructed, so it is possible to use
pointers to, or scribe, shared strings as arguments to
<CODE>vfsBuildPath</CODE> and
<CODE>vfsBuildPathScribed</CODE>. For example:
<SAMP>vfsBuildPath(vfsPATH_TYPE_NAME, <A HREF="vfs-x.html#vfsGetAppName"><CODE>vfsGetAppName</CODE></A>(),
NULL)</SAMP> would build a path using the current
application name. It would not destroy the shared string
referenced by <CODE><A HREF="vfs-x.html#vfsGetAppName"><CODE>vfsGetAppName</CODE></A></CODE> when a
<CODE><A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A></CODE> call is made to destroy
<SAMP>path</SAMP>. Scribes passed to
<CODE><A HREF="vfs-x.html#vfsAppendPathScribed"><CODE>vfsAppendPathScribed</CODE></A></CODE> are automatically
destroyed.
  <P>
<CODE>vfsBuildPath</CODE> and
<CODE>vfsBuildPathScribed</CODE> return a dynamically
allocated path that can be destroyed by
<CODE><A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A></CODE>.

<P>
A path to the root directory can be created if the first
component argument to either function is <SAMP>NULL</SAMP>
and <SAMP>type</SAMP> is
<SAMP>vfsPATH_TYPE_FULL</SAMP>.
<P>
Exceptions are as follows:

<DL>
<DT><SAMP>vexArgexception</SAMP>
<DD>Generated if <SAMP>type</SAMP> is not a legal value or
if <SAMP>componentScribe</SAMP> points to a scribe that
does not write out <SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP> strings. 

<DT><SAMP>vexArgNullexception</SAMP>
<DD>Generated if the first path component is
<SAMP>NULL</SAMP> and <SAMP>type</SAMP> is not
<SAMP>vfsPATH_TYPE_FULL</SAMP> (that is, you can create an
empty root path but not an empty name or relative path). 
</DL>
</DD></DL>
<P>
<A NAME="vfsChangeGroup"><HR><H4>vfsChangeGroup</H4></A>
<PRE>
        void <B>vfsChangeGroup</B>(
                const vfsPath * path,
                vfsGroupId groupId);
</PRE>

<DL><DD>
Changes the group reference of a file or directory
specified by the path <SAMP>path</SAMP>.
<SAMP>groupId</SAMP> indicates the ID of the
file/directory's group reference.
<P>
Exceptions:

<DL>
<DT><SAMP>vexArgNullexception</SAMP>
<DD>Generated if the path <SAMP>path</SAMP> is a
<SAMP>NULL</SAMP> pointer.</B> 

<DT><SAMP>vexArgexception</SAMP>
<DD>Generated if the path points outside the process's
address space (a condition not always guaranteed to be
caught); part of the path is not a directory; or, under
some UNIX operating system variants, the path refers to a
socket and not a file or directory. 

<DT><SAMP><A HREF="vfs-x.html#vfsAccessexception"><CODE>vfsAccessexception</CODE></A></SAMP>
<DD>Generated if search permission is denied for a
component of the path; the process user ID is not the owner
of the file; or, under POSIX compliant operating systems,
the process is not super-user enabled and the operating
system has defined the constant
<SAMP>_POSIX_CHOWN_RESTRICTED</SAMP>. 

<DT><SAMP><A HREF="vfs-x.html#vfsNameexception"><CODE>vfsNameexception</CODE></A></SAMP>
<DD>Generated if any part of the path references a file or
directory that does not exist or the file or directory
referenced by the path does not exist. 

<DT><SAMP><A HREF="vfs-x.html#vfsReadOnlyexception"><CODE>vfsReadOnlyexception</CODE></A></SAMP>
<DD>Generated if the path references a file or directory on
a read-only file system or volume. 

<DT><SAMP><A HREF="vfs-x.html#vfsMaxPathexception"><CODE>vfsMaxPathexception</CODE></A></SAMP>
<DD>Generated if the total number of characters in the path
(including its members and the required system format path
separators) is beyond the system limit as defined in
<SAMP>vfsMAXIMUM_PATH_LEN</SAMP>. It is also generated when
one of the path members exceeds
<SAMP>vfsMAXIMUM_NAME_LEN</SAMP> characters. 

<DT><SAMP><A HREF="vfs-x.html#vfsMaxLinksexception"><CODE>vfsMaxLinksexception</CODE></A></SAMP>
<DD>Generated if the path cannot be resolved by the
operating system because it contains too many symbolic link
or alias references. (Check if there is a symbolic link
``loop'' where the chain of symbolic links is ultimately
self-referential.) 

<DT><SAMP><A HREF="vfs-x.html#vfsIOexception"><CODE>vfsIOexception</CODE></A></SAMP>
<DD>Generated if a low-level operating system I/O error
occurred attempting to change the group reference for the
file or directory pointed to by the path. 
</DL>
</DD></DL>
<P>
<A NAME="vfsChangeMode"><HR><H4>vfsChangeMode</H4></A>
<PRE>
        void <B>vfsChangeMode</B>(
                const vfsPath * path,
                vfsMode mode);
</PRE>

<DL><DD>
Changes the access permissions of a file or directory
specified by the path <SAMP>path</SAMP>. <SAMP>mode</SAMP>
indicates the new mode to be assigned to the file or
directory. <CODE>vfsChangeMode</CODE> has no effect on
operating systems that do not support multiple user access
privileges.
<P>
The following mode masks may be combined (by ORing them
inclusively) to create the desired access privilege:

<DL>
<DT><CODE>vfsOWNER_READ</CODE>
<DD>Read for owner.

<DT><CODE>vfsOWNER_WRITE</CODE>
<DD>Write for owner.

<DT><CODE>vfsOWNER_EXECUTE</CODE>
<DD>File-execution for owner.

<DT><CODE>vfsOWNER_PERMISSIONS_MASK</CODE>
<DD>Read, write, and execute for owner.

<DT><CODE>vfsGROUP_READ</CODE>
<DD>Read for owner's group.

<DT><CODE>vfsGROUP_WRITE</CODE>
<DD>Write for owner's group.

<DT><CODE>vfsGROUP_EXECUTE</CODE>
<DD>File-execution for owner's group.

<DT><CODE>vfsGROUP_PERMISSIONS_MASK</CODE>
<DD>Read, write, and execute for owner's group.

<DT><CODE>vfsOTHER_READ</CODE>
<DD>Read for others.

<DT><CODE>vfsOTHER_WRITE</CODE>
<DD>Write for others.

<DT><CODE>vfsOTHER_EXECUTE</CODE>
<DD>File-execution for others.

<DT><CODE>vfsOTHER_PERMISSIONS_MASK</CODE>
<DD>Read, write, and execute for others.
</DL>

<P>
Sample Code: Using <CODE>vfsChangeMode</CODE>

<BLOCKQUOTE>
<PRE>
/*
 * Change access for the file "test" in the current directory
 * to give the owner and the process's group reference read
 * and execute access.
 */
<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>        *path;

path = vfsCloneWorkingDir();
<A HREF="vfs-x.html#vfsAppendPathScribed"><CODE>vfsAppendPathScribed</CODE></A>(path, <A HREF="vchar-x.html#vcharScribeLiteral"><CODE>vcharScribeLiteral</CODE></A>("test"), NULL);
vfsChangeMode(path,        (vfsOWNER_READ | vfsOWNER_EXECUTE |
                         vfsOTHER_READ | vfsOTHER_EXECUTE));

</PRE>
</BLOCKQUOTE>

<P>
Exceptions:
 
<DL>
<DT><SAMP>vexArgNullexception</SAMP>
<DD>Generated if the path is a <SAMP>NULL</SAMP>
pointer.</B> 

<DT><SAMP>vexArgexception</SAMP>
<DD>Generated if the path points outside the process's
address space (a condition not always guaranteed to be
caught); part of the path is not a directory; or, under
some UNIX operating system variants, <SAMP>path</SAMP>
refers to a socket and not a file or directory. 

<DT><SAMP><A HREF="vfs-x.html#vfsAccessexception"><CODE>vfsAccessexception</CODE></A></SAMP>
<DD>Generated if search permission is denied for a
component of the path; the process user ID is not the owner
of the file; or, under some UNIX operating system variants
such as SunOS, the process is not super-user enabled. 

<DT><SAMP><A HREF="vfs-x.html#vfsNameexception"><CODE>vfsNameexception</CODE></A></SAMP>
<DD>Generated if any part of the path references a file or
directory that does not exist or the file or directory
referenced by the path does not exist. 

<DT><SAMP><A HREF="vfs-x.html#vfsReadOnlyexception"><CODE>vfsReadOnlyexception</CODE></A></SAMP>
<DD>Generated if the path references a file or directory on
a read-only file system or volume. 

<DT><SAMP><A HREF="vfs-x.html#vfsMaxPathexception"><CODE>vfsMaxPathexception</CODE></A></SAMP>
<DD>Generated if the total number of characters in the path
(including its members and the required system format path
separators) is beyond the system limit as defined in
<SAMP>vfsMAXIMUM_PATH_LEN</SAMP>. Also generated when one
of the path members exceeds
<SAMP>vfsMAXIMUM_NAME_LEN</SAMP> characters. 

<DT><SAMP><A HREF="vfs-x.html#vfsMaxLinksexception"><CODE>vfsMaxLinksexception</CODE></A></SAMP>
<DD>Generated if the path cannot be resolved by the
operating system because it contains too many symbolic link
or alias references. (Check if there is a symbolic link
``loop'' where the chain of symbolic links is ultimately
self-referential.) 

<DT><SAMP><A HREF="vfs-x.html#vfsIOexception"><CODE>vfsIOexception</CODE></A></SAMP>
<DD>Generated if a low-level operating system I/O error
occurred attempting to change the access mode for the file
or directory pointed to by the path. 
</DL>
</DD></DL>
<P>
<A NAME="vfsChangeOwner"><HR><H4>vfsChangeOwner</H4></A>
<PRE>
        void <B>vfsChangeOwner</B>(
                const vfsPath * path,
                vfsUserId userId);
</PRE>

<DL><DD>
Changes the owner of a file or directory specified by the
path. <SAMP>userId</SAMP> indicates the ID of the new
owner.
<P>
Exceptions:
<DL>
<DT><SAMP>vexArgNullexception</SAMP>
<DD>Generated if the path is a <SAMP>NULL</SAMP>
pointer.</B> 

<DT><SAMP>vexArgexception</SAMP>
<DD>Generated if the path points outside the process's
address space (a condition not always guaranteed to be
caught). 

<DT><SAMP><A HREF="vfs-x.html#vfsAccessexception"><CODE>vfsAccessexception</CODE></A></SAMP>
<DD>Generated if search permission is denied for a
component of the path. 

<DT><SAMP><A HREF="vfs-x.html#vfsNameexception"><CODE>vfsNameexception</CODE></A></SAMP>
<DD>Generated if any part of <SAMP>path</SAMP> references a
file or directory that does not exist or the file or
directory referenced by the path does not exist. 

<DT><SAMP><A HREF="vfs-x.html#vfsReadOnlyexception"><CODE>vfsReadOnlyexception</CODE></A></SAMP>
<DD>Generated if the path references a file or directory on
a read-only file system or volume. 

<DT><SAMP><A HREF="vfs-x.html#vfsIsDirexception"><CODE>vfsIsDirexception</CODE></A></SAMP>
<DD>Generated if any part of the path is not a directory;
the user ID is not the owner of the file; or, under POSIX
compliant operating systems, the process is not super-user
enabled and the operating system has defined the constant
<SAMP>_POSIX_CHOWN_RESTRICTED</SAMP>. 

<DT><SAMP><A HREF="vfs-x.html#vfsMaxPathexception"><CODE>vfsMaxPathexception</CODE></A></SAMP>
<DD>Generated if the total number of characters in the path
(including its members and the required system format path
separators) is beyond the system limit as defined in
<SAMP>vfsMAXIMUM_PATH_LEN</SAMP>. It is also generated when
one of the path members exceeds
<SAMP>vfsMAXIMUM_NAME_LEN</SAMP> characters. 

<DT><SAMP><A HREF="vfs-x.html#vfsMaxLinksexception"><CODE>vfsMaxLinksexception</CODE></A></SAMP>
<DD>Generated if the path cannot be resolved by the
operating system because it contains too many symbolic link
or alias references. (Check if there is a symbolic link
``loop'' where the chain of symbolic links is ultimately
self-referential.) 

<DT><SAMP><A HREF="vfs-x.html#vfsIOexception"><CODE>vfsIOexception</CODE></A></SAMP>
<DD>Generated if a low-level operating system I/O error
occurred attempting to change the owner for the file or
directory pointed to by the path. 
</DL>
</DD></DL>
<P>
<A NAME="vfsCloneAppDirPath"><HR><H4>vfsCloneAppDirPath</H4></A>
<PRE>
        vfsPath * <B>vfsCloneAppDirPath</B>();
</PRE>

<DL><DD>
Returns a dynamically allocated copy of the directory in
which the currently executing application resides. For
example, if the full pathname to start an application is
``<SAMP>/apps/application</SAMP>,''
<CODE>vfsCloneAppDirPath</CODE> returns a copy of the path
``<SAMP>/apps</SAMP>.'' If a relative pathname is used to
invoke the application, <CODE>vfsCloneAppDirPath</CODE>
resolves the full pathname from the application's working
directory. If only the command name is used to invoke the
application, <CODE>vfsCloneAppDirPath</CODE> finds the full
path in the application's search path. (Search path
semantics used by the standard operating system shell are
followed to traverse the search path. For instance, the
``<SAMP>:</SAMP>'' character represents the ``current
directory'' if it appears at the beginning or end of the
search path string for the Bourne, Korn, and C shells under
UNIX.)
    <P>
<CODE>vfsCloneAppDirPath</CODE> returns a dynamically
allocated copy of the application's directory path, which
can be destroyed using <CODE><A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A></CODE>.
<CODE><A HREF="vfs-x.html#vfsGetAppDirPath"><CODE>vfsGetAppDirPath</CODE></A></CODE> returns a pointer to a shared
path that should never be modified by the Galaxy client
program.
</DD></DL>
<P>
<A NAME="vfsCloneAppName"><HR><H4>vfsCloneAppName</H4></A>
<PRE>
        vstr * <B>vfsCloneAppName</B>();
</PRE>

<DL><DD>
Returns a dynamically allocated copy of the string
representing the name of the application without any path
components. For example, if the application was invoked
using the command name ``<SAMP>/apps/app</SAMP> ,''
<CODE>vfsCloneAppName</CODE> would return a pointer to the
<SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP> string ``<SAMP>app</SAMP>.''
    <P>
<CODE>vfsCloneAppName</CODE> returns a dynamically
allocated copy of the application name string.
<CODE><A HREF="vfs-x.html#vfsGetAppName"><CODE>vfsGetAppName</CODE></A></CODE> returns a pointer to a shared
string that should never be modified by the Galaxy client
program.
</DD></DL>
<P>
<A NAME="vfsCloneCurrentPathElementString"><HR><H4>vfsCloneCurrentPathElementString</H4></A>
<PRE>
        vstr * <B>vfsCloneCurrentPathElementString</B>();
</PRE>

<DL><DD>
Returns a pointer to a dynamically allocated copy of the
string that symbolically represents the current path
element for the current operating system. For example, for
DOS/Windows this returns ``<SAMP>.</SAMP> ''.
<CODE>vfsCloneCurrentPathElementString</CODE> returns a
pointer to a shared string, which should not be altered in
any way.
</DD></DL>
<P>
<A NAME="vfsCloneGroupName"><HR><H4>vfsCloneGroupName</H4></A>
<PRE>
        vstr * <B>vfsCloneGroupName</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
Returns a dynamically allocated string containing the group
name associated with the group ID contained in
<SAMP>info</SAMP>. <SAMP>info</SAMP> is initialized using
function. <CODE><A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A></CODE> can be used to destroy
the name when you are finished using it. It returns
<SAMP>NULL</SAMP> if there is no group name for this
file/directory or the operating system does not support
this feature.
</DD></DL>
<P>
<A NAME="vfsCloneHomeDirPath"><HR><H4>vfsCloneHomeDirPath</H4></A>
<PRE>
        vfsPath * <B>vfsCloneHomeDirPath</B>();
</PRE>

<DL><DD>
Returns a dynamically allocated copy of the user's home
directory, or <SAMP>NULL</SAMP> if there is no home
directory designated for the user.
    <P>
<CODE>vfsCloneHomeDirPath</CODE> returns a dynamically
allocated copy of the user's home directory path, which can
be destroyed using <CODE><A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A></CODE>.
<CODE><A HREF="vfs-x.html#vfsGetHomeDirPath"><CODE>vfsGetHomeDirPath</CODE></A></CODE> returns a pointer to a
shared path that should never be modified by the Galaxy
client program.
</DD></DL>
<P>
<A NAME="vfsCloneParentPathElementString"><HR><H4>vfsCloneParentPathElementString</H4></A>
<PRE>
        vstr * <B>vfsCloneParentPathElementString</B>();
</PRE>

<DL><DD>
Returns a pointer to a dynamically allocated copy of the
string that comprises the parent path element for the
current operating system. For example, for DOS/Windows this
returns ``<SAMP>..</SAMP>''. This string can then be
destroyed with <CODE><A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A></CODE>.
    <P>
<CODE><A HREF="vfs-x.html#vfsGetParentPathElementString"><CODE>vfsGetParentPathElementString</CODE></A></CODE> returns a
pointer to a shared string, which should not be altered in
any way.
</DD></DL>
<P>
<A NAME="vfsClonePath"><HR><H4>vfsClonePath</H4></A>
<PRE>
        vfsPath * <B>vfsClonePath</B>(
                const vfsPath * path);
</PRE>

<DL><DD>
Creates a dynamically allocated copy of <SAMP>path</SAMP>
and returns a pointer to the result. The path returned from
<CODE>vfsClonePath</CODE> can be destroyed by
<CODE><A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A></CODE>. The exception:
<SAMP>vexArgNullexception</SAMP> is generated if
<SAMP>path</SAMP> is a <SAMP>NULL</SAMP> pointer.
</DD></DL>
<P>
<A NAME="vfsClonePathElementAt"><HR><H4>vfsClonePathElementAt</H4></A>
<PRE>
        vstr * <B>vfsClonePathElementAt</B>(
                const vfsPath * path,
                int element);
</PRE>

<DL><DD>
Returns a pointer to a dynamically allocated copy of the
<I>n</I>th element (n = <SAMP>element</SAMP>) of the path
<SAMP>path</SAMP>. For a sample path
``<SAMP>/dir1/dir2/filename</SAMP>,''
<CODE>vfsClonePathElementAt</CODE><SAMP>(path, 3)</SAMP>
would return a pointer to the dynamically allocated string
``<SAMP>filename</SAMP>.'' The root volume counts as the
first path element for full pathnames, so
<CODE><A HREF="vfs-x.html#vfsGetPathElementAt"><CODE>vfsGetPathElementAt</CODE></A></CODE><SAMP>(path, 0)</SAMP>
would return a pointer to the string representing the root
volume. For example, under UNIX, this would be the string
``<SAMP>/</SAMP>'', and under DOS/Windows the string
``<SAMP>\\</SAMP>''.
    <P>
<CODE><A HREF="vfs-x.html#vfsGetPathElementAt"><CODE>vfsGetPathElementAt</CODE></A></CODE> returns a pointer to the
shared string path component (and not a copy). Only use the
string pointers returned from
<CODE><A HREF="vfs-x.html#vfsGetPathElementAt"><CODE>vfsGetPathElementAt</CODE></A></CODE> as a read-only reference
and do not attempt to modify, destroy, or reallocate them.
Use <CODE>vfsClonePathElementAt</CODE> to obtain pointers
to dynamically allocated copies of path elements. Exceptions:
 
<DL>
<DT><SAMP>vexArgNullexception</SAMP>
<DD>Generated if the path is a <SAMP>NULL</SAMP>
pointer.</B> 

<DT><SAMP>vexArgRangeexception</SAMP>
<DD>Generated if <SAMP>element</SAMP> is less than zero or
greater than the number of elements in the path minus one.
(<SAMP><A HREF="vfs-x.html#vfsGetPathElementCount"><CODE>vfsGetPathElementCount</CODE></A> (path) - 1</SAMP> always
produces the offset to the last element in a path.) 
</DL>
</DD></DL>
<P>
<A NAME="vfsClonePathExtension"><HR><H4>vfsClonePathExtension</H4></A>
<PRE>
        vstr * <B>vfsClonePathExtension</B>(
                const vfsPath * path);
</PRE>

<DL><DD>
Returns a dynamically allocated string containing the
filename extension of the last component (leaf) of the path
<SAMP>path</SAMP>. The filename extension may be separated
from the basename of the component by a platform-specific
separator string (usually `.'). However, this separator is
not considered part of the extension and is not returned in
the string. <SAMP>NULL</SAMP> is returned if the path
contains no extension in its last component.
</DD></DL>
<P>
<A NAME="vfsClonePathSeparatorString"><HR><H4>vfsClonePathSeparatorString</H4></A>
<PRE>
        vstr * <B>vfsClonePathSeparatorString</B>();
</PRE>

<DL><DD>
Returns a pointer to a dynamically allocated copy of the
string that symbolically represents the path separator for
the operating system. For example, under DOS/Windows this
returns ``<SAMP>\\</SAMP>'' and for UNIX this returns
``<SAMP>/</SAMP>''.
<CODE>vfsClonePathSeparatorString</CODE> returns a pointer
to a dynamically allocated copy of the path separator
string, which can be destroyed using
<CODE><A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsClonePathVolumeName"><HR><H4>vfsClonePathVolumeName</H4></A>
<PRE>
        vstr * <B>vfsClonePathVolumeName</B>(
                vfsPath * path);
</PRE>

<DL><DD>
Returns a dynamically allocated copy of the volume name
string for the path <SAMP>path</SAMP> that can be destroyed
using <CODE><A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A></CODE>. The exception 
<SAMP>vexArgNullexception</SAMP> is generated if the path is a
<SAMP>NULL</SAMP> pointer.
</DD></DL>
<P>
<A NAME="vfsCloneRootVolumeElementString"><HR><H4>vfsCloneRootVolumeElementString</H4></A>
<PRE>
        vstr * <B>vfsCloneRootVolumeElementString</B>();
</PRE>

<DL><DD>
Returns a pointer to a dynamically allocated copy of the
root volume element string for the current operating
system, which can be destroyed using
<CODE><A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A></CODE>. For example, for UNIX this
returns ``<SAMP>/</SAMP> ''.
<CODE>vfsCloneRootVolumeElementString</CODE> returns a
pointer to a shared string, which should not be altered in
any way.
</DD></DL>
<P>
<A NAME="vfsCloneStartupDirPath"><HR><H4>vfsCloneStartupDirPath</H4></A>
<PRE>
        vfsPath * <B>vfsCloneStartupDirPath</B>();
</PRE>

<DL><DD>
Returns a dynamically allocated pointer to the full path
representing the directory that the current application
started up in, which can be destroyed using
<CODE><A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A></CODE>. The startup directory is
different from the application directory which is the directory
where the currently running application's executable file
resides. Refer to the sections <CODE><A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A></CODE>
and <CODE><A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A></CODE> for more information.
<P>
The startup directory is the directory the user
was in when launching the application. The startup
directory is always kept by the File System Manager and its
value is unaffected by calls to
<CODE><A HREF="vfs-x.html#vfsSetWorkingDir"><CODE>vfsSetWorkingDir</CODE></A></CODE>, <CODE><A HREF="vfs-x.html#vfsPushDir"><CODE>vfsPushDir</CODE></A></CODE>, and
<CODE><A HREF="vfs-x.html#vfsPopDir"><CODE>vfsPopDir</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsCloneUserName"><HR><H4>vfsCloneUserName</H4></A>
<PRE>
        vstr * <B>vfsCloneUserName</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
Returns a dynamically allocated copy of the string
containing the user name associated with the user ID
contained in the info<SAMP> info</SAMP>. <SAMP>info</SAMP>
is initialized using the <CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE> or
<CODE><A HREF="vfs-x.html#vfsGetLinkInfo"><CODE>vfsGetLinkInfo</CODE></A></CODE> function.
<CODE><A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A></CODE> can be used to destroy the name
when you are finished using it. It returns
<SAMP>NULL</SAMP> if there is no user name for this
file/directory or the operating system does not support
this feature.
</DD></DL>
<P>
<A NAME="vfsCloneVolume"><HR><H4>vfsCloneVolume</H4></A>
<PRE>
        vfsVolume * <B>vfsCloneVolume</B>(
                vfsVolume * volume);
</PRE>

<DL><DD>
Creates a dynamically allocated copy of the volume
<SAMP>volume</SAMP> and returns a pointer to the result.
The volume returned from <CODE>vfsCloneVolume</CODE> should
be destroyed by <CODE><A HREF="vfs-x.html#vfsDestroyVolume"><CODE>vfsDestroyVolume</CODE></A></CODE>. The exception 
<SAMP>vexArgNullexception</SAMP> is generated if the volume
is a <SAMP>NULL</SAMP> pointer.
</DD></DL>
<P>
<A NAME="vfsCloneVolumeSeparatorString"><HR><H4>vfsCloneVolumeSeparatorString</H4></A>
<PRE>
        vstr * <B>vfsCloneVolumeSeparatorString</B>();
</PRE>

<DL><DD>
Returns a pointer to a dynamically allocated copy of the
string that comprises the separator for volumes for the
current operating system. This pointer can be destroyed
using <CODE><A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A></CODE>. Currently, this returns a
pointer to a <SAMP>NULL</SAMP> string (not a
<SAMP>NULL</SAMP> pointer) for UNIX; under DOS/Windows it
returns a ``<SAMP>:</SAMP>''.
</DD></DL>
<P>
<A NAME="vfsCloneWorkingDirPath"><HR><H4>vfsCloneWorkingDirPath</H4></A>
<PRE>
        vfsPath * <B>vfsCloneWorkingDirPath</B>();
</PRE>

<DL><DD>
Returns a pointer to the path representing the current
working directory for the Galaxy client program.
<CODE>vfsCloneWorkingDirPath</CODE> returns a pointer to a
dynamically allocated copy of the current working
directory, which can be destroyed using
<CODE><A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A></CODE>.
<P>
The return from <CODE><A HREF="vfs-x.html#vfsGetWorkingDirPath"><CODE>vfsGetWorkingDirPath</CODE></A></CODE> is
guaranteed to be invalidated by calls to
<CODE><A HREF="vfs-x.html#vfsSetWorkingDir"><CODE>vfsSetWorkingDir</CODE></A></CODE>, <CODE><A HREF="vfs-x.html#vfsPushDir"><CODE>vfsPushDir</CODE></A></CODE>, and
<CODE><A HREF="vfs-x.html#vfsPopDir"><CODE>vfsPopDir</CODE></A></CODE>. It is also possible for it to be
invalidated by a call to any File System Manager function
that would cause a cached file with a relative pathname to
be opened. (The File System Manager will open cached
relative path files from their original referenced
directory using <CODE><A HREF="vfs-x.html#vfsPushDir"><CODE>vfsPushDir</CODE></A></CODE> and
<CODE><A HREF="vfs-x.html#vfsPopDir"><CODE>vfsPopDir</CODE></A></CODE>.) Only use
<CODE><A HREF="vfs-x.html#vfsGetWorkingDirPath"><CODE>vfsGetWorkingDirPath</CODE></A></CODE> in temporal situations
(for example, path comparisons), otherwise use
<CODE>vfsCloneWorkingDirPath</CODE>.
</DD></DL>
<P>
<A NAME="vfsCloseDir"><HR><H4>vfsCloseDir</H4></A>
<PRE>
        void <B>vfsCloseDir</B>(
                vfsDir * dir);
</PRE>

<DL><DD>
Closes <SAMP>dir</SAMP> and recovers any memory allocated
for its directory structure. An exception, 
<SAMP>vexArgNullexception</SAMP>, is generated if
<SAMP>dir</SAMP> is a <SAMP>NULL</SAMP> pointer.
</DD></DL>
<P>
<A NAME="vfsCloseFile"><HR><H4>vfsCloseFile</H4></A>
<PRE>
        void <B>vfsCloseFile</B>(
                vfsFile * file);
</PRE>

<DL><DD>
Closes <SAMP>file</SAMP> and recovers any memory allocated
to the file structure internally by the File System
Manager. Any unwritten portions of the file buffer are
flushed when the file is closed. The exception 
<SAMP>vexArgNullexception</SAMP> is generated if
<SAMP>file</SAMP> is a <SAMP>NULL</SAMP> pointer.
</DD></DL>
<P>
<A NAME="vfsCloseFileStream"><HR><H4>vfsCloseFileStream</H4></A>
<PRE>
        void <B>vfsCloseFileStream</B>(
                vfsFile * file);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsComparePath"><HR><H4>vfsComparePath</H4></A>
<PRE>
        int <B>vfsComparePath</B>(
                const vfsPath * path1,
                const vfsPath * path2);
</PRE>

<DL><DD>
Compares two paths and returns the result zero if they are
equal; <SAMP>3</SAMP> if the volume associated with
<SAMP>path1</SAMP> is lexicographically greater than the
corresponding volume in <SAMP>path2</SAMP>; <SAMP>-3</SAMP>
if the volume associated with <SAMP>path2</SAMP> is
lexicographically greater than the corresponding volume in
<SAMP>path1</SAMP>; <SAMP>2</SAMP> if <SAMP>path1</SAMP>
has more path components than <SAMP>path2</SAMP>;
<SAMP>-2</SAMP> if <SAMP>path1</SAMP> has fewer path
components than <SAMP>path2</SAMP>; <SAMP>1</SAMP> if
<SAMP>path1</SAMP> has the same number of path components
but contains the first path element that is
lexicographically greater than the corresponding element in
<SAMP>path2 </SAMP>; or <SAMP>-1</SAMP> if the
corresponding element in <SAMP>path2</SAMP> is
lexicographically greater than in <SAMP>path1</SAMP> . (The
essential rule to remember is that if it would appear first
in a dictionary, a string is lexicographically less than a
string that would appear later. For example, the string
<SAMP>directory</SAMP> is lexicographically less than the
string <SAMP>file</SAMP>.)
  <P>
<CODE>vfsComparePath</CODE> and
<CODE><A HREF="vfs-x.html#vfsComparePathCaseInsensitive"><CODE>vfsComparePathCaseInsensitive</CODE></A></CODE> both treat path
volume as the preceding element of the path for comparison
purposes. For example: <SAMP>A:\\DIR\\FILE.TXT</SAMP> is
less than <SAMP>B:\\DIR\\FILE.TXT</SAMP>. (Note: Since UNIX
does not support the concept of volumes, this is not a
concern in path comparison unless you explicitly set a
volume for a path.)
  <P>
<BLOCKQUOTE>
Table: Sample returns for <CODE>vfsComparePath</CODE>
<TABLE BORDER>
<TR>
<TD><B>Path1</B></TD> <TD><B>Path2</B></TD>
<TD><CODE>vfsComparePath</CODE><B> returns</B></TD> 
</TR>
<TR>
<TD><SAMP>/dir1/dir2/file</SAMP></TD>
<TD><SAMP>/dir1/dir2/file</SAMP></TD>
<TD><SAMP>0</SAMP></TD> 
</TR>
<TR>
<TD><SAMP>dir1/dir2/file</SAMP></TD>
<TD><SAMP>/dir1/dir2/file</SAMP></TD>
<TD><SAMP>-2</SAMP></TD> 
</TR>
<TR>
<TD><SAMP>/dir1/tmpdir/file</SAMP></TD>
<TD><SAMP>/dir1/dir2/file</SAMP></TD>
<TD><SAMP>1</SAMP></TD> 
</TR>
<TR>
<TD><SAMP>file</SAMP></TD> <TD><SAMP>file</SAMP></TD>
<TD><SAMP>0</SAMP></TD> 
</TR>
<TR>
<TD><SAMP>afile</SAMP></TD> <TD><SAMP>file</SAMP></TD>
<TD><SAMP>-1</SAMP></TD> 
</TR>
<TR>
<TD><SAMP>../file</SAMP></TD>
<TD><SAMP>/dir1/dir2/dir3/file</SAMP></TD>
<TD><SAMP>-2</SAMP></TD> 
</TR>
</TABLE>
</BLOCKQUOTE>

  <P>
exception:
  <P>
<SAMP>vexArgNullexception</SAMP> Generated if either
<SAMP>path1</SAMP> or <SAMP>path2</SAMP> is a
<SAMP>NULL</SAMP> pointer.
</DD></DL>
<P>
<A NAME="vfsComparePathCaseInsensitive"><HR><H4>vfsComparePathCaseInsensitive</H4></A>
<PRE>
        int <B>vfsComparePathCaseInsensitive</B>(
                const vfsPath * path1,
                const vfsPath * path2);
</PRE>

<DL><DD>
Compares two paths without regard to case and returns the
result zero if they are equal; <SAMP>3</SAMP> if the volume
associated with <SAMP>path1</SAMP> is lexicographically
greater without regard to case than the corresponding
volume in <SAMP>path2</SAMP>; <SAMP>-3</SAMP> if the volume
associated with <SAMP>path2</SAMP> is lexicographically
greater without regard to case than the corresponding
volume in <SAMP>path1</SAMP>; <SAMP>2</SAMP> if
<SAMP>path1</SAMP> has more path components than
<SAMP>path2</SAMP>; <SAMP>-2</SAMP> if <SAMP>path1</SAMP> 
has fewer path components than <SAMP>path2</SAMP>;
<SAMP>1</SAMP> if <SAMP>path1</SAMP> has the same number
of path components but contains the first path element that
is lexicographically greater without regard to case than
the corresponding element in <SAMP>path2</SAMP>; or
<SAMP>-1</SAMP> if the corresponding element in
<SAMP>path2</SAMP> is lexicographically greater without
regard to case than in <SAMP>path1</SAMP>. (The essential
rule to remember is that if it would appear first in a
dictionary, a string is lexicographically less than a
string that would appear later. For example, the string
<SAMP>directory</SAMP> is lexicographically less than the
string <SAMP>file</SAMP>.)
  <P>
<CODE>vfsComparePath</CODE> and
<CODE>vfsComparePathCaseInsensitive</CODE> both treat path
volume as the preceding element of the path for comparison
purposes. For example: <SAMP>A:\\DIR\\FILE.TXT</SAMP> is
less than <SAMP>B:\\DIR\\FILE.TXT</SAMP>.
  <P>
<BLOCKQUOTE>
NOTE:
  <P>
Since UNIX does not support the concept of volumes, this is
not be a concern in path comparison unless you explicitly
set a volume for a path.</BLOCKQUOTE> The exception: 
<SAMP>vexArgNullexception</SAMP>is generated if either
<SAMP>path1</SAMP> or <SAMP>path2</SAMP> is a
<SAMP>NULL</SAMP> pointer.
</DD></DL>
<P>
<A NAME="vfsComparePathExtension"><HR><H4>vfsComparePathExtension</H4></A>
<PRE>
        int <B>vfsComparePathExtension</B>(
                vfsPath * path1,
                vfsPath * path2);
</PRE>

<DL><DD>
Compares the filename extensions of the two paths and
returns the result <SAMP>0</SAMP> if they are the same. If
they are not the same, it returns <SAMP>-1</SAMP> if the
extension of <SAMP>path1</SAMP> is lexicographically less
than that of <SAMP>path2</SAMP>, and <SAMP>1</SAMP> if it
is greater. If either of the paths doesn't have an
extension an exception is generated. The lexicographical
comparison takes into account whether case sensitivity
applies on the given platform.
</DD></DL>
<P>
<A NAME="vfsCompareVolume"><HR><H4>vfsCompareVolume</H4></A>
<PRE>
        int <B>vfsCompareVolume</B>(
                const vfsVolume * volume1,
                const vfsVolume * volume2);
</PRE>

<DL><DD>
Compares two volumes and returns the result zero if they
are equal; <SAMP>1</SAMP> if <SAMP>volume1</SAMP> is
lexicographically greater than <SAMP>volume2</SAMP>;
<SAMP>-1</SAMP> if <SAMP>volume2</SAMP> is
lexicographically greater than <SAMP>volume1</SAMP> . (The
essential rule to remember is that if it would appear first
in a dictionary, a string is lexicographically less than a
string that would appear later. For example, the string
<SAMP>directory</SAMP> is lexicographically less than the
string <SAMP>file</SAMP>.)
<P>
<CODE>vfsCompareVolume</CODE> and
<CODE><A HREF="vfs-x.html#vfsCompareVolumeCaseInsensitive"><CODE>vfsCompareVolumeCaseInsensitive</CODE></A></CODE> both test
first for pointer values (for example, if
<SAMP>volume1</SAMP> is not <SAMP>NULL</SAMP> and
<SAMP>volume2</SAMP> is <SAMP>NULL</SAMP> they return
<SAMP>1</SAMP>). The volume name pointers are then tested
and if they are both non-<SAMP>NULL</SAMP>, the volume
names themselves are compared. If the volume names are
equal, the volume reference numbers are then compared and
the final result returned.
</DD></DL>
<P>
<A NAME="vfsCompareVolumeCaseInsensitive"><HR><H4>vfsCompareVolumeCaseInsensitive</H4></A>
<PRE>
        int <B>vfsCompareVolumeCaseInsensitive</B>(
                const vfsVolume * volume1,
                const vfsVolume * volume2);
</PRE>

<DL><DD>
Compares two volumes and returns the result zero if they
are equal; <SAMP>1</SAMP> if <SAMP>volume1</SAMP> is
lexicographically greater without regard to case than
<SAMP>volume2</SAMP>; <SAMP>-1</SAMP> if
<SAMP>volume2</SAMP> is lexicographically greater without
regard to case than <SAMP>volume1</SAMP> . (The essential
rule to remember is that if it would appear first in a
dictionary, a string is lexicographically less than a
string that would appear later. For example, the string
<SAMP>directory</SAMP> is lexicographically less than the
string <SAMP>file</SAMP>.)
  <P>
<CODE>vfsCompareVolume</CODE> and
<CODE>vfsCompareVolumeCaseInsensitive</CODE> both test
first for pointer values (for example, if
<SAMP>volume1</SAMP> is not <SAMP>NULL</SAMP> and
<SAMP>volume2</SAMP> is <SAMP>NULL</SAMP> they return
<SAMP>1</SAMP>). The volume name pointers are then tested
and if they are both non-<SAMP>NULL</SAMP>, the volume
names themselves are compared. If the volume names are
equal, the volume reference numbers are then compared and
the final result returned.
</DD></DL>
<P>
<A NAME="vfsCopy"><HR><H4>vfsCopy</H4></A>
<PRE>
        void <B>vfsCopy</B>(
                const vfsPath * pathFrom,
                const vfsPath * pathTo);
</PRE>

<DL><DD>
Copies the contents of the file at <SAMP>pathFrom</SAMP> to
the file at <SAMP>pathTo</SAMP>.
</DD></DL>
<P>
<A NAME="vfsCreateFile"><HR><H4>vfsCreateFile</H4></A>
<PRE>
        void <B>vfsCreateFile</B>(
                const vfsPath * path,
                vfsMode mode);
</PRE>

<DL><DD>
Creates a file referenced by the path <SAMP>path</SAMP> and
assigns it the file accesspermission mode
<SAMP>mode</SAMP>. <SAMP>mode</SAMP> can be created by
inclusive ORing any combination of the following permission
flags:
<P>

<DL>
<DT><CODE>vfsOWNER_READ</CODE>
<DD>Read access for owner.

<DT><CODE>vfsOWNER_WRITE</CODE>
<DD>Write access for owner.

<DT><CODE>vfsOWNER_EXECUTE</CODE>
<DD>Execute access for owner.

<DT><CODE>vfsOWNER_PERMISSIONS_MASK</CODE>
<DD>Read, write, and execute access for owner.

<DT><CODE>vfsGROUP_READ</CODE>
<DD>Read access for owner's group.

<DT><CODE>vfsGROUP_WRITE</CODE>
<DD>Write access for owner's group.

<DT><CODE>vfsGROUP_EXECUTE</CODE>
<DD>Execute access for owner's group.

<DT><CODE>vfsGROUP_PERMISSIONS_MASK</CODE>
<DD>Read, write, and execute access for owner's group.

<DT><CODE>vfsOTHER_READ</CODE>
<DD>Read access for others.

<DT><CODE>vfsOTHER_WRITE</CODE>
<DD>Write access for others.

<DT><CODE>vfsOTHER_EXECUTE</CODE>
<DD>Execute (search access) for others.

<DT><CODE>vfsOTHER_PERMISSIONS_MASK</CODE>
<DD>Read, write, and execute access for others.
</DL>

<P>
Mode is ignored on operating systems that do not support
permission modes. Exceptions are as follows:

<DL>
<DT><SAMP>vexArgNullexception</SAMP>
<DD>Generated if the path is a <SAMP>NULL</SAMP> pointer. 

<DT><SAMP>vexArgexception</SAMP>
<DD>Generated if the path points outside the process's
address space (a condition not always guaranteed to be
caught); part of the path is not a directory. 

<DT><SAMP><A HREF="vfs-x.html#vfsAccessexception"><CODE>vfsAccessexception</CODE></A></SAMP>
<DD>Generated if search permission is denied for a
component of the path. 

<DT><SAMP><A HREF="vfs-x.html#vfsNameexception"><CODE>vfsNameexception</CODE></A></SAMP>
<DD>Generated if a directory component of the path the path
does not exist. 

<DT><SAMP><A HREF="vfs-x.html#vfsExistsexception"><CODE>vfsExistsexception</CODE></A></SAMP>
<DD>Generated if the path the path points to a file or
directory that already exists. 

<DT><SAMP><A HREF="vfs-x.html#vfsMaxFilesexception"><CODE>vfsMaxFilesexception</CODE></A></SAMP>
<DD>Generated if the operating system has reached its
internal limit on the number of open files it can track
(the file must be opened to create it). Under
multi-processing operating systems this could mean that the
system-wide file table is full or that the file table for
the current process is full. 

<DT><SAMP><A HREF="vfs-x.html#vfsNoSpaceexception"><CODE>vfsNoSpaceexception</CODE></A></SAMP>
<DD>Generated if the user's disk quota is exceeded or there
are no more disk blocks available for the volume or file
system on which the directory would be created. 

<DT><SAMP><A HREF="vfs-x.html#vfsInterruptexception"><CODE>vfsInterruptexception</CODE></A></SAMP>
<DD>Generated if the low-level system call used to create
the file is interrupted by an asynchronous signal before
the operation could be completed. 

<DT><SAMP><A HREF="vfs-x.html#vfsReadOnlyexception"><CODE>vfsReadOnlyexception</CODE></A></SAMP>
<DD>Generated when attempting to create a file on a
read-only file system or volume. 

<DT><SAMP><A HREF="vfs-x.html#vfsMaxPathexception"><CODE>vfsMaxPathexception</CODE></A></SAMP>
<DD>Generated if the total number of characters in the path
(including its members and the required system format path
separators) is beyond the system limit as defined in
<SAMP>vfsMAXIMUM_PATH_LEN</SAMP>. Also generated when one
of the path members exceeds
<SAMP>vfsMAXIMUM_NAME_LEN</SAMP> characters. 

<DT><SAMP><A HREF="vfs-x.html#vfsMaxLinksexception"><CODE>vfsMaxLinksexception</CODE></A></SAMP>
<DD>Generated if a component directory in the path cannot
be resolved by the operating system because it contains too
many symbolic link or alias references. (Check if there is
a symbolic link ``loop'' where the chain of symbolic links
is ultimately self-referential.) 

<DT><SAMP><A HREF="vfs-x.html#vfsIOexception"><CODE>vfsIOexception</CODE></A></SAMP>
<DD>Generated if a low-level operating system I/O error
occurred attempting to create the file specified by the
path. 
</DL>
</DD></DL>
<P>
<A NAME="vfsCreateFileObject"><HR><H4>vfsCreateFileObject</H4></A>
<PRE>
        vfsFile * <B>vfsCreateFileObject</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsCreateRelativePath"><HR><H4>vfsCreateRelativePath</H4></A>
<PRE>
        vfsPath * <B>vfsCreateRelativePath</B>(
                const vfsPath * fromPath,
                const vfsPath * toPath);
</PRE>

<DL><DD>
Returns a pointer to a dynamically allocated relative path
that is generated by calculating the relative path from
<SAMP>fromPath</SAMP> to <SAMP>toPath</SAMP>.
  <P>
For example, given the full path
``<SAMP>/dir1/dir2/dir3/currentdir</SAMP>'' and the
relative path ``<SAMP>../../newdir/file</SAMP>,''
<CODE>vfsCreateRelativePath</CODE> returns a pointer to the
path ``<SAMP>/dir1/dir2/newdir/file</SAMP>.''
<P>
A call to <CODE>vfsCreateRelativePath</CODE> has the side
effect of automatically canonicalizing both path arguments.
This could alter the original contents of either
<SAMP>fromPath</SAMP> or <SAMP>toPath</SAMP> if they are
not already full canonicalized. (For example
``<SAMP>/dir/../dir2</SAMP>'' would become
``<SAMP>/dir2</SAMP>'' after a call to
<CODE>vfsCreateRelativePath</CODE>.)

<P>
<BLOCKQUOTE>
Table: Sample returns from
<CODE>vfsCreateRelativePath</CODE>
<TABLE BORDER>
<TR>
<TD><SAMP>fromPath</SAMP></TD> <TD><SAMP>toPath</SAMP></TD>
<TD><B>Path returned from
<CODE>vfsCreateRelativePath</CODE></B></TD> 
</TR>
<TR>
<TD><SAMP>/dir1/dir2/dir3</SAMP></TD>
<TD><SAMP>/dir6/file</SAMP></TD>
<TD><SAMP>../../../dir6/file</SAMP></TD> 
</TR>
<TR>
<TD><SAMP>/dir1/../dir2</SAMP></TD>
<TD><SAMP>/dir2/dir3/dir4</SAMP></TD>
<TD><SAMP>./dir3/dir4</SAMP></TD> 
</TR>
<TR>
<TD><SAMP>/dir1/dir2/dir3</SAMP></TD>
<TD><SAMP>/</SAMP></TD> <TD><SAMP>../../..</SAMP></TD> 
</TR>
</TABLE>
</BLOCKQUOTE>

  <P>
The exception <SAMP>vexArgNullexception</SAMP> is generated if either
<SAMP>fromPath</SAMP> or <SAMP>toPath</SAMP> is a
<SAMP>NULL</SAMP> pointers.
</DD></DL>
<P>
<A NAME="vfsCreateRootPath"><HR><H4>vfsCreateRootPath</H4></A>
<PRE>
        vfsPath * <B>vfsCreateRootPath</B>();
</PRE>

<DL><DD>
Returns a dynamically allocated path to the root directory.
Equivalent to <SAMP><A HREF="vfs-x.html#vfsBuildPath"><CODE>vfsBuildPath</CODE></A>(vfsPATH_TYPE_FULL,
NULL)</SAMP>. The path returned from
<CODE>vfsCreateRootPath</CODE> can be destroyed by
<CODE><A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsCreateVolume"><HR><H4>vfsCreateVolume</H4></A>
<PRE>
        vfsVolume * <B>vfsCreateVolume</B>();
</PRE>

<DL><DD>
Creates a dynamically allocated volume and returns a
pointer to the result. The volume name is initialized with
a <SAMP>NULL</SAMP> pointer and the volume reference number
set to the constant <SAMP>vfsNO_VOLUME_REFERENCE</SAMP>.
The volume returned from <CODE>vfsCreateVolume</CODE>
should be destroyed by <CODE><A HREF="vfs-x.html#vfsDestroyVolume"><CODE>vfsDestroyVolume</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsDeletePathElementAt"><HR><H4>vfsDeletePathElementAt</H4></A>
<PRE>
        void <B>vfsDeletePathElementAt</B>(
                vfsPath * path,
                int element);
</PRE>

<DL><DD>
Deletes the <I>n</I>th element (<I>n</I> =
<SAMP>element</SAMP>) of the path <SAMP>path</SAMP>.
<SAMP>element</SAMP> is a zero-based offset that indicates
the path component to delete. When a component is deleted,
the path components that follow it are directly inherited
by the deleted component's parent directory/folder. For
example, given the path ``
<SAMP>dir1/dir2/dir3/file</SAMP>,'' deleting the second
element using: <SAMP>vfsDeletePathElementAt(path, 1)</SAMP>
 would produce the path ``<SAMP>dir1/dir3/file</SAMP>.''
  <P>
For full pathnames, the root volume always counts as the
first element and cannot be deleted. For example, for the
path ``<SAMP>/dir1/dir2/dir3/file</SAMP>,'' deleting the
second element using <SAMP>vfsDeletePathElementAt(path,
1)</SAMP> would produce the path
``<SAMP>/dir2/dir3/file.</SAMP>''
(<SAMP>vfsDeletePathElementAt(path, 0)</SAMP> always
generates an exception for full pathnames, yet it is legal
for relative paths.)
  <P>
Exceptions are:
  
<DL>
<DT><SAMP>vexArgNullexception</SAMP>
<DD>Generated if the path is a <SAMP>NULL</SAMP>
pointer.</B> 
<DT><SAMP>vexArgRangeexception</SAMP>
<DD>Generated if <SAMP>element</SAMP> is less than zero or
greater than the number of elements in the path minus one.
(<CODE><A HREF="vfs-x.html#vfsGetPathElementCount"><CODE>vfsGetPathElementCount</CODE></A></CODE><SAMP>() - 1</SAMP>
always produces the offset to the last element in a path.) 
<DT><SAMP><A HREF="vfs-x.html#vfsRequestexception"><CODE>vfsRequestexception</CODE></A></SAMP>
<DD>Generated if <SAMP>element</SAMP> is a zero (0) and
<SAMP>path</SAMP> is of <SAMP>vfsPATH_TYPE_FULL</SAMP>. 
</DL>
</DD></DL>
<P>
<A NAME="vfsDestroyFileObject"><HR><H4>vfsDestroyFileObject</H4></A>
<PRE>
        void <B>vfsDestroyFileObject</B>(
                vfsFile * file);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsDestroyPath"><HR><H4>vfsDestroyPath</H4></A>
<PRE>
        void <B>vfsDestroyPath</B>(
                vfsPath * path);
</PRE>

<DL><DD>
Destroys the path <SAMP>path</SAMP> (including any volume
information associated with it) and recovers any memory
allocated to it by the File System Manager. This function
is called by the <CODE><A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A></CODE> destructor. You
should never have to call it directly. The exception 
<SAMP>vexArgNullexception</SAMP> is generated if
<SAMP>path</SAMP> is a <SAMP>NULL</SAMP> pointer.
</DD></DL>
<P>
<A NAME="vfsDestroyPathVolumeName"><HR><H4>vfsDestroyPathVolumeName</H4></A>
<PRE>
        void <B>vfsDestroyPathVolumeName</B>(
                vfsPath * path);
</PRE>

<DL><DD>
Destroys the volume name associated with the path
<SAMP>path</SAMP>. <CODE>vfsDestroyPathVolumeName</CODE>
ignores paths that do not have an existing volume name
associated with them and returns without generating an
exception.
  <P>
The exception <SAMP>vexArgNullexception</SAMP> ia generated 
if the path is a <SAMP>NULL</SAMP> pointer.
</DD></DL>
<P>
<A NAME="vfsDestroyVolume"><HR><H4>vfsDestroyVolume</H4></A>
<PRE>
        void <B>vfsDestroyVolume</B>(
                vfsVolume * volume);
</PRE>

<DL><DD>
Destroys a dynamically allocated volume pointed to by
<SAMP>volume</SAMP>. Volumes created by
<CODE><A HREF="vfs-x.html#vfsCreateVolume"><CODE>vfsCreateVolume</CODE></A></CODE> or <CODE><A HREF="vfs-x.html#vfsCloneVolume"><CODE>vfsCloneVolume</CODE></A></CODE>
should be destroyed using this function. The exception 
<SAMP>vexArgNullexception</SAMP> is generated if
<SAMP>volume</SAMP> is a <SAMP>NULL</SAMP> pointer.
</DD></DL>
<P>
<A NAME="vfsDestroyVolumeIterator"><HR><H4>vfsDestroyVolumeIterator</H4></A>
<PRE>
        void <B>vfsDestroyVolumeIterator</B>(
                vfsVolumeIterator ** iterator);
</PRE>

<DL><DD>
Destroys the volume list iterator <SAMP>iterator</SAMP>,
terminates the iteration of the current volume list and
resets the internally maintained volume list.
<CODE>vfsDestroyVolumeIterator</CODE> sets the value of the
iterator pointer pointed to by <SAMP>iterator</SAMP> to
<SAMP>NULL</SAMP>.
  <P>
This function should always be called after you are done
iterating on the current volume list using
<CODE><A HREF="vfs-x.html#vfsNextVolumeIterator"><CODE>vfsNextVolumeIterator</CODE></A></CODE>. The exception
<SAMP>vexArgNullexception</SAMP> is generated if the iterator
is a <SAMP>NULL</SAMP> pointer.
</DD></DL>
<P>
<A NAME="vfsDumpPath"><HR><H4>vfsDumpPath</H4></A>
<PRE>
        void <B>vfsDumpPath</B>(
                FILE * file,
                const vfsPath * path);
</PRE>

<DL><DD>
Dumps information about the path <SAMP>path</SAMP> onto the
C library FILE stream pointed to by <SAMP>file</SAMP>.
<CODE>vfsDumpPath</CODE> is used primarily for debugging
purposes.
  <P>
Sample Code: Sample output for <CODE>vfsDumpPath</CODE>

<BLOCKQUOTE>
<PRE>
<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>    *path;

<A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A>        *tmpStr;

tmpStr = <A HREF="vstr-x.html#vstrCloneScribed"><CODE>vstrCloneScribed</CODE></A>(<A HREF="vchar-x.html#vcharScribeLiteral"><CODE>vcharScribeLiteral</CODE></A>("/dir1/file"));
path  = <A HREF="vfs-x.html#vfsPathFromStr"><CODE>vfsPathFromStr</CODE></A>(tmpStr);
vfsDumpPath(stdout, path);/* Dump to controlling terminal */
<A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A>(path);
<A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A>(tmpStr);

Outputs:

        Path Dump
        =========
Volume Ref   :     ***No Volume Reference***
Volume Name   :     ***No Volume Name***
Path Type    :     vfsPATH_TYPE_FULL
Element     0:    '/'
Element     1:    'dir1'
Element     2:    'dir2'

</PRE>
</BLOCKQUOTE>
 
  <P>
Note that there is no volume information stored for this
path and also that each path element is bounded by single
quotes to be able to show leading and trailing tabs and
spaces embedded in the path element strings.
  <P>
The exception <SAMP>vexArgNullexception</SAMP> is generated if either
<SAMP>file</SAMP> or the path is a <SAMP>NULL</SAMP>
pointer.
</DD></DL>
<P>
<A NAME="vfsExpandVariablesInPath"><HR><H4>vfsExpandVariablesInPath</H4></A>
<PRE>
        void <B>vfsExpandVariablesInPath</B>(
                vfsPath * path);
</PRE>

<DL><DD>
Expands all environment variables (strings beginning with a
dollar sign `<SAMP>$</SAMP>') in the path
<SAMP>path</SAMP>. The expansion of environment variables
can have a number of consequences for the original path. It
can add or remove members from the path if an environment
variable references a multiple component path or a null
string, respectively. It can also change the path type when
the environment variable expands to a path type that
affects the original path.
  <P>
In addition to expanding environment variables, this
function also allows you to use a tilde character
`<SAMP>~</SAMP>' as a shortcut to represent the home
directory of the user executing the Galaxy application. The
tilde character is only expanded if it is the first
character of a path component and is terminated either by a
null character, or an environment variable; otherwise it
is treated literally. For example, the path components
``<SAMP>~</SAMP>'' and ``<SAMP>~$VAR</SAMP>'' will be
expanded, the components ``<SAMP>filename~</SAMP>,''
``<SAMP>~ filename</SAMP>,'' or even ``<SAMP>~$</SAMP>''
(because ``<SAMP>$</SAMP>'' alone is not an environment
variable) will not be expanded.
  <P>
A dollar sign can be escaped in a path component by
preceding it with another dollar sign. For example, the
path ``<SAMP>$$HOME/test</SAMP>'' would be changed to
``<SAMP>$HOME/test</SAMP>'' by a call to
<CODE>vfsExpandVariablesInPath</CODE>. (Note that a
subsequent call to <CODE>vfsExpandVariablesInPath</CODE>
replaces <SAMP>$HOME</SAMP> with the value of the
environment variable of that name.) Likewise, a tilde
character that would otherwise be expanded into the user's
home directory can be escaped by another tilde character.
For example, the path component `` <SAMP>~~$VAR</SAMP>''
would be changed to ``<SAMP>~$VAR</SAMP>'' by a call to
<CODE>vfsExpandVariablesInPath</CODE>. Tilde characters
need only be escaped where they will be expanded (that is,
``<SAMP>~~</SAMP>'' or ``<SAMP>~~$VAR</SAMP> '').
  <P>
These results reflect a value for <SAMP>$HOME</SAMP> of
``<SAMP>/user/me</SAMP>,'' a value for <SAMP>$TEST</SAMP>
of ``<SAMP>dir4/filename</SAMP>,'' and a value for
<SAMP>$NULL</SAMP> of `` '' (null string).
  <P>
<BLOCKQUOTE>
Table: Sample effects of calling
<CODE>vfsExpandVariablesInPath</CODE>
<TABLE BORDER>
<TR>
<TD><B>Original Path</B></TD> <TD><B>Expanded Path</B></TD>
<TD><B>Path Type Change</B></TD> 
</TR>
<TR>
<TD><SAMP>HOME</SAMP></TD> <TD><SAMP>/user/me</SAMP></TD>
<TD><SAMP>vfsPATH_TYPE_NAME</SAMP> to
<SAMP>vfsPATH_TYPE_FULL</SAMP>.</TD> 
</TR>
<TR>
<TD><SAMP>~</SAMP></TD> <TD><SAMP>/user/me</SAMP></TD>
<TD><SAMP>vfsPATH_TYPE_NAME</SAMP> to
<SAMP>vfsPATH_TYPE_FULL</SAMP>.</TD> 
</TR>
<TR>
<TD><SAMP>HOME</SAMP></TD> <TD><SAMP>HOME</SAMP></TD>
<TD>No change.</TD> 
</TR>
<TR>
<TD><SAMP>~</SAMP></TD> <TD><SAMP>/user/me</SAMP></TD>
<TD><SAMP>vfsPATH_TYPE_NAME</SAMP> to
<SAMP>vfsPATH_TYPE_FULL</SAMP>.</TD> 
</TR>
<TR>
<TD><SAMP>/dir1/~</SAMP></TD>
<TD><SAMP>/dir1/user/me</SAMP></TD> <TD>No change.</TD> 
</TR>
<TR>
<TD><SAMP>/HOME/testdir</SAMP></TD>
<TD><SAMP>/user/me/testdir</SAMP></TD> <TD>No change.</TD> 
</TR>
<TR>
<TD><SAMP>TEST</SAMP></TD>
<TD><SAMP>dir4/filename</SAMP></TD>
<TD><SAMP>vfsPATH_TYPE_NAME</SAMP> to
<SAMP>vfsPATH_TYPE_RELATIVE</SAMP>.</TD> 
</TR>
<TR>
<TD><SAMP>dirHOME</SAMP></TD>
<TD><SAMP>dir/user/me</SAMP></TD>
<TD><SAMP>vfsPATH_TYPE_NAME</SAMP> to
<SAMP>vfsPATH_TYPE_RELATIVE</SAMP>.</TD> 
</TR>
<TR>
<TD><SAMP>dir/HOME</SAMP></TD>
<TD><SAMP>dir/user/me</SAMP></TD> <TD>No change.</TD> 
</TR>
<TR>
<TD><SAMP>~/HOME</SAMP></TD>
<TD><SAMP>/user/me/user/me</SAMP></TD>
<TD><SAMP>vfsPATH_TYPE_RELATIVE</SAMP> to
<SAMP>vfsPATH_TYPE_FULL</SAMP>.</TD> 
</TR>
<TR>
<TD><SAMP>/NULL</SAMP></TD> <TD><SAMP>/</SAMP></TD> <TD>No
change.</TD> 
</TR>
<TR>
<TD><SAMP>NULL/dir</SAMP></TD> <TD><SAMP>dir</SAMP></TD>
<TD>No change. (Path is still assumed to be relative.)</TD>

</TR>
<TR>
<TD><SAMP>/NULL/dir</SAMP></TD> <TD><SAMP>/dir</SAMP></TD>
<TD>No change. (Path is still assumed to be full.)</TD> 
</TR>
<TR>
<TD><SAMP>NULL</SAMP></TD> <TD><I>N/A</I></TD> <TD></TD> 
</TR>
<TR>
<TD></TD> <TD>(Generates</TD> <TD></TD> 
</TR>
<TR>
<TD></TD> <TD><SAMP><A HREF="vfs-x.html#vfsRequestexception"><CODE>vfsRequestexception</CODE></A></SAMP>)</TD>
<TD></TD> 
</TR>
</TABLE>
</BLOCKQUOTE>

  <P>
Exceptions:

<DL>
<DT><SAMP>vexArgNullexception</SAMP>
<DD>Generated if the path is a <SAMP>NULL</SAMP>
pointer.</B> 

<DT><SAMP>vexRequestexception</SAMP>
<DD>Generated if all of the members of the path are
environment variables that point to null strings or
reference nonexistent values and the path is not a full
path. (Note that if the user has no home directory defined,
the ``<SAMP>~</SAMP>'' character also maps into a null
string.) 
</DL>

<P>
<CODE>vfsExpandVariablesInPath</CODE> expands environment
variables embedded within the path component only when they
are terminated by the end of the component string (for
example, ``<SAMP>dirHOME</SAMP>'') or another environment
variable (for example, ``<SAMP>HOMEVAR</SAMP> ''). The
tilde character is also expanded when terminated by another
environment variable (for example, ``<SAMP>~VAR</SAMP>''),
but not by another tilde.
</DD></DL>
<P>
<A NAME="vfsFindNameInSearchPath"><HR><H4>vfsFindNameInSearchPath</H4></A>
<PRE>
        vfsPath * <B>vfsFindNameInSearchPath</B>(
                vchar * progname);
</PRE>

<DL><DD>
Returns a pointer to a dynamically allocated directory path
where the file name string <SAMP>progname</SAMP> is found,
or <SAMP>NULL</SAMP> if it is not found.
  <P>
This functions uses the search path defined for the current
Galaxy process. Search path semantics used by standard
operating system shells are followed to traverse the search
path. For instance the ``<SAMP>:</SAMP>'' character
represents the ``current directory'' if it appears at the
beginning or end of the search path string for the Bourne,
Korn, and C shells under UNIX.
<P>
For optimization purposes, this function only searches the
current directory once, even if it is referenced multiple
times in the search path (a common mistake).</BLOCKQUOTE>
<P>
Exceptions:

<DL>
<DT><SAMP>vexArgNullexception</SAMP>
<DD>Generated if <SAMP>progname</SAMP> is a
<SAMP>NULL</SAMP> pointer. 

<DT><SAMP>vexArgRangeexception</SAMP>
<DD>Generated if <SAMP>progname</SAMP> points to a string
that is longer than the maximum file name length
<SAMP>vfsMAXIMUM_NAME_LEN</SAMP>. 
</DL>
</DD></DL>
<P>
<A NAME="vfsFindNameInSearchPathScribed"><HR><H4>vfsFindNameInSearchPathScribed</H4></A>
<PRE>
        vfsPath * <B>vfsFindNameInSearchPathScribed</B>(
                vscribe * nameScribe);
</PRE>

<DL><DD>
Returns a pointer to a dynamically allocated directory path
where the file name string generated by the scribe
<SAMP>nameScribe</SAMP> is found, or <SAMP>NULL</SAMP> if
it is not found. <SAMP>nameScribe</SAMP> is automatically
destroyed by <CODE>vfsFindNameInSearchPathScribed</CODE>.
  <P>
This function uses the search path defined for the current
Galaxy process. Search path semantics used by standard
operating system shells are followed to traverse the search
path. For instance the ``<SAMP>:</SAMP>'' character
represents the ``current directory'' if it appears at the
beginning or end of the search path string for the Bourne,
Korn, and C shells under UNIX.
  <P>
For optimization purposes, this function only searches the
current directory once, even if it is referenced multiple
times in the search path (a common mistake).
<P>
Exceptions:

<DL>
<DT><SAMP>vexArgNullexception</SAMP>
<DD>Generated if <SAMP>nameScribe</SAMP> is a
<SAMP>NULL</SAMP> pointer. 

<DT><SAMP>vexArgRangeexception</SAMP>
<DD>Generated if <SAMP>nameScribe</SAMP> will scribe a
string that is longer than the maximum file name length
<SAMP>vfsMAXIMUM_NAME_LEN</SAMP>. 

<DT><SAMP>vexArgexception</SAMP>
<DD>Generated if <SAMP>nameScribe</SAMP> scribes something
other than a <SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP> string. 
</DL>
</DD></DL>
<P>
<A NAME="vfsFlushFileBuffer"><HR><H4>vfsFlushFileBuffer</H4></A>
<PRE>
        void <B>vfsFlushFileBuffer</B>(
                vfsFile * file);
</PRE>

<DL><DD>
Flushes any buffered file contents to disk.
<CODE>vfsFlushFileBuffer</CODE> does not flush OS file
structures to disk (equivalent to <SAMP>fsync</SAMP> in
UNIX), only the contents of the data buffer. Some operating
systems keep a secondary cache of disk blocks in memory for
performance reasons and may not actually flush the contents
to the physical storage media until a later time.
Transaction-based systems using Galaxy have to investigate
facilities provided by each individual OS or by third
parties if they want to guarantee atomic file I/O.
<P>
<bold>Exceptions</bold> include:

<DL>
<DT><SAMP><A HREF="vex-x.html#vexArgNullException"><CODE>vexArgNullException</CODE></A></SAMP>
<DD>Generated if either <SAMP>buffer</SAMP> or the file is
a <SAMP>NULL</SAMP> pointer. 

<DT><SAMP><A HREF="vfs-x.html#vfsIOException"><CODE>vfsIOException</CODE></A></SAMP>
<DD>Generated if a low-level operating system I/O error
occurred attempting to flush file contents to disk. 
</DL>
</DD></DL>
<P>
<A NAME="vfsGenerateTempName"><HR><H4>vfsGenerateTempName</H4></A>
<PRE>
        vchar * <B>vfsGenerateTempName</B>(
                vchar * templateString);
</PRE>

<DL><DD>
Returns a pointer to <SAMP>templateString</SAMP> after
replacing all the `X' characters in
<SAMP>templateString</SAMP> with random digits. For
example, passing ``<SAMP>fileXXXX.XXX</SAMP>'' to
<CODE>vfsGenerateTempName</CODE> would return a pointer to
<SAMP>template</SAMP> that might have the following name
(depending upon the digits generated):
``<SAMP>file3071.927</SAMP>''.
  <P>
While there is no limit to the number of characters in a
given string that <CODE>vfsGenerateTempName</CODE>
replaces, it reuses the random number digits it has
generated when it ``runs out.'' For example, if
<CODE>vfsGenerateTempName</CODE> internally creates the
random number 359, the above example would have produced
``<SAMP>file3593.59</SAMP>''.

<P>
16-bit machines produce random numbers with up to 5 digits
(2^16), some 32-bit OS environments produce up to 10
digits, and 64-bit machines, up to 20 digits.
<P>
For portability purposes, you should try to use the ``8.3''
DOS/Windows file system naming convention.
<CODE>vfsGenerateTempName</CODE> is not guaranteed to
produce a file name unique to the target directory. You may
(in rare cases) have to call it successively until it does.
  <P>
Sample Code: Using <CODE>vfsGenerateTempName</CODE>

<BLOCKQUOTE>
<PRE>

/*
 * Create a temporary file for reading and writing in the
 * current directory.
 */
<A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A>   *openFile;

<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>   *path;
<A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A>    *tmpFileName;

while(TRUE) {
 tmpFileName = <A HREF="vstr-x.html#vstrCloneScribed"><CODE>vstrCloneScribed</CODE></A>(<A HREF="vchar-x.html#vcharScribeLiteral"><CODE>vcharScribeLiteral</CODE></A>(tmpXXXXX));
 path    = <A HREF="vfs-x.html#vfsPathFromStr"><CODE>vfsPathFromStr</CODE></A>(vfsGenerateTempName(tmpFileName));
 if (<A HREF="vfs-x.html#vfsAccess"><CODE>vfsAccess</CODE></A>(path, vfsFILE_EXISTS)) {

  /*
   * File already exists, destroy 'path' and
   * 'tmpFileName' string and try another temporary name.
   */

  <A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A>(path);
  <A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A>(tmpFileName);
  continue;
 }
 break;    /* Found a unique name */
}
openFile = <A HREF="vfs-x.html#vfsOpenFile"><CODE>vfsOpenFile</CODE></A>(path, vfsOPEN_WRITE_TRUNCATE);

/*
 * Continue processing.
 */
.
.
.

</PRE>
</BLOCKQUOTE>

  <P>
exception:
  <P>
<SAMP>vexArgNullexception</SAMP> Generated if
<SAMP>templateString</SAMP> is a <SAMP>NULL</SAMP> pointer.
</DD></DL>
<P>
<A NAME="vfsGetAccessException"><HR><H4>vfsGetAccessException</H4></A>
<PRE>
        vfsAccessException * <B>vfsGetAccessException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetAccessExceptionClass"><HR><H4>vfsGetAccessExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetAccessExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetAccessexception"><HR><H4>vfsGetAccessexception</H4></A>
<PRE>
        void <B>vfsGetAccessexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsAccessexception"><CODE>vfsAccessexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetAccessexceptionClass"><HR><H4>vfsGetAccessexceptionClass</H4></A>
<PRE>
        void <B>vfsGetAccessexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsAccessexception"><CODE>vfsAccessexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions. For example, the following code fragment 
would generate an exception of type <SAMP><A HREF="vfs-x.html#vfsAccessexception"><CODE>vfsAccessexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>
<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetAccessexceptionClass(), vexNULL);
</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetAppDirPath"><HR><H4>vfsGetAppDirPath</H4></A>
<PRE>
        const vfsPath * <B>vfsGetAppDirPath</B>();
</PRE>

<DL><DD>
Returns a pointer to the path representing the directory in
which the currently executing application resides. For
example, if the full pathname to start an application is
``<SAMP>/apps/application</SAMP>,''
<CODE>vfsGetAppDirPath</CODE> returns a pointer to the path
``<SAMP>/apps</SAMP>.'' If a relative pathname is used to
invoke the application, <CODE>vfsGetAppDirPath</CODE>
resolves the full pathname from the application's working
directory. If only the command name is used to invoke the
application, <CODE>vfsGetAppDirPath</CODE> finds the full
path in the application's search path. (Search path
semantics used by the standard operating system shell are
followed to traverse the search path. For instance, the
``<SAMP>:</SAMP>'' character represents the ``current
directory'' if it appears at the beginning or end of the
search path string for the Bourne, Korn, and C shells under
UNIX.)
  <P>
<CODE>vfsGetAppDirPath</CODE> returns a pointer to a shared
path that should never be modified by the Galaxy client
program. <CODE><A HREF="vfs-x.html#vfsCloneAppDirPath"><CODE>vfsCloneAppDirPath</CODE></A></CODE> returns a
dynamically allocated copy of the application's directory
path, which can be destroyed using
<CODE><A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A></CODE>.
  <P>
The returns in Table reflect an application working
directory of ``<SAMP>/dir1/appdir</SAMP>'' and a search
path that includes the directory ``<SAMP>/apps</SAMP>.''
  <P>
<BLOCKQUOTE>
Table: Sample returns from <CODE>vfsGetAppDirPath</CODE>
<TABLE BORDER>
<TR>
<TD><B>Actual Path</B></TD> <TD><B>Command Used</B></TD>
<TD><CODE><A HREF="vfs-x.html#vfsCloneAppDirPath"><CODE>vfsCloneAppDirPath</CODE></A></CODE></TD> 
</TR>
<TR>
<TD><B>to the Application</B></TD>
<TD><SAMP>(argv[0])</SAMP></TD> <TD><B>return</B></TD> 
</TR>
<TR>
<TD><SAMP>/dir1/dir2/app</SAMP></TD>
<TD><SAMP>/dir1/dir2/app</SAMP></TD>
<TD><SAMP>/dir1/dir2</SAMP></TD> 
</TR>
<TR>
<TD><SAMP>/dir1/app</SAMP></TD>
<TD><SAMP>../app</SAMP></TD> <TD><SAMP>/dir1</SAMP></TD> 
</TR>
<TR>
<TD><SAMP>/apps/app</SAMP></TD> <TD><SAMP>app</SAMP></TD>
<TD><SAMP>/apps</SAMP></TD> 
</TR>
</TABLE>
</BLOCKQUOTE>

  <P>
Exceptions are:
 
<DL>
<DT><SAMP><A HREF="vfs-x.html#vfsAccessexception"><CODE>vfsAccessexception</CODE></A></SAMP>
<DD>Generated if the process does not have access to all of
the parent directories in order to generate a current
directory pathname (for example,
``<SAMP>/<SAMP>dir_without_access</SAMP>/currentdir''). 
<DT><SAMP><A HREF="vfs-x.html#vfsSystemexception"><CODE>vfsSystemexception</CODE></A></SAMP>
<DD>Generated if the operating system failed to generate
the current pathname due to internal failure. 
</DL>
</DD></DL>
<P>
<A NAME="vfsGetAppName"><HR><H4>vfsGetAppName</H4></A>
<PRE>
        const vchar * <B>vfsGetAppName</B>();
</PRE>

<DL><DD>
Returns a pointer to the string representing the name of
the application without any path components. For example,
if the application was invoked using the command name
``<SAMP>/apps/app</SAMP>,'' <CODE>vfsGetAppName</CODE>
would return a pointer to the <SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP> string ``
<SAMP>app</SAMP>.''
  <P>
<CODE>vfsGetAppName</CODE> returns a pointer to a shared
string that should never be modified by the Galaxy client
program. <CODE><A HREF="vfs-x.html#vfsCloneAppName"><CODE>vfsCloneAppName</CODE></A></CODE> returns a dynamically
allocated copy of the application name string.
</DD></DL>
<P>
<A NAME="vfsGetArgs"><HR><H4>vfsGetArgs</H4></A>
<PRE>
        void <B>vfsGetArgs</B>(
                int * numArgs,
                const vfsPath *** args);
</PRE>

<DL><DD>
Initializes an array of full path references (pointed to by
<SAMP>args</SAMP> ) to the file and directory arguments in
the program's argument list (that is, the part of the
argument list not parsed by the Preference Manager).
<SAMP>numArgs</SAMP> is initialized to the size of the
list; <SAMP>args</SAMP> points to the list of pathnames.
The first entry is always the full pathname of the program
being executed.
  <P>
Exceptions are:

<DL>
<DT><SAMP>vexArgNullexception</SAMP>
<DD>Generated if pointers for <SAMP>numArgs</SAMP> or the
arguments array <SAMP>args</SAMP> are <SAMP>NULL</SAMP>. 

<DT><SAMP><A HREF="vfs-x.html#vfsAccessexception"><CODE>vfsAccessexception</CODE></A></SAMP>
<DD>Generated if the process does not have access to all of
the parent directories in order to generate a current
directory pathname (for example,
``<SAMP>/<SAMP>dir_without_access</SAMP>/currentdir''). 

<DT><SAMP><A HREF="vfs-x.html#vfsSystemexception"><CODE>vfsSystemexception</CODE></A></SAMP>
<DD>Generated if the system failed to generate the current
pathname due to internal failure. 
</DL>
</DD></DL>
<P>
<A NAME="vfsGetChar"><HR><H4>vfsGetChar</H4></A>
<PRE>
        vbool <B>vfsGetChar</B>(
                vchar * c,
                vfsFile * file);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if <SAMP>c</SAMP> is initialized
with the next character from the file <SAMP>file</SAMP>,
<SAMP>FALSE</SAMP> when end-of-file (<SAMP>EOF</SAMP>) has
been reached. Note that <CODE>vfsGetChar</CODE> continues to return
<SAMP>FALSE</SAMP> on each successive call when
<SAMP>EOF</SAMP> has been reached. 
<P>
Because <CODE>vfsGetChar</CODE>
is relatively efficient and does not perform physical reads
each time it is called. Successive calls cause it to read
characters from the file's intermediate buffer and the
function only accesses secondary storage when it reaches
the end of the buffer.
<P>
Note that <CODE>vfsGetChar</CODE> is optimized for the case
<SAMP>sizeof(<A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A>) == sizeof(char)</SAMP>, but also
accommodates multi-byte <SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP>
values.
<P>
<bold>Exceptions</bold> are:
<P>

<DL>
<DT><SAMP>vexArgNullexception</SAMP>
<DD>Generated if either <SAMP>file</SAMP> or <SAMP>c</SAMP>
is a <SAMP>NULL</SAMP> pointer. 

<DT><SAMP><A HREF="vfs-x.html#vfsReadexception"><CODE>vfsReadexception</CODE></A></SAMP>
<DD>Generated if <CODE>vfsGetChar</CODE> could not complete
the read operation because a system error occurred. 
</DL>

<P>
Sample Code: Using <CODE>vfsGetChar</CODE>

<BLOCKQUOTE>
<PRE>

/*
 *  copyFileCharByChar() -      Copy the contents of one open file to
 *                              another using character-by-character
 *                              I/O functions.
 */
void copyFileCharByChar(<A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A> *sourceFile, <A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A> *destinationFile)
{

  <A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A> c;

  while(vfsGetChar(&c, sourceFile))
    <A HREF="vfs-x.html#vfsPutChar"><CODE>vfsPutChar</CODE></A>(c, destinationFile);

  return;
}
</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetCreationTime"><HR><H4>vfsGetCreationTime</H4></A>
<PRE>
        vtimestamp <B>vfsGetCreationTime</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
Returns the time a file or directory was created using
information obtained by initializing the info
<SAMP>info</SAMP> with the <CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE> or
<CODE><A HREF="vfs-x.html#vfsGetLinkInfo"><CODE>vfsGetLinkInfo</CODE></A></CODE> function.
<CODE>vfsGetCreationTime</CODE> returns the time in
<SAMP><A HREF="vtimestamp-x.html#vtimestamp"><CODE>vtimestamp</CODE></A></SAMP> format. Use the Galaxy Date Manager
to manipulate, print, and format <SAMP><A HREF="vtimestamp-x.html#vtimestamp"><CODE>vtimestamp</CODE></A></SAMP>
objects.
</DD></DL>
<P>
<A NAME="vfsGetCurrentPathElementString"><HR><H4>vfsGetCurrentPathElementString</H4></A>
<PRE>
        const vchar * <B>vfsGetCurrentPathElementString</B>();
</PRE>

<DL><DD>
Returns a pointer to a string that symbolically represents
the current path element for the current operating system.
For example, in the DOS/Windows environment, this returns
``<SAMP>.</SAMP>''.
<CODE>vfsGetCurrentPathElementString</CODE> returns a
pointer to a shared string, which should not be altered in
any way.
</DD></DL>
<P>
<A NAME="vfsGetDirNameException"><HR><H4>vfsGetDirNameException</H4></A>
<PRE>
        vfsDirNameException * <B>vfsGetDirNameException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetDirNameExceptionClass"><HR><H4>vfsGetDirNameExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetDirNameExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetDirNameexception"><HR><H4>vfsGetDirNameexception</H4></A>
<PRE>
        void <B>vfsGetDirNameexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsDirNameexception"><CODE>vfsDirNameexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetDirNameexceptionClass"><HR><H4>vfsGetDirNameexceptionClass</H4></A>
<PRE>
        void <B>vfsGetDirNameexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsDirNameexception"><CODE>vfsDirNameexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions. For example, the following code fragment 
would generate an exception of type <SAMP><A HREF="vfs-x.html#vfsDirNameexception"><CODE>vfsDirNameexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>
<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetDirNameexceptionClass(), vexNULL);
</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetException"><HR><H4>vfsGetException</H4></A>
<PRE>
        vfsException * <B>vfsGetException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetExceptionClass"><HR><H4>vfsGetExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetExistsException"><HR><H4>vfsGetExistsException</H4></A>
<PRE>
        vfsExistsException * <B>vfsGetExistsException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetExistsExceptionClass"><HR><H4>vfsGetExistsExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetExistsExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetExistsexception"><HR><H4>vfsGetExistsexception</H4></A>
<PRE>
        void <B>vfsGetExistsexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsExistsexception"><CODE>vfsExistsexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetExistsexceptionClass"><HR><H4>vfsGetExistsexceptionClass</H4></A>
<PRE>
        void <B>vfsGetExistsexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsExistsexception"><CODE>vfsExistsexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions. For example, the following code fragment 
would generate an exception of type <SAMP><A HREF="vfs-x.html#vfsExistsexception"><CODE>vfsExistsexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetExistsexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetFileAccessType"><HR><H4>vfsGetFileAccessType</H4></A>
<PRE>
        vfsType <B>vfsGetFileAccessType</B>(
                vfsFile * file);
</PRE>

<DL><DD>
Returns the access type constant used to open the file
<SAMP>file</SAMP>. The access type is one of the following:

<DL>
<DT><CODE>vfsOPEN_READ_ONLY</CODE>
<DD>Opened for reading only. 

<DT><CODE>vfsOPEN_READ_WRITE</CODE>
<DD>Opened for reading and writing. 

<DT><CODE>vfsOPEN_WRITE_TRUNCATE</CODE>
<DD>Opened for reading and writing and the file was
truncated to zero length when it was opened. 

<DT><CODE>vfsOPEN_APPEND</CODE>
<DD>Opened for reading and writing to the end of the file.
This mode guarantees that all writes take place starting
from the end of the file. You can seek anywhere in the
file to read. However, any write automatically causes a
seek to the end of the file before the write operation. 
</DL>
</DD></DL>
<P>
<A NAME="vfsGetFileInfo"><HR><H4>vfsGetFileInfo</H4></A>
<PRE>
        void <B>vfsGetFileInfo</B>(
                const vfsPath * path,
                vfsInfo * info);
</PRE>

<DL><DD>
Initializes a data structure that contains general
information about the file specified by the path
<SAMP>path</SAMP>, including its type, size, and access
permissions. If a file is a symbolic link or alias,
<CODE>vfsGetFileInfo</CODE> returns information about the
file or directory to which the link points. Use
<CODE><A HREF="vfs-x.html#vfsGetLinkInfo"><CODE>vfsGetLinkInfo</CODE></A></CODE> to return information on the
link itself.
<P>
Sample Code: Using <CODE>vfsGetFileInfo</CODE>

<BLOCKQUOTE>
<PRE>

<A HREF="vfs-x.html#vfsInfo"><CODE>vfsInfo</CODE></A> info;
<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *appPath;

/*
 * Get info on the directory containing the application.
 */

appPath = vfsGetAppPath();
vexWITH_HANDLING {
 vfsGetFileInfo(path, &info);
} vexON_exception {
 if (<A HREF="vfs-x.html#vfsGetRequestexception"><CODE>vfsGetRequestexception</CODE></A>())
/* Handle invalid symbolic link here */
 else if (<A HREF="vfs-x.html#vfsGetAccessexception"><CODE>vfsGetAccessexception</CODE></A>())
  /* Handle access problems here */
 else if (<A HREF="vfs-x.html#vfsGetNameexception"><CODE>vfsGetNameexception</CODE></A>())
  /* Handle non-existent target file/dir here */
 else
  /* Handle other "esoteric" problems here */
} vexEND_HANDLING;
/*
 * Continue processing....
 */

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetFileNameException"><HR><H4>vfsGetFileNameException</H4></A>
<PRE>
        vfsFileNameException * <B>vfsGetFileNameException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetFileNameExceptionClass"><HR><H4>vfsGetFileNameExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetFileNameExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetFileNameexception"><HR><H4>vfsGetFileNameexception</H4></A>
<PRE>
        void <B>vfsGetFileNameexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsFileNameexception"><CODE>vfsFileNameexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetFileNameexceptionClass"><HR><H4>vfsGetFileNameexceptionClass</H4></A>
<PRE>
        void <B>vfsGetFileNameexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsFileNameexception"><CODE>vfsFileNameexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions. For example, the following code fragment 
would generate an exception of type <SAMP><A HREF="vfs-x.html#vfsFileNameexception"><CODE>vfsFileNameexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetFileNameexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetFilePos"><HR><H4>vfsGetFilePos</H4></A>
<PRE>
        long <B>vfsGetFilePos</B>(
                vfsFile * file);
</PRE>

<DL><DD>
Returns the current file pointer offset from the beginning
of the file <SAMP>file</SAMP>. This offset determines where
the next read/write operation begins.
</DD></DL>
<P>
<A NAME="vfsGetFilePtr"><HR><H4>vfsGetFilePtr</H4></A>
<PRE>
        FILE * <B>vfsGetFilePtr</B>(
                vfsFile * file);
</PRE>

<DL><DD>
Returns a file pointer that can be used for file operations
using standard C library functionssuch as
<SAMP>fprintf()</SAMP> and <SAMP>fscanf()</SAMP>. Be aware
that while these operations are generally portable across
operating systems, you may encounter problems with
internationalization, especially with multi-byte character
sets (for example, Unicode, ISO 10646).
<P>
Note that the file pointer returned by <CODE>vfsGetFilePtr</CODE> may
be invalidated by File System Manager operations on other
files, because files can be closed by its internal caching
mechanism. The file pointer should not be saved for future
reference unless you have specifically informed the File
System Manager not to make the file eligible for caching.
This can be accomplished by opening a file with the open
flag <SAMP>vfsOPEN_NOT_CACHED</SAMP> or calling
<CODE><A HREF="vfs-x.html#vfsAllowCachingForFile"><CODE>vfsAllowCachingForFile</CODE></A></CODE><SAMP>(file,
FALSE)</SAMP> on an open file. Functions that can
invalidate the file pointer include:

<ul>
<li><CODE><A HREF="vfs-x.html#vfsOpenFile"><CODE>vfsOpenFile</CODE></A></CODE>
<li><CODE>vfsGetFilePtr</CODE>
<li><CODE><A HREF="vfs-x.html#vfsReadFile"><CODE>vfsReadFile</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsRawReadFile"><CODE>vfsRawReadFile</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsWriteFile"><CODE>vfsWriteFile</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsRawWriteFile"><CODE>vfsRawWriteFile</CODE></A></CODE>
</ul>
</DD></DL>
<P>
<A NAME="vfsGetFileRefNum"><HR><H4>vfsGetFileRefNum</H4></A>
<PRE>
        int <B>vfsGetFileRefNum</B>(
                vfsFile * file);
</PRE>

<DL><DD>
Returns the underlying file reference number for the
<SAMP><A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A></SAMP> file. This function is used on the
Macintosh to access file reference numbers which correspond
to the <A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A> structure.
</DD></DL>
<P>
<A NAME="vfsGetFileSeekException"><HR><H4>vfsGetFileSeekException</H4></A>
<PRE>
        vfsFileSeekException * <B>vfsGetFileSeekException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetFileSeekExceptionClass"><HR><H4>vfsGetFileSeekExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetFileSeekExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetFileSeekexception"><HR><H4>vfsGetFileSeekexception</H4></A>
<PRE>
        void <B>vfsGetFileSeekexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsFileSeekexception"><CODE>vfsFileSeekexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetFileSeekexceptionClass"><HR><H4>vfsGetFileSeekexceptionClass</H4></A>
<PRE>
        void <B>vfsGetFileSeekexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsFileSeekexception"><CODE>vfsFileSeekexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions. For example, the following code fragment 
would generate an exception of type <SAMP><A HREF="vfs-x.html#vfsFileSeekexception"><CODE>vfsFileSeekexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetFileSeekexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetFileType"><HR><H4>vfsGetFileType</H4></A>
<PRE>
        vfsFileType <B>vfsGetFileType</B>(
                const vfsPath * path);
</PRE>

<DL><DD>
Returns the file type of the file referenced by the <A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>
<SAMP>path</SAMP>. This function is used on the Macintosh.
  <P>
The <SAMP><A HREF="vfs-x.html#vfsFileType"><CODE>vfsFileType</CODE></A></SAMP> is an <SAMP>int</SAMP>.
Non-negative values are intended to be offsets from
<SAMP>128</SAMP> for 'FREF' resource types in the current
application. For example, if your application has an 'FREF'
with resource ID 130, whose File Type field is the value you
desire for the current file, call:
<SAMP><A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>(path , 2);</SAMP> The following
values are predefined by Galaxy:

<DL>
<DT><CODE>vfsFILETYPE_UNKNOWN</CODE>
<DD>Unknown filetype.

<DT><CODE>vfsFILETYPE_TEXT</CODE>
<DD>A stream of characters.

<DT><CODE>vfsFILETYPE_APPLICATION</CODE>
<DD>A launchable application.

<DT><CODE>vfsFILETYPE_PICT</CODE>
<DD>A picture document.
</DL>
</DD></DL>
<P>
<A NAME="vfsGetGroupId"><HR><H4>vfsGetGroupId</H4></A>
<PRE>
        vfsGroupId <B>vfsGetGroupId</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
Returns the group ID associated with the file or directory
information contained in the info <SAMP>info</SAMP>.
<SAMP>info</SAMP> is initialized using the
<CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE> or <CODE><A HREF="vfs-x.html#vfsGetLinkInfo"><CODE>vfsGetLinkInfo</CODE></A></CODE>
function. It returns <SAMP>-1</SAMP> if there is no group
ID for this file/directory or the operating system does not
support group IDs.
</DD></DL>
<P>
<A NAME="vfsGetHomeDirPath"><HR><H4>vfsGetHomeDirPath</H4></A>
<PRE>
        const vfsPath * <B>vfsGetHomeDirPath</B>();
</PRE>

<DL><DD>
Returns a pointer to the path representing the path
representing the user's home directory, or
<SAMP>NULL</SAMP> if there is no home directory designated
for the user.
  <P>
<CODE>vfsGetHomeDirPath</CODE> returns a pointer to a
shared path that should never be modified by the Galaxy
client program. <CODE><A HREF="vfs-x.html#vfsCloneHomeDirPath"><CODE>vfsCloneHomeDirPath</CODE></A></CODE> returns a
dynamically allocated copy of the user's home directory
path, which can be destroyed using
<CODE><A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsGetIOException"><HR><H4>vfsGetIOException</H4></A>
<PRE>
        vfsIOException * <B>vfsGetIOException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetIOExceptionClass"><HR><H4>vfsGetIOExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetIOExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetIOexception"><HR><H4>vfsGetIOexception</H4></A>
<PRE>
        void <B>vfsGetIOexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsIOexception"><CODE>vfsIOexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetIOexceptionClass"><HR><H4>vfsGetIOexceptionClass</H4></A>
<PRE>
        void <B>vfsGetIOexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsIOexception"><CODE>vfsIOexception</CODE></A></SAMP>. It is most often
used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to generate
exceptions. For example, the following code fragment would generate an
exception of type <SAMP><A HREF="vfs-x.html#vfsIOexception"><CODE>vfsIOexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetIOexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetInterruptException"><HR><H4>vfsGetInterruptException</H4></A>
<PRE>
        vfsInterruptException * <B>vfsGetInterruptException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetInterruptExceptionClass"><HR><H4>vfsGetInterruptExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetInterruptExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetInterruptexception"><HR><H4>vfsGetInterruptexception</H4></A>
<PRE>
        void <B>vfsGetInterruptexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsInterruptexception"><CODE>vfsInterruptexception</CODE></A></SAMP> in the exception
handling chain, or <SAMP>NULL</SAMP> if there were no
exceptions. Along with other exception handling functions,
it is used mainly to determine which of a number of
possible exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetInterruptexceptionClass"><HR><H4>vfsGetInterruptexceptionClass</H4></A>
<PRE>
        void <B>vfsGetInterruptexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsInterruptexception"><CODE>vfsInterruptexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions. For example, the following code fragment 
would generate an exception of type <SAMP><A HREF="vfs-x.html#vfsInterruptexception"><CODE>vfsInterruptexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetInterruptexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetIsDirException"><HR><H4>vfsGetIsDirException</H4></A>
<PRE>
        vfsIsDirException * <B>vfsGetIsDirException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetIsDirExceptionClass"><HR><H4>vfsGetIsDirExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetIsDirExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetIsDirexception"><HR><H4>vfsGetIsDirexception</H4></A>
<PRE>
        void <B>vfsGetIsDirexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsIsDirexception"><CODE>vfsIsDirexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetIsDirexceptionClass"><HR><H4>vfsGetIsDirexceptionClass</H4></A>
<PRE>
        void <B>vfsGetIsDirexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsIsDirexception"><CODE>vfsIsDirexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions. For example, the following code fragment 
would generate an exception of type <SAMP><A HREF="vfs-x.html#vfsIsDirexception"><CODE>vfsIsDirexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetIsDirexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetLinkContents"><HR><H4>vfsGetLinkContents</H4></A>
<PRE>
        vfsPath * <B>vfsGetLinkContents</B>(
                const vfsPath * path);
</PRE>

<DL><DD>
Returns a pointer to a dynamically allocated path
containing the <I>contents</I> of the symbolic link or
alias. The contents of a link is the path of the file
system object that it actually references. For example, if
you have a symbolic link named ``<SAMP>foo</SAMP>'' that
points to a file ``<SAMP>/dir1/dir2/file</SAMP>,''
<SAMP>vfsGetLinkContents(foo)</SAMP> would return the path
``<SAMP>/dir1/dir2/file</SAMP>.'' The path returned from
<CODE>vfsGetLinkContents</CODE> can be destroyed by calling
<CODE><A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsGetLinkInfo"><HR><H4>vfsGetLinkInfo</H4></A>
<PRE>
        void <B>vfsGetLinkInfo</B>(
                const vfsPath * path,
                vfsInfo * info);
</PRE>

<DL><DD>
Initializes a data structure that contains general
information about the link or file specified by the path
<SAMP>path</SAMP>, including its type, size, and access
permissions. If a file is a symbolic link or alias,
<CODE>vfsGetLinkInfo</CODE> returns information about the
link itself, not the file system object to which it points.
Use <CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE> to get information on the
resolved link. If the path is not a symbolic link,
<CODE>vfsGetLinkInfo</CODE> initializes <SAMP>info</SAMP>
with information about the file or directory specified by
the path.
  <P>
Sample Code: Using <CODE>vfsGetLinkInfo</CODE>

<BLOCKQUOTE>
<PRE>
<A HREF="vfs-x.html#vfsInfo"><CODE>vfsInfo</CODE></A> info;

<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *appPath;

/*
 * A standard way to use vfsGetLinkInfo() is to get info on a path and
 * check to see if it is actually a link. At that point, if you are 
 * really interested in the actual file system object it points to, 
 * use <A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A>().
 */
appPath = vfsGetAppPath();
vexWITH_HANDLING {
 vfsGetLinkInfo(appPath, &info);
} vexON_exception {
 if (<A HREF="vfs-x.html#vfsGetAccessexception"><CODE>vfsGetAccessexception</CODE></A>())
  /* Handle access problems here */
 else if (<A HREF="vfs-x.html#vfsGetNameexception"><CODE>vfsGetNameexception</CODE></A>())
  /* Handle non-existent target file/dir here */
 else
  /* Handle other "esoteric" problems here */
} vexEND_HANDLING;
/*
 * Get info on the object resolved from the link appPath.
 */
if (<A HREF="vfs-x.html#vfsIsLink"><CODE>vfsIsLink</CODE></A>(&info)) {
 vexWITH_HANDLING {
  <A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A>(appPath, &info);
 } vexON_exception {
  if (<A HREF="vfs-x.html#vfsGetRequestexception"><CODE>vfsGetRequestexception</CODE></A>())
  /*
   * Symbolic link pointing to nowhere...
   * Leave the info structure alone, it already
   * contains info on the link itself.
   */
  ;
  else if (<A HREF="vfs-x.html#vfsGetAccessexception"><CODE>vfsGetAccessexception</CODE></A>())
   /* Handle access problems here */
  else if (<A HREF="vfs-x.html#vfsGetNameexception"><CODE>vfsGetNameexception</CODE></A>())
   /* Handle non-existent target file/dir here */
  else
   /* Handle other "esoteric" problems here */
 } vexEND_HANDLING;
}
/*
 * Continue processing....
 */

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetLockException"><HR><H4>vfsGetLockException</H4></A>
<PRE>
        vfsLockException * <B>vfsGetLockException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetLockExceptionClass"><HR><H4>vfsGetLockExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetLockExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetLockexception"><HR><H4>vfsGetLockexception</H4></A>
<PRE>
        void <B>vfsGetLockexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsLockexception"><CODE>vfsLockexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetLockexceptionClass"><HR><H4>vfsGetLockexceptionClass</H4></A>
<PRE>
        void <B>vfsGetLockexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsLockexception"><CODE>vfsLockexception</CODE></A></SAMP>. It is most often
used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to generate
exceptions. For example, the following code fragment would generate an
exception of type <SAMP><A HREF="vfs-x.html#vfsLockexception"><CODE>vfsLockexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetLockexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetMaxFilesException"><HR><H4>vfsGetMaxFilesException</H4></A>
<PRE>
        vfsMaxFilesException * <B>vfsGetMaxFilesException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetMaxFilesExceptionClass"><HR><H4>vfsGetMaxFilesExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetMaxFilesExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetMaxFilesexception"><HR><H4>vfsGetMaxFilesexception</H4></A>
<PRE>
        void <B>vfsGetMaxFilesexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsMaxFilesexception"><CODE>vfsMaxFilesexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetMaxFilesexceptionClass"><HR><H4>vfsGetMaxFilesexceptionClass</H4></A>
<PRE>
        void <B>vfsGetMaxFilesexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsMaxFilesexception"><CODE>vfsMaxFilesexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions. For example, the following code fragment 
would generate an exception of type <SAMP><A HREF="vfs-x.html#vfsMaxFilesexception"><CODE>vfsMaxFilesexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetMaxFilesexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetMaxLinksException"><HR><H4>vfsGetMaxLinksException</H4></A>
<PRE>
        vfsMaxLinksException * <B>vfsGetMaxLinksException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetMaxLinksExceptionClass"><HR><H4>vfsGetMaxLinksExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetMaxLinksExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetMaxLinksexception"><HR><H4>vfsGetMaxLinksexception</H4></A>
<PRE>
        void <B>vfsGetMaxLinksexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsMaxLinksexception"><CODE>vfsMaxLinksexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetMaxLinksexceptionClass"><HR><H4>vfsGetMaxLinksexceptionClass</H4></A>
<PRE>
        void <B>vfsGetMaxLinksexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsMaxLinksexception"><CODE>vfsMaxLinksexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions. For example, the following code fragment 
would generate an
exception of type <SAMP><A HREF="vfs-x.html#vfsMaxLinksexception"><CODE>vfsMaxLinksexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetMaxLinksexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetMaxLocksException"><HR><H4>vfsGetMaxLocksException</H4></A>
<PRE>
        vfsMaxLocksException * <B>vfsGetMaxLocksException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetMaxLocksExceptionClass"><HR><H4>vfsGetMaxLocksExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetMaxLocksExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetMaxLocksexception"><HR><H4>vfsGetMaxLocksexception</H4></A>
<PRE>
        void <B>vfsGetMaxLocksexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsMaxLocksexception"><CODE>vfsMaxLocksexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetMaxLocksexceptionClass"><HR><H4>vfsGetMaxLocksexceptionClass</H4></A>
<PRE>
        void <B>vfsGetMaxLocksexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsMaxLocksexception"><CODE>vfsMaxLocksexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions. For example, the following code 
fragment would generate an
exception of type <SAMP><A HREF="vfs-x.html#vfsMaxLocksexception"><CODE>vfsMaxLocksexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetMaxLocksexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetMaxNameException"><HR><H4>vfsGetMaxNameException</H4></A>
<PRE>
        vfsMaxNameException * <B>vfsGetMaxNameException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetMaxNameExceptionClass"><HR><H4>vfsGetMaxNameExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetMaxNameExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetMaxNameexception"><HR><H4>vfsGetMaxNameexception</H4></A>
<PRE>
        void <B>vfsGetMaxNameexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsMaxNameexception"><CODE>vfsMaxNameexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetMaxNameexceptionClass"><HR><H4>vfsGetMaxNameexceptionClass</H4></A>
<PRE>
        void <B>vfsGetMaxNameexceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetMaxPathException"><HR><H4>vfsGetMaxPathException</H4></A>
<PRE>
        vfsMaxPathException * <B>vfsGetMaxPathException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetMaxPathExceptionClass"><HR><H4>vfsGetMaxPathExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetMaxPathExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetMaxPathexception"><HR><H4>vfsGetMaxPathexception</H4></A>
<PRE>
        void <B>vfsGetMaxPathexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsMaxPathexception"><CODE>vfsMaxPathexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetMaxPathexceptionClass"><HR><H4>vfsGetMaxPathexceptionClass</H4></A>
<PRE>
        void <B>vfsGetMaxPathexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsMaxPathexception"><CODE>vfsMaxPathexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions. For example, the following code 
fragment would generate an exception of type 
<SAMP><A HREF="vfs-x.html#vfsMaxPathexception"><CODE>vfsMaxPathexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetMaxPathexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetMode"><HR><H4>vfsGetMode</H4></A>
<PRE>
        vfsMode <B>vfsGetMode</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
Returns the access mode for a file referenced by its
information structure <SAMP>info</SAMP>. <SAMP>info</SAMP>
is initialized using the <CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE> or
<CODE><A HREF="vfs-x.html#vfsGetLinkInfo"><CODE>vfsGetLinkInfo</CODE></A></CODE> function. For operating systems
that do not support access modes, <CODE>vfsGetMode</CODE>
returns a mode with permission masks valid because the
current process will have access to the file regardless.
<CODE>vfsGetMode</CODE> returns a mode with one or more of
the following access permission masks set:
 
<DL>
<DT><CODE>vfsOWNER_READ</CODE>
<DD>Read for owner.

<DT><CODE>vfsOWNER_WRITE</CODE>
<DD>Write for owner.

<DT><CODE>vfsOWNER_EXECUTE</CODE>
<DD>File-execution for owner.

<DT><CODE>vfsOWNER_PERMISSIONS_MASK</CODE>
<DD>Read, write, and execute for owner.

<DT><CODE>vfsGROUP_READ</CODE>
<DD>Read for owner's group.

<DT><CODE>vfsGROUP_WRITE</CODE>
<DD>Write for owner's group.

<DT><CODE>vfsGROUP_EXECUTE</CODE>
<DD>File-execution for owner's group.

<DT><CODE>vfsGROUP_PERMISSIONS_MASK</CODE>
<DD>Read, write, and execute for owner's group.

<DT><CODE>vfsOTHER_READ</CODE>
<DD>Read for others.

<DT><CODE>vfsOTHER_WRITE</CODE>
<DD>Write for others.

<DT><CODE>vfsOTHER_EXECUTE</CODE>
<DD>File-execution for others.

<DT><CODE>vfsOTHER_PERMISSIONS_MASK</CODE>
<DD>Read, write, and execute for others.
</DL>

<P>
Sample Code: Using <CODE>vfsGetMode</CODE>

<BLOCKQUOTE>
<PRE>
/*
 * Determine whether every user has write and execute access
 * to the directory that contains the currently running application.
 */
<A HREF="vfs-x.html#vfsInfo"><CODE>vfsInfo</CODE></A>  info;
<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *appPath;
<A HREF="vfs-x.html#vfsMode"><CODE>vfsMode</CODE></A>  mode;

appPath = vfsGetAppPath();
<A HREF="vfs-x.html#vfsGetLinkInfo"><CODE>vfsGetLinkInfo</CODE></A>(appPath, &info);
mode    = vfsGetMode(&info);
if ((mode & vfsOTHER_WRITE) && (mode & vfsOTHER_EXECUTE))
  /* Write and execute access allowed for all users */
else
  /* One or both access permissions are denied. */
<A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A>(appPath);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetModificationTime"><HR><H4>vfsGetModificationTime</H4></A>
<PRE>
        vtimestamp <B>vfsGetModificationTime</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
Returns the time a file or directory was last modified
using information obtained by initializing
<SAMP>info</SAMP> with the <CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE> or
<CODE><A HREF="vfs-x.html#vfsGetLinkInfo"><CODE>vfsGetLinkInfo</CODE></A></CODE> function.
<CODE>vfsGetModificationTime</CODE> returns the time in
<SAMP><A HREF="vtimestamp-x.html#vtimestamp"><CODE>vtimestamp</CODE></A></SAMP> format. Use the Galaxy Date Manager
to manipulate, print, and format <SAMP><A HREF="vtimestamp-x.html#vtimestamp"><CODE>vtimestamp</CODE></A></SAMP>
objects.
</DD></DL>
<P>
<A NAME="vfsGetNameException"><HR><H4>vfsGetNameException</H4></A>
<PRE>
        vfsNameException * <B>vfsGetNameException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetNameExceptionClass"><HR><H4>vfsGetNameExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetNameExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetNameexception"><HR><H4>vfsGetNameexception</H4></A>
<PRE>
        void <B>vfsGetNameexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsNameexception"><CODE>vfsNameexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetNameexceptionClass"><HR><H4>vfsGetNameexceptionClass</H4></A>
<PRE>
        void <B>vfsGetNameexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsNameexception"><CODE>vfsNameexception</CODE></A></SAMP>. It is most often
used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to generate
exceptions. For example, the following code fragment would generate an
exception of type <SAMP><A HREF="vfs-x.html#vfsNameexception"><CODE>vfsNameexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetNameexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetNoMemoryException"><HR><H4>vfsGetNoMemoryException</H4></A>
<PRE>
        vfsNoMemoryException * <B>vfsGetNoMemoryException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetNoMemoryExceptionClass"><HR><H4>vfsGetNoMemoryExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetNoMemoryExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetNoMemoryexception"><HR><H4>vfsGetNoMemoryexception</H4></A>
<PRE>
        void <B>vfsGetNoMemoryexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsNoSpaceexception"><CODE>vfsNoSpaceexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetNoMemoryexceptionClass"><HR><H4>vfsGetNoMemoryexceptionClass</H4></A>
<PRE>
        void <B>vfsGetNoMemoryexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsNoSpaceexception"><CODE>vfsNoSpaceexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions.
  <P>
For example, the following code fragment would generate an
exception of type <SAMP><A HREF="vfs-x.html#vfsNoSpaceexception"><CODE>vfsNoSpaceexception</CODE></A></SAMP>:
  <P>
<BLOCKQUOTE>


<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetNoMemoryexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetNoSpaceException"><HR><H4>vfsGetNoSpaceException</H4></A>
<PRE>
        vfsNoSpaceException * <B>vfsGetNoSpaceException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetNoSpaceExceptionClass"><HR><H4>vfsGetNoSpaceExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetNoSpaceExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetNoSpaceexception"><HR><H4>vfsGetNoSpaceexception</H4></A>
<PRE>
        void <B>vfsGetNoSpaceexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsNoSpaceexception"><CODE>vfsNoSpaceexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetNoSpaceexceptionClass"><HR><H4>vfsGetNoSpaceexceptionClass</H4></A>
<PRE>
        void <B>vfsGetNoSpaceexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsNoSpaceexception"><CODE>vfsNoSpaceexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions. For example, the following code 
fragment would generate an
exception of type <SAMP><A HREF="vfs-x.html#vfsNoSpaceexception"><CODE>vfsNoSpaceexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetNoSpaceexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetNotEmptyException"><HR><H4>vfsGetNotEmptyException</H4></A>
<PRE>
        vfsNotEmptyException * <B>vfsGetNotEmptyException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetNotEmptyExceptionClass"><HR><H4>vfsGetNotEmptyExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetNotEmptyExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetNotEmptyexception"><HR><H4>vfsGetNotEmptyexception</H4></A>
<PRE>
        void <B>vfsGetNotEmptyexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsNotEmptyexception"><CODE>vfsNotEmptyexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetNotEmptyexceptionClass"><HR><H4>vfsGetNotEmptyexceptionClass</H4></A>
<PRE>
        void <B>vfsGetNotEmptyexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsNotEmptyexception"><CODE>vfsNotEmptyexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions. For example, the following code 
fragment would generate an
exception of type <SAMP><A HREF="vfs-x.html#vfsNotEmptyexception"><CODE>vfsNotEmptyexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetNotEmptyexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetNumAvailableFileChannels"><HR><H4>vfsGetNumAvailableFileChannels</H4></A>
<PRE>
        int <B>vfsGetNumAvailableFileChannels</B>();
</PRE>

<DL><DD>
Returns the number of operating system file
channels/descriptors available to the current Galaxy client
program. This number takes into account any file channels
reserved by the client program using
<CODE><A HREF="vfs-x.html#vfsReserveFileChannels"><CODE>vfsReserveFileChannels</CODE></A></CODE> and any open files used
by the File System Manager.
<P>
This function is useful only to Galaxy client programs
performing special-purpose I/O operations that require file
channels that may be used by the File System Manager. It is
usually used in conjunction with
<CODE><A HREF="vfs-x.html#vfsReserveFileChannels"><CODE>vfsReserveFileChannels</CODE></A></CODE> and
<CODE><A HREF="vfs-x.html#vfsSurrenderFileChannels"><CODE>vfsSurrenderFileChannels</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsGetNumOpenFiles"><HR><H4>vfsGetNumOpenFiles</H4></A>
<PRE>
        int <B>vfsGetNumOpenFiles</B>();
</PRE>

<DL><DD>
Returns the number of files currently opened by the File
System Manager. This does not include files that were
opened by <CODE><A HREF="vfs-x.html#vfsOpenFile"><CODE>vfsOpenFile</CODE></A></CODE> that are currently
cached. The number returned corresponds to the number of
operating system file channels/descriptors currently used
by the File System Manager.
<P>
This function is useful only to those Galaxy clients
performing special-purpose I/O operations that require file
channels that may be used by the File System Manager. It is
usually used in conjunction with
<CODE><A HREF="vfs-x.html#vfsReserveFileChannels"><CODE>vfsReserveFileChannels</CODE></A></CODE> and
<CODE><A HREF="vfs-x.html#vfsSurrenderFileChannels"><CODE>vfsSurrenderFileChannels</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsGetNumReservedFileChannels"><HR><H4>vfsGetNumReservedFileChannels</H4></A>
<PRE>
        int <B>vfsGetNumReservedFileChannels</B>();
</PRE>

<DL><DD>
Returns the number of operating system file
channels/descriptors reserved for special use by the
current Galaxy client program. File channels are reserved
for the Galaxy client application and surrendered back to
the File System Manager using
<CODE><A HREF="vfs-x.html#vfsReserveFileChannels"><CODE>vfsReserveFileChannels</CODE></A></CODE> and
<CODE><A HREF="vfs-x.html#vfsSurrenderFileChannels"><CODE>vfsSurrenderFileChannels</CODE></A></CODE> respectively.
</DD></DL>
<P>
<A NAME="vfsGetParentPathElementString"><HR><H4>vfsGetParentPathElementString</H4></A>
<PRE>
        const vchar * <B>vfsGetParentPathElementString</B>();
</PRE>

<DL><DD>
Returns a pointer to a string that comprises the parent
path element for the current operating system. For example,
for DOS/Windows this returns ``<SAMP>..</SAMP>''.
<CODE>vfsGetParentPathElementString</CODE> returns a
pointer to a shared string, which should not be altered in
any way.
  <P>
<CODE><A HREF="vfs-x.html#vfsCloneParentPathElementString"><CODE>vfsCloneParentPathElementString</CODE></A></CODE> returns a
pointer to a dynamically allocated copy of the parent path
element string, which can be destroyed using
<CODE><A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsGetPathElementAt"><HR><H4>vfsGetPathElementAt</H4></A>
<PRE>
        vchar * <B>vfsGetPathElementAt</B>(
                const vfsPath * path,
                int element);
</PRE>

<DL><DD>
Returns a pointer to the <I>n</I>th element (n =
<SAMP>element</SAMP>) of the path. For a sample path
``<SAMP>/dir1/dir2/filename</SAMP>,'' The root volume
counts as the first path element for full pathnames, so
<SAMP>vfsGetPathElementAt(path, 0)</SAMP> would return a
pointer to the string representing the root volume. For
example, under UNIX, this would be the string
``<SAMP>/</SAMP>'', and under DOS/Windows the string
``<SAMP>\\</SAMP>''.
  <P>
<CODE>vfsGetPathElementAt</CODE> returns a pointer to the
shared string path component (and not a copy). Only use the
string pointers returned from
<CODE>vfsGetPathElementAt</CODE> as a read-only reference
and do not attempt to modify, destroy, or reallocate them.
Use <CODE><A HREF="vfs-x.html#vfsClonePathElementAt"><CODE>vfsClonePathElementAt</CODE></A></CODE> to obtain pointers
to dynamically allocated copies of path elements.
  <P>
Exceptions are:

<DL>
<DT><SAMP>vexArgNullexception</SAMP>
<DD>Generated if the path is a <SAMP>NULL</SAMP>
pointer.</B> 

<DT><SAMP>vexArgRangeexception</SAMP>
<DD>Generated if <SAMP>element</SAMP> is less than zero or
greater than the number of elements in the path minus one.
(<SAMP><A HREF="vfs-x.html#vfsGetPathElementCount"><CODE>vfsGetPathElementCount</CODE></A>(path) - 1</SAMP> always
produces the offset to the last element in a path.) 
</DL>
</DD></DL>
<P>
<A NAME="vfsGetPathElementCount"><HR><H4>vfsGetPathElementCount</H4></A>
<PRE>
        int <B>vfsGetPathElementCount</B>(
                const vfsPath * path);
</PRE>

<DL><DD>
Returns the number of elements/components in the path
<SAMP>path</SAMP>. For full pathnames (that is,
<SAMP>vfsPATH_TYPE_FULL</SAMP>), the root volume is counted
as well. It is helpful to note that
<SAMP>vfsGetPathElementCount(path) - 1</SAMP> calculates
the offset to the last element (path leaf) in a path.
  <P>
Table: Sample returns for <CODE>vfsGetPathElementCount</CODE>

<DL>
<DT><B>Path</B>
<DD><CODE>vfsGetPathElementCount</CODE> <B>returns</B>

<DT><SAMP>/dir1/dir2/dir3/file</SAMP>
<DD><SAMP>5</SAMP>

<DT><SAMP>dir1/dir2/dir3/file</SAMP>
<DD><SAMP>4</SAMP>

<DT><SAMP>/</SAMP>
<DD><SAMP>1</SAMP>

<DT><SAMP>file</SAMP>
<DD><SAMP>1</SAMP>

<DT><SAMP>../../dir1/dir2/dir3/file</SAMP>
<DD><SAMP>6</SAMP>
</DL>
</DD></DL>
<P>
<A NAME="vfsGetPathSeparatorString"><HR><H4>vfsGetPathSeparatorString</H4></A>
<PRE>
        const vchar * <B>vfsGetPathSeparatorString</B>();
</PRE>

<DL><DD>
Returns a pointer to a string that symbolically represents
the path separator for the operating system. For example,
under DOS/Windows this returns ``<SAMP>\\</SAMP>'' and for
UNIX this returns ``<SAMP>/</SAMP>''.
<CODE>vfsGetPathSeparatorString</CODE> returns a pointer to
a shared string, which should not be altered in any way.
</DD></DL>
<P>
<A NAME="vfsGetPathType"><HR><H4>vfsGetPathType</H4></A>
<PRE>
        vfsType <B>vfsGetPathType</B>(
                const vfsPath * path);
</PRE>

<DL><DD>
Returns the type of the path <SAMP>path</SAMP>.
<CODE>vfsGetPathType</CODE> returns one of the following
values:

<DL>
<DT><CODE>vfsPATH_TYPE_FULL</CODE>
<DD>Denotes a full path that begins at the root volume in
the form ``<SAMP>/dir/dir/filename</SAMP>''. 

<DT><CODE>vfsPATH_TYPE_RELATIVE</CODE>
<DD>Denotes a path that is relative to another directory.
For instance, ``<SAMP>../dir/filename</SAMP>'' would
describe a path that is relative to the parent directory or
folder. Note that <CODE>vfsPATH_TYPE_RELATIVE</CODE> is
used only for file and directory pathnames that <I>begin
</I>with a relative reference. For example,
``<SAMP>/dir/dir2/../filename</SAMP>'' would be considered
a full pathname. 

<DT><CODE>vfsPATH_TYPE_NAME</CODE>
<DD>Denotes a file or directory name only, for example,
``<SAMP>filename</SAMP>.'' This is treated internally by
the File System Manager as a special type of relative path,
because it is relative to the directory that contains it. 
</DL>

<P>
When a Galaxy client program builds a path using functions
other than <A HREF="vfs-x.html#vfsBuildPath"><CODE>vfsBuildPath</CODE></A>, the File System Manager
automatically determines the type of the path.
Understanding a path's correct type is critical to the
operation of the File System Manager's cache.
</DD></DL>
<P>
<A NAME="vfsGetPathVolumeName"><HR><H4>vfsGetPathVolumeName</H4></A>
<PRE>
        const vchar * <B>vfsGetPathVolumeName</B>(
                vfsPath * path);
</PRE>

<DL><DD>
<CODE>vfsGetPathVolumeName</CODE> returns a pointer to a
shared volume name string for the path <SAMP>path</SAMP>
that should never be modified by the Galaxy client program.
<CODE><A HREF="vfs-x.html#vfsCloneHomeDirPath"><CODE>vfsCloneHomeDirPath</CODE></A></CODE> returns a dynamically
allocated copy of the volume name for the path
<SAMP>path</SAMP>.
  <P>
The exception <SAMP>vexArgNullexception</SAMP> is generated if the path
is a <SAMP>NULL</SAMP> pointer.
</DD></DL>
<P>
<A NAME="vfsGetPathVolumeRef"><HR><H4>vfsGetPathVolumeRef</H4></A>
<PRE>
        vfsVolumeRef <B>vfsGetPathVolumeRef</B>(
                vfsPath * path);
</PRE>

<DL><DD>
Returns the numeric volume reference associated with the
path <SAMP>path</SAMP> or the constant
<SAMP>vfsNO_VOLUME_REFERENCE</SAMP> if the path has no
volume reference associated with it.
</DD></DL>
<P>
<A NAME="vfsGetReadException"><HR><H4>vfsGetReadException</H4></A>
<PRE>
        vfsReadException * <B>vfsGetReadException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetReadExceptionClass"><HR><H4>vfsGetReadExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetReadExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetReadOnlyException"><HR><H4>vfsGetReadOnlyException</H4></A>
<PRE>
        vfsReadOnlyException * <B>vfsGetReadOnlyException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetReadOnlyExceptionClass"><HR><H4>vfsGetReadOnlyExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetReadOnlyExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetReadOnlyexception"><HR><H4>vfsGetReadOnlyexception</H4></A>
<PRE>
        void <B>vfsGetReadOnlyexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsReadOnlyexception"><CODE>vfsReadOnlyexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetReadOnlyexceptionClass"><HR><H4>vfsGetReadOnlyexceptionClass</H4></A>
<PRE>
        void <B>vfsGetReadOnlyexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsReadOnlyexception"><CODE>vfsReadOnlyexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions. For example, the following code 
fragment would generate an
exception of type <SAMP><A HREF="vfs-x.html#vfsReadOnlyexception"><CODE>vfsReadOnlyexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetReadOnlyexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetReadexception"><HR><H4>vfsGetReadexception</H4></A>
<PRE>
        void <B>vfsGetReadexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsReadexception"><CODE>vfsReadexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetReadexceptionClass"><HR><H4>vfsGetReadexceptionClass</H4></A>
<PRE>
        void <B>vfsGetReadexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsReadexception"><CODE>vfsReadexception</CODE></A></SAMP>. It is most often
used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to generate
exceptions. For example, the following code 
fragment would generate an
exception of type <SAMP><A HREF="vfs-x.html#vfsReadexception"><CODE>vfsReadexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetReadexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetRequestException"><HR><H4>vfsGetRequestException</H4></A>
<PRE>
        vfsRequestException * <B>vfsGetRequestException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetRequestExceptionClass"><HR><H4>vfsGetRequestExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetRequestExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetRequestexception"><HR><H4>vfsGetRequestexception</H4></A>
<PRE>
        void <B>vfsGetRequestexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsRequestexception"><CODE>vfsRequestexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetRequestexceptionClass"><HR><H4>vfsGetRequestexceptionClass</H4></A>
<PRE>
        void <B>vfsGetRequestexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsRequestexception"><CODE>vfsRequestexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions. For example, the following code 
fragment would generate an
exception of type <SAMP><A HREF="vfs-x.html#vfsRequestexception"><CODE>vfsRequestexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetRequestexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetRootVolumeElementString"><HR><H4>vfsGetRootVolumeElementString</H4></A>
<PRE>
        const vchar * <B>vfsGetRootVolumeElementString</B>();
</PRE>

<DL><DD>
Returns a pointer to a string that symbolically represents
the root volume element for the current operating system.
For example, for UNIX this returns ``<SAMP>/</SAMP>''.
<CODE>vfsGetRootVolumeElementString</CODE> returns a
pointer to a shared string, which should not be altered in
any way.
</DD></DL>
<P>
<A NAME="vfsGetSize"><HR><H4>vfsGetSize</H4></A>
<PRE>
        long <B>vfsGetSize</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
Returns the size (in bytes) for a file or directory from
information contained in its information structure
<SAMP>info</SAMP>. <SAMP>info</SAMP> is initialized using
the <CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE>, or
<CODE><A HREF="vfs-x.html#vfsGetLinkInfo"><CODE>vfsGetLinkInfo</CODE></A></CODE> function. If the info
<SAMP>info</SAMP> references a directory,
<CODE>vfsGetSize</CODE> returns the size of the directory
file itself, not the cumulative size of its contents.
</DD></DL>
<P>
<A NAME="vfsGetStartupDirPath"><HR><H4>vfsGetStartupDirPath</H4></A>
<PRE>
        const vfsPath * <B>vfsGetStartupDirPath</B>();
</PRE>

<DL><DD>
Returns a pointer to the full path representing the
directory that the current application started up in. This
should never be modified by the Galaxy client program. The
startup directory is different from the application
directory (see <CODE><A HREF="vfs-x.html#vfsGetAppDirPath"><CODE>vfsGetAppDirPath</CODE></A></CODE> and
<CODE><A HREF="vfs-x.html#vfsCloneAppDirPath"><CODE>vfsCloneAppDirPath</CODE></A></CODE>) which is the directory
where the currently running application's executable file
resides. The startup directory is the directory the user
was in when launching the application. The startup
directory is always kept by the File System Manager and its
value is unaffected by calls to
<CODE><A HREF="vfs-x.html#vfsSetWorkingDir"><CODE>vfsSetWorkingDir</CODE></A></CODE>, <CODE><A HREF="vfs-x.html#vfsPushDir"><CODE>vfsPushDir</CODE></A></CODE>, and
<CODE><A HREF="vfs-x.html#vfsPopDir"><CODE>vfsPopDir</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsGetSystemException"><HR><H4>vfsGetSystemException</H4></A>
<PRE>
        vfsSystemException * <B>vfsGetSystemException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetSystemExceptionClass"><HR><H4>vfsGetSystemExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetSystemExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetSystemMaxException"><HR><H4>vfsGetSystemMaxException</H4></A>
<PRE>
        vfsSystemMaxException * <B>vfsGetSystemMaxException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetSystemMaxExceptionClass"><HR><H4>vfsGetSystemMaxExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetSystemMaxExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetSystemMaxexception"><HR><H4>vfsGetSystemMaxexception</H4></A>
<PRE>
        void <B>vfsGetSystemMaxexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsSystemMaxexception"><CODE>vfsSystemMaxexception</CODE></A></SAMP> in the exception
handling chain, or <SAMP>NULL</SAMP> if there were no
exceptions. Along with other exception handling functions,
it is used mainly to determine which of a number of
possible exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetSystemMaxexceptionClass"><HR><H4>vfsGetSystemMaxexceptionClass</H4></A>
<PRE>
        void <B>vfsGetSystemMaxexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsSystemMaxexception"><CODE>vfsSystemMaxexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions.
  <P>
For example, the following code fragment would generate an
exception of type <SAMP><A HREF="vfs-x.html#vfsSystemMaxexception"><CODE>vfsSystemMaxexception</CODE></A></SAMP>:
  <P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetSystemMaxexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetSystemexception"><HR><H4>vfsGetSystemexception</H4></A>
<PRE>
        void <B>vfsGetSystemexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsSystemexception"><CODE>vfsSystemexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetSystemexceptionClass"><HR><H4>vfsGetSystemexceptionClass</H4></A>
<PRE>
        void <B>vfsGetSystemexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsSystemexception"><CODE>vfsSystemexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions. For example, the following code 
fragment would generate an
exception of type <SAMP><A HREF="vfs-x.html#vfsSystemexception"><CODE>vfsSystemexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetSystemexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetUserId"><HR><H4>vfsGetUserId</H4></A>
<PRE>
        vfsUserId <B>vfsGetUserId</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
Returns the user ID associated with the file or directory
information contained in the info <SAMP>info</SAMP>.
<SAMP>info</SAMP> is initialized using the
<CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE> or <CODE><A HREF="vfs-x.html#vfsGetLinkInfo"><CODE>vfsGetLinkInfo</CODE></A></CODE>
function. It returns <SAMP>-1</SAMP> if there is no user ID
for this file/directory or the operating system does not
support user IDs.
</DD></DL>
<P>
<A NAME="vfsGetVolumeIteratorVolume"><HR><H4>vfsGetVolumeIteratorVolume</H4></A>
<PRE>
        const vfsVolume * <B>vfsGetVolumeIteratorVolume</B>(
                vfsVolumeIterator * iterator);
</PRE>

<DL><DD>
Returns the volume associated with the iterator
<SAMP>iterator</SAMP>.
<CODE>vfsGetVolumeIteratorVolume</CODE> should only be
called after <CODE><A HREF="vfs-x.html#vfsNextVolumeIterator"><CODE>vfsNextVolumeIterator</CODE></A></CODE> has
returned <SAMP>TRUE</SAMP>. The volume returned by
<CODE>vfsGetVolumeIteratorVolume</CODE> should not be
destroyed by the Galaxy Client program. The volume list is
cached internally by the File System Manager and reused.
Use the following code fragment to return a dynamically
allocated copy of the volume:
  <P>
<BLOCKQUOTE>
<PRE>

/*
 * The following code fragment demonstrates correct use of
 * the vfsGetVolumeIteratorVolume() function.
 */
<A HREF="vfs-x.html#vfsVolume"><CODE>vfsVolume</CODE></A>      *volume;
<A HREF="vfs-x.html#vfsVolumeIterator"><CODE>vfsVolumeIterator</CODE></A>  iterator;

<A HREF="vfs-x.html#vfsInitVolumeIterator"><CODE>vfsInitVolumeIterator</CODE></A>(&iterator);
while (<A HREF="vfs-x.html#vfsNextVolumeIterator"><CODE>vfsNextVolumeIterator</CODE></A>(&iterator)) {
 volume = vfsGetVolumeIteratorVolume(&iterator);
 /* Process 'volume' data... */
  .
  .
  .
}
<A HREF="vfs-x.html#vfsDestroyVolumeIterator"><CODE>vfsDestroyVolumeIterator</CODE></A>(&iterator);

</PRE>

<PRE>
volume = <A HREF="vfs-x.html#vfsCloneVolume"><CODE>vfsCloneVolume</CODE></A>(vfsGetVolumeIteratorVolume(&iterator));
</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetVolumeName"><HR><H4>vfsGetVolumeName</H4></A>
<PRE>
        vchar * <B>vfsGetVolumeName</B>(
                const vfsVolume * volume);
</PRE>

<DL><DD>
Returns the volume name string associated with the volume
<SAMP>volume</SAMP>. You should not destroy the volume name
using <CODE><A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A></CODE>. Use
<CODE><A HREF="vfs-x.html#vfsSetVolumeName"><CODE>vfsSetVolumeName</CODE></A></CODE> to set the volume name to
another name and to destroy the current reference. Use
<CODE><A HREF="vfs-x.html#vfsDestroyVolume"><CODE>vfsDestroyVolume</CODE></A></CODE> to destroy both the volume
and volume name.
</DD></DL>
<P>
<A NAME="vfsGetVolumeReference"><HR><H4>vfsGetVolumeReference</H4></A>
<PRE>
        vfsVolumeRef <B>vfsGetVolumeReference</B>(
                const vfsVolume * volume);
</PRE>

<DL><DD>
Returns the volume reference associated with the volume
<SAMP>volume</SAMP>.
</DD></DL>
<P>
<A NAME="vfsGetVolumeSeparatorString"><HR><H4>vfsGetVolumeSeparatorString</H4></A>
<PRE>
        const vchar * <B>vfsGetVolumeSeparatorString</B>();
</PRE>

<DL><DD>
Returns a pointer to a string that comprises the separator
for volumes for the current operating system. Currently
this returns a pointer to a <SAMP>NULL</SAMP> string (not a
<SAMP>NULL</SAMP> pointer) for UNIX; under DOS/Windows it
returns a ``<SAMP>:</SAMP>''.
<CODE>vfsGetVolumeSeparatorString</CODE> returns a pointer
to a shared string, which should not be altered in any way.
</DD></DL>
<P>
<A NAME="vfsGetVolumeType"><HR><H4>vfsGetVolumeType</H4></A>
<PRE>
        int <B>vfsGetVolumeType</B>(
                const vfsVolume * volume);
</PRE>

<DL><DD>
Returns the type of the volume <SAMP>volume</SAMP>.
<CODE>vfsGetVolumeType</CODE> returns one of the following
values:

<ul>
<li>vfsVOLUME_TYPE_NONEXISTENT Volume nonexistent
<li>vfsVOLUME_TYPE_UNKNOWN Not known vfsVOLUME_TYPE_REMOVABLE
<li>Removeable media vfsVOLUME_TYPE_FIXED Fixed hard disks
<li>vfsVOLUME_TYPE_REMOTE Network volumes
<li>vfsVOLUME_TYPE_SPECIAL Special volumes
</ul>

<P>
Galaxy on UNIX platforms does not have the concept of
separate logical volumes and always returns
<SAMP>vfsVOLUME_TYPE_NONEXISTENT</SAMP> for calls to
<CODE>vfsGetVolumeType</CODE>.
</DD></DL>
<P>
<A NAME="vfsGetWorkingDirPath"><HR><H4>vfsGetWorkingDirPath</H4></A>
<PRE>
        const vfsPath * <B>vfsGetWorkingDirPath</B>();
</PRE>

<DL><DD>
Returns a pointer to the path representing the current
working directory for the Galaxy client program.
<P>
The return from <CODE>vfsGetWorkingDirPath</CODE> is
guaranteed to be invalidated by calls to
<CODE><A HREF="vfs-x.html#vfsSetWorkingDir"><CODE>vfsSetWorkingDir</CODE></A></CODE>, <CODE><A HREF="vfs-x.html#vfsPushDir"><CODE>vfsPushDir</CODE></A></CODE>, and
<CODE><A HREF="vfs-x.html#vfsPopDir"><CODE>vfsPopDir</CODE></A></CODE>. It is also possible for it to be
invalidated by a call to any File System Manager function
that would cause a cached file with a relative pathname to
be opened. (The File System Manager will open cached
relative path files from their original referenced
directory using <CODE><A HREF="vfs-x.html#vfsPushDir"><CODE>vfsPushDir</CODE></A></CODE> and
<CODE><A HREF="vfs-x.html#vfsPopDir"><CODE>vfsPopDir</CODE></A></CODE>.) Only use
<CODE>vfsGetWorkingDirPath</CODE> in temporal situations
(for example, path comparisons), otherwise use
<CODE><A HREF="vfs-x.html#vfsCloneWorkingDirPath"><CODE>vfsCloneWorkingDirPath</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsGetWorkingVolume"><HR><H4>vfsGetWorkingVolume</H4></A>
<PRE>
        const vfsVolume * <B>vfsGetWorkingVolume</B>();
</PRE>

<DL><DD>
Returns a pointer to the current working volume or a
<SAMP>NULL</SAMP> pointer in the event that no volume is
associated with the current working directory. Galaxy on
UNIX platforms always returns a <SAMP>NULL</SAMP> pointer.
Conversely, on the DOS/Windows platform, Galaxy always
returns a non-null value from
<CODE>vfsGetWorkingVolume</CODE>.
</DD></DL>
<P>
<A NAME="vfsGetWriteException"><HR><H4>vfsGetWriteException</H4></A>
<PRE>
        vfsWriteException * <B>vfsGetWriteException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetWriteExceptionClass"><HR><H4>vfsGetWriteExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vfsGetWriteExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsGetWriteexception"><HR><H4>vfsGetWriteexception</H4></A>
<PRE>
        void <B>vfsGetWriteexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP><A HREF="vfs-x.html#vfsWriteexception"><CODE>vfsWriteexception</CODE></A></SAMP> in the exception handling
chain, or <SAMP>NULL</SAMP> if there were no exceptions.
Along with other exception handling functions, it is used
mainly to determine which of a number of possible
exceptions occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetWriteexceptionClass"><HR><H4>vfsGetWriteexceptionClass</H4></A>
<PRE>
        void <B>vfsGetWriteexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP><A HREF="vfs-x.html#vfsWriteexception"><CODE>vfsWriteexception</CODE></A></SAMP>. It is most
often used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to
generate exceptions. For example, the following code 
fragment would generate an
exception of type <SAMP><A HREF="vfs-x.html#vfsWriteexception"><CODE>vfsWriteexception</CODE></A></SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetWriteexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsGetexception"><HR><H4>vfsGetexception</H4></A>
<PRE>
        void <B>vfsGetexception</B>();
</PRE>

<DL><DD>
This function is used by exception handlers to return a
pointer to the highest exception of the type
<SAMP>vfsexception</SAMP> in the exception handling chain,
or <SAMP>NULL</SAMP> if there were no exceptions. Along
with other exception handling functions, it is used mainly
to determine which of a number of possible exceptions
occurred during any given operation.
</DD></DL>
<P>
<A NAME="vfsGetexceptionClass"><HR><H4>vfsGetexceptionClass</H4></A>
<PRE>
        void <B>vfsGetexceptionClass</B>();
</PRE>

<DL><DD>
This function returns a pointer to the exception ``class''
of the type <SAMP>vfsexception</SAMP>. It is most often
used as an argument to <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> to generate
exceptions. For example, the following code fragment would generate an
exception of type <SAMP>vfsexception</SAMP>:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A>(vfsGetexceptionClass(), vexNULL);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsInitVolumeIterator"><HR><H4>vfsInitVolumeIterator</H4></A>
<PRE>
        void <B>vfsInitVolumeIterator</B>(
                vfsVolumeIterator ** iterator);
</PRE>

<DL><DD>
Begins an iteration of all file system volumes that are
known to the operating system. Initially, the iterator will
not contain a volume reference. You must use
<CODE><A HREF="vfs-x.html#vfsNextVolumeIterator"><CODE>vfsNextVolumeIterator</CODE></A></CODE> to obtain the first and
subsequent volume iterators with volume references. This
function has no effect under UNIX (with its single
directory hierarchy built around mounted logical volumes)
which does not conceptually support separate physical
volumes.
  <P>
<CODE>vfsInitVolumeIterator</CODE> rebuilds the volume list
each time it is called to ensure its accuracy. This can
make it a relatively expensive call under some
circumstances.
  <P>
Note that <CODE>vfsInitVolumeIterator</CODE> builds a list of all
volumes known to the operating system. This does not always
mean that the file system associated with the volume is
``mounted'' or that the physical media required to read and
write from a volume is currently on line. For example,
Galaxy on the DOS/Windows platform almost always builds a
volume list that includes a reference to the volume
``A:''which is normally a removable media (floppy) disk
drive; even if a diskette is not actually
inserted.
<P>
Under DOS/Windows the volume list does not include volumes
that are valid drive names that do not have physical or
logical devices attached to them.
</DD></DL>
<P>
<A NAME="vfsInitialize"><HR><H4>vfsInitialize</H4></A>
<PRE>
        void <B>vfsInitialize</B>(
                int numArgs,
                const vchar ** args);
</PRE>

<DL><DD>
Sets the File System Manager argument list and initializes
the File System Manager. <SAMP>numArgs</SAMP> is the number
of elements in the array <SAMP>args</SAMP>. The array
<SAMP>args</SAMP> contains the components of the argument
list not processed by the Preference Manager during command
line preprocessing. The elements of <SAMP>args</SAMP> are
used by <CODE><A HREF="vfs-x.html#vfsGetArgs"><CODE>vfsGetArgs</CODE></A></CODE> and are assumed to be
pathnames.
  <P>
This function is automatically called by the Preference
Manager function <CODE><A HREF="vpref-x.html#vprefSetArgs"><CODE>vprefSetArgs</CODE></A></CODE>, and generally
does not need to be called. However,
<CODE>vfsInitialize</CODE> (or <CODE><A HREF="vpref-x.html#vprefSetArgs"><CODE>vprefSetArgs</CODE></A></CODE>)
must be called before the application has changed working
directories or opened any files other than those passed to
it by the operating system (usually <SAMP>stdin</SAMP>,
<SAMP>stdout</SAMP>, and <SAMP>stderr</SAMP>.) It is a good
idea to make <CODE><A HREF="vstartup-x.html#vstartup"><CODE>vstartup</CODE></A></CODE> (which calls
<CODE><A HREF="vpref-x.html#vprefSetArgs"><CODE>vprefSetArgs</CODE></A></CODE>) one of the first calls you make
in a Galaxy program so that <CODE>vfsInitialize</CODE> is
always called.
</DD></DL>
<P>
<A NAME="vfsIsArchive"><HR><H4>vfsIsArchive</H4></A>
<PRE>
        vbool <B>vfsIsArchive</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the info <SAMP>info</SAMP>
references a DOS archive file, <SAMP>FALSE</SAMP> if it
does not. This attribute is only set for Galaxy on the
OS/2, Windows 3.X, and Windows NT platforms. Use
<CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE> to initialize <SAMP>info</SAMP>
for a given file.
<P>
The DOS file system automatically marks new files and files
that have been modified as archive files. There are no
access restrictions to a file that is marked as an archive
file. The archive attribute is generally used by programs
to see if a file has been updated.
</DD></DL>
<P>
<A NAME="vfsIsAsciiText"><HR><H4>vfsIsAsciiText</H4></A>
<PRE>
        vbool <B>vfsIsAsciiText</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
If the file system supports intrinsic file typing, this
function returns <SAMP>TRUE</SAMP> if the file specified
with the <CODE><A HREF="vfs-x.html#vfsInfo"><CODE>vfsInfo</CODE></A></CODE> <SAMP>info</SAMP> is an ASCII
text file. Otherwise, this function returns
<SAMP>FALSE</SAMP>. 
On systems that do not support intrinsic file typing, this
function always returns <SAMP>FALSE</SAMP>.
</DD></DL>
<P>
<A NAME="vfsIsDirectory"><HR><H4>vfsIsDirectory</H4></A>
<PRE>
        vbool <B>vfsIsDirectory</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the file information
<SAMP>info</SAMP> references a directory or folder,
<SAMP>FALSE</SAMP> if it does not. Use
<CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE> or <CODE><A HREF="vfs-x.html#vfsGetLinkInfo"><CODE>vfsGetLinkInfo</CODE></A></CODE>
to initialize the file information for a given file or
directory.
</DD></DL>
<P>
<A NAME="vfsIsExecutable"><HR><H4>vfsIsExecutable</H4></A>
<PRE>
        vbool <B>vfsIsExecutable</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
If the file system supports intrinsic file typing, this
function returns <SAMP>TRUE</SAMP> if the file specified
with the <A HREF="vfs-x.html#vfsInfo"><CODE>vfsInfo</CODE></A> <SAMP>info</SAMP> is an executable file.
Otherwise, this function returns <SAMP>FALSE</SAMP>.
On systems that do not support intrinsic file typing, this
function always returns <SAMP>FALSE</SAMP>.
</DD></DL>
<P>
<A NAME="vfsIsFile"><HR><H4>vfsIsFile</H4></A>
<PRE>
        vbool <B>vfsIsFile</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the info <SAMP>info</SAMP>
references a regular file, <SAMP>FALSE</SAMP> if it does
not. Use <CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE> or
<CODE><A HREF="vfs-x.html#vfsGetLinkInfo"><CODE>vfsGetLinkInfo</CODE></A></CODE> to initialize the info for a
given file or directory.
</DD></DL>
<P>
<A NAME="vfsIsFileInDirectory"><HR><H4>vfsIsFileInDirectory</H4></A>
<PRE>
        vbool <B>vfsIsFileInDirectory</B>(
                vfsPath * dirName,
                vchar * fileName);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the file name string
<SAMP>fileName</SAMP> is found in the directory
<SAMP>dirName</SAMP>, <SAMP>FALSE</SAMP> if it is not
found.
</DD></DL>
<P>
<A NAME="vfsIsFileInDirectoryScribed"><HR><H4>vfsIsFileInDirectoryScribed</H4></A>
<PRE>
        vbool <B>vfsIsFileInDirectoryScribed</B>(
                vfsPath * dirName,
                vscribe * nameScribe);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the file name string generated
by the scribe <SAMP>nameScribe</SAMP> is found in the
directory <SAMP>dirName</SAMP>, <SAMP>FALSE</SAMP> if it is
not found. <SAMP>nameScribe</SAMP> is automatically
destroyed by <CODE>vfsIsFileInDirectoryScribed</CODE>.
</DD></DL>
<P>
<A NAME="vfsIsFileLocked"><HR><H4>vfsIsFileLocked</H4></A>
<PRE>
        vbool <B>vfsIsFileLocked</B>(
                vfsFile * file);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if one or more locks have been
created anywhere in the file <SAMP>file</SAMP>,
<SAMP>FALSE</SAMP> if no locks are present anywhere in the
file. Equivalent to <CODE><A HREF="vfs-x.html#vfsIsFileRangeLocked"><CODE>vfsIsFileRangeLocked</CODE></A></CODE><SAMP>(file, 0L,
vfsLOCK_TO_END)</SAMP>.
<P>
<B>Note</B>that under UNIX systems that support Sun's Network File System, 
<CODE>vfsIsFileLocked</CODE> can incorrectly return
<SAMP>TRUE</SAMP> when the NFS lock daemon for the file
system containing the file is not running.
</DD></DL>
<P>
<A NAME="vfsIsFileOpen"><HR><H4>vfsIsFileOpen</H4></A>
<PRE>
        vbool <B>vfsIsFileOpen</B>(
                vfsPath * path,
                vfsFile ** file);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if a file referenced by the path
<SAMP>path</SAMP> is already open, <SAMP>FALSE</SAMP> if it
is not. If <SAMP>TRUE</SAMP>, the handle <SAMP>file</SAMP>
is initialized with the pointer to the <SAMP><A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A></SAMP>
structure for the open file. Note that
<CODE>vfsIsFileOpen</CODE> searches the File System
Manager's internal file list in a linear fashion. If you
have opened the same file more than one time, it
initializes <SAMP>file</SAMP> with the first file pointer
it finds that matches <SAMP>path</SAMP>. (This usually
corresponds to the last opened version of the file, but
this behavior is not guaranteed.)
  <P>
<CODE>vfsIsFileOpen</CODE> matches <I>exact</I> paths, not
their canonical form. For example, if
``<SAMP>/dir/file</SAMP>'' is open and
``<SAMP>../dir/file</SAMP>'' references the same file,
<CODE>vfsIsFileOpen</CODE> still returns
<SAMP>FALSE</SAMP>.
  <P>
Sample Code: Using <CODE>vfsIsFileOpen</CODE>

<BLOCKQUOTE>
<PRE>

/*
 * Determine whether a file is open and read it if it is.
 */
<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *path;
<A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A> *file;
vbyte  buffer[vfsIO_BUFFER_SIZE];

if (vfsIsFileOpen(path, &file)) {
 while(<A HREF="vfs-x.html#vfsReadFile"><CODE>vfsReadFile</CODE></A>(buffer, sizeof(vbyte), vfsIO_BUFFER_SIZE, file)) {

  /*
   * Do something with the file contents.
   * .
   * .
   */

 }
}

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsIsFileRangeLocked"><HR><H4>vfsIsFileRangeLocked</H4></A>
<PRE>
        vbool <B>vfsIsFileRangeLocked</B>(
                vfsFile * file,
                long offset,
                long numBytes);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if one or more locks have been
placed anywhere within the specified range of bytes in the
file <SAMP>file</SAMP> starting at <SAMP>offset</SAMP> and
extending <SAMP>numBytes</SAMP> bytes. It returns
<SAMP>FALSE</SAMP> if no locks are present.
<P>
The File System Manager constant
<SAMP>vfsLOCK_TO_END</SAMP> is supported by
<CODE>vfsIsFileRangeLocked</CODE> as a legal value for
<SAMP>numBytes</SAMP>. This indicates that the lock test
operation is to extend from <SAMP>offset</SAMP> to the end
of the file.
<P>
<B>Note</b> that under UNIX systems that support Sun's Network File System
(NFS), <CODE><A HREF="vfs-x.html#vfsIsFileLocked"><CODE>vfsIsFileLocked</CODE></A></CODE> can incorrectly return
<SAMP>TRUE</SAMP> when the NFS lock daemon for the file
system containing the file is not running.
</DD></DL>
<P>
<A NAME="vfsIsFileStreamOpen"><HR><H4>vfsIsFileStreamOpen</H4></A>
<PRE>
        vbool <B>vfsIsFileStreamOpen</B>(
                const vfsFile * file);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsIsHidden"><HR><H4>vfsIsHidden</H4></A>
<PRE>
        vbool <B>vfsIsHidden</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the info <SAMP>info</SAMP>
references a hidden file or directory, <SAMP>FALSE</SAMP>
if it does not. Use <CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE> or
<CODE><A HREF="vfs-x.html#vfsGetLinkInfo"><CODE>vfsGetLinkInfo</CODE></A></CODE> to initialize the info for a
given file or directory.
    <P>
Under UNIX, hidden files are actually fully accessible
(depending upon their access permissions); by convention
they simply will not be listed by the various shells unless
the user explicitly requests to see all hidden files. Under
UNIX the names of hidden files and directories begin with a
period (for example, ``<SAMP>.login</SAMP>'').
</DD></DL>
<P>
<A NAME="vfsIsLink"><HR><H4>vfsIsLink</H4></A>
<PRE>
        vbool <B>vfsIsLink</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the info <SAMP>info</SAMP>
references a symbolic link or file system alias,
<SAMP>FALSE</SAMP> if it does not. Use
<CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE> or <CODE><A HREF="vfs-x.html#vfsGetLinkInfo"><CODE>vfsGetLinkInfo</CODE></A></CODE>
to initialize the info for a given file or directory.
</DD></DL>
<P>
<A NAME="vfsIsPathEqual"><HR><H4>vfsIsPathEqual</H4></A>
<PRE>
        vbool <B>vfsIsPathEqual</B>(
                const vfsPath * path1,
                const vfsPath * path2);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if <SAMP>path1</SAMP> and
<SAMP>path2</SAMP> are equal (that is, identical),
<SAMP>FALSE</SAMP> if they are not. It is equivalent to
<SAMP>(<CODE><A HREF="vfs-x.html#vfsComparePath"><CODE>vfsComparePath</CODE></A></CODE>(path1, path2) ==
0)</SAMP>.
</DD></DL>
<P>
<A NAME="vfsIsResolvedFromLink"><HR><H4>vfsIsResolvedFromLink</H4></A>
<PRE>
        vbool <B>vfsIsResolvedFromLink</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the info <SAMP>info</SAMP>
references a file or directory that was originally
referenced using a symbolic link or file system alias,
<SAMP>FALSE</SAMP> if it does not. Use
<CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE> to initialize the info for a
given file or directory.
<P>
This function only returns accurate information on
information obtained from <CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE>. The
rest of the info structure contains information on the
actual file system object that was referenced by the
original link. <CODE><A HREF="vfs-x.html#vfsGetLinkInfo"><CODE>vfsGetLinkInfo</CODE></A></CODE> obtains
information on the link itself and does not care about what
it points to. <CODE>vfsIsResolvedFromLink</CODE> always
returns <SAMP>FALSE</SAMP> when passed a
<SAMP><A HREF="vfs-x.html#vfsInfo"><CODE>vfsInfo</CODE></A></SAMP> structure pointer initialized using
<CODE><A HREF="vfs-x.html#vfsGetLinkInfo"><CODE>vfsGetLinkInfo</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsIsSpecialFile"><HR><H4>vfsIsSpecialFile</H4></A>
<PRE>
        vbool <B>vfsIsSpecialFile</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the info <SAMP>info</SAMP>
references a special file, <SAMP>FALSE</SAMP> if it does
not. Use <CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE> or
<CODE><A HREF="vfs-x.html#vfsGetLinkInfo"><CODE>vfsGetLinkInfo</CODE></A></CODE> to initialize the info for a
given file or directory.
    <P>
Examples of special files include a device driver reference
(block or character device), a named pipe or FIFO, or a
socket under UNIX. Special files generally have unique I/O
characteristics, so if you are manipulating devices
directly your Galaxy application may require conditionally
compiled code for each operating system you support.
</DD></DL>
<P>
<A NAME="vfsIsSystem"><HR><H4>vfsIsSystem</H4></A>
<PRE>
        vbool <B>vfsIsSystem</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the info <SAMP>info</SAMP>
references a DOS system file, <SAMP>FALSE</SAMP> if it does
not. This attribute is only set for Galaxy on the OS/2,
Windows 3.X, and Windows NT platforms. Use
<CODE><A HREF="vfs-x.html#vfsGetFileInfo"><CODE>vfsGetFileInfo</CODE></A></CODE> to initialize the info for a
given file.
    <P>
The DOS file system uses the system attribute to mark
system files such as IO.SYS and MSDOS.SYS. There are no
access restrictions to a file that is marked as a system
file. The system attribute is used to prevent the DOS
command interpreter from finding and executing system
files.
</DD></DL>
<P>
<A NAME="vfsIsVolumeCaseInsensitive"><HR><H4>vfsIsVolumeCaseInsensitive</H4></A>
<PRE>
        vbool <B>vfsIsVolumeCaseInsensitive</B>(
                const vfsVolume * volume);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the volume is case
insensitive, <SAMP>FALSE</SAMP> if not.
</DD></DL>
<P>
<A NAME="vfsIsVolumeValid"><HR><H4>vfsIsVolumeValid</H4></A>
<PRE>
        int <B>vfsIsVolumeValid</B>(
                const vfsVolume * volume);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the volume volume is
accessible by the Galaxy client program, <SAMP>FALSE</SAMP>
if it is not. This function tells you whether a physical
drive is attached to a logical volume.
<P>
Galaxy on UNIX platforms does not have the concept of
separate logical volumes and always returns
<SAMP>FALSE</SAMP> for calls to
<CODE>vfsIsVolumeValid</CODE>.
<P>
Under DOS/Windows, <CODE>vfsIsVolumeValid</CODE> will
sometimes access the physical drive associated with a
volume for information if it is not already cached by the
operating system. Often, this can be a relatively slow
operation.
</DD></DL>
<P>
<A NAME="vfsJoinPaths"><HR><H4>vfsJoinPaths</H4></A>
<PRE>
        void <B>vfsJoinPaths</B>(
                vfsPath * path1,
                vfsPath * path2);
</PRE>

<DL><DD>
Joins <SAMP>path2</SAMP> to <SAMP>path1</SAMP>. The
resulting path is stored in <SAMP>path1</SAMP> and inherits
its path type (either <SAMP>vfsPATH_TYPE_FULL</SAMP>,
<SAMP>vfsPATH_TYPE_RELATIVE</SAMP>, or
<SAMP>vfsPATH_TYPE_NAME</SAMP>) from the original
<SAMP>path1</SAMP> . <SAMP>path2</SAMP> is destroyed by
this function. <CODE>vfsJoinPaths</CODE> is often used to
join a current directory with a relative path to build a
path to pass to <CODE><A HREF="vfs-x.html#vfsMakePathCanonical"><CODE>vfsMakePathCanonical</CODE></A></CODE>.
<P>
Sample Code: Using <CODE>vfsJoinPaths</CODE>

<BLOCKQUOTE>
<PRE>

/*
 * makeFullPathFromRelative() - Returns a full pathname from a
 *               path relative to the current
 *               working directory. Destroys
 *               the path 'relPath'.
 */

<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *makeFullPathFromRelative(<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *relPath) {
 <A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>     *curPath;

 curPath = <A HREF="vfs-x.html#vfsCloneWorkingDirPath"><CODE>vfsCloneWorkingDirPath</CODE></A>();
 vfsJoinPaths(curPath, relPath);

 return(curPath);
}

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsLink"><HR><H4>vfsLink</H4></A>
<PRE>
        void <B>vfsLink</B>(
                const vfsPath * old,
                const vfsPath * newLink);
</PRE>

<DL><DD>
Creates the symbolic link or alias <SAMP>newLink</SAMP>
that points to a file/directory referenced by the path
<SAMP>old</SAMP>.
</DD></DL>
<P>
<A NAME="vfsLockFile"><HR><H4>vfsLockFile</H4></A>
<PRE>
        vbool <B>vfsLockFile</B>(
                vfsFile * file);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if an advisory lock is obtained
for the entire contents of the file <SAMP>file</SAMP>. It
returns <SAMP>FALSE</SAMP> if an existing lock for this
file created by another process currently exists and the
file could not be locked. The lock remains in effect for
any additional data that is appended to the end of the
file. Equivalent to
<CODE><A HREF="vfs-x.html#vfsLockFileRange"><CODE>vfsLockFileRange</CODE></A></CODE><SAMP>(file</SAMP>,
<SAMP>0L</SAMP>, <SAMP>vfsLOCK_TO_END)</SAMP>.
</DD></DL>
<P>
<A NAME="vfsLockFileRange"><HR><H4>vfsLockFileRange</H4></A>
<PRE>
        vbool <B>vfsLockFileRange</B>(
                vfsFile * file,
                long offset,
                long numBytes);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if <CODE>vfsLockFileRange</CODE>
successfully locks the range of bytes in the file
<SAMP>file</SAMP> starting at <SAMP>offset</SAMP> and
extending <SAMP>numBytes</SAMP> bytes. It returns
<SAMP>FALSE</SAMP> if an existing lock created by another
process overlaps the requested lock region and the lock
operation could not be completed.
<P>
The File System Manager constant
<SAMP>vfsLOCK_TO_END</SAMP> is supported by
<CODE>vfsLockFileRange</CODE> as a legal value for
<SAMP>numBytes</SAMP>. This indicates that the lock is to
extend from <SAMP>offset</SAMP> to the end of the file.
Files locked using <SAMP>vfsLOCK_TO_END</SAMP> always locks
to the end of the file's contents even after new data is
appended to the file.
</DD></DL>
<P>
<A NAME="vfsMakeDir"><HR><H4>vfsMakeDir</H4></A>
<PRE>
        void <B>vfsMakeDir</B>(
                const vfsPath * path,
                vfsMode mode);
</PRE>

<DL><DD>
Creates an empty directory specified by the path
<SAMP>path</SAMP> and assigns it access mode
<SAMP>mode</SAMP>. By default, <CODE>vfsMakeDir</CODE>
creates current and parent directory references in the new
directory. <SAMP>mode</SAMP> can be created by inclusive
ORing any combination of the allowed constants. For a list
of constants, see <CODE><A HREF="vfs-x.html#vfsCreateFile"><CODE>vfsCreateFile</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsMakePathCanonical"><HR><H4>vfsMakePathCanonical</H4></A>
<PRE>
        void <B>vfsMakePathCanonical</B>(
                vfsPath * path);
</PRE>

<DL><DD>
Rebuilds the path <SAMP>path</SAMP> into its fully
canonical form by removing any references to parent and
current directories. <CODE>vfsMakePathCanonical</CODE>
canonicalizes relative as well as full paths. Relative
paths that have leading parent directory references are
only canonicalized to a certain extent because they are
relative to an unknown directory. (Use
<CODE><A HREF="vfs-x.html#vfsResolvePath"><CODE>vfsResolvePath</CODE></A></CODE> or <CODE><A HREF="vfs-x.html#vfsJoinPaths"><CODE>vfsJoinPaths</CODE></A></CODE>
with a subsequent call to <CODE>vfsMakePathCanonical</CODE>
to fully canonicalize a relative path if you know its
reference directory.) Table shows a list of sample returns
from this function, and Example shows an example of use.
  <P>
<CODE>vfsMakePathCanonical</CODE> is very useful if you are
storing pathnames for future reference or when you need to
accurately determine the list of parent path components.
  <P>
Sample Returns of Path Canonicalization
<DL>
<DT><B>Path</B>
<DD><B>Canonicalized Form</B>

<DT><SAMP>/dir1/dir2/dir3/../../filename</SAMP>
<DD><SAMP>/dir1/filename</SAMP>

<DT><SAMP>../../dir1/../../filename</SAMP>
<DD><SAMP>../../../filename</SAMP>

<DT><SAMP>/dir1/dir4/../dir5/..</SAMP>
<DD><SAMP>/dir1</SAMP>

<DT><SAMP>/../../../..</SAMP>
<DD><SAMP>/</SAMP>

<DT><SAMP>/dir1/dir2/./filename</SAMP>
<DD><SAMP>/dir1/dir2/filename</SAMP>

<DT><SAMP>filename</SAMP>
<DD><SAMP>filename</SAMP>

<DT><SAMP>../../dir1/dir2/dir3/filename</SAMP>
<DD><SAMP>../../dir1/dir2/dir3/filename</SAMP>
</DL>

<P>
Note that the root directory has itself as a parent
directory.
  
<P>
Sample Code: Using <CODE>vfsMakePathCanonical</CODE>

<BLOCKQUOTE>
<PRE>

/*
 * makeCanonicalPathFromRelative() - Returns a fully
 *                  canonicalized pathname
 *                  relative to the current
 *                  current working. Destroys
 *                  the path 'relPath'.
 */
<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *makeFullPathFromRelative(<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *relPath) {

 <A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *curPath;

 curPath = <A HREF="vfs-x.html#vfsCloneWorkingDirPath"><CODE>vfsCloneWorkingDirPath</CODE></A>();
 <A HREF="vfs-x.html#vfsJoinPaths"><CODE>vfsJoinPaths</CODE></A>(curPath, relPath);
 vfsMakePathCanonical(curPath);

 return(curPath);
}

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsNextVolumeIterator"><HR><H4>vfsNextVolumeIterator</H4></A>
<PRE>
        int <B>vfsNextVolumeIterator</B>(
                vfsVolumeIterator ** iterator);
</PRE>

<DL><DD>
Performs the next iteration of the volume list and
initializes the iterator <SAMP>iterator</SAMP> with the
next iterator on the list. Returns <SAMP>TRUE</SAMP> if the
iterator is initialized, <SAMP>FALSE</SAMP> if there are no
more volume iterators in the list. Successive calls to
<CODE>vfsNextVolumeIterator</CODE> should only be initiated
after <CODE><A HREF="vfs-x.html#vfsInitVolumeIterator"><CODE>vfsInitVolumeIterator</CODE></A></CODE> has been called to
initialize the file system volume list and set up the
iteration.
<P>
Sample Code: Using <CODE>vfsNextVolumeIterator</CODE>

<BLOCKQUOTE>
<PRE>

/*
 * isValidVolume() - Function to determine whether a volume is
 *          valid (i.e., known by the operating system.)
 */
isValidVolume(register <A HREF="vfs-x.html#vfsVolume"><CODE>vfsVolume</CODE></A> *volume)
{
 <A HREF="vfs-x.html#vfsVolumeIterator"><CODE>vfsVolumeIterator</CODE></A>   iterator;

 register <A HREF="vfs-x.html#vfsVolume"><CODE>vfsVolume</CODE></A>  *tmpVolume;

 <A HREF="vfs-x.html#vfsInitVolumeIterator"><CODE>vfsInitVolumeIterator</CODE></A>(&iterator);

 while (vfsNextVolumeIterator(&iterator)) {
  tmpVolume = <A HREF="vfs-x.html#vfsGetVolumeIteratorVolume"><CODE>vfsGetVolumeIteratorVolume</CODE></A>(iterator);
#ifdef vportNEED_DOS_FILESYSTEM /* Everything treated as upper case */
  if (<A HREF="vfs-x.html#vfsCompareVolumeCaseInsensitive"><CODE>vfsCompareVolumeCaseInsensitive</CODE></A>(tmpVolume, volume) == 0)
#else  /* Covers any other operating system that "honors" case.  */
  if (<A HREF="vfs-x.html#vfsCompareVolume"><CODE>vfsCompareVolume</CODE></A>(tmpVolume, volume) == 0)
#endif
   return(TRUE);
 }
 <A HREF="vfs-x.html#vfsDestroyVolumeIterator"><CODE>vfsDestroyVolumeIterator</CODE></A>(&iterator);
 return(FALSE);
}

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsOpenDir"><HR><H4>vfsOpenDir</H4></A>
<PRE>
        vfsDir * <B>vfsOpenDir</B>(
                const vfsPath * path);
</PRE>

<DL><DD>
Opens a directory specified by <SAMP>path</SAMP> and
returns a directory structure used for reading the
directory contents. Opens the file and directory names
in that particular directory. 
<P>
<CODE>vfsOpenDir</CODE> sets
the read pointer to the first file/directory name in the
directory. Use <CODE><A HREF="vfs-x.html#vfsReadDir"><CODE>vfsReadDir</CODE></A></CODE> to successively read
the name entries of the directory.
</DD></DL>
<P>
<A NAME="vfsOpenFile"><HR><H4>vfsOpenFile</H4></A>
<PRE>
        vfsFile * <B>vfsOpenFile</B>(
                const vfsPath * fileName,
                int accessType);
</PRE>

<DL><DD>
Returns a pointer to the open file <SAMP>fileName</SAMP>
with the open mode specified in <SAMP>accessType</SAMP>.
The file pointer that is returned can be used subsequently
as an argument to File System Manager I/O calls such as:

<ul>
<li><CODE><A HREF="vfs-x.html#vfsReadFile"><CODE>vfsReadFile</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsWriteFile"><CODE>vfsWriteFile</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsFlushFileBuffer"><CODE>vfsFlushFileBuffer</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsCloseFile"><CODE>vfsCloseFile</CODE></A></CODE>
</ul>

<P>
<SAMP>accessType</SAMP> can have one of the following
values:
 
<DL>
<DT><CODE>vfsOPEN_APPEND</CODE>
<DD>Opened for reading and writing to the end of the file.
This mode guarantees that all writes take place starting
from the end of the file. (You can seek anywhere in the
file to read. However, any write automatically causes a
seek to the end of the file before the write operation.) 

<DT><CODE>vfsOPEN_READ_ONLY</CODE>
<DD>Opened for reading only. 

<DT><CODE>vfsOPEN_READ_WRITE</CODE>
<DD>Opened for reading and writing. 

<DT><CODE>vfsOPEN_WRITE_TRUNCATE</CODE>
<DD>Opened for reading and writing and the file was
truncated to zero length when it was opened. 
</DL>

<P>
In addition, any of the following flags may by ORed to
modify the access type:

<DL>
<DT><CODE>vfsOPEN_TEXT_MODE</CODE>
<DD>For systems which support both and text and binary modes
for opening files, this mode indicates to the File System
Manager to use text mode. The default behavior for opening
files is binary mode, in which all characters are read in as
they appear in the file, and written to the file as they
appear in memory. The text mode is actually implemented by
the system on some platforms, but is a compatibility layer
added by Galaxy on others. Using this mode to read and
write text data will ensure that all strings read from a
file will contain <CODE>\n</CODE> as the newline character.
However, this newline will be translated to or from the
appropriate line-termination sequence when it is written to
or read from the file.  On platforms which do not
distinguish between text and data modes, this flag has no
effect.

<DT><CODE>vfsOPEN_NOT_CACHED</CODE>
<DD>This flag indicates to the File System Manager that this
file may not be temporarily closed and stored in the cache
if the File System Manager runs out of file pointers to
allocate. One would typically use this flag for ``special''
files, where the file's context cannot be saved on close and
restored on open. For example, on Unix, if the file referred
to a a hardware device of some sort, it might not be
possible to save the exact state of the device at the time
it was to be put in the cache. Another use of the flag might
be for a file which is doing some sort of asynchronous I/O,
and thus must be left open.

<DT><CODE>vfsOPEN_DENY_READ</CODE>

<DT><CODE>vfsOPEN_DENY_WRITE</CODE>

<DT><CODE>vfsOPEN_DENY_READ_WRITE</CODE>
<DD>For operating systems that have special file sharing modes or
"deny bits", the Galaxy default is to allow sharing for both
reading and writing.  To turn off one or the other or both,
OR one of these flags into the access type.
</DL>

<P>
Sample Code: Using <CODE>vfsOpenFile</CODE>
<PRE>

/*
 * Open the application executable file for reading only
 * and do not allow the File System Manager to include it
 * in its file cache.
 */
<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *path;

<A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A> *file;

path = <A HREF="vfs-x.html#vfsCloneAppDirPath"><CODE>vfsCloneAppDirPath</CODE></A>();
<A HREF="vfs-x.html#vfsAppendPath"><CODE>vfsAppendPath</CODE></A>(path, <A HREF="vfs-x.html#vfsGetAppName"><CODE>vfsGetAppName</CODE></A>(), NULL);
file = vfsOpenFile(path, (vfsOPEN_READ_ONLY | vfsOPEN_NOT_CACHED));
/*
 * Process information read from the application executable.
 */
.
.
.
<A HREF="vfs-x.html#vfsCloseFile"><CODE>vfsCloseFile</CODE></A>(file)
<A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A>(path);
</PRE>
</DD></DL>
<P>
<A NAME="vfsOpenFileLocalized"><HR><H4>vfsOpenFileLocalized</H4></A>
<PRE>
        vfsFile * <B>vfsOpenFileLocalized</B>(
                const vfsPath * fileName,
                int accessType);
</PRE>

<DL><DD>
Opens a file and returns a pointer to a <A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A> structure
referencing the file. This function will try to open a
localized version of the file first, based on the user's
environment language preference (platform-dependent).
Typically, a component corresponding to the string
``locale'' is appended to the file path, as well as one
corresponding to the language preference, and access to
this localized file path is attempted. In case of failure,
a regular vfsOpenFile call on the original file path is
executed.
</DD></DL>
<P>
<A NAME="vfsOpenFileStream"><HR><H4>vfsOpenFileStream</H4></A>
<PRE>
        void <B>vfsOpenFileStream</B>(
                vfsFile * file,
                const vfsPath * fileName,
                int accessType);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsPathFromFile"><HR><H4>vfsPathFromFile</H4></A>
<PRE>
        vfsPath * <B>vfsPathFromFile</B>(
                vfsFile * file);
</PRE>

<DL><DD>
Returns a dynamically allocated full pathname to the open
file referenced by the file. For example, if you had
opened the file <SAMP>'foo'</SAMP> in the
<SAMP>'/usr/tmp'</SAMP> directory, the function would
return the <SAMP>vfsPath '/usr/tmp/foo'</SAMP>. Refer to the 
following code sample for more information. 
<P>
<CODE>vfsPathFromFile</CODE> does not return the
canonical form of the path. It may have relative
references in it, such as <SAMP>/usr/tmp/../tmp/foo</SAMP>.
The path may be made canonical by <CODE><A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A></CODE>. 
The path returned must be deleted.
<P>
Sample Code: Using <CODE><A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A></CODE>

<BLOCKQUOTE>
<PRE>

{
  // Get the full pathname of a file by opening it.
  // (Not the optimal approach--used for illustration
  // purposes only.)

  <A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A>       *file;
  vfsPath       *namePath,
                *fullPath;

  namePath = new vfsPath;
  namePath->SetScribed( <A HREF="vchar-x.html#vcharScribeLiteral"><CODE>vcharScribeLiteral</CODE></A>("filename"));
  file     = <A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A>(namePath, vfsOPEN_READ_ONLY);
  fullPath = file->GetPath();
  .
  .
  .
  delete fullPath;
  delete namePath;
  file->Close();
}

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsPathFromStr"><HR><H4>vfsPathFromStr</H4></A>
<PRE>
        vfsPath * <B>vfsPathFromStr</B>(
                const vchar * path);
</PRE>

<DL><DD>
Returns a dynamically allocated path that is converted from
the operating system-dependent string <SAMP>str</SAMP> in
<CODE>vfsPathFromStr</CODE>. The Galaxy client program is
responsible for destroying the returned path with
<CODE><A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsPathFromStrScribed"><HR><H4>vfsPathFromStrScribed</H4></A>
<PRE>
        vfsPath * <B>vfsPathFromStrScribed</B>(
                vscribe * pathScribe);
</PRE>

<DL><DD>
Returns a dynamically allocated path that is converted from
the <SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP> string written out by the scribe
<SAMP>pathScribe</SAMP> in
<CODE>vfsPathFromStrScribed</CODE>. The Galaxy client
program is responsible for destroying the returned path
with <CODE><A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A></CODE>.
<P>
Sample Code: Using <CODE>vfsPathFromStr</CODE> and
<CODE>vfsPathFromStrScribed</CODE>

<BLOCKQUOTE>
<PRE>
vfsPath *path;
<A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A>  *tmpStr;

tmpStr = <A HREF="vchar-x.html#vcharCopyScribed"><CODE>vcharCopyScribed</CODE></A>(<A HREF="vchar-x.html#vcharScribeLiteral"><CODE>vcharScribeLiteral</CODE></A>("/dir/file"));
path  = vfsPathFromStr(tmpStr);
<A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A>(tmpStr);

/*
 * Use vfsPathFromStrScribed() to perform the same task.
 */
<A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A>(path);
path =vfsPathFromStrScribed(<A HREF="vchar-x.html#vcharScribeLiteral"><CODE>vcharScribeLiteral</CODE></A>("/dir/file"));

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsPathToStr"><HR><H4>vfsPathToStr</H4></A>
<PRE>
        vstr * <B>vfsPathToStr</B>(
                const vfsPath * path);
</PRE>

<DL><DD>
Returns a dynamically allocated string that represents the
operating system's format for the path <SAMP>path</SAMP>.
This function is useful for displaying pathnames. The
Galaxy client program is responsible for destroying the
string with <CODE><A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsPopDir"><HR><H4>vfsPopDir</H4></A>
<PRE>
        void <B>vfsPopDir</B>();
</PRE>

<DL><DD>
Pops (removes) the top level directory from the File System
Manager directory stack and makes it the current working
directory. The directory stack is especially useful for
operations that temporarily traverse directories or folders
or traverse them recursively, because it allows you to
backtrack easily to the original working directory.
  <P>
Sample Code: Using <CODE>vfsPopDir</CODE>

<BLOCKQUOTE>
<PRE>

/*
 * Function to list the files in every parent directory
 * of a path. (Called recursively.)
 */
void listParentDirs(<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *dir) {

 static <A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>    *parent = NULL;
 <A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>        *current;
 <A HREF="vfs-x.html#vfsDir"><CODE>vfsDir</CODE></A>        *tmpDir;
 <A HREF="vstr-x.html#vstr"><CODE>vstr</CODE></A>         *tmpName;

 if (!parent) /* Initialize parent path for <A HREF="vfs-x.html#vfsPushDir"><CODE>vfsPushDir</CODE></A>() */
  parent = <A HREF="vfs-x.html#vfsPathFromStr"><CODE>vfsPathFromStr</CODE></A>(<A HREF="vfs-x.html#vfsGetParentPathElementString"><CODE>vfsGetParentPathElementString</CODE></A>());

 /*
  * If this is the root directory, no sense going any
  * further up...
  */

 if (<A HREF="vfs-x.html#vfsGetPathElementCount"><CODE>vfsGetPathElementCount</CODE></A>(dir) == 1)
  return;
 <A HREF="vfs-x.html#vfsPushDir"><CODE>vfsPushDir</CODE></A>(parent);
 current = <A HREF="vfs-x.html#vfsCloneWorkingDirPath"><CODE>vfsCloneWorkingDirPath</CODE></A>();
 tmpDir = <A HREF="vfs-x.html#vfsOpenDir"><CODE>vfsOpenDir</CODE></A>(current);
 displayCurrentDirectoryName();        /* Fictitious */
 while (tmpName = <A HREF="vfs-x.html#vfsReadDir"><CODE>vfsReadDir</CODE></A>(tmpDir))
  displayName(tmpName);            /* Fictitious */
 <A HREF="vfs-x.html#vfsCloseDir"><CODE>vfsCloseDir</CODE></A>(tmpDir);
 listParentDirs(current);
 <A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A>(current);
 vfsPopDir();

 return;
}

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsPrintF"><HR><H4>vfsPrintF</H4></A>
<PRE>
        void <B>vfsPrintF</B>(
                vfsFile * file,
                const char * formatLiteral,
                ... arg3);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsPushDir"><HR><H4>vfsPushDir</H4></A>
<PRE>
        void <B>vfsPushDir</B>(
                vfsPath * path);
</PRE>

<DL><DD>
Pushes the current working directory onto the File System
Manager directory stack and changes to <SAMP>path</SAMP>
the path. For example, if your current working directory is
``<SAMP>/dir/dir1</SAMP>'' and you called
<CODE>vfsPushDir</CODE> with
``<SAMP>/dir2/dir3/dir4</SAMP>'' as the path argument, your
new working directory would be
``<SAMP>/dir2/dir3/dir4</SAMP>'' and ``
<SAMP>/dir/dir1</SAMP>'' would be pushed on the directory
stack. (Use <CODE><A HREF="vfs-x.html#vfsPopDir"><CODE>vfsPopDir</CODE></A></CODE> to pop a directory from
the stack and make it the current working directory.)
  <P>
The directory stack is especially useful for operations
that temporarily traverse directories or folders, because
it allows you to backtrack easily to the original working
directory.
  <P>
Sample Code: Using vfsPushDir

<BLOCKQUOTE>
<PRE>

/*
 * Function to create a file relative to the
 * parent directory
 */
void createFileInParentDir(<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *fileToCreate, <A HREF="vfs-x.html#vfsMode"><CODE>vfsMode</CODE></A> mode) {

 <A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *parent;

 parent = <A HREF="vfs-x.html#vfsPathFromStr"><CODE>vfsPathFromStr</CODE></A>(<A HREF="vfs-x.html#vfsGetParentPathElementString"><CODE>vfsGetParentPathElementString</CODE></A>());
 vfsPushDir(parent); /* Go to the parent directory */
 <A HREF="vfs-x.html#vfsCreateFile"><CODE>vfsCreateFile</CODE></A>(fileToCreate, mode);
 <A HREF="vfs-x.html#vfsPopDir"><CODE>vfsPopDir</CODE></A>();    /* Go back to original directory */
 <A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A>(parent);

 return;
}
</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsPutChar"><HR><H4>vfsPutChar</H4></A>
<PRE>
        vchar <B>vfsPutChar</B>(
                vchar c,
                vfsFile * file);
</PRE>

<DL><DD>
Returns the character <SAMP>c</SAMP> after it is written to
the file <SAMP>file</SAMP>. <CODE>vfsPutChar</CODE> is
relatively efficient and does not perform physical writes
each time it is called. Successive calls cause it to place
characters in the file's intermediate buffer and only write
out the entire buffer when it is full.
<P>
<b>Note</b> that <CODE><A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A></CODE> is optimized for the case
<SAMP>sizeof(<A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A>) == sizeof(char)</SAMP>, but also
accommodates multi-byte <SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP> values.
</DD></DL>
<P>
<A NAME="vfsRawReadFile"><HR><H4>vfsRawReadFile</H4></A>
<PRE>
        long <B>vfsRawReadFile</B>(
                vbyte * buffer,
                long size,
                vfsFile * file);
</PRE>

<DL><DD>
Returns the number of bytes read (using unbuffered file
input) from the file <SAMP>file</SAMP>.
<CODE>vfsRawReadFile</CODE> reads <SAMP>size</SAMP> bytes
from the file and places them in the buffer pointed to by
<SAMP>buffer</SAMP>. It returns 0 when a read operation
begins at end of file (EOF).
    <P>
<CODE>vfsRawReadFile</CODE> does not modify the contents of
the file in any way. However, after a read operation, the
file pointer is set to an offset one byte past the last
byte read. This offset is valid for both unbuffered I/O and
buffered I/O.
    <P>
<CODE>vfsRawReadFile</CODE> is implemented so it does not
interfere with buffered file I/O using
<CODE><A HREF="vfs-x.html#vfsReadFile"><CODE>vfsReadFile</CODE></A></CODE> and <CODE><A HREF="vfs-x.html#vfsWriteFile"><CODE>vfsWriteFile</CODE></A></CODE>. The
only side effect of <CODE>vfsRawReadFile</CODE> is to
invalidate the contents of the target file's read buffer
and flush the contents of its output buffer before
executing the read operation.
    <P>
You should only use raw file I/O when you want to gain
direct access to a file, network connection, or device. In
most cases, it is more efficient to use the File System
Manager's default buffered file I/O. Raw file I/O reads and
writes directly to the target file, whereas buffered file
I/O uses intermediate buffers for reading and writing to
reduce the number of physical reads and writes to a device
or network connection effectively caching file contents.
Buffered file I/O uses the operating system's optimal
buffer size for reading and writing and generally
guarantees the minimum amount of physical access to slow
secondary storage, like disk drives and CD-ROMs.
    <P>
As a final note, remember that raw reads and writes do not
guarantee real time physical access to files; a feature
critical for some types of transaction processing. Many
operating systems keep an in-memory buffer cache of disk
blocks for performance reasons which may be used in a read
operation.
    <P>
Sample Code: Using <CODE>vfsRawReadFile</CODE>

<BLOCKQUOTE>
<PRE>

/*
 * rawCopyFile() - Function to copy a file using raw I/O.
 *                 Return TRUE if copy is successful,
 *                 FALSE if it is not. (Normal production
 *                 code would handle errors more gracefully.)
 */

vbool rawCopyFile(<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *fromPath, <A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *toPath) {

  register <A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A>      *readFile  = (<A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A> *) NULL,
                        *writeFile = (<A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A> *) NULL;

  register long numBytes;

  /*
   * Use the stack for the copy buffer (use
   * vfsIO_BUFFER_SIZE for the optimal system
   * buffer size--very important for efficient raw
   * file I/O.)
   */

  vbyte   copyBuffer[vfsIO_BUFFER_SIZE];

  vexWITH_HANDLING {
    readFile  = <A HREF="vfs-x.html#vfsOpenFile"><CODE>vfsOpenFile</CODE></A>(fromPath, vfsOPEN_READ_ONLY);
    /*
     * The vfsOPEN_WRITE_TRUNCATE open mode will also
     * create the file if it does not already exist.
     */
    writeFile = <A HREF="vfs-x.html#vfsOpenFile"><CODE>vfsOpenFile</CODE></A>(toPath, vfsOPEN_WRITE_TRUNCATE);
    /*
     * Read the file into the buffer using bytes as the
     * reference size.
     */
    while ((numBytes = vfsRawReadFile(copyBuffer, 
                          vfsIO_BUFFER_SIZE,readFile)) != 0){
     <A HREF="vfs-x.html#vfsRawWriteFile"><CODE>vfsRawWriteFile</CODE></A>(copyBuffer, numBytes, writeFile);
    }
  } vexON_exception {
    if (readFile)
      /*
       * Failed opening writeFile, or during I/O.
       */
      <A HREF="vfs-x.html#vfsCloseFile"><CODE>vfsCloseFile</CODE></A>(readFile);
    if (writeFile)
      /*
       * Failed during I/O.
       */
      <A HREF="vfs-x.html#vfsCloseFile"><CODE>vfsCloseFile</CODE></A>(writeFile);
    /*
     * A more normal error handler would probably 
     * propagate the exception up the handler chain. Here
     * just return FALSE because the operation failed.
     */
    return(FALSE);
  } vexEND_HANDLING;

  <A HREF="vfs-x.html#vfsCloseFile"><CODE>vfsCloseFile</CODE></A>(readFile);
  <A HREF="vfs-x.html#vfsCloseFile"><CODE>vfsCloseFile</CODE></A>(writeFile);
  return(TRUE);
}
</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsRawWriteFile"><HR><H4>vfsRawWriteFile</H4></A>
<PRE>
        long <B>vfsRawWriteFile</B>(
                vbyte * buffer,
                long size,
                vfsFile * file);
</PRE>

<DL><DD>
Returns the number of bytes written (using unbuffered file
output) to the file <SAMP>file</SAMP>.
<CODE>vfsRawWriteFile</CODE> writes <SAMP>size</SAMP> bytes
to the file from the buffer pointed to by
<SAMP>buffer</SAMP>.
    <P>
<CODE>vfsRawWriteFile</CODE> sets the file pointer to an
offset one byte past the last byte written. This offset is
valid for both unbuffered I/O and buffered I/O.
    <P>
<CODE>vfsRawWriteFile</CODE> is implemented so it does not
interfere with buffered file I/O using
<CODE><A HREF="vfs-x.html#vfsReadFile"><CODE>vfsReadFile</CODE></A></CODE> and <CODE><A HREF="vfs-x.html#vfsWriteFile"><CODE>vfsWriteFile</CODE></A></CODE>. The
only side effect of <CODE>vfsRawWriteFile</CODE> is to
invalidate the contents of the target file's read buffer
and flush the contents of its output buffer before
executing the write operation.
    <P>
You should only use raw file I/O when you want to gain
direct access to a file, network connection, or device. In
most cases it is more efficient to use the File System
Manager's default buffered file I/O. Raw file I/O reads and
writes directly to the target file, whereas buffered file
I/O uses intermediate buffers for reading and writing to
reduce the number of physical reads and writes to a device
or network connection effectively caching file contents.
Buffered file I/O uses the operating system's optimal
buffer size for reading and writing and generally
guarantees the minimum amount of physical access to slow
secondary storage like disk drives and CD-ROMs.
    <P>
As a final note, remember that raw reads and writes do not
guarantee real time physical access to files; a feature
critical for some type of transaction processing. Many
operating systems keep an in-memory buffer cache of disk
blocks for performance reasons that may be used as the
initial target of a write operation.
    <P>
Sample Code: Using <CODE>vfsRawWriteFile</CODE> 

<BLOCKQUOTE>
<PRE>
/*
 * rawWriteStringAt() - Function to write out a string at a
 *                      given location in a file using raw
 *                      file output. Return TRUE it the string
 *                      is written out, FALSE if not. (Note:
 *                      production code would certainly be
 *                      more careful handling errors.)
 */

vbool rawWriteStringAt(<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *path, <A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A> *str, long offset) {

  <A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A>              *file = (<A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A> *) NULL;
  register size_t       numBytes;

  numBytes = <A HREF="vstr-x.html#vstrGetSize"><CODE>vstrGetSize</CODE></A>(str);
  vexWITH_HANDLING {
    /*
     * Open the file and seek to the designated spot
     */
    file = <A HREF="vfs-x.html#vfsOpenFile"><CODE>vfsOpenFile</CODE></A>(fromPath, vfsOPEN_READ_WRITE);
    <A HREF="vfs-x.html#vfsSeekFile"><CODE>vfsSeekFile</CODE></A>(file, offset, vfsSEEK_FROM_START);
    /*
     * Write out the string buffer.
     */
    vfsRawWriteFile(str, numBytes, file);
  } vexON_exception {
    if (file)
      /* 
       * <A HREF="vfs-x.html#vfsSeekFile"><CODE>vfsSeekFile</CODE></A>() or vfsRawWriteFile() failed.
       */
      <A HREF="vfs-x.html#vfsCloseFile"><CODE>vfsCloseFile</CODE></A>(file);
    /*
     * A more normal error handler would probably
     * propagate the exception of the handler chain.
     * Here just return FALSE because the operation failed.
     */
    return(FALSE);
  } vexEND_HANDLING;

  <A HREF="vfs-x.html#vfsCloseFile"><CODE>vfsCloseFile</CODE></A>(file);
  return(TRUE);
}
</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsReadDir"><HR><H4>vfsReadDir</H4></A>
<PRE>
        vstr * <B>vfsReadDir</B>(
                vfsDir * dir);
</PRE>

<DL><DD>
Returns a pointer to a dynamically allocated string
representing the current entry in the directory
<SAMP>dir</SAMP> and advances the current entry pointer to
the next entry. It returns <SAMP>NULL</SAMP> if no other
entries are available in the directory. The user is
responsible for destroying the returned string with
<CODE><A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A></CODE>.

<P>
Sample Code: Using <CODE>vfsReadDir</CODE>

<BLOCKQUOTE>
<PRE>

<A HREF="vfs-x.html#vfsDir"><CODE>vfsDir</CODE></A>          *openDir;
<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>         *rootPath;
<A HREF="vstr-x.html#vstr"><CODE>vstr</CODE></A>            *dirEntry;

/*
 * Read all the entries for the root volume
 */
rootPath = <A HREF="vfs-x.html#vfsCreateRootPath"><CODE>vfsCreateRootPath</CODE></A>();
openDir  = <A HREF="vfs-x.html#vfsOpenDir"><CODE>vfsOpenDir</CODE></A>(rootPath);
while ((dirEntry = vfsReadDir(openDir)) != (<A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A> *) NULL) {
  displayName(dirEntry); /* displayName() is fictitious */
  <A HREF="vstr-x.html#vstrDestroy"><CODE>vstrDestroy</CODE></A>(dirEntry);
}
<A HREF="vfs-x.html#vfsCloseDir"><CODE>vfsCloseDir</CODE></A>(openDir);
<A HREF="vfs-x.html#vfsDestroyPath"><CODE>vfsDestroyPath</CODE></A>(rootPath);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsReadFile"><HR><H4>vfsReadFile</H4></A>
<PRE>
        long <B>vfsReadFile</B>(
                vbyte * ptr,
                long size,
                long nitems,
                vfsFile * file);
</PRE>

<DL><DD>
Reads <SAMP>nitems</SAMP> number of items of
<SAMP>size</SAMP> bytes from the file <SAMP>file</SAMP>
into the buffer <SAMP>ptr</SAMP>. <SAMP>ptr</SAMP> is a
pointer to the target buffer; <SAMP>size</SAMP> is the
stated item size (in bytes); <SAMP>nitems</SAMP> is the
number of items to be read; and <SAMP>file</SAMP> is the
file containing the items to be read. It returns the number
of items actually read. It returns 0 if <SAMP>size</SAMP>
or <SAMP>nitems</SAMP> is zero or if the read operation
reached end of file (EOF).
    <P>
<CODE>vfsReadFile</CODE> does not modify the contents of
the file in any way. However, after a read operation, the
file pointer is set to an offset one byte past the last
byte read.
    <P>
Sample Code: Using <CODE>vfsReadFile</CODE>

<BLOCKQUOTE>
<PRE>

/*
 * copyFile() - function to copy a file. Return TRUE
 *              if the file is successfully copied,
 *              FALSE if it is not. (Normal production
 *              code would handle errors more gracefully.)
 */

vbool copyFile(<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *fromPath, <A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *toPath) {

  register <A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A>      *readFile  = (<A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A> *) NULL,
                        *writeFile = (<A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A> *) NULL;
  register long numBytes;

  /*
   * Use the stack for the copy buffer (use
   * vfsIO_BUFFER_SIZE for the optimal system
   * buffer size.)
   */
  vbyte copyBuffer[vfsIO_BUFFER_SIZE];

  vexWITH_HANDLING {
    readFile  = <A HREF="vfs-x.html#vfsOpenFile"><CODE>vfsOpenFile</CODE></A>(fromPath, vfsOPEN_READ_ONLY);
    /*
     * The vfsOPEN_WRITE_TRUNCATE open mode will also
     * create the file if it does not already exist.
     */
    writeFile = <A HREF="vfs-x.html#vfsOpenFile"><CODE>vfsOpenFile</CODE></A>(toPath, vfsOPEN_WRITE_TRUNCATE);
    /*
     * Read the file into the buffer using bytes as the
     * reference size.
     */
    while ((numBytes = vfsReadFile(copyBuffer, sizeof(vbyte),
                       vfsIO_BUFFER_SIZE, readFile)) != 0) {
      <A HREF="vfs-x.html#vfsWriteFile"><CODE>vfsWriteFile</CODE></A>(copyBuffer, sizeof(vbyte), numBytes, writeFile);
    }
  } vexON_exception {
    if (readFile)
      /*
       * Failed opening writeFile, or during I/O.
       */
      <A HREF="vfs-x.html#vfsCloseFile"><CODE>vfsCloseFile</CODE></A>(readFile);
    if (writeFile)
      /*
       * Failed during I/O.
       */
      <A HREF="vfs-x.html#vfsCloseFile"><CODE>vfsCloseFile</CODE></A>(writeFile);
    /*
     * A more normal error handler would probably
     * propagate the exception up the handler chain. Here
     * just return FALSE because the operation failed.
     */
    return(FALSE);
  } vexEND_HANDLING;
  <A HREF="vfs-x.html#vfsCloseFile"><CODE>vfsCloseFile</CODE></A>(readFile);
<A HREF="vfs-x.html#vfsCloseFile"><CODE>vfsCloseFile</CODE></A>(writeFile);

  return(TRUE);
}

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsReadString"><HR><H4>vfsReadString</H4></A>
<PRE>
        vchar * <B>vfsReadString</B>(
                vchar * buffer,
                int bufSize,
                vfsFile * file);
</PRE>

<DL><DD>
Returns a pointer to <SAMP>buffer</SAMP> containing the
string read from the file <SAMP>file</SAMP>. It returns a
<SAMP>NULL</SAMP> pointer if nothing is read because the
file pointer was at end-of-file (<SAMP>EOF</SAMP>) or if
<SAMP>bufSize</SAMP> equals zero. The file is read from the
current file position until <SAMP>bufSize</SAMP> - 1 bytes
have been read, a <SAMP>NEWLINE</SAMP> character is
reached, or <SAMP>EOF</SAMP> is reached. If the string is
terminated by a <SAMP>NEWLINE</SAMP> character, the
<SAMP>NEWLINE</SAMP> is appended to the end of the string.
A <SAMP>NEWLINE</SAMP> character is not be appended if the
string is terminated by <SAMP>EOF</SAMP>, or if it is
greater than size - 1 bytes in length.
    <P>
<CODE>vfsReadString</CODE> is designed to operate
identically to the C library function <SAMP>fgets</SAMP>.
This includes the behavior that allows
<CODE>vfsReadString</CODE> to read in a string that
contains <SAMP>ASC_NUL</SAMP> characters. In this case, the
buffer contains the full contents of the read operation,
but the ``string'' only extends until the first null
character.
    <P>
<b>Note</b> that <CODE>vfsReadString</CODE> is optimized for the case
<SAMP>sizeof(<A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A>) == sizeof(char)</SAMP>, but also
accommodates multi-byte <SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP> values.
<CODE>vfsReadString</CODE> is also optimized for line sizes
of 256 bytes or less, however, it will handle lines of any
size.
<P>

Sample Code: Using <CODE>vfsReadString</CODE>

<BLOCKQUOTE>
<PRE>

/*
 *  copyFileLineByLine() - Copies the contents of one open file to
 *                         another using vfsReadString to read a
 *                         line at a time. (Note:  this function
 *                         assumes that the data is line-oriented,
 *                         i.e. records terminated by a NEWLINE.)
 */
void copyFileLineByLine(<A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A> *sourceFile, <A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A> *destinationFile)
{

  <A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A>        buf[82];    /* In this case we "know" that lines are no
                              longer than 80 characters. (Note that we
                              use two extra characters in the buffer
for
                              the NEWLINE character and the terminating
                              ASC_NUL character.) */

  while(vfsReadString(buf, 82, sourceFile)) {
    <A HREF="vfs-x.html#vfsWriteString"><CODE>vfsWriteString</CODE></A>(buf, destinationFile);
    <A HREF="vfs-x.html#vfsPutChar"><CODE>vfsPutChar</CODE></A>(ASC_LF, destinationFile); /* Terminate with a NEWLINE */
  }
  return;
}

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsRemove"><HR><H4>vfsRemove</H4></A>
<PRE>
        void <B>vfsRemove</B>(
                const vfsPath * path);
</PRE>

<DL><DD>
Removes the file <SAMP>path</SAMP> from the file system.
<CODE>vfsRemove</CODE> does not allow you to remove
directories from a volume or file system. Use
<CODE><A HREF="vfs-x.html#vfsRemoveDir"><CODE>vfsRemoveDir</CODE></A></CODE> for this purpose.
</DD></DL>
<P>
<A NAME="vfsRemoveDir"><HR><H4>vfsRemoveDir</H4></A>
<PRE>
        void <B>vfsRemoveDir</B>(
                const vfsPath * path);
</PRE>

<DL><DD>
Removes the directory referenced by <SAMP>path</SAMP> from
the file system or volume. <CODE>vfsRemoveDir</CODE> only
removes directories that are empty. (Empty is defined as
having no file or directory entries except for references
to the current and parent directories.)
</DD></DL>
<P>
<A NAME="vfsRename"><HR><H4>vfsRename</H4></A>
<PRE>
        void <B>vfsRename</B>(
                const vfsPath * old,
                const vfsPath * newPath);
</PRE>

<DL><DD>
Assigns to <SAMP>old</SAMP> (which can be either a file or
a directory), a new name <SAMP>newPath</SAMP>, effectively
moving the file or directory. If <SAMP>newPath</SAMP>
exists, it is first removed. If <SAMP>newPath</SAMP> refers
to a directory, it must be empty (that is, contain nothing
other than parent and child directory references). Write
access permission is required for the directories that hold
both <SAMP>old</SAMP> and <SAMP>newPath</SAMP>. If a
<CODE>vfsRename</CODE> call results in relocating a
directory, write permission is required in the directory
referenced by <SAMP>old</SAMP> because its parent
directory reference must be updated.
  <P>
If the path <SAMP>newPath</SAMP> resolves to a symbolic
link or alias, the link itself is renamed, not the actual
file or directory to which it points.
</DD></DL>
<P>
<A NAME="vfsReserveFileChannels"><HR><H4>vfsReserveFileChannels</H4></A>
<PRE>
        void <B>vfsReserveFileChannels</B>(
                int numChannels);
</PRE>

<DL><DD>
Reserves <SAMP>numChannels</SAMP> number of operating
system file channels (descriptors) for use by the Galaxy
client program. <CODE>vfsReserveFileChannels</CODE> is used
to set aside file channels for special client I/O needs
that are not handled by the File System Manager. Examples
of this type of I/O requirement might include unbuffered
access to devices, memory-mapped file I/O and special
transaction processing interfaces. In the normal course of
application construction, the Galaxy File System Manager
should provide all of the I/O primitives and performance
that you need. Normally, applications that use
special-purpose I/O are non-portable, so be wary of your
requirement to do so.
    <P>
<CODE>vfsReserveFileChannels</CODE> is used to keep the
client program's special I/O needs in sync with the File
System Manager's open file caching mechanism. If you do not
use <CODE>vfsReserveFileChannels</CODE> and
<CODE><A HREF="vfs-x.html#vfsSurrenderFileChannels"><CODE>vfsSurrenderFileChannels</CODE></A></CODE> to obtain file
channel slots from the File System Manager prior to opening
files, any number of File System Manager I/O operations
will potentially generate a
<SAMP><A HREF="vfs-x.html#vfsMaxFilesexception"><CODE>vfsMaxFilesexception</CODE></A></SAMP> exception if the number
of file channels allowed by the operating system is
exceeded.
    <P>
When you reserve file channels using
<CODE>vfsReserveFileChannels</CODE> the File System Manager
will not close or cache any of its currently open files.
The total available pool of file channels available at any
given time is equal to the number of possible channels
(determined by the operating system), minus the number of
files open by the File System Manager and six channels that
are reserved for the Debugging Manager and internal File
System Manager use.
    <P>
Sample Code: Using <CODE>vfsReserveFileChannels</CODE> and
<CODE><A HREF="vfs-x.html#vfsSurrenderFileChannels"><CODE>vfsSurrenderFileChannels</CODE></A></CODE>

<BLOCKQUOTE>
<PRE>

/*
 * openMemoryMappedFile() - Function to open a memory-mapped file
 *                          under UNIX for reading and writing.
 *                          Returns NULL pointer if it fails
 *                          to open the file or some other error
 *                          occurs. (Note that normally a Galaxy
 *                          program would reserve a file channel for
 *                          extended use. Here it is only used
 *                          momentarily to open a file, map it into
 *                          memory and then close it. In fact this
 *                          code would only really make sense in
 *                          multithreaded environments where multiple
 *                          process threads were vying for File System
 *                          Manager resources. It is used here for
 *                          illustration purposes only.)
 */
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>
/*
 *  The constant 'MAP_FILE' is required by 4.3 BSD, but is not used by
 *  other operating systems. Define it here so the mmap() call below
 *  does not have to be conditionally defined.
 */
#ifndef MAP_FILE
#define MAP_FILE 0
#endif

char *openMemoryMappedFile(<A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A> *fileName)
{
  char   sysName[vfsMAXIMUM_NAME_LEN], /* Same as MAXNAMELEN */
        *retVal;                       /* Return value.      */
 
  int    fd;

  struct stat statBuffer;        /* To get file size.  */
 
  vfsReserveFileChannels(1);     /* Reserve one file channel. */

  /*
   *  Create a file name suitable for the operating system.
   */

  <A HREF="vchar-x.html#vcharExport"><CODE>vcharExport</CODE></A>(<A HREF="vchar-x.html#vcharScribeSystemExport"><CODE>vcharScribeSystemExport</CODE></A>(fileName), sysName);

  /*
   *  Do not create the file if it does not exist because it
   *  would be zero-length. (In that case you might want to
   *  set the size of the file for output by seeking out the
   *  number of bytes you want to map into memory and writing
   *  an ASC_NUL, or EOF character to create a sparse file.)
   *  
   */

  if ((fd = open(sysName, O_RDWR)) < 0)
    return(NULL);

  /*
   *  Get the size for the mmap() call. (We need to know how much
   *  memory to ask for, to map the entire file.)
   */

  if (fstat(fd, &statBuffer) < 0) {
    close(fd);
    <A HREF="vfs-x.html#vfsSurrenderFileChannels"><CODE>vfsSurrenderFileChannels</CODE></A>(1);        /* Give file channel back */
    return(NULL);
  }

  /*
   *  Map the file into memory. (Lets the system choose the starting
   *  address.)
   */

  if ((retVal = (char *) mmap(0, statBuffer.st_size, (PROT_READ |
      PROT_WRITE, MAP_FILE | MAP_SHARED), fd, 0)) == (char *) -1) {
    close(fd);
    <A HREF="vfs-x.html#vfsSurrenderFileChannels"><CODE>vfsSurrenderFileChannels</CODE></A>(1);        /* Give file channel back */
    return(NULL);
  }

  /*
   *  Close the file (which will not unmap the file I/O region--this must
   *  done explicitly by calling munmap().) Release the file channel.
   */

  close(fd);
  <A HREF="vfs-x.html#vfsSurrenderFileChannels"><CODE>vfsSurrenderFileChannels</CODE></A>(1);

  /*
   *  Returns a pointer into the process address space that corresponds
   *  to the mapped file. In other words, you can now write to this
   *  location in memory and read from it and it will be automatically
   *  be mapped into the file pointed to by the 'fileName' argument. The
   *  operating system's virtual memory subsystem will manage the I/O and
   *  "guarantee" that the file is updated when we write into the
   *  mapped region.
   */

  return(retVal);

}

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsResolvePath"><HR><H4>vfsResolvePath</H4></A>
<PRE>
        vfsPath * <B>vfsResolvePath</B>(
                const vfsPath * fullPath,
                const vfsPath * relativePath);
</PRE>

<DL><DD>
Returns a pointer to a dynamically allocated full path that
is generated by resolving the relative path
<SAMP>relativePath</SAMP> with the full path
<SAMP>fullPath</SAMP>. <SAMP>relativePath</SAMP> is always
assumed to be relative to the path. For example, given the
full path ``<SAMP>/dir1/dir2/dir3/currentdir</SAMP>'' and
the relative path ``<SAMP>../../newdir/file</SAMP>,''
<CODE>vfsResolvePath</CODE> returns a pointer to the path
``<SAMP>/dir1/dir2/newdir/file</SAMP>.'' In the case where
<SAMP>relativePath</SAMP> is actually a full pathname (that
is, <SAMP><A HREF="vfs-x.html#vfsGetPathType"><CODE>vfsGetPathType</CODE></A>(relativePath) ==
vfsPATH_TYPE_FULL</SAMP>), <CODE>vfsResolvePath</CODE>
returns a pointer to a copy of <SAMP>source</SAMP>. (This
appears anomalous, but is the correct behavior since
<SAMP>source</SAMP> is the argument that requires
resolution to a full path. In this case the
<SAMP>fullPath</SAMP> argument is useless.)
  <P>
<CODE>vfsResolvePath</CODE> only canonicalizes the path to
the point where it generates a valid full pathname. For
example, given the full path
``<SAMP>/dir/../dir1/dir2</SAMP>'' and the relative path
``<SAMP>../filename</SAMP>,'' <CODE>vfsResolvePath</CODE>
produces the full path
``<SAMP>/dir/../dir1/filename</SAMP>,'' which still
contains a relative reference. Use
<CODE><A HREF="vfs-x.html#vfsMakePathCanonical"><CODE>vfsMakePathCanonical</CODE></A></CODE> if you need to fully
canonicalize the path generated by
<CODE>vfsResolvePath</CODE>.
</DD></DL>
<P>
<A NAME="vfsRewindDir"><HR><H4>vfsRewindDir</H4></A>
<PRE>
        void <B>vfsRewindDir</B>(
                vfsDir * dir);
</PRE>

<DL><DD>
Resets the current entry pointer of the directory structure
<SAMP>dir</SAMP> to point to the first directory entry; either
file or directory/folder name.
</DD></DL>
<P>
<A NAME="vfsRewindFile"><HR><H4>vfsRewindFile</H4></A>
<PRE>
        void <B>vfsRewindFile</B>(
                vfsFile * file);
</PRE>

<DL><DD>
Repositions the file pointer offset to the beginning of the
file. The next read or write operation on the file starts
from the first byte in the file. Equivalent to
<CODE><A HREF="vfs-x.html#vfsSeekFile"><CODE>vfsSeekFile</CODE></A></CODE><SAMP>(file, 0, vfsSEEK_FROM_START)</SAMP>.
</DD></DL>
<P>
<A NAME="vfsSeekFile"><HR><H4>vfsSeekFile</H4></A>
<PRE>
        void <B>vfsSeekFile</B>(
                vfsFile * file,
                long offset,
                int from);
</PRE>

<DL><DD>
Sets the file pointer <SAMP>offset</SAMP> in the file
<SAMP>file</SAMP> where the next read/write operation takes
place. The position can be relative to the beginning of the
file, the current location, or the end of the file. The
beginning of the file is offset zero, not one (that is,
<SAMP>vfsSeekFile(file,0, vfsSEEK_FROM_START)</SAMP>  would
place the file pointer at the beginning of the file).
<SAMP>file</SAMP> is a pointer to the <SAMP><A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A></SAMP>
structure returned by <CODE><A HREF="vfs-x.html#vfsOpenFile"><CODE>vfsOpenFile</CODE></A></CODE>,
<SAMP>offset</SAMP> is the offset (in bytes), and
<SAMP>from</SAMP> takes one of the following values:

<DL>
<DT><CODE>vfsSEEK_FROM_START</CODE>
<DD>Measure offset from the beginning of the file. For
example, if the value of offset was 9, the next byte
read/written would be the tenth byte in the file. Negative
offsets should never be used with
<CODE>vfsSEEK_FROM_START</CODE> unless you are certain the
file type supports them. (Some character special device
files under UNIX support negative seeks from the beginning
of the file.) 

<DT><CODE>vfsSEEK_FROM_CURRENT</CODE>
<DD>Measure offset from current file pointer offset. For
example, if the value of offset were (-10),
<CODE>vfsSeekFile</CODE> would place the file offset
pointer ten bytes prior to the current pointer. If offset
had a value of 10, the pointer would be placed ten bytes
ahead of the current position. 

<DT><CODE>vfsSEEK_FROM_END</CODE>
<DD>Measure offset from end of file. For example, if the
value of offset was (-10), the file pointer would be placed
ten bytes prior to the end of the file. (Note that positive
offset numbers actually place the file pointer past the end
of the file in some operating systems using
<CODE>vfsSEEK_FROM_END</CODE>. For example, UNIX creates a
``sparse'' file if you seek beyond the end of a file and
write data. The gap in the file occupies no physical space
on the storage media and is read as zeroes.) 
</DL>

<P>
Sample Code: Using vfsSeekFile

<BLOCKQUOTE>
<PRE>

{
  // Overwrite the last portion of a file with the
  // contents of a string.

  <A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A>       *file = (<A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A> *) NULL;
  size_t        numBytes;
  <A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A>        *str;

  numBytes = <A HREF="vstr-x.html#vstrGetSize"><CODE>vstrGetSize</CODE></A>(str);
  file     = <A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A>(fromPath, vfsOPEN_READ_WRITE);

  // Seek the length of the string from the end of the file.

  file->Seek((numBytes * (-1)), vfsSEEK_FROM_END);

  // Write out the string buffer.

  file->Write(str, sizeof(vbyte), numBytes);
  file->Close();
}

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsSetFileType"><HR><H4>vfsSetFileType</H4></A>
<PRE>
        void <B>vfsSetFileType</B>(
                const vfsPath * path,
                vfsFileType type);
</PRE>

<DL><DD>
Sets the file type of the file referenced by the <A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>
<SAMP>path</SAMP>. This function is used on the Macintosh.
  <P>
The <SAMP><A HREF="vfs-x.html#vfsFileType"><CODE>vfsFileType</CODE></A></SAMP> is an <SAMP>int</SAMP>.
Non-negative values are intended to be offsets from
<SAMP>128</SAMP> for 'FREF' resource types in the current
application. For example, if your application has an 'FREF'
with resource ID 130, whose File Type field is the value you
desire for the current file, call:
<SAMP><A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>(path , 2);</SAMP> The following
values are predefined by Galaxy:
<P>

<DL>
<DT><CODE>vfsFILETYPE_UNKNOWN</CODE>
<DD>Unknown filetype.

<DT><CODE>vfsFILETYPE_TEXT</CODE>
<DD>A stream of characters.

<DT><CODE>vfsFILETYPE_APPLICATION</CODE>
<DD>A launchable application.

<DT><CODE>vfsFILETYPE_PICT</CODE>
<DD>A picture document.
</DL>
</DD></DL>
<P>
<A NAME="vfsSetPathExtension"><HR><H4>vfsSetPathExtension</H4></A>
<PRE>
        void <B>vfsSetPathExtension</B>(
                vfsPath * path,
                vchar * extension);
</PRE>

<DL><DD>
Sets the filename extension of the last component (leaf) of
the path <SAMP>path</SAMP> to the string
<SAMP>extension</SAMP>. If <SAMP>path</SAMP> already
contains a filename extension it is replaced with the new
extension. If <SAMP>path</SAMP> isn't a sensible filename
to set an extension on (the root path <SAMP>/</SAMP> under
Unix, for example), an exception is generated.
</DD></DL>
<P>
<A NAME="vfsSetPathExtensionScribed"><HR><H4>vfsSetPathExtensionScribed</H4></A>
<PRE>
        void <B>vfsSetPathExtensionScribed</B>(
                vfsPath * path,
                vscribe * extension);
</PRE>

<DL><DD>
Sets the filename extension of the last component (leaf) of
the path <SAMP>path</SAMP> to the scribe extension. If
<SAMP>path</SAMP> already contains a filename extension it
is replaced with the new extension. If <SAMP>path</SAMP>
isn't a sensible filename to set an extension on (the root
path <SAMP>/</SAMP> under Unix, for example), an exception
is generated.
</DD></DL>
<P>
<A NAME="vfsSetPathLeaf"><HR><H4>vfsSetPathLeaf</H4></A>
<PRE>
        void <B>vfsSetPathLeaf</B>(
                vfsPath * path,
                const vchar * name);
</PRE>

<DL><DD>
Replaces the last element of the path <SAMP>path</SAMP>
with <SAMP>name</SAMP>. In the case of a path that contains
only the root volume, these functions append the requested
path element to the root volume.
</DD></DL>
<P>
<A NAME="vfsSetPathLeafScribed"><HR><H4>vfsSetPathLeafScribed</H4></A>
<PRE>
        void <B>vfsSetPathLeafScribed</B>(
                vfsPath * path,
                vscribe * nameScribe);
</PRE>

<DL><DD>
Replaces the last element of the path <SAMP>path</SAMP>
with the <SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP> string written out by the
scribe <SAMP>nameScribe</SAMP>. The scribe is automatically
destroyed by <CODE>vfsSetPathLeafScribed</CODE>. In the
case of a path that contains only the root volume, these
functions append the requested path element to the root
volume.
  <P>
<BLOCKQUOTE>
Table: Paths returned after call to <CODE>vfsSetPathLeaf</CODE>
<TABLE BORDER>
<TR>
<TD><B> </B></TD> <TD><B> </B></TD> <TD><B>Path after call
to</B></TD> 
</TR>
<TR>
<TD><B>Path</B></TD> <TD><B>Name</B></TD>
<TD><CODE>vfsSetPathLeaf</CODE></TD> 
</TR>
<TR>
<TD><SAMP>/dir1/dir2</SAMP></TD> <TD><SAMP>file</SAMP></TD>
<TD><SAMP>/dir1/file</SAMP></TD> 
</TR>
<TR>
<TD><SAMP>../dir1/oldfile</SAMP></TD>
<TD><SAMP>newfile</SAMP></TD>
<TD><SAMP>../dir1/newfile</SAMP></TD> 
</TR>
<TR>
<TD><SAMP>/</SAMP></TD> <TD><SAMP>file</SAMP></TD>
<TD><SAMP>/file</SAMP></TD> 
</TR>
</TABLE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsSetPathVolumeName"><HR><H4>vfsSetPathVolumeName</H4></A>
<PRE>
        void <B>vfsSetPathVolumeName</B>(
                vfsPath * path,
                vchar * volName);
</PRE>

<DL><DD>
Sets the volume name for the path <SAMP>path</SAMP> to the
string name <SAMP>volName</SAMP>. Destroys the previous
volume name if there is one already defined. Setting the
volume name generally has no effect under UNIX, since
external and remote file systems are mounted in a single
file system hierarchy.
  <P>
If there is no volume structure allocated for the path when
either <CODE>vfsSetPathVolumeName</CODE> or
<CODE><A HREF="vfs-x.html#vfsSetPathVolumeNameScribed"><CODE>vfsSetPathVolumeNameScribed</CODE></A></CODE> is called, one is
automatically allocated.
<P>
Under DOS/Windows the volume reference is automatically set
for the drive label specified by
<CODE>vfsSetPathVolumeName</CODE> or
<CODE><A HREF="vfs-x.html#vfsSetPathVolumeNameScribed"><CODE>vfsSetPathVolumeNameScribed</CODE></A></CODE>. This only occurs
when using legal (`A' through `Z') drive labels for volume
names. (The drive reference itself is set with `A' == 1,
..., `Z' == 26.)
  <P>
Because of this convention, you rarely need to use the
<CODE><A HREF="vfs-x.html#vfsSetPathVolumeReference"><CODE>vfsSetPathVolumeReference</CODE></A></CODE>
function.
</DD></DL>
<P>
<A NAME="vfsSetPathVolumeNameScribed"><HR><H4>vfsSetPathVolumeNameScribed</H4></A>
<PRE>
        void <B>vfsSetPathVolumeNameScribed</B>(
                vfsPath * path,
                vscribe * nameScribe);
</PRE>

<DL><DD>
Sets the volume name for <SAMP>path</SAMP> to the string
written out by the scribe <SAMP>nameScribe</SAMP>. Destroys
the previous volume name if there is one already defined.
Setting the volume name generally has no effect under UNIX,
since external and remote file systems are mounted in a
single file system hierarchy.
<CODE>vfsSetPathVolumeNameScribed</CODE> automatically
destroys <SAMP>nameScribe</SAMP>.
  <P>
If there is no volume structure allocated for the path when
either <CODE>vfsSetPathVolumeName</CODE> or
<CODE>vfsSetPathVolumeNameScribed</CODE> is called, one is
automatically allocated.
<P>
Under DOS/Windows the volume reference is automatically set
for the drive label specified by
<CODE>vfsSetPathVolumeName</CODE> or
<CODE>vfsSetPathVolumeNameScribed</CODE>. This only occurs
when using legal (`A' through `Z') drive labels for volume
names. (The drive reference itself is set with `A' == 1,
..., `Z' == 26.)
  <P>
Because of this convention, you rarely need to use the
<CODE><A HREF="vfs-x.html#vfsSetPathVolumeReference"><CODE>vfsSetPathVolumeReference</CODE></A></CODE>
function.
</DD></DL>
<P>
<A NAME="vfsSetPathVolumeRef"><HR><H4>vfsSetPathVolumeRef</H4></A>
<PRE>
        void <B>vfsSetPathVolumeRef</B>(
                vfsPath * path,
                vfsVolumeRef volRef);
</PRE>

<DL><DD>
<I><B>(Deprecated)</B></I> This deprecated function is the same as
<CODE><A HREF="vfs-x.html#vfsSetPathVolumeReference"><CODE>vfsSetPathVolumeReference</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsSetPathVolumeReference"><HR><H4>vfsSetPathVolumeReference</H4></A>
<PRE>
        void <B>vfsSetPathVolumeReference</B>(
                vfsPath * path,
                vfsVolumeRef volRef);
</PRE>

<DL><DD>
Sets the volume reference associated with the path
<SAMP>path</SAMP> to <SAMP>volRef</SAMP>. The volume
reference can also be explicitly set to the
<SAMP>vfsNO_VOLUME_REFERENCE</SAMP> constant if there is no
longer a volume reference ID for this path.
  <P>
If there is no volume structure allocated for the path when
<CODE>vfsSetPathVolumeReference</CODE> is called, one is
automatically allocated.
</DD></DL>
<P>
<A NAME="vfsSetVolumeName"><HR><H4>vfsSetVolumeName</H4></A>
<PRE>
        void <B>vfsSetVolumeName</B>(
                vfsVolume * volume,
                vchar * volName);
</PRE>

<DL><DD>
Replaces the volume name for the volume <SAMP>volume</SAMP>
with <SAMP>volName</SAMP>. This function automatically
destroys the previous volume name if one exists.
<CODE>vfsSetVolumeName</CODE> will use a copy of the volume
name pointed to by <SAMP>volName</SAMP>.
<P>
Under DOS/Windows the volume reference is automatically set
for the drive label specified by
<CODE>vfsSetVolumeName</CODE> or
<CODE><A HREF="vfs-x.html#vfsSetVolumeNameScribed"><CODE>vfsSetVolumeNameScribed</CODE></A></CODE>. This only occurs when
using legal (`A' through `Z') drive labels for volume
names. (The drive reference itself is set with `A' == 1,
..., `Z' == 26.)
</DD></DL>
<P>
<A NAME="vfsSetVolumeNameScribed"><HR><H4>vfsSetVolumeNameScribed</H4></A>
<PRE>
        void <B>vfsSetVolumeNameScribed</B>(
                vfsVolume * volume,
                vscribe * nameScribe);
</PRE>

<DL><DD>
Replaces the volume name for the volume <SAMP>volume</SAMP>
with the <SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP> string written out by the
scribe <SAMP>nameScribe</SAMP>. The scribe is automatically
destroyed by <CODE>vfsSetVolumeNameScribed</CODE>. This
function automatically destroys the previous volume name if
one exists.
<P>
Under DOS/Windows the volume reference is automatically set
for the drive label specified by
<CODE>vfsSetVolumeName</CODE> or
<CODE>vfsSetVolumeNameScribed</CODE>. This only occurs when
using legal (`A' through `Z') drive labels for volume
names. (The drive reference itself is set with `A' == 1,
..., `Z' == 26.)
</DD></DL>
<P>
<A NAME="vfsSetVolumeReference"><HR><H4>vfsSetVolumeReference</H4></A>
<PRE>
        void <B>vfsSetVolumeReference</B>(
                vfsVolume * volume,
                vfsVolumeRef volRef);
</PRE>

<DL><DD>
Replaces the volume reference for the volume
<SAMP>volume</SAMP> with the value in <SAMP>volRef</SAMP>.
<P>
Under DOS/Windows the volume reference is automatically set
for the drive label specified by
<CODE><A HREF="vfs-x.html#vfsSetVolumeName"><CODE>vfsSetVolumeName</CODE></A></CODE> or
<CODE><A HREF="vfs-x.html#vfsSetVolumeNameScribed"><CODE>vfsSetVolumeNameScribed</CODE></A></CODE>. This only occurs when
using legal (`A' through `Z') drive labels for volume
names. (The drive reference itself is set with `A' == 1,
..., `Z' == 26.)
  <P>
Because of this convention, you rarely need to use the
<CODE>vfsSetVolumeReference</CODE> function.
</DD></DL>
<P>
<A NAME="vfsSetWorkingDir"><HR><H4>vfsSetWorkingDir</H4></A>
<PRE>
        void <B>vfsSetWorkingDir</B>(
                vfsPath * path);
</PRE>

<DL><DD>
Sets the current working directory for the Galaxy program
to the path <SAMP>path</SAMP>. All subsequent references to
relative paths and file/directory names will be relative to
the new working directory.
  <P>
<CODE>vfsSetWorkingDir</CODE> does not interfere with the
operation of the File System Manager file cache or the
directory stack (see <CODE><A HREF="vfs-x.html#vfsPushDir"><CODE>vfsPushDir</CODE></A></CODE> and
<CODE><A HREF="vfs-x.html#vfsPopDir"><CODE>vfsPopDir</CODE></A></CODE>).
</DD></DL>
<P>
<A NAME="vfsStartup"><HR><H4>vfsStartup</H4></A>
<PRE>
        void <B>vfsStartup</B>();
</PRE>

<DL><DD>
Initializes the File System Manager. This function is
rarely used since it is called from
<CODE><A HREF="vfs-x.html#vfsInitialize"><CODE>vfsInitialize</CODE></A></CODE> (which in turn is usually called
by <CODE><A HREF="vpref-x.html#vprefSetArgs"><CODE>vprefSetArgs</CODE></A></CODE>.)
  <P>
By convention, all Galaxy managers that register global
shutdown functions by
<CODE><A HREF="vclient-x.html#vclientRegisterGlobalShutdown"><CODE>vclientRegisterGlobalShutdown</CODE></A></CODE> are shut down
in the reverse order of their registration. The purpose of
<CODE>vfsStartup</CODE> is to allow other Galaxy managers
to initialize the File System Manager (and therefore
register its global shutdown function) prior to registering
their own shutdown function. This guarantees that the File
System Manager is shut down after they are.
  <P>
If you are building a manager that registers a global
shutdown function using
<CODE><A HREF="vclient-x.html#vclientRegisterGlobalShutdown"><CODE>vclientRegisterGlobalShutdown</CODE></A></CODE>, and the
manager requires File System Manager services <I>during its
own shutdown routine</I>, then you must make a call to
<CODE>vfsStartup</CODE> before you register your shutdown
function.
</DD></DL>
<P>
<A NAME="vfsSupportsFileTyping"><HR><H4>vfsSupportsFileTyping</H4></A>
<PRE>
        vbool <B>vfsSupportsFileTyping</B>(
                vfsInfo * info);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the file specified with the
<A HREF="vfs-x.html#vfsInfo"><CODE>vfsInfo</CODE></A> <SAMP>info</SAMP> supports intrinsic file typing.
</DD></DL>
<P>
<A NAME="vfsSurrenderFileChannels"><HR><H4>vfsSurrenderFileChannels</H4></A>
<PRE>
        void <B>vfsSurrenderFileChannels</B>(
                int numChannels);
</PRE>

<DL><DD>
Surrenders <SAMP>numChannels</SAMP> number of operating
system file channels (descriptors) currently used by the
Galaxy client program back to the File System Manager, or
all reserved file channels if the constant
vfsSURRENDER_ALL_CHANNELS is passed for <SAMP>numChannels</SAMP>.
<CODE>vfsSurrenderFileChannels</CODE> is used to return
file channels that were reserved for special use by
previous calls to <CODE><A HREF="vfs-x.html#vfsReserveFileChannels"><CODE>vfsReserveFileChannels</CODE></A></CODE>.
    <P>
If you do not use <CODE><A HREF="vfs-x.html#vfsReserveFileChannels"><CODE>vfsReserveFileChannels</CODE></A></CODE> and
<CODE>vfsSurrenderFileChannels</CODE> to obtain file
channel slots from the File System Manager prior to opening
files, any number of File System Manager I/O operations can
potentially generate a <SAMP><A HREF="vfs-x.html#vfsMaxFilesexception"><CODE>vfsMaxFilesexception</CODE></A></SAMP>
exception if the number of file channels allowed by the
operating system is exceeded. However, it is a good idea to
return any file channel allocated for special use when done
so that the File System Manager can more efficiently manage
I/O resources.
<P>
Make sure to close the file channel/descriptor before 
surrendering it back to the File System Manager.
</DD></DL>
<P>
<A NAME="vfsTruncateFile"><HR><H4>vfsTruncateFile</H4></A>
<PRE>
        void <B>vfsTruncateFile</B>(
                vfsFile * file,
                long size);
</PRE>

<DL><DD>
Sets the size of the file to <SAMP>size</SAMP>.
</DD></DL>
<P>
<A NAME="vfsTruncateOpenFile"><HR><H4>vfsTruncateOpenFile</H4></A>
<PRE>
        void <B>vfsTruncateOpenFile</B>(
                vfsFile * file);
</PRE>

<DL><DD>
Truncates the open file <SAMP>file</SAMP> to zero length
and resets the file offset pointer to zero. This function
is useful for editors that must write out altered contents
of an open file on top of itself.
<P>
Note that in the rare instance when either a
<SAMP><A HREF="vfs-x.html#vfsInterruptexception"><CODE>vfsInterruptexception</CODE></A></SAMP> or
<SAMP><A HREF="vfs-x.html#vfsIOexception"><CODE>vfsIOexception</CODE></A></SAMP> exception is generated by
<CODE>vfsTruncateOpenFile</CODE>, it is possible that the
file is no longer open or is opened with a different open
mode. A call to <CODE><A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A></CODE> ignoring any
exceptions generated guarantees that the file is
closed.
</DD></DL>
<P>
<A NAME="vfsTruncatePath"><HR><H4>vfsTruncatePath</H4></A>
<PRE>
        void <B>vfsTruncatePath</B>(
                vfsPath * path,
                int elements);
</PRE>

<DL><DD>
Truncates the path by removing the last elements
<SAMP>elements</SAMP>. This function allows you to
efficiently remove path components instead of using
multiple calls to <CODE><A HREF="vfs-x.html#vfsDeletePathElementAt"><CODE>vfsDeletePathElementAt</CODE></A></CODE>. If
the path is a full path (<SAMP>vfsPATH_TYPE_FULL</SAMP>),
then it can only be truncated up to the number of
non-root-volume members. For example, even though the
function <CODE><A HREF="vfs-x.html#vfsGetPathElementCount"><CODE>vfsGetPathElementCount</CODE></A></CODE> would return a
count of three for the path ``<SAMP>/dir/dir2</SAMP>,''
<SAMP>vfsTruncatePath(path, 3)</SAMP> would generate an
exception because it is attempting to remove the root path.
(<SAMP>vfsTruncatePath(path, 2)</SAMP> would remove all
named elements from the path and leave the root path
``<SAMP>/</SAMP>'' intact.)
  <P>
If a path is not a full path (that is,
<SAMP>vfsPATH_TYPE_RELATIVE</SAMP> or
<SAMP>vfsPATH_TYPE_NAME</SAMP>), it is possible to truncate
it to have no members. At this point you will have a null
path that is marked as either
<SAMP>vfsPATH_TYPE_RELATIVE</SAMP> or
<SAMP>vfsPATH_TYPE_NAME</SAMP>. It will not be useful for
File System Manager calls using pathnames.
<P>
It is your responsibility to construct a new path of the
same type as the path that was truncated if you remove all
its members.
<P>
Sample Code: Using <CODE>vfsTruncatePath</CODE>

<BLOCKQUOTE>
<PRE>
/*
 * For the path "/usr/visix/galaxy/src/vfs", the following
 * code fragment would produce the path "/usr/visix"
 */
<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *path;

vfsTruncatePath(path, 3);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsUnlockFile"><HR><H4>vfsUnlockFile</H4></A>
<PRE>
        void <B>vfsUnlockFile</B>(
                vfsFile * file);
</PRE>

<DL><DD>
Removes all locks in the file <SAMP>file</SAMP> placed by
the current process. Equivalent to
<CODE><A HREF="vfs-x.html#vfsUnlockFileRange"><CODE>vfsUnlockFileRange</CODE></A></CODE><SAMP>(file, 0L,
vfsLOCK_TO_END).</SAMP>
</DD></DL>
<P>
<A NAME="vfsUnlockFileRange"><HR><H4>vfsUnlockFileRange</H4></A>
<PRE>
        void <B>vfsUnlockFileRange</B>(
                vfsFile * file,
                long offset,
                long numBytes);
</PRE>

<DL><DD>
Unlocks the range of bytes within the file
<SAMP>file</SAMP> starting at <SAMP>offset</SAMP> and
extending <SAMP>numBytes</SAMP> bytes. The File System
Manager constant <SAMP>vfsLOCK_TO_END</SAMP> is supported
by <CODE>vfsUnlockFileRange</CODE> as a legal value for
<SAMP>numBytes</SAMP>. This indicates that the unlock
operation is to extend from <SAMP>offset</SAMP> to the end
of the file.
</DD></DL>
<P>
<A NAME="vfsWriteFile"><HR><H4>vfsWriteFile</H4></A>
<PRE>
        void <B>vfsWriteFile</B>(
                vbyte * ptr,
                long size,
                long nitems,
                vfsFile * file);
</PRE>

<DL><DD>
Writes at most <SAMP>nitems</SAMP> number of items of
<SAMP>size</SAMP> bytes into the file <SAMP>file</SAMP>
from the buffer <SAMP>ptr</SAMP>. <SAMP>ptr</SAMP> is a
pointer to the buffer containing the items to be written
out, <SAMP>size</SAMP> is the stated item size (in bytes),
<SAMP>nitems</SAMP> is the number of items to be written,
and <SAMP>file</SAMP> is the open file to which the target
information is to be written.
    <P>
<CODE>vfsWriteFile</CODE> sets the file pointer to an
offset one byte past the last byte written after each write
operation.
    <P>
Sample Code: Using <CODE>vfsWriteFile</CODE>

<BLOCKQUOTE>
<PRE>

/*
 * writeStringAt() -    Function to write out a string at a
 *                      given location in a file. Return TRUE
 *                      if the string is written out, FALSE
 *                      if not. (Note: production code would
 *                      certainly be more careful handling
 *                      errors.)
 */

vbool writeStringAt(<A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> *path, <A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A> *str, long offset) {

  <A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A>              *file = (<A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A> *) NULL;

  register size_t       numBytes;

  numBytes = <A HREF="vstr-x.html#vstrGetSize"><CODE>vstrGetSize</CODE></A>(str);
  vexWITH_HANDLING {

    /*
     * Open the file and seek to the designated spot
     */

    file = <A HREF="vfs-x.html#vfsOpenFile"><CODE>vfsOpenFile</CODE></A>(fromPath, vfsOPEN_READ_WRITE);
    <A HREF="vfs-x.html#vfsSeekFile"><CODE>vfsSeekFile</CODE></A>(file, offset, vfsSEEK_FROM_START);

    /*
     * Write out the string buffer.
     */

    vfsWriteFile(str, sizeof(vbyte), numBytes, file);
  } vexON_exception {
    if (file)

      /*
       * <A HREF="vfs-x.html#vfsSeekFile"><CODE>vfsSeekFile</CODE></A>() or vfsWriteFile() failed.
       */

      <A HREF="vfs-x.html#vfsCloseFile"><CODE>vfsCloseFile</CODE></A>(file);

    /*
     * A more normal error handler would probably
     * propagate the exception up the handler chain. Here
     * just return FALSE because the operation failed.
     */

    return(FALSE);
  } vexEND_HANDLING;

  <A HREF="vfs-x.html#vfsCloseFile"><CODE>vfsCloseFile</CODE></A>(file);
  return(TRUE);
}

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsWriteString"><HR><H4>vfsWriteString</H4></A>
<PRE>
        void <B>vfsWriteString</B>(
                const vchar * buffer,
                vfsFile * file);
</PRE>

<DL><DD>
Writes the null-terminated string pointed to by
<SAMP>buffer</SAMP> to the file <SAMP>file</SAMP> starting
at the current file position. <CODE>vfsWriteString</CODE>
only writes out the contents of the string, it does not
append either the <SAMP>ASC_NUL</SAMP> or
<SAMP>ASC_LF</SAMP> (<SAMP>NEWLINE</SAMP>) character. 
<CODE>vfsWriteString</CODE> is designed to operate
identically to the C library function <SAMP>fputs</SAMP>.
<P>
Note that <CODE>vfsWriteString</CODE> is optimized for the case
<SAMP>sizeof(<A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A>) == sizeof(char)</SAMP>, but also
accommodates multi-byte <SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP>
values.
<P>
Sample Code: Using <CODE>vfsWriteString</CODE>

<BLOCKQUOTE>
<PRE>

/*
 *  writeStringAtLocation() -  Write a string at a certain location
 *                             in the requested file.
 */
void writeStringAtLocation(<A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A>        *string,
                           long          offset,
                           <A HREF="vfs-x.html#vfsFile"><CODE>vfsFile</CODE></A>      *destinationFile)
{
  <A HREF="vfs-x.html#vfsSeekFile"><CODE>vfsSeekFile</CODE></A>(destinationFile, offset, vfsSEEK_FROM_START);
  vfsWriteString(string, destinationFile)
  return;
}

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vfsWriteStringScribed"><HR><H4>vfsWriteStringScribed</H4></A>
<PRE>
        void <B>vfsWriteStringScribed</B>(
                vscribe * stringScribe,
                vfsFile * file);
</PRE>

<DL><DD>
Writes the string represented by a scribe to a file
starting at the current file position. This is the scribe
form of <CODE>vfsWriteString</CODE>.
</DD></DL>
<P>
<A NAME="section_Constant"><HR>
<CENTER><H2>Constants</H2></CENTER></A><P>
<A NAME="vfsALL_DENY_MODES"><HR><H4>vfsALL_DENY_MODES</H4></A>
<PRE>
        <B>vfsALL_DENY_MODES</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsALL_OPEN_MODES"><HR><H4>vfsALL_OPEN_MODES</H4></A>
<PRE>
        <B>vfsALL_OPEN_MODES</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsALL_PATH_TYPES"><HR><H4>vfsALL_PATH_TYPES</H4></A>
<PRE>
        <B>vfsALL_PATH_TYPES</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsALL_VOLUME_TYPES"><HR><H4>vfsALL_VOLUME_TYPES</H4></A>
<PRE>
        <B>vfsALL_VOLUME_TYPES</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsAMBIGUOUS_VOLUME_REFERENCE"><HR><H4>vfsAMBIGUOUS_VOLUME_REFERENCE</H4></A>
<PRE>
        <B>vfsAMBIGUOUS_VOLUME_REFERENCE</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsARCHIVE"><HR><H4>vfsARCHIVE</H4></A>
<PRE>
        <B>vfsARCHIVE</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsBAD_GID"><HR><H4>vfsBAD_GID</H4></A>
<PRE>
        <B>vfsBAD_GID</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsBAD_UID"><HR><H4>vfsBAD_UID</H4></A>
<PRE>
        <B>vfsBAD_UID</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsCAN_READ"><HR><H4>vfsCAN_READ</H4></A>
<PRE>
        <B>vfsCAN_READ</B>
</PRE>
<A NAME="vfsCAN_WRITE"><PRE>
        <B>vfsCAN_WRITE</B>
</PRE>
</A>
<A NAME="vfsCAN_EXECUTE"><PRE>
        <B>vfsCAN_EXECUTE</B>
</PRE>
</A>
<A NAME="vfsFILE_EXISTS"><PRE>
        <B>vfsFILE_EXISTS</B>
</PRE>
</A>

<DL><DD>
Values for the <SAMP>accessMode</SAMP> parameter to
<CODE><A HREF="vfs-x.html#vfsAccess"><CODE>vfsAccess</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsDIR"><HR><H4>vfsDIR</H4></A>
<PRE>
        <B>vfsDIR</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsEXTRA_FILETYPING"><HR><H4>vfsEXTRA_FILETYPING</H4></A>
<PRE>
        <B>vfsEXTRA_FILETYPING</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsFILE"><HR><H4>vfsFILE</H4></A>
<PRE>
        <B>vfsFILE</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsFILETYPE_APPLICATION"><HR><H4>vfsFILETYPE_APPLICATION</H4></A>
<PRE>
        <B>vfsFILETYPE_APPLICATION</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsFILETYPE_ASCII_TEXT"><HR><H4>vfsFILETYPE_ASCII_TEXT</H4></A>
<PRE>
        <B>vfsFILETYPE_ASCII_TEXT</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsFILETYPE_EXECUTABLE"><HR><H4>vfsFILETYPE_EXECUTABLE</H4></A>
<PRE>
        <B>vfsFILETYPE_EXECUTABLE</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsFILETYPE_PICT"><HR><H4>vfsFILETYPE_PICT</H4></A>
<PRE>
        <B>vfsFILETYPE_PICT</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsFILETYPE_TEXT"><HR><H4>vfsFILETYPE_TEXT</H4></A>
<PRE>
        <B>vfsFILETYPE_TEXT</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsFILETYPE_UNKNOWN"><HR><H4>vfsFILETYPE_UNKNOWN</H4></A>
<PRE>
        <B>vfsFILETYPE_UNKNOWN</B>
</PRE>

<DL><DD>
Predefined values for <CODE><A HREF="vfs-x.html#vfsFileType"><CODE>vfsFileType</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsFILE_IN_CACHE"><HR><H4>vfsFILE_IN_CACHE</H4></A>
<PRE>
        <B>vfsFILE_IN_CACHE</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsFILE_IS_LOCKED"><HR><H4>vfsFILE_IS_LOCKED</H4></A>
<PRE>
        <B>vfsFILE_IS_LOCKED</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsFILE_SEEK_ILLEGAL"><HR><H4>vfsFILE_SEEK_ILLEGAL</H4></A>
<PRE>
        <B>vfsFILE_SEEK_ILLEGAL</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsHIDDEN"><HR><H4>vfsHIDDEN</H4></A>
<PRE>
        <B>vfsHIDDEN</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsINCLUDED"><HR><H4>vfsINCLUDED</H4></A>
<PRE>
        <B>vfsINCLUDED</B>
</PRE>

<DL><DD>
Defined when the header file <SAMP>vfs.h</SAMP> is
included.
</DD></DL>
<P>
<A NAME="vfsINVALID_VOLUME_REFERENCE"><HR><H4>vfsINVALID_VOLUME_REFERENCE</H4></A>
<PRE>
        <B>vfsINVALID_VOLUME_REFERENCE</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsIO_BUFFER_SIZE"><HR><H4>vfsIO_BUFFER_SIZE</H4></A>
<PRE>
        <B>vfsIO_BUFFER_SIZE</B>
</PRE>

<DL><DD>
The optimum buffer size for file I/O.
</DD></DL>
<P>
<A NAME="vfsLINK"><HR><H4>vfsLINK</H4></A>
<PRE>
        <B>vfsLINK</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsLOCK_TO_END"><HR><H4>vfsLOCK_TO_END</H4></A>
<PRE>
        <B>vfsLOCK_TO_END</B>
</PRE>

<DL><DD>
Value to indicate the end of the file in file locking
operations. This constant may be passed as the
<SAMP>numBytes</SAMP> parameter to:

<ul>
<li><CODE><A HREF="vfs-x.html#vfsLockFileRange"><CODE>vfsLockFileRange</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsUnlockFileRange"><CODE>vfsUnlockFileRange</CODE></A></CODE>
<li><CODE><A HREF="vfs-x.html#vfsIsFileRangeLocked"><CODE>vfsIsFileRangeLocked</CODE></A></CODE>
</ul>
</DD></DL>
<P>
<A NAME="vfsMAXIMUM_NAME_LEN"><HR><H4>vfsMAXIMUM_NAME_LEN</H4></A>
<PRE>
        <B>vfsMAXIMUM_NAME_LEN</B>
</PRE>

<DL><DD>
The maximum length of a single element of a <A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>.
</DD></DL>
<P>
<A NAME="vfsMAXIMUM_PATH_LEN"><HR><H4>vfsMAXIMUM_PATH_LEN</H4></A>
<PRE>
        <B>vfsMAXIMUM_PATH_LEN</B>
</PRE>

<DL><DD>
The maximum length of an entire <A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A>, including separators.
</DD></DL>
<P>
<A NAME="vfsNO_FILE"><HR><H4>vfsNO_FILE</H4></A>
<PRE>
        <B>vfsNO_FILE</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsNO_VOLUME_REFERENCE"><HR><H4>vfsNO_VOLUME_REFERENCE</H4></A>
<PRE>
        <B>vfsNO_VOLUME_REFERENCE</B>
</PRE>

<DL><DD>
Indicates that a path does not include a volume. This
constant is returned when <CODE><A HREF="vfs-x.html#vfsGetPathVolumeRef"><CODE>vfsGetPathVolumeRef</CODE></A></CODE>
is called with a <A HREF="vfs-x.html#vfsPath"><CODE>vfsPath</CODE></A> that does not have a volume.
</DD></DL>
<P>
<A NAME="vfsOPEN_READ_ONLY"><HR><H4>vfsOPEN_READ_ONLY</H4></A>
<PRE>
        <B>vfsOPEN_READ_ONLY</B>
</PRE>
<A NAME="vfsOPEN_READ_WRITE"><PRE>
        <B>vfsOPEN_READ_WRITE</B>
</PRE>
</A>
<A NAME="vfsOPEN_WRITE_TRUNCATE"><PRE>
        <B>vfsOPEN_WRITE_TRUNCATE</B>
</PRE>
</A>
<A NAME="vfsOPEN_APPEND"><PRE>
        <B>vfsOPEN_APPEND</B>
</PRE>
</A>

<DL><DD>
Access types for opening files. These constants are used to
specify the access type in <CODE><A HREF="vfs-x.html#vfsOpenFile"><CODE>vfsOpenFile</CODE></A></CODE>, and are
also the possible return values from
<CODE><A HREF="vfs-x.html#vfsGetFileAccessType"><CODE>vfsGetFileAccessType</CODE></A></CODE>. 
</DD></DL>
<P>
<A NAME="vfsOPEN_TEXT_MODE"><HR><H4>vfsOPEN_TEXT_MODE</H4></A>
<PRE>
        <B>vfsOPEN_TEXT_MODE</B>
</PRE>
<A NAME="vfsOPEN_NOT_CACHED"><PRE>
        <B>vfsOPEN_NOT_CACHED</B>
</PRE>
</A>
<A NAME="vfsOPEN_DENY_READ"><PRE>
        <B>vfsOPEN_DENY_READ</B>
</PRE>
</A>
<A NAME="vfsOPEN_DENY_WRITE"><PRE>
        <B>vfsOPEN_DENY_WRITE</B>
</PRE>
</A>
<A NAME="vfsOPEN_DENY_READ_WRITE"><PRE>
        <B>vfsOPEN_DENY_READ_WRITE</B>
</PRE>
</A>

<DL><DD>
Access type modifiers for opening files. These flags may be
ORed into the access type passed to <CODE>vfsOpen</CODE> to
specify additional attributes.
</DD></DL>
<P>
<A NAME="vfsOWNER_READ"><HR><H4>vfsOWNER_READ</H4></A>
<PRE>
        <B>vfsOWNER_READ</B>
</PRE>
<A NAME="vfsOWNER_WRITE"><PRE>
        <B>vfsOWNER_WRITE</B>
</PRE>
</A>
<A NAME="vfsOWNER_EXECUTE"><PRE>
        <B>vfsOWNER_EXECUTE</B>
</PRE>
</A>
<A NAME="vfsOWNER_PERMISSIONS_MASK"><PRE>
        <B>vfsOWNER_PERMISSIONS_MASK</B>
</PRE>
</A>
<A NAME="vfsGROUP_READ"><PRE>
        <B>vfsGROUP_READ</B>
</PRE>
</A>
<A NAME="vfsGROUP_WRITE"><PRE>
        <B>vfsGROUP_WRITE</B>
</PRE>
</A>
<A NAME="vfsGROUP_EXECUTE"><PRE>
        <B>vfsGROUP_EXECUTE</B>
</PRE>
</A>
<A NAME="vfsGROUP_PERMISSIONS_MASK"><PRE>
        <B>vfsGROUP_PERMISSIONS_MASK</B>
</PRE>
</A>
<A NAME="vfsOTHER_READ"><PRE>
        <B>vfsOTHER_READ</B>
</PRE>
</A>
<A NAME="vfsOTHER_WRITE"><PRE>
        <B>vfsOTHER_WRITE</B>
</PRE>
</A>
<A NAME="vfsOTHER_EXECUTE"><PRE>
        <B>vfsOTHER_EXECUTE</B>
</PRE>
</A>
<A NAME="vfsOTHER_PERMISSIONS_MASK"><PRE>
        <B>vfsOTHER_PERMISSIONS_MASK</B>
</PRE>
</A>

<DL><DD>
Masks for setting and testing file permissions. These
values may be ORed together to pass to
<CODE><A HREF="vfs-x.html#vfsChangeMode"><CODE>vfsChangeMode</CODE></A></CODE> or used to test the value
returned from <CODE><A HREF="vfs-x.html#vfsGetMode"><CODE>vfsGetMode</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsPATH_TYPE_CANONICAL"><HR><H4>vfsPATH_TYPE_CANONICAL</H4></A>
<PRE>
        <B>vfsPATH_TYPE_CANONICAL</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsPATH_TYPE_FULL"><HR><H4>vfsPATH_TYPE_FULL</H4></A>
<PRE>
        <B>vfsPATH_TYPE_FULL</B>
</PRE>
<A NAME="vfsPATH_TYPE_RELATIVE"><PRE>
        <B>vfsPATH_TYPE_RELATIVE</B>
</PRE>
</A>
<A NAME="vfsPATH_TYPE_NAME"><PRE>
        <B>vfsPATH_TYPE_NAME</B>
</PRE>
</A>

<DL><DD>
Values for <CODE><A HREF="vfs-x.html#vfsType"><CODE>vfsType</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsRESOLVED_FROM_LINK"><HR><H4>vfsRESOLVED_FROM_LINK</H4></A>
<PRE>
        <B>vfsRESOLVED_FROM_LINK</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsSEEK_FROM_START"><HR><H4>vfsSEEK_FROM_START</H4></A>
<PRE>
        <B>vfsSEEK_FROM_START</B>
</PRE>
<A NAME="vfsSEEK_FROM_CURRENT"><PRE>
        <B>vfsSEEK_FROM_CURRENT</B>
</PRE>
</A>
<A NAME="vfsSEEK_FROM_END"><PRE>
        <B>vfsSEEK_FROM_END</B>
</PRE>
</A>

<DL><DD>
Values for the seek-from parameter. These values are used
for the <SAMP>from</SAMP> parameter to
<CODE><A HREF="vfs-x.html#vfsSeekFile"><CODE>vfsSeekFile</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vfsSPECIAL"><HR><H4>vfsSPECIAL</H4></A>
<PRE>
        <B>vfsSPECIAL</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsSURRENDER_ALL_CHANNELS"><HR><H4>vfsSURRENDER_ALL_CHANNELS</H4></A>
<PRE>
        <B>vfsSURRENDER_ALL_CHANNELS</B>
</PRE>

<DL><DD>
Indicates that all file channels should be surrendered.
This constant should be used for the number of channels in
<CODE><A HREF="vfs-x.html#vfsSurrenderFileChannels"><CODE>vfsSurrenderFileChannels</CODE></A></CODE> to surrender all
channels.
</DD></DL>
<P>
<A NAME="vfsSYSTEM"><HR><H4>vfsSYSTEM</H4></A>
<PRE>
        <B>vfsSYSTEM</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsVOLUME"><HR><H4>vfsVOLUME</H4></A>
<PRE>
        <B>vfsVOLUME</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsVOLUME_TYPE_NONEXISTENT"><HR><H4>vfsVOLUME_TYPE_NONEXISTENT</H4></A>
<PRE>
        <B>vfsVOLUME_TYPE_NONEXISTENT</B>
</PRE>
<A NAME="vfsVOLUME_TYPE_UNKNOWN"><PRE>
        <B>vfsVOLUME_TYPE_UNKNOWN</B>
</PRE>
</A>
<A NAME="vfsVOLUME_TYPE_REMOVABLE"><PRE>
        <B>vfsVOLUME_TYPE_REMOVABLE</B>
</PRE>
</A>
<A NAME="vfsVOLUME_TYPE_FIXED"><PRE>
        <B>vfsVOLUME_TYPE_FIXED</B>
</PRE>
</A>
<A NAME="vfsVOLUME_TYPE_REMOTE"><PRE>
        <B>vfsVOLUME_TYPE_REMOTE</B>
</PRE>
</A>
<A NAME="vfsVOLUME_TYPE_SPECIAL"><PRE>
        <B>vfsVOLUME_TYPE_SPECIAL</B>
</PRE>
</A>

<DL><DD>
Volume type identifiers returned by <CODE><A HREF="vfs-x.html#vfsGetVolumeType"><CODE>vfsGetVolumeType</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="section_Macro"><HR>
<CENTER><H2>Macros</H2></CENTER></A><P>
<A NAME="vfsSetMacFileCreator"><HR><H4>vfsSetMacFileCreator</H4></A>
<PRE>
        #define <B>vfsSetMacFileCreator</B>(...) ...
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vfsSetMacFileType"><HR><H4>vfsSetMacFileType</H4></A>
<PRE>
        #define <B>vfsSetMacFileType</B>(...) ...
</PRE>

<DL><DD>

</DD></DL>
<P>

<P>
<!--[[/CONTENT]]-->

<HR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">
		<TD>
		<CENTER>
<!--[[NAVIGATE_ICONIC]]-->
<!--[[/NAVIGATE_ICONIC]]-->
		</CENTER>
		</TD>
		    
		<TD>
		<BR>
		<FONT SIZE=-1>
	        <A HREF="#Top">Top of This Page</A> <BR>
	        <A HREF="index.html">Table of Contents</A> <BR>
		<A HREF="../index.html">Switch to Another Document</A><BR>
		<BR>
		</FONT>
		</TD>

		<TD>
		<BR>
		<FONT SIZE=-1>
		Need help?
		<A HREF="../contact-visix.html">
		Contact Visix</A>.
		<BR> <BR>
	        <A HREF="../copyright.html">Copyright &#169; 1996-97</A>,
		<A HREF="http://www.visix.com/">Visix Software Inc.</A><BR>
		<BR>
		</FONT>
		</TD>

	</TR>

</TABLE>
		
</BODY>
</HTML>



