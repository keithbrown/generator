<HTML>
  <HEAD>
<!--[[HEADING]]-->
<title>vformat prefix</title><!--[[/HEADING]]-->
  </HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<A NAME="Top"><IMG SRC="../graphics/trans.gif" WIDTH=2 HEIGHT=2></A><BR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">

		<TD>
		<CENTER>
		<A HREF="../index.html">
		<IMG SRC="../graphics/logo.gif" BORDER=0></A>
		</CENTER>
		</TD>

	        <TD VALIGN=TOP>
	        <BR><H1>
<!--[[TITLE]]-->
vformat prefix<!--[[/TITLE]]-->
	        </H1><BR>
		</TD>
      
	</TR>

</TABLE>

<HR>

<BR>

<!--[[PREAMBLE]]-->
<TABLE>
<TR>
<TD><A HREF="vformat-x.html#section_DataType">Types</A> [47]</TD>
<TD><A HREF="vformat-x.html#section_Function">Functions</A> [498]</TD>
<TD><A HREF="vformat-x.html#section_Message">Messages</A> [27]</TD>
<TD><A HREF="vformat-x.html#section_Constant">Constants</A> [7]</TD>
<TD><A HREF="vformat-x.html#section_Macro">Macros</A> [20]</TD>
</TR>
</TABLE>
<!--[[/PREAMBLE]]-->

<!--[[CONTENT]]-->

<P>
<A NAME="section_DataType"><HR>
<CENTER><H2>Types</H2></CENTER></A><P>
<A NAME="vformat"><HR><H4>vformat</H4></A>
<PRE>
        typedef ... <B>vformat</B>;
</PRE>

<DL><DD>
A format is an adapter between a type, such as integer or
Boolean, and a string representation of that type. 
The base Vformat class provides the implementation
infrastructure necessary to support its type-specific
derivatives, and thus, cannot be used on its own.
<P>
Additional format types can be created by extending
from this class. Use <class><A HREF="vformat-x.html#vformatGetDefaultClass"><CODE>vformatGetDefaultClass</CODE></A></code> to get
a pointer to the default <code><A HREF="vformat-x.html#vformatClass"><CODE>vformatClass</CODE></A></code>, which can be
used as an argument to <code><A HREF="vclass-x.html#vclassReproduce"><CODE>vclassReproduce</CODE></A></code> or
<class><A HREF="vclass-x.html#vclassSpawn"><CODE>vclassSpawn</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatBoolean"><HR><H4>vformatBoolean</H4></A>
<PRE>
        typedef ... <B>vformatBoolean</B>;
</PRE>

<DL><DD>
A <code>vformatBoolean</code> defines a two-segmented pattern 
where the first segment, by convention, represents a positive or true value 
and the second segment represents a negative or false value. 
An input string matches a boolean pattern segment when it compares, 
in a case-insensitive alpha-numeric sense, equally
with at least one of the pattern segment strings.
<P>
If the <code>vformatBoolean</code> was made up of the following patterns:

<pre>
  "on;off"
  "true;false"
  "yes;no"

The following input strings would be considered valid:

  "ON"
  "no"
</pre>

If alignment or color specifiers are embedded in the patterns, they are not
included in the pattern string text but are first extracted by the base
<code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> class.
</DD></DL>
<P>
<A NAME="vformatBooleanClass"><HR><H4>vformatBooleanClass</H4></A>
<PRE>
        typedef ... <B>vformatBooleanClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatBoolean</CODE>. Classes declared with this
type contain the same set of methods and variables as the
default Boolean format class, but the behavior of methods and
the contents of variables may vary. This class type is derived
from <CODE><A HREF="vformat-x.html#vformatClass"><CODE>vformatClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatBooleanSegment"><HR><H4>vformatBooleanSegment</H4></A>
<PRE>
        typedef ... <B>vformatBooleanSegment</B>;
</PRE>

<DL><DD>
Uses a case-insensitive, alpha-numeric comparison to determine if an input
string matches any of the format's pattern segment strings.
</DD></DL>
<P>
<A NAME="vformatBooleanSegmentClass"><HR><H4>vformatBooleanSegmentClass</H4></A>
<PRE>
        typedef ... <B>vformatBooleanSegmentClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatBooleanSegment</CODE>. Classes declared with
this type contain the same set of methods and variables as the
default Boolean format segment class, but the behavior of
methods and the contents of variables may vary. This class
type is derived from <CODE><A HREF="vformat-x.html#vformatSegmentClass"><CODE>vformatSegmentClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatBooleanSegmentIterator"><HR><H4>vformatBooleanSegmentIterator</H4></A>
<PRE>
        typedef ... <B>vformatBooleanSegmentIterator</B>;
</PRE>

<DL><DD>
Gives access to each <code>vformatBooleanSegment</code> in turn, 
as well as the index of the segment's pattern and the index 
of the segment within the pattern. From the segment you can obtain 
various attributes of the segment including
its color and text alignment attributes.
</DD></DL>
<P>
<A NAME="vformatBooleanSegmentIteratorClass"><HR><H4>vformatBooleanSegmentIteratorClass</H4></A>
<PRE>
        typedef ... <B>vformatBooleanSegmentIteratorClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatBooleanSegmentIterator</CODE>. Classes declared
with this type contain the same set of methods and variables
as the default Boolean format segment iterator class, but the
behavior of methods and the contents of variables may vary.
This class type is derived from
<CODE><A HREF="vformat-x.html#vformatSegmentIteratorClass"><CODE>vformatSegmentIteratorClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatClass"><HR><H4>vformatClass</H4></A>
<PRE>
        typedef ... <B>vformatClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformat</CODE>. Classes declared with this type
contain the same set of methods and variables as the
default format class, but the behavior of methods and
the contents of variables may vary. This class type is
derived from <CODE><A HREF="vloadable-x.html#vloadableClass"><CODE>vloadableClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatDate"><HR><H4>vformatDate</H4></A>
<PRE>
        typedef ... <B>vformatDate</B>;
</PRE>

<DL><DD>
A <code>vformatDate</code> defines a single-segmented pattern 
representing a point in time. The date format pattern consists of 
a series of fields, each field being represented in the pattern 
language as another series of alpha-numeric characters.
The allowable field types include those listed below.

<ol>
<li>Static text
<li>Year:
     <ul>
     <li>y-year number
     <li>yy-year number, zero padded
     <li>yyyy-full year number
     </ul>
<li>Month:
     <ul>
     <li>m-month number
     <li>mm-month number, zero padded
     <li>mmm-abbreviated month name
     <li>mmmm-full month name
     </ul>
<li>Day:
     <ul>
     <li>d-day number
     <li>dd-day number, zero padded
     <li>ddd-abbreviated day name
     <li>dddd-full day name
     </ul>
<li>Hour:
     <ul>
     <li>h-hour number
     <li>hh-hour number, zero padded
     </ul>
<li>Minute:
     <ul>
     <li>n-minute number
     <li>nn-minute number, zero padded
     </ul>
<li>Second:
     <ul>
     <li>s-second number
     <li>ss-second number, zero padded
     </ul>
</ol>
</DD></DL>
<P>
<A NAME="vformatDateClass"><HR><H4>vformatDateClass</H4></A>
<PRE>
        typedef ... <B>vformatDateClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatDate</CODE>. Classes declared with this type
contain the same set of methods and variables as the
default date format class, but the behavior of methods and
the contents of variables may vary. This class type is
derived from <CODE><A HREF="vformat-x.html#vformatClass"><CODE>vformatClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatDateSegment"><HR><H4>vformatDateSegment</H4></A>
<PRE>
        typedef ... <B>vformatDateSegment</B>;
</PRE>

<DL><DD>
Interprets a string as a date/time value.
</DD></DL>
<P>
<A NAME="vformatDateSegmentClass"><HR><H4>vformatDateSegmentClass</H4></A>
<PRE>
        typedef ... <B>vformatDateSegmentClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatDateSegment</CODE>. Classes declared with
this type contain the same set of methods and variables
as the default date format segment class, but the behavior
of methods and the contents of variables may vary. This
class type is derived from <CODE><A HREF="vformat-x.html#vformatSegmentClass"><CODE>vformatSegmentClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatDateSegmentIterator"><HR><H4>vformatDateSegmentIterator</H4></A>
<PRE>
        typedef ... <B>vformatDateSegmentIterator</B>;
</PRE>

<DL><DD>
Gives access to each <code>vformatDateSegment</code> in turn, 
as well as the index of the segment's pattern and the 
index of the segment within the pattern.
From the segment you can obtain various attributes of the segment including
its color and alignment attributes.
The <code><A HREF="vformat-x.html#vformatDateSegmentClass"><CODE>vformatDateSegmentClass</CODE></A></code> adds nothing beyond the color and text
alignment attributes contributed by the base <code><A HREF="vformat-x.html#vformatSegmentClass"><CODE>vformatSegmentClass</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatDateSegmentIteratorClass"><HR><H4>vformatDateSegmentIteratorClass</H4></A>
<PRE>
        typedef ... <B>vformatDateSegmentIteratorClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatDateSegmentIterator</CODE>. Classes declared
with this type contain the same set of methods and variables
as the default date format segment iterator class, but the
behavior of methods and the contents of variables may vary.
This class type is derived from
<CODE><A HREF="vformat-x.html#vformatSegmentIteratorClass"><CODE>vformatSegmentIteratorClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatDouble"><HR><H4>vformatDouble</H4></A>
<PRE>
        typedef ... <B>vformatDouble</B>;
</PRE>

<DL><DD>
This class defines a three-segmented pattern made up of positive, negative,
and zero parts. The representational language grammer includes the symbols
defined below.

<DL>
<DT>0
<DD>A zero-pad, displays digit if it's significant and non-zero, else
displays a zero.

<DT>?  
<DD>A space-pad, displays digits if it's significant and non-zero, else 
displays a space

<DT># 
<DD>Vacuous-digit placeholder, displays digits if it's significant, else
displays nothing digit-run - a contiuous series of the previous elements:

<UL>
<LI> . - Decimal point, displays decimal point and optional places to the right
<li> / - Fractional separator; separates a numerator digit-run from a denominator
     digit-run
</ul>
</DL>

<P>
Example double format patterns include:

<ul>
<li>"0" - parse/display a single digit
<li>"#,###" - parse/display up to 4 digits with comma seperator required
<li>"???" - parse/display up to three digits with possible leading space padding
<li>"#/#" - parse/display a fraction with a single digits of numerator and 
denominator.
</ul>
</DD></DL>
<P>
<A NAME="vformatDoubleClass"><HR><H4>vformatDoubleClass</H4></A>
<PRE>
        typedef ... <B>vformatDoubleClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatDouble</CODE>. Classes declared with this
type contain the same set of methods and variables as
the default double format class, but the behavior of methods
and the contents of variables may vary. This class type
is derived from <CODE><A HREF="vformat-x.html#vformatClass"><CODE>vformatClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatDoubleSegment"><HR><H4>vformatDoubleSegment</H4></A>
<PRE>
        typedef ... <B>vformatDoubleSegment</B>;
</PRE>

<DL><DD>
Interprets a string as a double value in one of the states:
positive; negative; or zero.
</DD></DL>
<P>
<A NAME="vformatDoubleSegmentClass"><HR><H4>vformatDoubleSegmentClass</H4></A>
<PRE>
        typedef ... <B>vformatDoubleSegmentClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatDoubleSegment</CODE>. Classes declared with
this type contain the same set of methods and variables
as the default double format segment class, but the behavior
of methods and the contents of variables may vary. This class
type is derived from <CODE><A HREF="vformat-x.html#vformatSegmentClass"><CODE>vformatSegmentClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatDoubleSegmentIterator"><HR><H4>vformatDoubleSegmentIterator</H4></A>
<PRE>
        typedef ... <B>vformatDoubleSegmentIterator</B>;
</PRE>

<DL><DD>
Gives access to each <code>vformatDoubleSegment</code> in turn, 
as well as the index of the segment's pattern and the index 
of the segment within the pattern.
From the segment you can obtain various attributes of the segment including
its color and alignment attributes.
The <code><A HREF="vformat-x.html#vformatDoubleSegmentClass"><CODE>vformatDoubleSegmentClass</CODE></A></code> adds nothing beyond 
the scaling factor and prefix/suffix strings contributed by the 
base <code><A HREF="vformat-x.html#vformatNumberSegmentClass"><CODE>vformatNumberSegmentClass</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatDoubleSegmentIteratorClass"><HR><H4>vformatDoubleSegmentIteratorClass</H4></A>
<PRE>
        typedef ... <B>vformatDoubleSegmentIteratorClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatDoubleSegmentIterator</CODE>. Classes declared
with this type contain the same set of methods and variables
as the default double format segment iterator class, but the
behavior of methods and the contents of variables may vary.
This class type is derived from
<CODE><A HREF="vformat-x.html#vformatSegmentIteratorClass"><CODE>vformatSegmentIteratorClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatLong"><HR><H4>vformatLong</H4></A>
<PRE>
        typedef ... <B>vformatLong</B>;
</PRE>

<DL><DD>
Class of objects capable of interpreting a string as a long integer value.
</DD></DL>
<P>
<A NAME="vformatLongClass"><HR><H4>vformatLongClass</H4></A>
<PRE>
        typedef ... <B>vformatLongClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatLong</CODE>. Classes declared with this type
contain the same set of methods and variables as the
default long integer format class, but the behavior of
methods and the contents of variables may vary. This
class type is derived from <CODE><A HREF="vformat-x.html#vformatNumberClass"><CODE>vformatNumberClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatLongSegment"><HR><H4>vformatLongSegment</H4></A>
<PRE>
        typedef ... <B>vformatLongSegment</B>;
</PRE>

<DL><DD>
Class of objects that can interpret a string as an integer value in one of
the states: positive; negative; or zero.
</DD></DL>
<P>
<A NAME="vformatLongSegmentClass"><HR><H4>vformatLongSegmentClass</H4></A>
<PRE>
        typedef ... <B>vformatLongSegmentClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatLongSegment</CODE>. Classes declared with
this type contain the same set of methods and variables
as the default long integer format segment class, but the
behavior of methods and the contents of variables may vary.
This class type is derived from
<CODE><A HREF="vformat-x.html#vformatNumberSegmentClass"><CODE>vformatNumberSegmentClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatLongSegmentIterator"><HR><H4>vformatLongSegmentIterator</H4></A>
<PRE>
        typedef ... <B>vformatLongSegmentIterator</B>;
</PRE>

<DL><DD>
From the segment you can obtain various attributes of the segment including
its color and alignment attributes.
The <code><A HREF="vformat-x.html#vformatLongSegmentClass"><CODE>vformatLongSegmentClass</CODE></A></code> adds nothing beyond the 
scaling factor and prefix/suffix strings contributed 
by the base <code><A HREF="vformat-x.html#vformatNumberSegmentClass"><CODE>vformatNumberSegmentClass</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatLongSegmentIteratorClass"><HR><H4>vformatLongSegmentIteratorClass</H4></A>
<PRE>
        typedef ... <B>vformatLongSegmentIteratorClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatLongSegmentIterator</CODE>. Classes declared
with this type contain the same set of methods and
variables as the default long integer format segment
iterator class, but the behavior of methods and the
contents of variables may vary. This class type is derived
from <CODE><A HREF="vformat-x.html#vformatNumberSegmentIteratorClass"><CODE>vformatNumberSegmentIteratorClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatNumber"><HR><H4>vformatNumber</H4></A>
<PRE>
        typedef ... <B>vformatNumber</B>;
</PRE>

<DL><DD>
This is a common base-class for the type-specific numeric formats, and not
meant to be independently used.
</DD></DL>
<P>
<A NAME="vformatNumberClass"><HR><H4>vformatNumberClass</H4></A>
<PRE>
        typedef ... <B>vformatNumberClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatNumber</CODE>. Classes declared with this
type contain the same set of methods and variables as the
default number format class, but the behavior of methods and
the contents of variables may vary. This class type is
derived from <CODE><A HREF="vformat-x.html#vformatClass"><CODE>vformatClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatNumberSegment"><HR><H4>vformatNumberSegment</H4></A>
<PRE>
        typedef ... <B>vformatNumberSegment</B>;
</PRE>

<DL><DD>
The <code><A HREF="vformat-x.html#vformatNumberSegmentClass"><CODE>vformatNumberSegmentClass</CODE></A></code> adds prefix/suffix strings, 
as well as a numeric scaling factor, to the color and alignment attributes 
contributed by the base <code><A HREF="vformat-x.html#vformatSegmentClass"><CODE>vformatSegmentClass</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatNumberSegmentClass"><HR><H4>vformatNumberSegmentClass</H4></A>
<PRE>
        typedef ... <B>vformatNumberSegmentClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatNumberSegment</CODE>. Classes declared with
this type contain the same set of methods and variables
as the default number format segment class, but the behavior
of methods and the contents of variables may vary. This
class type is derived from <CODE><A HREF="vformat-x.html#vformatSegmentClass"><CODE>vformatSegmentClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatNumberSegmentIterator"><HR><H4>vformatNumberSegmentIterator</H4></A>
<PRE>
        typedef ... <B>vformatNumberSegmentIterator</B>;
</PRE>

<DL><DD>
Gives access to each <code>vformatNumberSegment</code> in turn, 
as well as the index of the segment's pattern and the 
index of the segment within the pattern.
From the segment you can obtain various attributes of the segment including
its color, text alignment, numeric scaling factor, and its prefix/suffix
strings.
</DD></DL>
<P>
<A NAME="vformatNumberSegmentIteratorClass"><HR><H4>vformatNumberSegmentIteratorClass</H4></A>
<PRE>
        typedef ... <B>vformatNumberSegmentIteratorClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatNumberSegmentIterator</CODE>. Classes declared
with this type contain the same set of methods and variables
as the default number format segment iterator class, but the
behavior of methods and the contents of variables may vary.
This class type is derived from
<CODE><A HREF="vformat-x.html#vformatSegmentIteratorClass"><CODE>vformatSegmentIteratorClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatParseException"><HR><H4>vformatParseException</H4></A>
<PRE>
        typedef ... <B>vformatParseException</B>;
</PRE>

<DL><DD>
Generated by type-specific format parsing methods when some portion
of a segment pattern string or candidate input string is not understood
by a format. This exception contains the offset of the character in the
segment pattern or input string that was not understood by the format
and is derived from <CODE><A HREF="vex-x.html#vexException"><CODE>vexException</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatParseRange"><HR><H4>vformatParseRange</H4></A>
<PRE>
        typedef ... <B>vformatParseRange</B>;
</PRE>

<DL><DD>
A <code>vformatParseRange</code> maintains a pair of integers 
that represent a contiguous range with respect to some format segment 
pattern string. The first integer represents the starting offset 
of the range and the other integer represents the length of that range.
These objects are created internally by the format when parsing a pattern
string.
</DD></DL>
<P>
<A NAME="vformatParseRangeClass"><HR><H4>vformatParseRangeClass</H4></A>
<PRE>
        typedef ... <B>vformatParseRangeClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatParseRange</CODE>. Classes declared with
this type contain the same set of methods and variables
as the default parse range class, but the behavior of methods
and the contents of variables may vary. This class type is
derived from <CODE><A HREF="vinstance-x.html#vinstanceClass"><CODE>vinstanceClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatPatternIndex"><HR><H4>vformatPatternIndex</H4></A>
<PRE>
        typedef ... <B>vformatPatternIndex</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatSegment"><HR><H4>vformatSegment</H4></A>
<PRE>
        typedef ... <B>vformatSegment</B>;
</PRE>

<DL><DD>
Some types have logical states, of consequence to the users of those types,
which are really catagorizations of certain ranges of the types total
range. A floating point value has the logical states positive; 
negative; or zero. A boolean value has the set of logical states true and false.
<P>
The concept of a pattern is that of a set of one or more segments. When a
string representing some typed value is validated, it is checked against each
pattern segment, in turn, and is deemed valid if it matches any single pattern
segment. Similarily, an input string is to be considered invalid if it fails to
match any single pattern segment.
<P>
A <code>vformatSegment</code> contains all the information necessary to go from a
type-specific high-level pattern language to the artifacts necessary to test
the validity of some arbitrary input string, and to generate a new output string
that represents that typed value, in terms of the pattern language.
</DD></DL>
<P>
<A NAME="vformatSegmentClass"><HR><H4>vformatSegmentClass</H4></A>
<PRE>
        typedef ... <B>vformatSegmentClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatSegment</CODE>. Classes declared with this
type contain the same set of methods and variables
as the default format segment class, but the behavior of methods
and the contents of variables may vary. This class type is
derived from <CODE><A HREF="vinstance-x.html#vinstanceClass"><CODE>vinstanceClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatSegmentIndex"><HR><H4>vformatSegmentIndex</H4></A>
<PRE>
        typedef ... <B>vformatSegmentIndex</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatSegmentIterator"><HR><H4>vformatSegmentIterator</H4></A>
<PRE>
        typedef ... <B>vformatSegmentIterator</B>;
</PRE>

<DL><DD>
Gives access to each <code>vformatSegment</code> in turn, as well as the index
of the segment's pattern and the index of the segment within the pattern.
From the segment you can obtain various attributes of the segment including
color and alignment attributes and whatever other type-specific artifacts were
generated for interpreting arbitrary input strings.
</DD></DL>
<P>
<A NAME="vformatSegmentIteratorClass"><HR><H4>vformatSegmentIteratorClass</H4></A>
<PRE>
        typedef ... <B>vformatSegmentIteratorClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatSegmentIterator</CODE>. Classes declared with
this type contain the same set of methods and variables
as the default format segment iterator class, but the behavior
of methods and the contents of variables may vary. This class
type is derived from <CODE><A HREF="viterator-x.html#viteratorClass"><CODE>viteratorClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatULong"><HR><H4>vformatULong</H4></A>
<PRE>
        typedef ... <B>vformatULong</B>;
</PRE>

<DL><DD>
This class defines a 2-segmented pattern made up of positive and zero parts.
The representational language grammer includes the symbols defined below.

<DL>
<DT>0
<DD>A zero-pad, displays digit if it's significant and non-zero, else
displays a zero.

<DT>?
<DT>A space-pad, displays digits if it's significant and non-zero, else
displays a space.

<DT>#
<DT>A vacuous-digit placeholder, displays digits if it's significant, else
displays nothing.
</DL>

<P>
Examples of unsigned long format patterns include:

<DL>
<DT>0
<DD>Parse/display a single digit.

<DT>#,###
<DD>Parse/display up to 4 digits with comma separator required.

<DT>???
<DD>Parse/display up to three digits with possible leading space padding.
</DL>
</DD></DL>
<P>
<A NAME="vformatULongClass"><HR><H4>vformatULongClass</H4></A>
<PRE>
        typedef ... <B>vformatULongClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatULong</CODE>. Classes declared with this type
contain the same set of methods and variables as the
default unsigned long integer format class, but the behavior
of methods and the contents of variables may vary. This
class type is derived from <CODE><A HREF="vformat-x.html#vformatNumberClass"><CODE>vformatNumberClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatULongSegment"><HR><H4>vformatULongSegment</H4></A>
<PRE>
        typedef ... <B>vformatULongSegment</B>;
</PRE>

<DL><DD>
Class of objects capable of interpreting an arbitrary string as an unsigned
long integer value in one of the states, either positive, or zero.
</DD></DL>
<P>
<A NAME="vformatULongSegmentClass"><HR><H4>vformatULongSegmentClass</H4></A>
<PRE>
        typedef ... <B>vformatULongSegmentClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatULongSegment</CODE>. Classes declared with
this type contain the same set of methods and variables
as the default unsigned long integer format segment class,
but the behavior of methods and the contents of variables
may vary. This class type is derived from
<CODE><A HREF="vformat-x.html#vformatNumberSegmentClass"><CODE>vformatNumberSegmentClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vformatULongSegmentIterator"><HR><H4>vformatULongSegmentIterator</H4></A>
<PRE>
        typedef ... <B>vformatULongSegmentIterator</B>;
</PRE>

<DL><DD>
Gives access to each <code>vformatULongSegment</code> in turn, 
as well as the index of the segment's pattern and the 
index of the segment within the pattern.
From the segment you can obtain various attributes of the segment including
its color and alignment attributes.
The <code><A HREF="vformat-x.html#vformatULongSegmentClass"><CODE>vformatULongSegmentClass</CODE></A></code> adds nothing 
beyond the scaling factor and prefix/suffix strings 
contributed by the base <code><A HREF="vformat-x.html#vformatNumberSegmentClass"><CODE>vformatNumberSegmentClass</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatULongSegmentIteratorClass"><HR><H4>vformatULongSegmentIteratorClass</H4></A>
<PRE>
        typedef ... <B>vformatULongSegmentIteratorClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vformatULongSegmentIterator</CODE>. Classes declared
with this type contain the same set of methods and variables
as the default unsigned long integer format segment interator
class, but the behavior of methods and the contents of
variables may vary. This class type is derived from
<CODE><A HREF="vformat-x.html#vformatNumberSegmentIteratorClass"><CODE>vformatNumberSegmentIteratorClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="section_Function"><HR>
<CENTER><H2>Functions</H2></CENTER></A><P>
<A NAME="vformatAppendBooleanPattern"><HR><H4>vformatAppendBooleanPattern</H4></A>
<PRE>
        void <B>vformatAppendBooleanPattern</B>(
                vformatBoolean * format,
                const vchar * string);
</PRE>

<DL><DD>
This is a convenience method that simply calls 
<code><A HREF="vformat-x.html#vformatInsertPattern"><CODE>vformatInsertPattern</CODE></A></code> with an index equal to the 
current pattern count, obtained by calling <code><A HREF="vformat-x.html#vformatGetPatternCount"><CODE>vformatGetPatternCount</CODE></A></code>.
<code>VformatInsertPattern</code> for a description of the exceptions 
that may be raised by a call to this method.
</DD></DL>
<P>
<A NAME="vformatAppendDatePattern"><HR><H4>vformatAppendDatePattern</H4></A>
<PRE>
        void <B>vformatAppendDatePattern</B>(
                vformatDate * format,
                const vchar * string);
</PRE>

<DL><DD>
This is a convenience method that simply calls 
<code><A HREF="vformat-x.html#vformatInsertPattern"><CODE>vformatInsertPattern</CODE></A><code> with an index equal to the 
current pattern count, obtained by calling <code><A HREF="vformat-x.html#vformatGetPatternCount"><CODE>vformatGetPatternCount</CODE></A></code>.
Refer to the section <code><A HREF="vformat-x.html#vformatInsertPattern"><CODE>vformatInsertPattern</CODE></A></code> for a description 
of the exceptions that may be raised by a call to this method.
</DD></DL>
<P>
<A NAME="vformatAppendDoublePattern"><HR><H4>vformatAppendDoublePattern</H4></A>
<PRE>
        void <B>vformatAppendDoublePattern</B>(
                vformatDouble * format,
                const vchar * string);
</PRE>

<DL><DD>
This is a convenience method that simply calls 
<code><A HREF="vformat-x.html#vformatInsertPattern"><CODE>vformatInsertPattern</CODE></A></code> with an index equal to the 
current pattern count, obtained by calling <code><A HREF="vformat-x.html#vformatGetPatternCount"><CODE>vformatGetPatternCount</CODE></A></code>.
<code>VformatInsertPattern</code> for a description of the exceptions that may
be raised by a call to this method.
</DD></DL>
<P>
<A NAME="vformatAppendLongPattern"><HR><H4>vformatAppendLongPattern</H4></A>
<PRE>
        void <B>vformatAppendLongPattern</B>(
                vformatLong * format,
                const vchar * string);
</PRE>

<DL><DD>
This is a convenience method that simply calls 
<code><A HREF="vformat-x.html#vformatInsertPattern"><CODE>vformatInsertPattern</CODE></A></code> with an index equal to 
the current pattern count, obtained by calling
<code><A HREF="vformat-x.html#vformatGetPatternCount"><CODE>vformatGetPatternCount</CODE></A></code>.
Refer to section <code><A HREF="vformat-x.html#vformatInsertPattern"><CODE>vformatInsertPattern</CODE></A></code> 
for a description of the exceptions that may
be raised by a call to this method.
</DD></DL>
<P>
<A NAME="vformatAppendNumberPattern"><HR><H4>vformatAppendNumberPattern</H4></A>
<PRE>
        void <B>vformatAppendNumberPattern</B>(
                vformatNumber * format,
                const vchar * pattern);
</PRE>

<DL><DD>
This is a convenience method that simply calls 
<code><A HREF="vformat-x.html#vformatInsertPattern"><CODE>vformatInsertPattern</CODE></A></code> with an index equal 
to the current pattern count, obtained by calling 
<code><A HREF="vformat-x.html#vformatGetPatternCount"><CODE>vformatGetPatternCount</CODE></A></code>.
Refer to section <code><A HREF="vformat-x.html#vformatInsertPattern"><CODE>vformatInsertPattern</CODE></A></code> 
for a description of the exceptions that may
be raised by a call to this method.
</DD></DL>
<P>
<A NAME="vformatAppendPattern"><HR><H4>vformatAppendPattern</H4></A>
<PRE>
        void <B>vformatAppendPattern</B>(
                vformat * format,
                const vchar * string);
</PRE>

<DL><DD>
This is a convenience method that simply calls
<code><A HREF="vformat-x.html#vformatInsertPattern"><CODE>vformatInsertPattern</CODE></A></code> with an index equal to the current
pattern count, obtained by calling <code><A HREF="vformat-x.html#vformatGetPatternCount"><CODE>vformatGetPatternCount</CODE></A></code>.
<P>
Refer to the section <code><A HREF="vformat-x.html#vformatInsertPattern"><CODE>vformatInsertPattern</CODE></A></code> 
for a description of the exceptions that may be raised 
by a call to this method.
</DD></DL>
<P>
<A NAME="vformatAppendULongPattern"><HR><H4>vformatAppendULongPattern</H4></A>
<PRE>
        void <B>vformatAppendULongPattern</B>(
                vformatULong * format,
                const vchar * string);
</PRE>

<DL><DD>
This is a convenience method that simply calls 
<code><A HREF="vformat-x.html#vformatInsertPattern"><CODE>vformatInsertPattern</CODE></A></code> with
an index equal to the current pattern count, obtained by calling
<code><A HREF="vformat-x.html#vformatGetPatternCount"><CODE>vformatGetPatternCount</CODE></A></code>.
Refer to section <code><A HREF="vformat-x.html#vformatInsertPattern"><CODE>vformatInsertPattern</CODE></A></code> 
for a description of the exceptions that may
be raised by a call to this method.
</DD></DL>
<P>
<A NAME="vformatClone"><HR><H4>vformatClone</H4></A>
<PRE>
        vformat * <B>vformatClone</B>(
                vformat * format);
</PRE>

<DL><DD>
This ultimately calls on the object's copy constructor.
</DD></DL>
<P>
<A NAME="vformatCloneBoolean"><HR><H4>vformatCloneBoolean</H4></A>
<PRE>
        vformatBoolean * <B>vformatCloneBoolean</B>(
                vformatBoolean * format);
</PRE>

<DL><DD>
This ultimately calls on the object's copy constructor.
</DD></DL>
<P>
<A NAME="vformatCloneDate"><HR><H4>vformatCloneDate</H4></A>
<PRE>
        vformatDate * <B>vformatCloneDate</B>(
                vformatDate * format);
</PRE>

<DL><DD>
This ultimately calls on the object's copy constructor.
</DD></DL>
<P>
<A NAME="vformatCloneDouble"><HR><H4>vformatCloneDouble</H4></A>
<PRE>
        vformatDouble * <B>vformatCloneDouble</B>(
                vformatDouble * format);
</PRE>

<DL><DD>
This ultimately calls on the object's copy constructor.
</DD></DL>
<P>
<A NAME="vformatCloneLong"><HR><H4>vformatCloneLong</H4></A>
<PRE>
        vformatLong * <B>vformatCloneLong</B>(
                vformatLong * format);
</PRE>

<DL><DD>
This ultimately calls on the object's copy constructor.
</DD></DL>
<P>
<A NAME="vformatCloneNumber"><HR><H4>vformatCloneNumber</H4></A>
<PRE>
        vformatNumber * <B>vformatCloneNumber</B>(
                vformatNumber * format);
</PRE>

<DL><DD>
This ultimately calls on the object's copy constructor.
</DD></DL>
<P>
<A NAME="vformatCloneULong"><HR><H4>vformatCloneULong</H4></A>
<PRE>
        vformatULong * <B>vformatCloneULong</B>(
                vformatULong * format);
</PRE>

<DL><DD>
This ultimately calls on the object's copy constructor.
</DD></DL>
<P>
<A NAME="vformatCopy"><HR><H4>vformatCopy</H4></A>
<PRE>
        void <B>vformatCopy</B>(
                vformat * dest,
                vformat * src);
</PRE>

<DL><DD>
Both <SAMP>dest</SAMP> and <SAMP>src</SAMP> are fully intialized instances.
</DD></DL>
<P>
<A NAME="vformatCopyBoolean"><HR><H4>vformatCopyBoolean</H4></A>
<PRE>
        void <B>vformatCopyBoolean</B>(
                vformatBoolean * dest,
                vformatBoolean * src);
</PRE>

<DL><DD>
Both <SAMP>dest</SAMP> and <SAMP>src</SAMP> are fully intialized instances.
</DD></DL>
<P>
<A NAME="vformatCopyDate"><HR><H4>vformatCopyDate</H4></A>
<PRE>
        void <B>vformatCopyDate</B>(
                vformatDate * dest,
                vformatDate * src);
</PRE>

<DL><DD>
Both <SAMP>dest</SAMP> and <SAMP>src</SAMP> are fully intialized instances.
</DD></DL>
<P>
<A NAME="vformatCopyDouble"><HR><H4>vformatCopyDouble</H4></A>
<PRE>
        void <B>vformatCopyDouble</B>(
                vformatDouble * dest,
                vformatDouble * src);
</PRE>

<DL><DD>
Both <SAMP>dest</SAMP> and <SAMP>src</SAMP> are fully intialized instances.
</DD></DL>
<P>
<A NAME="vformatCopyInit"><HR><H4>vformatCopyInit</H4></A>
<PRE>
        void <B>vformatCopyInit</B>(
                vformat * dest,
                vformat * src);
</PRE>

<DL><DD>
Both <SAMP>dest</SAMP> and <SAMP>src</SAMP> are fully intialized instances.
</DD></DL>
<P>
<A NAME="vformatCopyInitBoolean"><HR><H4>vformatCopyInitBoolean</H4></A>
<PRE>
        void <B>vformatCopyInitBoolean</B>(
                vformatBoolean * dest,
                vformatBoolean * src);
</PRE>

<DL><DD>
<SAMP>Dest</SAMP> is uninitialized, while <SAMP>src</SAMP> is fully
intialized.
</DD></DL>
<P>
<A NAME="vformatCopyInitDate"><HR><H4>vformatCopyInitDate</H4></A>
<PRE>
        void <B>vformatCopyInitDate</B>(
                vformatDate * dest,
                vformatDate * src);
</PRE>

<DL><DD>
<SAMP>Dest</SAMP> is uninitialized, while <SAMP>src</SAMP> is fully
intialized.
</DD></DL>
<P>
<A NAME="vformatCopyInitDouble"><HR><H4>vformatCopyInitDouble</H4></A>
<PRE>
        void <B>vformatCopyInitDouble</B>(
                vformatDouble * dest,
                vformatDouble * src);
</PRE>

<DL><DD>
<SAMP>Dest</SAMP> is uninitialized, while <SAMP>src</SAMP> is fully
intialized.
</DD></DL>
<P>
<A NAME="vformatCopyInitLong"><HR><H4>vformatCopyInitLong</H4></A>
<PRE>
        void <B>vformatCopyInitLong</B>(
                vformatLong * dest,
                vformatLong * src);
</PRE>

<DL><DD>
<SAMP>Dest</SAMP> is uninitialized, while <SAMP>src</SAMP> is fully
intialized.
</DD></DL>
<P>
<A NAME="vformatCopyInitNumber"><HR><H4>vformatCopyInitNumber</H4></A>
<PRE>
        void <B>vformatCopyInitNumber</B>(
                vformatNumber * dest,
                vformatNumber * src);
</PRE>

<DL><DD>
<SAMP>Dest</SAMP> is uninitialized, while <SAMP>src</SAMP> is fully
intialized.
</DD></DL>
<P>
<A NAME="vformatCopyInitULong"><HR><H4>vformatCopyInitULong</H4></A>
<PRE>
        void <B>vformatCopyInitULong</B>(
                vformatULong * dest,
                vformatULong * src);
</PRE>

<DL><DD>
<SAMP>Dest</SAMP> is uninitialized, while <SAMP>src</SAMP> is fully
intialized.
</DD></DL>
<P>
<A NAME="vformatCopyLong"><HR><H4>vformatCopyLong</H4></A>
<PRE>
        void <B>vformatCopyLong</B>(
                vformatLong * dest,
                vformatLong * src);
</PRE>

<DL><DD>
Both <SAMP>dest</SAMP> and <SAMP>src</SAMP> are fully intialized instances.
</DD></DL>
<P>
<A NAME="vformatCopyNumber"><HR><H4>vformatCopyNumber</H4></A>
<PRE>
        void <B>vformatCopyNumber</B>(
                vformatNumber * dest,
                vformatNumber * src);
</PRE>

<DL><DD>
Both <SAMP>dest</SAMP> and <SAMP>src</SAMP> are fully intialized instances.
</DD></DL>
<P>
<A NAME="vformatCopyULong"><HR><H4>vformatCopyULong</H4></A>
<PRE>
        void <B>vformatCopyULong</B>(
                vformatULong * dest,
                vformatULong * src);
</PRE>

<DL><DD>
Both <SAMP>dest</SAMP> and <SAMP>src</SAMP> are fully intialized instances.
</DD></DL>
<P>
<A NAME="vformatCreate"><HR><H4>vformatCreate</H4></A>
<PRE>
        vformat * <B>vformatCreate</B>();
</PRE>

<DL><DD>
Users should not call this function; only type-specific 
derivatives of <code>vformat</code> are useful.
</DD></DL>
<P>
<A NAME="vformatCreateBoolean"><HR><H4>vformatCreateBoolean</H4></A>
<PRE>
        vformatBoolean * <B>vformatCreateBoolean</B>();
</PRE>

<DL><DD>
Initially the format has an empty pattern set.
Use <code><A HREF="vformat-x.html#vformatAppendBooleanPattern"><CODE>vformatAppendBooleanPattern</CODE></A></code> or 
<code><A HREF="vformat-x.html#vformatInsertBooleanPattern"><CODE>vformatInsertBooleanPattern</CODE></A></code> to
add to the format's pattern set.
</DD></DL>
<P>
<A NAME="vformatCreateBooleanSegment"><HR><H4>vformatCreateBooleanSegment</H4></A>
<PRE>
        vformatBooleanSegment * <B>vformatCreateBooleanSegment</B>();
</PRE>

<DL><DD>
This function is used internally when adding a new pattern with
<code>vformatAppendAppendPattern</code> or 
<code><A HREF="vformat-x.html#vformatInsertBooleanPattern"><CODE>vformatInsertBooleanPattern</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatCreateBooleanSegmentIteratorOfClass"><HR><H4>vformatCreateBooleanSegmentIteratorOfClass</H4></A>
<PRE>
        void <B>vformatCreateBooleanSegmentIteratorOfClass</B>();
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a boolean format segment
iterator of the specified class.
</DD></DL>
<P>
<A NAME="vformatCreateBooleanSegmentOfClass"><HR><H4>vformatCreateBooleanSegmentOfClass</H4></A>
<PRE>
        vformatBooleanSegment * <B>vformatCreateBooleanSegmentOfClass</B>(
                vformatBooleanSegmentClass * clas);
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a boolean format segment
of the specified class.
</DD></DL>
<P>
<A NAME="vformatCreateDate"><HR><H4>vformatCreateDate</H4></A>
<PRE>
        vformatDate * <B>vformatCreateDate</B>();
</PRE>

<DL><DD>
Initially the date format has an empty pattern set.
Use <code><A HREF="vformat-x.html#vformatAppendDatePattern"><CODE>vformatAppendDatePattern</CODE></A></code> or 
<code><A HREF="vformat-x.html#vformatInsertDatePattern"><CODE>vformatInsertDatePattern</CODE></A></code> to add to the
format's pattern set.
</DD></DL>
<P>
<A NAME="vformatCreateDateSegment"><HR><H4>vformatCreateDateSegment</H4></A>
<PRE>
        vformatDateSegment * <B>vformatCreateDateSegment</B>();
</PRE>

<DL><DD>
This function is used internally when adding a new pattern with
<code><A HREF="vformat-x.html#vformatAppendDatePattern"><CODE>vformatAppendDatePattern</CODE></A></code> or 
</code><A HREF="vformat-x.html#vformatInsertDatePattern"><CODE>vformatInsertDatePattern</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatCreateDateSegmentIteratorOfClass"><HR><H4>vformatCreateDateSegmentIteratorOfClass</H4></A>
<PRE>
        void <B>vformatCreateDateSegmentIteratorOfClass</B>();
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a date format segment
iterator of the specified class.
</DD></DL>
<P>
<A NAME="vformatCreateDateSegmentOfClass"><HR><H4>vformatCreateDateSegmentOfClass</H4></A>
<PRE>
        vformatDateSegment * <B>vformatCreateDateSegmentOfClass</B>(
                vformatDateSegmentClass * clas);
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a date format segment of
the specified class.
</DD></DL>
<P>
<A NAME="vformatCreateDouble"><HR><H4>vformatCreateDouble</H4></A>
<PRE>
        vformatDouble * <B>vformatCreateDouble</B>();
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a double format.
</DD></DL>
<P>
<A NAME="vformatCreateDoubleSegment"><HR><H4>vformatCreateDoubleSegment</H4></A>
<PRE>
        vformatDoubleSegment * <B>vformatCreateDoubleSegment</B>();
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a double format segment.
</DD></DL>
<P>
<A NAME="vformatCreateDoubleSegmentIteratorOfClass"><HR><H4>vformatCreateDoubleSegmentIteratorOfClass</H4></A>
<PRE>
        void <B>vformatCreateDoubleSegmentIteratorOfClass</B>();
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a double format segment
iterator of the specified class.
</DD></DL>
<P>
<A NAME="vformatCreateDoubleSegmentOfClass"><HR><H4>vformatCreateDoubleSegmentOfClass</H4></A>
<PRE>
        vformatDoubleSegment * <B>vformatCreateDoubleSegmentOfClass</B>(
                vformatDoubleSegmentClass * clas);
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a double format segment
of the specified class.
</DD></DL>
<P>
<A NAME="vformatCreateLong"><HR><H4>vformatCreateLong</H4></A>
<PRE>
        vformatLong * <B>vformatCreateLong</B>();
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a long integer format.
</DD></DL>
<P>
<A NAME="vformatCreateLongSegment"><HR><H4>vformatCreateLongSegment</H4></A>
<PRE>
        vformatLongSegment * <B>vformatCreateLongSegment</B>();
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a long integer format
segment.
</DD></DL>
<P>
<A NAME="vformatCreateLongSegmentIteratorOfClass"><HR><H4>vformatCreateLongSegmentIteratorOfClass</H4></A>
<PRE>
        void <B>vformatCreateLongSegmentIteratorOfClass</B>();
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a long integer format
segment iterator of the specified class.
</DD></DL>
<P>
<A NAME="vformatCreateLongSegmentOfClass"><HR><H4>vformatCreateLongSegmentOfClass</H4></A>
<PRE>
        vformatLongSegment * <B>vformatCreateLongSegmentOfClass</B>(
                vformatLongSegmentClass * clas);
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a long integer format
segment of the specified class.
</DD></DL>
<P>
<A NAME="vformatCreateNumber"><HR><H4>vformatCreateNumber</H4></A>
<PRE>
        vformatNumber * <B>vformatCreateNumber</B>();
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a number format.
</DD></DL>
<P>
<A NAME="vformatCreateNumberSegment"><HR><H4>vformatCreateNumberSegment</H4></A>
<PRE>
        vformatNumberSegment * <B>vformatCreateNumberSegment</B>();
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a number format segment.
</DD></DL>
<P>
<A NAME="vformatCreateNumberSegmentIteratorOfClass"><HR><H4>vformatCreateNumberSegmentIteratorOfClass</H4></A>
<PRE>
        void <B>vformatCreateNumberSegmentIteratorOfClass</B>();
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a number format segment
iterator of the specified class.
</DD></DL>
<P>
<A NAME="vformatCreateNumberSegmentOfClass"><HR><H4>vformatCreateNumberSegmentOfClass</H4></A>
<PRE>
        vformatNumberSegment * <B>vformatCreateNumberSegmentOfClass</B>(
                vformatNumberSegmentClass * clas);
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a number format segment
of the specified class.
</DD></DL>
<P>
<A NAME="vformatCreateOfClass"><HR><H4>vformatCreateOfClass</H4></A>
<PRE>
        vformat * <B>vformatCreateOfClass</B>(
                vformatClass * clas);
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a format of the specified
class.
</DD></DL>
<P>
<A NAME="vformatCreateParseRange"><HR><H4>vformatCreateParseRange</H4></A>
<PRE>
        vformatParseRange * <B>vformatCreateParseRange</B>();
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a parse range.
</DD></DL>
<P>
<A NAME="vformatCreateParseRangeOfClass"><HR><H4>vformatCreateParseRangeOfClass</H4></A>
<PRE>
        vformatParseRange * <B>vformatCreateParseRangeOfClass</B>(
                vformatParseRangeClass * clas);
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a parse range of the
specified class.
</DD></DL>
<P>
<A NAME="vformatCreateSegment"><HR><H4>vformatCreateSegment</H4></A>
<PRE>
        vformatSegment * <B>vformatCreateSegment</B>();
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a format segment.
</DD></DL>
<P>
<A NAME="vformatCreateSegmentIteratorOfClass"><HR><H4>vformatCreateSegmentIteratorOfClass</H4></A>
<PRE>
        void <B>vformatCreateSegmentIteratorOfClass</B>();
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a format segment iterator
of the specified class.
</DD></DL>
<P>
<A NAME="vformatCreateSegmentOfClass"><HR><H4>vformatCreateSegmentOfClass</H4></A>
<PRE>
        vformatSegment * <B>vformatCreateSegmentOfClass</B>(
                vformatSegmentClass * clas);
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, a format segment of the
specified class.
</DD></DL>
<P>
<A NAME="vformatCreateULong"><HR><H4>vformatCreateULong</H4></A>
<PRE>
        vformatULong * <B>vformatCreateULong</B>();
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, an unsigned integer
format.
</DD></DL>
<P>
<A NAME="vformatCreateULongSegment"><HR><H4>vformatCreateULongSegment</H4></A>
<PRE>
        vformatULongSegment * <B>vformatCreateULongSegment</B>();
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, an unsigned integer
format segment.
</DD></DL>
<P>
<A NAME="vformatCreateULongSegmentIteratorOfClass"><HR><H4>vformatCreateULongSegmentIteratorOfClass</H4></A>
<PRE>
        void <B>vformatCreateULongSegmentIteratorOfClass</B>();
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, an unsigned integer
format segment iterator of the specified class.
</DD></DL>
<P>
<A NAME="vformatCreateULongSegmentOfClass"><HR><H4>vformatCreateULongSegmentOfClass</H4></A>
<PRE>
        vformatULongSegment * <B>vformatCreateULongSegmentOfClass</B>(
                vformatULongSegmentClass * clas);
</PRE>

<DL><DD>
Instantiates, and initializes to its default values, an unsigned integer
format segment of the specified class.
</DD></DL>
<P>
<A NAME="vformatDecrementParseRangeLength"><HR><H4>vformatDecrementParseRangeLength</H4></A>
<PRE>
        void <B>vformatDecrementParseRangeLength</B>(
                vformatParseRange * range,
                int len);
</PRE>

<DL><DD>
When valid pattern information can be extracted from the end of the parse
range, this method is used to update the new, unparsed, range length.
</DD></DL>
<P>
<A NAME="vformatDestroy"><HR><H4>vformatDestroy</H4></A>
<PRE>
        void <B>vformatDestroy</B>(
                vformat * format);
</PRE>

<DL><DD>
Releases any resources held by the format back to the system, effectively
causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyBoolean"><HR><H4>vformatDestroyBoolean</H4></A>
<PRE>
        void <B>vformatDestroyBoolean</B>(
                vformatBoolean * format);
</PRE>

<DL><DD>
Releases any resources held by the format back to the system, effectively
causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyBooleanPatternAt"><HR><H4>vformatDestroyBooleanPatternAt</H4></A>
<PRE>
        void <B>vformatDestroyBooleanPatternAt</B>(
                vformatBoolean * format,
                int index);
</PRE>

<DL><DD>
The <SAMP>index</SAMP> pattern is removed from the set and each of its
segments is destroyed.
<SAMP>index</SAMP> must refer to a valid pattern; it should be greater-
than or equal to 0, and less than the result of calling
<code><A HREF="vformat-x.html#vformatGetBooleanPatternCount"><CODE>vformatGetBooleanPatternCount</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatDestroyBooleanSegment"><HR><H4>vformatDestroyBooleanSegment</H4></A>
<PRE>
        void <B>vformatDestroyBooleanSegment</B>(
                vformatBooleanSegment * segment);
</PRE>

<DL><DD>
Releases any resources held by the boolean format segment back to the system,
effectively causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyBooleanSegmentIterator"><HR><H4>vformatDestroyBooleanSegmentIterator</H4></A>
<PRE>
        void <B>vformatDestroyBooleanSegmentIterator</B>();
</PRE>

<DL><DD>
Releases any resources held by the boolean format segment iterator back to the
system, effectively causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyDate"><HR><H4>vformatDestroyDate</H4></A>
<PRE>
        void <B>vformatDestroyDate</B>(
                vformatDate * format);
</PRE>

<DL><DD>
Releases any resources held by the date format back to the system, effectively
causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyDatePatternAt"><HR><H4>vformatDestroyDatePatternAt</H4></A>
<PRE>
        void <B>vformatDestroyDatePatternAt</B>(
                vformatDate * format,
                int index);
</PRE>

<DL><DD>
The <SAMP>index</SAMP> pattern is removed from the set and each of its
segments is destroyed.
<SAMP>index</SAMP> must refer to a valid pattern; it should be greater-
than or equal to 0 and less than the result of calling
<code><A HREF="vformat-x.html#vformatGetDatePatternCount"><CODE>vformatGetDatePatternCount</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatDestroyDateSegment"><HR><H4>vformatDestroyDateSegment</H4></A>
<PRE>
        void <B>vformatDestroyDateSegment</B>(
                vformatDateSegment * segment);
</PRE>

<DL><DD>
Releases any resources held by the date format segment back to the system,
effectively causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyDateSegmentIterator"><HR><H4>vformatDestroyDateSegmentIterator</H4></A>
<PRE>
        void <B>vformatDestroyDateSegmentIterator</B>();
</PRE>

<DL><DD>
Releases any resources held by the date format segment iterator back to the
system, effectively causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyDefaultNamedFormat"><HR><H4>vformatDestroyDefaultNamedFormat</H4></A>
<PRE>
        void <B>vformatDestroyDefaultNamedFormat</B>(
                const vname * name);
</PRE>

<DL><DD>
If the named format is not in the collection of defaults
at the time of invocation, this is a no-op.
</DD></DL>
<P>
<A NAME="vformatDestroyDouble"><HR><H4>vformatDestroyDouble</H4></A>
<PRE>
        void <B>vformatDestroyDouble</B>(
                vformatDouble * format);
</PRE>

<DL><DD>
Releases any resources held by the double format back to the system,
effectively causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyDoublePatternAt"><HR><H4>vformatDestroyDoublePatternAt</H4></A>
<PRE>
        void <B>vformatDestroyDoublePatternAt</B>(
                vformatDouble * format,
                int at);
</PRE>

<DL><DD>
The <SAMP>index</SAMP pattern is removed from the set and each of its
segments is destroyed.
<SAMP>Index</SAMP> must refer to a valid pattern; it should be greater-
than or equal-to 0 and less than the result of calling
<code>vformatGetDoublePatternCount</code>.
</DD></DL>
<P>
<A NAME="vformatDestroyDoubleSegment"><HR><H4>vformatDestroyDoubleSegment</H4></A>
<PRE>
        void <B>vformatDestroyDoubleSegment</B>(
                vformatDoubleSegment * segment);
</PRE>

<DL><DD>
Releases any resources held by the double format segment back to the system,
effectively causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyDoubleSegmentIterator"><HR><H4>vformatDestroyDoubleSegmentIterator</H4></A>
<PRE>
        void <B>vformatDestroyDoubleSegmentIterator</B>();
</PRE>

<DL><DD>
Releases any resources held by the double format segment iterator back to the
system, effectively causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyLong"><HR><H4>vformatDestroyLong</H4></A>
<PRE>
        void <B>vformatDestroyLong</B>(
                vformatLong * format);
</PRE>

<DL><DD>
Releases any resources held by the long integer format back to the system,
effectively causing the format to "go away."
</DD></DL>
<P>
<A NAME="vformatDestroyLongPatternAt"><HR><H4>vformatDestroyLongPatternAt</H4></A>
<PRE>
        void <B>vformatDestroyLongPatternAt</B>(
                vformatLong * format,
                int index);
</PRE>

<DL><DD>
The <SAMP>index</SAMP> pattern is removed from the set and each of its
segments is destroyed.
<SAMP>index</SAMP> must refer to a valid pattern; it should be greater-
than or equal to 0 and less than the result of calling
<code><A HREF="vformat-x.html#vformatGetLongPatternCount"><CODE>vformatGetLongPatternCount</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatDestroyLongSegment"><HR><H4>vformatDestroyLongSegment</H4></A>
<PRE>
        void <B>vformatDestroyLongSegment</B>(
                vformatLongSegment * segment);
</PRE>

<DL><DD>
Releases any resources held by the long integer format segment back to the
system, effectively causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyLongSegmentIterator"><HR><H4>vformatDestroyLongSegmentIterator</H4></A>
<PRE>
        void <B>vformatDestroyLongSegmentIterator</B>();
</PRE>

<DL><DD>
Releases any resources held by the long integer format segment iterator back
to the system, effectively causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyNumber"><HR><H4>vformatDestroyNumber</H4></A>
<PRE>
        void <B>vformatDestroyNumber</B>(
                vformatNumber * format);
</PRE>

<DL><DD>
Releases any resources held by the number format back to the system,
effectively causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyNumberPatternAt"><HR><H4>vformatDestroyNumberPatternAt</H4></A>
<PRE>
        void <B>vformatDestroyNumberPatternAt</B>(
                vformatNumber * format,
                int index);
</PRE>

<DL><DD>
The <SAMP>index</SAMP> pattern is removed from the set and each of its
segments are each destroyed.
<SAMP>index</SAMP> must refer to a valid pattern, that is it should be greater-
than or equal to 0 and less than the result of calling
<code><A HREF="vformat-x.html#vformatGetNumberPatternCount"><CODE>vformatGetNumberPatternCount</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatDestroyNumberSegment"><HR><H4>vformatDestroyNumberSegment</H4></A>
<PRE>
        void <B>vformatDestroyNumberSegment</B>(
                vformatNumberSegment * segment);
</PRE>

<DL><DD>
Releases any resources held by the number format segment back to the system,
effectively causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyNumberSegmentIterator"><HR><H4>vformatDestroyNumberSegmentIterator</H4></A>
<PRE>
        void <B>vformatDestroyNumberSegmentIterator</B>();
</PRE>

<DL><DD>
Releases any resources held by the number format segment iterator back to the
system, effectively causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyParseRange"><HR><H4>vformatDestroyParseRange</H4></A>
<PRE>
        void <B>vformatDestroyParseRange</B>(
                vformatParseRange * range);
</PRE>

<DL><DD>
Releases any resources held by the parse range back to the system, effectively
causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyPatternAt"><HR><H4>vformatDestroyPatternAt</H4></A>
<PRE>
        void <B>vformatDestroyPatternAt</B>(
                vformat * format,
                int index);
</PRE>

<DL><DD>
The specified <SAMP>index</SAMP> must be greater-than or equal to zero 
and less than the result of calling <code>GetPatternCount</code>.
If the specified pattern does not exist in the format's ordered 
set of patterns, Galaxy raises a <samp>BadArgument</samp> 
exception.
</DD></DL>
<P>
<A NAME="vformatDestroySegment"><HR><H4>vformatDestroySegment</H4></A>
<PRE>
        void <B>vformatDestroySegment</B>(
                vformatSegment * segment);
</PRE>

<DL><DD>
Releases any resources held by the format segment back to the system,
effectively causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroySegmentIterator"><HR><H4>vformatDestroySegmentIterator</H4></A>
<PRE>
        void <B>vformatDestroySegmentIterator</B>(
                vformatSegmentIterator * iterator);
</PRE>

<DL><DD>
Releases any resources held by the format segment iterator back to the system,
effectively causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyULong"><HR><H4>vformatDestroyULong</H4></A>
<PRE>
        void <B>vformatDestroyULong</B>(
                vformatULong * format);
</PRE>

<DL><DD>
Releases any resources held by the unsigned long format back to the system,
effectively causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyULongPatternAt"><HR><H4>vformatDestroyULongPatternAt</H4></A>
<PRE>
        void <B>vformatDestroyULongPatternAt</B>(
                vformatULong * format,
                int index);
</PRE>

<DL><DD>
The <SAMP>index</SAMP> pattern is removed from the set and each of its
segments are each destroyed.
<SAMP>index</SAMP> must refer to a valid pattern; it should be greater-
than or equal to 0 and less than the result of calling
<code><A HREF="vformat-x.html#vformatGetULongPatternCount"><CODE>vformatGetULongPatternCount</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatDestroyULongSegment"><HR><H4>vformatDestroyULongSegment</H4></A>
<PRE>
        void <B>vformatDestroyULongSegment</B>(
                vformatULongSegment * segment);
</PRE>

<DL><DD>
Releases any resources held by the unsigned long integer format segment back
to the system, effectively causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDestroyULongSegmentIterator"><HR><H4>vformatDestroyULongSegmentIterator</H4></A>
<PRE>
        void <B>vformatDestroyULongSegmentIterator</B>();
</PRE>

<DL><DD>
Releases any resources held by the unsigned long integer format segment
iterator back to the system, effectively causing the format to go away.
</DD></DL>
<P>
<A NAME="vformatDetermineBooleanValidity"><HR><H4>vformatDetermineBooleanValidity</H4></A>
<PRE>
        int <B>vformatDetermineBooleanValidity</B>(
                vformatBoolean * format,
                const vchar * string);
</PRE>

<DL><DD>
The format returns an indication of the validity of the input string
with respect to its constituent patterns. Possible return values include:

<ul>
<li>vformatINVALID,
<li>vformatPARTIALLY_VALID
<li>vformatVALID
</ul>

This method never raises an exception. It is a convenience method that
makes use of <code><A HREF="vformat-x.html#vformatIsBooleanValid"><CODE>vformatIsBooleanValid</CODE></A></code> and 
<code><A HREF="vformat-x.html#vformatIsBooleanPartiallyValid"><CODE>vformatIsBooleanPartiallyValid</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatDetermineDateValidity"><HR><H4>vformatDetermineDateValidity</H4></A>
<PRE>
        int <B>vformatDetermineDateValidity</B>(
                vformatDate * format,
                const vchar * string);
</PRE>

<DL><DD>
The format returns an indication of the validity of the input string
with respect to its constituent patterns. Possible return values include:

<ul>
<li>vformatINVALID,
<li>vformatPARTIALLY_VALID
<li>vformatVALID
</ul>

This method never raises an exception. It is a convenience method that
makes use of <code><A HREF="vformat-x.html#vformatIsBooleanValid"><CODE>vformatIsBooleanValid</CODE></A></code> and 
<code><A HREF="vformat-x.html#vformatIsBooleanPartiallyValid"><CODE>vformatIsBooleanPartiallyValid</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatDetermineDoubleValidity"><HR><H4>vformatDetermineDoubleValidity</H4></A>
<PRE>
        int <B>vformatDetermineDoubleValidity</B>(
                vformatDouble * format,
                const vchar * string);
</PRE>

<DL><DD>
The format returns an indication of the validity of the input string
with respect to its constituent patterns. Possible return values include:

<ul>
<li>vformatINVALID,
<li>vformatPARTIALLY_VALID
<li>vformatVALID
</ul>

This method never raises an exception. It is a convenience method that
makes use of <code><A HREF="vformat-x.html#vformatIsBooleanValid"><CODE>vformatIsBooleanValid</CODE></A></code> and 
<code><A HREF="vformat-x.html#vformatIsBooleanPartiallyValid"><CODE>vformatIsBooleanPartiallyValid</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatDetermineLongValidity"><HR><H4>vformatDetermineLongValidity</H4></A>
<PRE>
        int <B>vformatDetermineLongValidity</B>(
                vformatLong * format,
                const vchar * string);
</PRE>

<DL><DD>
The format returns an indication of the validity of the input string
with respect to its constituent patterns. Possible return values include:

<ul>
<li>vformatINVALID,
<li>vformatPARTIALLY_VALID
<li>vformatVALID
</ul>

This method never raises an exception. It is a convenience method that
makes use of <code><A HREF="vformat-x.html#vformatIsBooleanValid"><CODE>vformatIsBooleanValid</CODE></A></code> and 
<code><A HREF="vformat-x.html#vformatIsBooleanPartiallyValid"><CODE>vformatIsBooleanPartiallyValid</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatDetermineNumberValidity"><HR><H4>vformatDetermineNumberValidity</H4></A>
<PRE>
        int <B>vformatDetermineNumberValidity</B>(
                vformatNumber * format,
                const vchar * string);
</PRE>

<DL><DD>
The format returns an indication of the validity of the input string
with respect to its constituent patterns. Possible return values include:

<ul>
<li>vformatINVALID,
<li>vformatPARTIALLY_VALID
<li>vformatVALID
</ul>

This method never raises an exception. It is a convenience method that
makes use of <code><A HREF="vformat-x.html#vformatIsBooleanValid"><CODE>vformatIsBooleanValid</CODE></A></code> and 
<code><A HREF="vformat-x.html#vformatIsBooleanPartiallyValid"><CODE>vformatIsBooleanPartiallyValid</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatDetermineULongValidity"><HR><H4>vformatDetermineULongValidity</H4></A>
<PRE>
        int <B>vformatDetermineULongValidity</B>(
                vformatULong * format,
                const vchar * string);
</PRE>

<DL><DD>
The format returns an indication of the validity of the input string
with respect to its constituent patterns. Possible return values include:

<ul>
<li>vformatINVALID,
<li>vformatPARTIALLY_VALID
<li>vformatVALID
</ul>

This method never raises an exception. It is a convenience method that
makes use of <code><A HREF="vformat-x.html#vformatIsBooleanValid"><CODE>vformatIsBooleanValid</CODE></A></code> and 
<code><A HREF="vformat-x.html#vformatIsBooleanPartiallyValid"><CODE>vformatIsBooleanPartiallyValid</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatDetermineValidity"><HR><H4>vformatDetermineValidity</H4></A>
<PRE>
        int <B>vformatDetermineValidity</B>(
                vformat * format,
                const vchar * string);
</PRE>

<DL><DD>
The format returns an indication of the validity of the input string
with respect to its constituent patterns. Possible return values include:

<ul>
<li>vformatVALID
<li>vformatPARTIALLY_VALID
<li>vformatINVALID
</ul>

This method never raises an exception. It is a convenience method that
makes use of <samp><A HREF="vformat-x.html#vformatIsValid"><CODE>vformatIsValid</CODE></A></samp> and 
<samp><A HREF="vformat-x.html#vformatIsPartiallyValid"><CODE>vformatIsPartiallyValid</CODE></A></samp>.
</DD></DL>
<P>
<A NAME="vformatDump"><HR><H4>vformatDump</H4></A>
<PRE>
        void <B>vformatDump</B>(
                vformat * format,
                FILE * stream);
</PRE>

<DL><DD>
Prints the contents of the <SAMP>format</SAMP> on the file <SAMP>stream</SAMP>
in user-readable form. This function is intended for debugging and should not
be used to store the contents of the format in recoverable form. This function
has effect only if debugging is enabled. This function is implemented by
sending the message <CODE>vobjectDUMP</CODE> to <SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatDumpBoolean"><HR><H4>vformatDumpBoolean</H4></A>
<PRE>
        void <B>vformatDumpBoolean</B>(
                vformatBoolean * format,
                FILE * stream);
</PRE>

<DL><DD>
Prints the contents of the boolean <SAMP>format</SAMP> on the file
<SAMP>stream</SAMP> in user-readable form. This function is intended for
debugging and should not be used to store the contents of the format in
recoverable form. This function has effect only if debugging is enabled.
This function is implemented by sending the message <CODE>vobjectDUMP</CODE>
to <SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatDumpBooleanSegment"><HR><H4>vformatDumpBooleanSegment</H4></A>
<PRE>
        void <B>vformatDumpBooleanSegment</B>(
                const vformatBooleanSegment * segment,
                FILE * stream);
</PRE>

<DL><DD>
Prints the contents of the boolean format <SAMP>segment</SAMP> on the file
<SAMP>stream</SAMP> in user-readable form. This function is intended for
debugging and should not be used to store the contents of the segment in
recoverable form. This function has effect only if debugging is enabled.
This function is implemented by sending the message <CODE>vobjectDUMP</CODE>
to <SAMP>segment</SAMP>.
</DD></DL>
<P>
<A NAME="vformatDumpDate"><HR><H4>vformatDumpDate</H4></A>
<PRE>
        void <B>vformatDumpDate</B>(
                vformatDate * format,
                FILE * stream);
</PRE>

<DL><DD>
Prints the contents of the date <SAMP>format</SAMP> on the file
<SAMP>stream</SAMP> in user-readable form. This function is intended for
debugging and should not be used to store the contents of the format in
recoverable form. This function has effect only if debugging is enabled.
This function is implemented by sending the message <CODE>vobjectDUMP</CODE>
to <SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatDumpDateSegment"><HR><H4>vformatDumpDateSegment</H4></A>
<PRE>
        void <B>vformatDumpDateSegment</B>(
                const vformatDateSegment * segment,
                FILE * stream);
</PRE>

<DL><DD>
Prints the contents of the date format <SAMP>segment</SAMP> on the file
<SAMP>stream</SAMP> in user-readable form. This function is intended for
debugging and should not be used to store the contents of the segment in
recoverable form. This function has effect only if debugging is enabled.
This function is implemented by sending the message <CODE>vobjectDUMP</CODE>
to date format <SAMP>segment</SAMP>.
</DD></DL>
<P>
<A NAME="vformatDumpDouble"><HR><H4>vformatDumpDouble</H4></A>
<PRE>
        void <B>vformatDumpDouble</B>(
                vformatDouble * format,
                FILE * stream);
</PRE>

<DL><DD>
Prints the contents of the double <SAMP>format</SAMP> on the file
<SAMP>stream</SAMP> in user-readable form. This function is intended for
debugging and should not be used to store the contents of the format in
recoverable form. This function has effect only if debugging is enabled.
This function is implemented by sending the message <CODE>vobjectDUMP</CODE>
to double <SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatDumpDoubleSegment"><HR><H4>vformatDumpDoubleSegment</H4></A>
<PRE>
        void <B>vformatDumpDoubleSegment</B>(
                const vformatDoubleSegment * segment,
                FILE * stream);
</PRE>

<DL><DD>
Prints the contents of the double format <SAMP>segment</SAMP> on the file
<SAMP>stream</SAMP> in user-readable form. This function is intended for
debugging and should not be used to store the contents of the segment in
recoverable form. This function has effect only if debugging is enabled.
This function is implemented by sending the message <CODE>vobjectDUMP</CODE>
to double format <SAMP>segment</SAMP>.
</DD></DL>
<P>
<A NAME="vformatDumpLong"><HR><H4>vformatDumpLong</H4></A>
<PRE>
        void <B>vformatDumpLong</B>(
                vformatLong * format,
                FILE * stream);
</PRE>

<DL><DD>
Prints the contents of the long integer <SAMP>format</SAMP> on the file
<SAMP>stream</SAMP> in user-readable form. This function is intended for
debugging and should not be used to store the contents of the format in
recoverable form. This function has effect only if debugging is enabled.
This function is implemented by sending the message <CODE>vobjectDUMP</CODE>
to long integer <SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatDumpLongSegment"><HR><H4>vformatDumpLongSegment</H4></A>
<PRE>
        void <B>vformatDumpLongSegment</B>(
                const vformatLongSegment * segment,
                FILE * stream);
</PRE>

<DL><DD>
Prints the contents of the long integer format <SAMP>segment</SAMP> on the file
<SAMP>stream</SAMP> in user-readable form. This function is intended for
debugging and should not be used to store the contents of the segment in
recoverable form. This function has effect only if debugging is enabled.
This function is implemented by sending the message <CODE>vobjectDUMP</CODE>
to long integer format <SAMP>segment</SAMP>.
</DD></DL>
<P>
<A NAME="vformatDumpNumber"><HR><H4>vformatDumpNumber</H4></A>
<PRE>
        void <B>vformatDumpNumber</B>(
                vformatNumber * format,
                FILE * stream);
</PRE>

<DL><DD>
Prints the contents of the number <SAMP>format</SAMP> on the file
<SAMP>stream</SAMP> in user-readable form. This function is intended for
debugging and should not be used to store the contents of the format in
recoverable form. This function has effect only if debugging is enabled.
This function is implemented by sending the message <CODE>vobjectDUMP</CODE>
to number <SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatDumpNumberSegment"><HR><H4>vformatDumpNumberSegment</H4></A>
<PRE>
        void <B>vformatDumpNumberSegment</B>(
                const vformatNumberSegment * segment,
                FILE * stream);
</PRE>

<DL><DD>
Prints the contents of the number format <SAMP>segment</SAMP> on the file
<SAMP>stream</SAMP> in user-readable form. This function is intended for
debugging and should not be used to store the contents of the segment in
recoverable form. This function has effect only if debugging is enabled.
This function is implemented by sending the message <CODE>vobjectDUMP</CODE>
to number format <SAMP>segment</SAMP>.
</DD></DL>
<P>
<A NAME="vformatDumpParseRange"><HR><H4>vformatDumpParseRange</H4></A>
<PRE>
        void <B>vformatDumpParseRange</B>(
                const vformatParseRange * range,
                FILE * stream);
</PRE>

<DL><DD>
Prints the contents of the <SAMP>range</SAMP> on the file <SAMP>stream</SAMP>
in user-readable form. This function is intended for debugging and should not
be used to store the contents of the parse range in recoverable form. This
function has effect only if debugging is enabled. This function is implemented
by sending the message <CODE>vobjectDUMP</CODE> to <SAMP>range</SAMP>.
</DD></DL>
<P>
<A NAME="vformatDumpSegment"><HR><H4>vformatDumpSegment</H4></A>
<PRE>
        void <B>vformatDumpSegment</B>(
                const vformatSegment * segment,
                FILE * stream);
</PRE>

<DL><DD>
This method can only be successfully used in a debug environment.
</DD></DL>
<P>
<A NAME="vformatDumpULong"><HR><H4>vformatDumpULong</H4></A>
<PRE>
        void <B>vformatDumpULong</B>(
                vformatULong * format,
                FILE * stream);
</PRE>

<DL><DD>
Prints the contents of the unsigned long integer <SAMP>format</SAMP> on the
file <SAMP>stream</SAMP> in user-readable form. This function is intended for
debugging and should not be used to store the contents of the parse range in
recoverable form. This function has effect only if debugging is enabled. This
function is implemented by sending the message <CODE>vobjectDUMP</CODE> to
<SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatDumpULongSegment"><HR><H4>vformatDumpULongSegment</H4></A>
<PRE>
        void <B>vformatDumpULongSegment</B>(
                const vformatULongSegment * segment,
                FILE * stream);
</PRE>

<DL><DD>
Prints the contents of the unsigned long integer format <SAMP>segment</SAMP>
on the file <SAMP>stream</SAMP> in user-readable form. This function is
intended for debugging and should not be used to store the contents of the
segment in recoverable form. This function has effect only if debugging is
enabled. This function is implemented by sending the message
<CODE>vobjectDUMP</CODE> to <SAMP>segment</SAMP>.
</DD></DL>
<P>
<A NAME="vformatERROR_CODE"><HR><H4>vformatERROR_CODE</H4></A>
<PRE>
        void <B>vformatERROR_CODE</B>(
                void * exception,
                va_list * ap);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatGetBooleanBase"><HR><H4>vformatGetBooleanBase</H4></A>
<PRE>
        vformat * <B>vformatGetBooleanBase</B>(
                vformatBoolean * format);
</PRE>

<DL><DD>
Returns a pointer to the <code>vformat</code> portion of the 
boolean format instance.
</DD></DL>
<P>
<A NAME="vformatGetBooleanClass"><HR><H4>vformatGetBooleanClass</H4></A>
<PRE>
        vformatBooleanClass * <B>vformatGetBooleanClass</B>(
                vformatBoolean * format);
</PRE>

<DL><DD>
Returns the class of the boolean Format <SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatGetBooleanLoadable"><HR><H4>vformatGetBooleanLoadable</H4></A>
<PRE>
        vloadable * <B>vformatGetBooleanLoadable</B>(
                vformatBoolean * format);
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vloadable-x.html#vloadable"><CODE>vloadable</CODE></A></code> portion of the 
boolean format instance.
</DD></DL>
<P>
<A NAME="vformatGetBooleanOutputPatternIndex"><HR><H4>vformatGetBooleanOutputPatternIndex</H4></A>
<PRE>
        int <B>vformatGetBooleanOutputPatternIndex</B>(
                vformatBoolean * format);
</PRE>

<DL><DD>
Returns the index of the pattern to be used for generating an output form of
a boolean value.
</DD></DL>
<P>
<A NAME="vformatGetBooleanOutputSegment"><HR><H4>vformatGetBooleanOutputSegment</H4></A>
<PRE>
        const vformatBooleanSegment * <B>vformatGetBooleanOutputSegment</B>(
                vformatBoolean * format,
                vbool value);
</PRE>

<DL><DD>
Dialog items that hold an associated <code><A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A></code>, 
such as <samp><A HREF="vboolitem-x.html#vboolitem"><CODE>vboolitem</CODE></A></samp>, can make use of this method (when the value they 
are representing changes) to update any graphical characteristics 
bound to the value, such as the foreground color, or text alignment.
</DD></DL>
<P>
<A NAME="vformatGetBooleanOutputSegmentIndex"><HR><H4>vformatGetBooleanOutputSegmentIndex</H4></A>
<PRE>
        int <B>vformatGetBooleanOutputSegmentIndex</B>(
                vformatBoolean * format,
                vbool value);
</PRE>

<DL><DD>
Used internally by the Scribe methods.
</DD></DL>
<P>
<A NAME="vformatGetBooleanPatternCount"><HR><H4>vformatGetBooleanPatternCount</H4></A>
<PRE>
        long <B>vformatGetBooleanPatternCount</B>(
                const vformatBoolean * format);
</PRE>

<DL><DD>
Returns the number of patterns contained by the boolean format.
</DD></DL>
<P>
<A NAME="vformatGetBooleanPatternSegmentAt"><HR><H4>vformatGetBooleanPatternSegmentAt</H4></A>
<PRE>
        const vformatBooleanSegment * <B>vformatGetBooleanPatternSegmentAt</B>(
                vformatBoolean * format,
                int patternIndex,
                int segmentIndex);
</PRE>

<DL><DD>
The <SAMP>patternIndex</SAMP> must be greater-than or equal to zero and less
than the result of calling <code><A HREF="vformat-x.html#vformatGetBooleanPatternCount"><CODE>vformatGetBooleanPatternCount</CODE></A></code>. 
The <SAMP>segmentIndex</SAMP> must be greater-than or equal to 
zero and less than the result of calling 
<code><A HREF="vformat-x.html#vformatGetBooleanSegmentCount"><CODE>vformatGetBooleanSegmentCount</CODE></A></code>. 
A call to this method always returns a non-null object.
</DD></DL>
<P>
<A NAME="vformatGetBooleanSegmentAlignment"><HR><H4>vformatGetBooleanSegmentAlignment</H4></A>
<PRE>
        int <B>vformatGetBooleanSegmentAlignment</B>(
                vformatBooleanSegment * segment);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatBooleanSegment"><CODE>vformatBooleanSegment</CODE></A></code> class supports 
the ability to specify color and text alignment. 
A text alignment may be specified with the 
following pattern syntax:

<pre>
  "{this is a left aligned string"
  "}this is a right aligned string"
  "|this is a centered string"
</pre>

<P>
The text alignment codes returned are:

<ul>
<li>vformatALIGN_LEFT [default]
<li>vformatALIGN_RIGHT
<li>vformatALIGN_CENTER
</ul>
</DD></DL>
<P>
<A NAME="vformatGetBooleanSegmentBase"><HR><H4>vformatGetBooleanSegmentBase</H4></A>
<PRE>
        vformatSegment * <B>vformatGetBooleanSegmentBase</B>(
                vformatBooleanSegment * segment);
</PRE>

<DL><DD>
Returns a pointer to the <CODE><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> 
portion of the boolean format segment instance.
</DD></DL>
<P>
<A NAME="vformatGetBooleanSegmentColor"><HR><H4>vformatGetBooleanSegmentColor</H4></A>
<PRE>
        vcolor * <B>vformatGetBooleanSegmentColor</B>(
                vformatBooleanSegment * segment);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> class supports 
the ability to specify color and textutal alignment for a segment. 
For example, to specify that a <code><A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A></code> 
"negative" segment has a red color attribute, use the following pattern.

<Pre>
  "true:[red]false"
</Pre>

The segment's color and alignment attributes are not used 
by the <code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes, 
but are meant to be used by higher-level,
user-interface constructs, such as a spreadsheet cell formatter, or database
form.
</DD></DL>
<P>
<A NAME="vformatGetBooleanSegmentCount"><HR><H4>vformatGetBooleanSegmentCount</H4></A>
<PRE>
        int <B>vformatGetBooleanSegmentCount</B>(
                vformatBoolean * format);
</PRE>

<DL><DD>
Does not raise an exception.
</DD></DL>
<P>
<A NAME="vformatGetBooleanSegmentFormat"><HR><H4>vformatGetBooleanSegmentFormat</H4></A>
<PRE>
        const vchar * <B>vformatGetBooleanSegmentFormat</B>(
                vformatBooleanSegment * segment);
</PRE>

<DL><DD>
This is the string that is used for comparisons when parsing an input string
to determine its boolean value.
</DD></DL>
<P>
<A NAME="vformatGetBooleanSegmentInstance"><HR><H4>vformatGetBooleanSegmentInstance</H4></A>
<PRE>
        vinstance * <B>vformatGetBooleanSegmentInstance</B>(
                vformatBooleanSegment * segment);
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></code> portion of the 
boolean format segment object.
</DD></DL>
<P>
<A NAME="vformatGetBooleanSegmentIteratorBase"><HR><H4>vformatGetBooleanSegmentIteratorBase</H4></A>
<PRE>
        void <B>vformatGetBooleanSegmentIteratorBase</B>();
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vformat-x.html#vformatSegmentIterator"><CODE>vformatSegmentIterator</CODE></A></code> 
portion of the boolean format segement iterator object.
</DD></DL>
<P>
<A NAME="vformatGetBooleanSegmentIteratorClass"><HR><H4>vformatGetBooleanSegmentIteratorClass</H4></A>
<PRE>
        void <B>vformatGetBooleanSegmentIteratorClass</B>();
</PRE>

<DL><DD>
Returns a pointer to the default boolean format segment iterator class.
</DD></DL>
<P>
<A NAME="vformatGetBooleanSegmentIteratorFormat"><HR><H4>vformatGetBooleanSegmentIteratorFormat</H4></A>
<PRE>
        void <B>vformatGetBooleanSegmentIteratorFormat</B>();
</PRE>

<DL><DD>
Returns a pointer to the boolean format on which this segment iterator has been
created.
</DD></DL>
<P>
<A NAME="vformatGetBooleanSegmentIteratorInstance"><HR><H4>vformatGetBooleanSegmentIteratorInstance</H4></A>
<PRE>
        void <B>vformatGetBooleanSegmentIteratorInstance</B>();
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></code> portion of the 
boolean format segment iterator object.
</DD></DL>
<P>
<A NAME="vformatGetBooleanSegmentIteratorIterator"><HR><H4>vformatGetBooleanSegmentIteratorIterator</H4></A>
<PRE>
        void <B>vformatGetBooleanSegmentIteratorIterator</B>();
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="viterator-x.html#viterator"><CODE>viterator</CODE></A></code> portion of the 
boolean format segment iterator object.
</DD></DL>
<P>
<A NAME="vformatGetBooleanSegmentIteratorPatternIndex"><HR><H4>vformatGetBooleanSegmentIteratorPatternIndex</H4></A>
<PRE>
        void <B>vformatGetBooleanSegmentIteratorPatternIndex</B>();
</PRE>

<DL><DD>
Returns the index of the current boolean format pattern in the sequence.
</DD></DL>
<P>
<A NAME="vformatGetBooleanSegmentIteratorSegment"><HR><H4>vformatGetBooleanSegmentIteratorSegment</H4></A>
<PRE>
        void <B>vformatGetBooleanSegmentIteratorSegment</B>();
</PRE>

<DL><DD>
Returns a pointer to the current <code><A HREF="vformat-x.html#vformatBooleanSegment"><CODE>vformatBooleanSegment</CODE></A></code> 
in the sequence.
</DD></DL>
<P>
<A NAME="vformatGetBooleanSegmentIteratorSegmentIndex"><HR><H4>vformatGetBooleanSegmentIteratorSegmentIndex</H4></A>
<PRE>
        void <B>vformatGetBooleanSegmentIteratorSegmentIndex</B>();
</PRE>

<DL><DD>
Returns the pattern-relative index of the current 
<code><A HREF="vformat-x.html#vformatBooleanSegment"><CODE>vformatBooleanSegment</CODE></A></code> in the sequence.
</DD></DL>
<P>
<A NAME="vformatGetBooleanSegmentString"><HR><H4>vformatGetBooleanSegmentString</H4></A>
<PRE>
        const vchar * <B>vformatGetBooleanSegmentString</B>(
                vformatBooleanSegment * segment);
</PRE>

<DL><DD>
This is the segment's portion of the original pattern strings set by
<code><A HREF="vformat-x.html#vformatAppendBooleanPattern"><CODE>vformatAppendBooleanPattern</CODE></A></code> or 
<code><A HREF="vformat-x.html#vformatInsertBooleanPattern"><CODE>vformatInsertBooleanPattern</CODE></A></code>.
This function is used internally by <code>vformatGetBooleanPatternAt</code> 
to reconstruct the original pattern string.
</DD></DL>
<P>
<A NAME="vformatGetClass"><HR><H4>vformatGetClass</H4></A>
<PRE>
        vformatClass * <B>vformatGetClass</B>(
                vformat * format);
</PRE>

<DL><DD>
Returns the format class of the format <SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatGetDateBase"><HR><H4>vformatGetDateBase</H4></A>
<PRE>
        vformat * <B>vformatGetDateBase</B>(
                vformatDate * format);
</PRE>

<DL><DD>
Returns a pointer to the <code>vformat</code> portion of the date format
<SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatGetDateClass"><HR><H4>vformatGetDateClass</H4></A>
<PRE>
        vformatDateClass * <B>vformatGetDateClass</B>(
                vformatDate * format);
</PRE>

<DL><DD>
Returns the date format class of the date format <SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatGetDateLoadable"><HR><H4>vformatGetDateLoadable</H4></A>
<PRE>
        vloadable * <B>vformatGetDateLoadable</B>(
                vformatDate * format);
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vloadable-x.html#vloadable"><CODE>vloadable</CODE></A></code> portion of the date format
<SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatGetDateOutputPatternIndex"><HR><H4>vformatGetDateOutputPatternIndex</H4></A>
<PRE>
        int <B>vformatGetDateOutputPatternIndex</B>(
                vformatDate * format);
</PRE>

<DL><DD>
The returned value is greater-than zero and less-than the result of
calling <code><A HREF="vformat-x.html#vformatGetDatePatternCount"><CODE>vformatGetDatePatternCount</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatGetDateOutputSegment"><HR><H4>vformatGetDateOutputSegment</H4></A>
<PRE>
        const vformatDateSegment * <B>vformatGetDateOutputSegment</B>(
                vformatDate * format,
                const vdate * value);
</PRE>

<DL><DD>
When the represented value changes, dialog items that hold an associated 
<code><A HREF="vformat-x.html#vformatDate"><CODE>vformatDate</CODE></A></code>, such as <code><A HREF="vdateitem-x.html#vdateitem"><CODE>vdateitem</CODE></A></code>, can make use of this 
method to update any graphical characteristics bound to the value; examples 
include foreground color, or text alignment.
</DD></DL>
<P>
<A NAME="vformatGetDateOutputSegmentIndex"><HR><H4>vformatGetDateOutputSegmentIndex</H4></A>
<PRE>
        int <B>vformatGetDateOutputSegmentIndex</B>(
                vformatDate * format,
                const vdate * value);
</PRE>

<DL><DD>
Used internally by the Scribe methods.
</DD></DL>
<P>
<A NAME="vformatGetDatePatternCount"><HR><H4>vformatGetDatePatternCount</H4></A>
<PRE>
        long <B>vformatGetDatePatternCount</B>(
                const vformatDate * format);
</PRE>

<DL><DD>
Returns the number of patterns contained by the date format.
</DD></DL>
<P>
<A NAME="vformatGetDatePatternSegmentAt"><HR><H4>vformatGetDatePatternSegmentAt</H4></A>
<PRE>
        const vformatDateSegment * <B>vformatGetDatePatternSegmentAt</B>(
                vformatDate * format,
                int patternIndex,
                int segmentIndex);
</PRE>

<DL><DD>
The <SAMP>patternIndex</SAMP> must be greater-than or equal to zero and less
than the result of calling <code><A HREF="vformat-x.html#vformatGetDatePatternCount"><CODE>vformatGetDatePatternCount</CODE></A></code>. The
<SAMP>segmentIndex</SAMP> must be greater-than or equal to zero and less than
the result of calling <code><A HREF="vformat-x.html#vformatGetDateSegmentCount"><CODE>vformatGetDateSegmentCount</CODE></A></code>. 
Always return a non-null object.
</DD></DL>
<P>
<A NAME="vformatGetDateSegmentAlignment"><HR><H4>vformatGetDateSegmentAlignment</H4></A>
<PRE>
        int <B>vformatGetDateSegmentAlignment</B>(
                const vformatDateSegment * segment);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatDateSegment"><CODE>vformatDateSegment</CODE></A></code> class supports 
the ability to specify color and text alignment. 
A text alignment may be specified with the following pattern syntax.

<Pre>

      "{mm/dd/yy" // left-aligned date
      "}mm/dd/yy" // right-aligned date
      "|mm/dd/yy" // centered date
</Pre>

<P>
The text alignment codes returned are:

<ul>
<li>vformatALIGN_LEFT [default]
<li>vformatALIGN_RIGHT
<li>vformatALIGN_CENTER
</ul>

</DD></DL>
<P>
<A NAME="vformatGetDateSegmentBase"><HR><H4>vformatGetDateSegmentBase</H4></A>
<PRE>
        vformatSegment * <B>vformatGetDateSegmentBase</B>(
                vformatDateSegment * segment);
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> 
portion of the date format segment object.
</DD></DL>
<P>
<A NAME="vformatGetDateSegmentColor"><HR><H4>vformatGetDateSegmentColor</H4></A>
<PRE>
        vcolor * <B>vformatGetDateSegmentColor</B>(
                const vformatDateSegment * segment);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> class supports the ability 
to specify color and text alignment for a segment. For example, 
to specify that a <code><A HREF="vformat-x.html#vformatDateSegment"><CODE>vformatDateSegment</CODE></A></code> have a red color 
attribute, use the following pattern.

<Pre>
  "[red]mm.dd.yyyy"
</Pre>

<P>
The segment's color and alignment attributes are not used by classes 
derived from <code>vformat<code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code>, 
but are meant to be used by higher-level, user-interface constructs, 
such as a spreadsheet cell formatter, or database form.
</DD></DL>
<P>
<A NAME="vformatGetDateSegmentCount"><HR><H4>vformatGetDateSegmentCount</H4></A>
<PRE>
        int <B>vformatGetDateSegmentCount</B>(
                vformatDate * format);
</PRE>

<DL><DD>
A date format pattern contains a single segment, representing a single
date/time value in the form of a <code><A HREF="vdate-x.html#vdate"><CODE>vdate</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatGetDateSegmentFormat"><HR><H4>vformatGetDateSegmentFormat</H4></A>
<PRE>
        vdateFormat * <B>vformatGetDateSegmentFormat</B>(
                const vformatDateSegment * segment);
</PRE>

<DL><DD>
Returns the <code><A HREF="vdate-x.html#vdateFormat"><CODE>vdateFormat</CODE></A></code> the segment uses for 
parsing and generating output forms of a <code><A HREF="vdate-x.html#vdate"><CODE>vdate</CODE></A></code> value.
</DD></DL>
<P>
<A NAME="vformatGetDateSegmentInstance"><HR><H4>vformatGetDateSegmentInstance</H4></A>
<PRE>
        vinstance * <B>vformatGetDateSegmentInstance</B>(
                vformatDateSegment * segment);
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></code> portion of the 
date format segment.
</DD></DL>
<P>
<A NAME="vformatGetDateSegmentIteratorBase"><HR><H4>vformatGetDateSegmentIteratorBase</H4></A>
<PRE>
        void <B>vformatGetDateSegmentIteratorBase</B>();
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vformat-x.html#vformatSegmentIterator"><CODE>vformatSegmentIterator</CODE></A></code> 
portion of the date format segment iterator.
</DD></DL>
<P>
<A NAME="vformatGetDateSegmentIteratorClass"><HR><H4>vformatGetDateSegmentIteratorClass</H4></A>
<PRE>
        void <B>vformatGetDateSegmentIteratorClass</B>();
</PRE>

<DL><DD>
Returns the date format segment iterator class of <SAMP>iterator</SAMP>.
</DD></DL>
<P>
<A NAME="vformatGetDateSegmentIteratorFormat"><HR><H4>vformatGetDateSegmentIteratorFormat</H4></A>
<PRE>
        void <B>vformatGetDateSegmentIteratorFormat</B>();
</PRE>

<DL><DD>
A <code><A HREF="vformat-x.html#vformatDateSegmentIterator"><CODE>vformatDateSegmentIterator</CODE></A></code> is initialized by a call to
<code><A HREF="vformat-x.html#vformatInitDateSegmentIterator"><CODE>vformatInitDateSegmentIterator</CODE></A></code>, 
taking as a parameter a pointer to the <code><A HREF="vformat-x.html#vformatDate"><CODE>vformatDate</CODE></A></code> 
over whose segments the iterator passes. 
This accessor method returns a pointer to that date format.
</DD></DL>
<P>
<A NAME="vformatGetDateSegmentIteratorInstance"><HR><H4>vformatGetDateSegmentIteratorInstance</H4></A>
<PRE>
        void <B>vformatGetDateSegmentIteratorInstance</B>();
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></code> portion of the 
date format segment iterator.
</DD></DL>
<P>
<A NAME="vformatGetDateSegmentIteratorIterator"><HR><H4>vformatGetDateSegmentIteratorIterator</H4></A>
<PRE>
        void <B>vformatGetDateSegmentIteratorIterator</B>();
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="viterator-x.html#viterator"><CODE>viterator</CODE></A></code> portion of the 
date format segment iterator.
</DD></DL>
<P>
<A NAME="vformatGetDateSegmentIteratorPatternIndex"><HR><H4>vformatGetDateSegmentIteratorPatternIndex</H4></A>
<PRE>
        void <B>vformatGetDateSegmentIteratorPatternIndex</B>();
</PRE>

<DL><DD>
Returns the index of the current date format pattern in the sequence.
</DD></DL>
<P>
<A NAME="vformatGetDateSegmentIteratorSegment"><HR><H4>vformatGetDateSegmentIteratorSegment</H4></A>
<PRE>
        void <B>vformatGetDateSegmentIteratorSegment</B>();
</PRE>

<DL><DD>
Returns a pointer to the current <code><A HREF="vformat-x.html#vformatDateSegment"><CODE>vformatDateSegment</CODE></A></code> 
in the sequence.
</DD></DL>
<P>
<A NAME="vformatGetDateSegmentIteratorSegmentIndex"><HR><H4>vformatGetDateSegmentIteratorSegmentIndex</H4></A>
<PRE>
        void <B>vformatGetDateSegmentIteratorSegmentIndex</B>();
</PRE>

<DL><DD>
Returns the pattern-relative index of the current 
<code><A HREF="vformat-x.html#vformatDateSegment"><CODE>vformatDateSegment</CODE></A></code> in the sequence.
</DD></DL>
<P>
<A NAME="vformatGetDateSegmentString"><HR><H4>vformatGetDateSegmentString</H4></A>
<PRE>
        const vchar * <B>vformatGetDateSegmentString</B>(
                const vformatDateSegment * segment);
</PRE>

<DL><DD>
This is the segment's portion of the original pattern strings set by
<code><A HREF="vformat-x.html#vformatAppendDatePattern"><CODE>vformatAppendDatePattern</CODE></A></code> or 
</code><A HREF="vformat-x.html#vformatInsertDatePattern"><CODE>vformatInsertDatePattern</CODE></A></code>. This function is 
used internally by <code>vformatGetDatePatternAt</code> to
reconstruct the original pattern string.
</DD></DL>
<P>
<A NAME="vformatGetDefaultBoolean"><HR><H4>vformatGetDefaultBoolean</H4></A>
<PRE>
        vformatBoolean * <B>vformatGetDefaultBoolean</B>();
</PRE>

<DL><DD>
This should be considered a read-only reference.
</DD></DL>
<P>
<A NAME="vformatGetDefaultBooleanClass"><HR><H4>vformatGetDefaultBooleanClass</H4></A>
<PRE>
        vformatBooleanClass * <B>vformatGetDefaultBooleanClass</B>();
</PRE>

<DL><DD>
Returns the class used to create boolean formats by the
<CODE><A HREF="vformat-x.html#vformatCreateBoolean"><CODE>vformatCreateBoolean</CODE></A></CODE> and <CODE><A HREF="vformat-x.html#vformatInitBoolean"><CODE>vformatInitBoolean</CODE></A></CODE>
functions. This class can be modified to alter the behavior of all boolean
formats subsequently created by these functions. Changes to this class are
not visible to any other applications in the same process. This function can
be called to explicitly register the default boolean format class with the
Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultBooleanSegmentClass"><HR><H4>vformatGetDefaultBooleanSegmentClass</H4></A>
<PRE>
        vformatBooleanSegmentClass * <B>vformatGetDefaultBooleanSegmentClass</B>();
</PRE>

<DL><DD>
Returns the class used to create boolean format segments by the
<CODE><A HREF="vformat-x.html#vformatCreateBooleanSegment"><CODE>vformatCreateBooleanSegment</CODE></A></CODE> and
<CODE><A HREF="vformat-x.html#vformatInitBooleanSegment"><CODE>vformatInitBooleanSegment</CODE></A></CODE> functions. This class can be modified
to alter the behavior of all boolean format segments subsequently created by
these functions. Changes to this class are not visible to any other
applications in the same process. This function can be called to explicitly
register the default boolean format segment class with the 
Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultBooleanSegmentIteratorClass"><HR><H4>vformatGetDefaultBooleanSegmentIteratorClass</H4></A>
<PRE>
        void <B>vformatGetDefaultBooleanSegmentIteratorClass</B>();
</PRE>

<DL><DD>
Returns the class used to initialize boolean format segment iterators with the
<CODE><A HREF="vformat-x.html#vformatInitBooleanSegmentIterator"><CODE>vformatInitBooleanSegmentIterator</CODE></A></CODE> function. This class can be
modified to alter the behavior of all boolean format segment iterators
subsequently created with this function. Changes to this class are not
visible to any other applications in the same process. This function can be
called to explicitly register the default boolean format segment iterator
class with the Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultClass"><HR><H4>vformatGetDefaultClass</H4></A>
<PRE>
        vformatClass * <B>vformatGetDefaultClass</B>();
</PRE>

<DL><DD>
Returns the class used to create formats by the <CODE><A HREF="vformat-x.html#vformatCreate"><CODE>vformatCreate</CODE></A></CODE> and
<CODE><A HREF="vformat-x.html#vformatInit"><CODE>vformatInit</CODE></A></CODE> functions. This class can be modified to alter the
behavior of all formats subsequently created by these functions. Changes to
this class are not visible to any other applications in the same process.
This function can be called to explicitly register the default format class
with the Class Manager classes.
<P>
Note that the Base <code>vformat</code> class is not useful on its own 
as it has no type-specific interfaces.
</DD></DL>
<P>
<A NAME="vformatGetDefaultDate"><HR><H4>vformatGetDefaultDate</H4></A>
<PRE>
        vformatDate * <B>vformatGetDefaultDate</B>();
</PRE>

<DL><DD>
This should be considered a read-only reference.
</DD></DL>
<P>
<A NAME="vformatGetDefaultDateClass"><HR><H4>vformatGetDefaultDateClass</H4></A>
<PRE>
        vformatDateClass * <B>vformatGetDefaultDateClass</B>();
</PRE>

<DL><DD>
Returns the class used to create formats by the <CODE><A HREF="vformat-x.html#vformatCreateDate"><CODE>vformatCreateDate</CODE></A></CODE>
and <CODE><A HREF="vformat-x.html#vformatInitDate"><CODE>vformatInitDate</CODE></A></CODE> functions. This class can be modified to
alter the behavior of all date formats subsequently created by these functions.
Changes to this class are not visible to any other applications in the same
process. This function can be called to explicitly register the default date
format class with the Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultDateSegmentClass"><HR><H4>vformatGetDefaultDateSegmentClass</H4></A>
<PRE>
        vformatDateSegmentClass * <B>vformatGetDefaultDateSegmentClass</B>();
</PRE>

<DL><DD>
Returns the class used to create date format segments by the
<CODE><A HREF="vformat-x.html#vformatCreateDateSegment"><CODE>vformatCreateDateSegment</CODE></A></CODE> and <CODE><A HREF="vformat-x.html#vformatInitDateSegment"><CODE>vformatInitDateSegment</CODE></A></CODE>
functions. This class can be modified to alter the behavior of all date
format segments subsequently created by these functions. Changes to this class
are not visible to any other applications in the same process. This function
can be called to explicitly register the default date format segment class
with the Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultDateSegmentIteratorClass"><HR><H4>vformatGetDefaultDateSegmentIteratorClass</H4></A>
<PRE>
        void <B>vformatGetDefaultDateSegmentIteratorClass</B>();
</PRE>

<DL><DD>
Returns the class used to create date format segment iterators with the
<CODE><A HREF="vformat-x.html#vformatInitDateSegmentIterator"><CODE>vformatInitDateSegmentIterator</CODE></A></CODE> function. This class can be
modified to alter the behavior of all date format segments subsequently
created by this function. Changes to this class are not visible to any other
applications in the same process. This function can be called to explicitly
register the default date format segment iterator class with the 
Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultDouble"><HR><H4>vformatGetDefaultDouble</H4></A>
<PRE>
        vformatDouble * <B>vformatGetDefaultDouble</B>();
</PRE>

<DL><DD>
This should be considered a constructor reference.
</DD></DL>
<P>
<A NAME="vformatGetDefaultDoubleClass"><HR><H4>vformatGetDefaultDoubleClass</H4></A>
<PRE>
        vformatDoubleClass * <B>vformatGetDefaultDoubleClass</B>();
</PRE>

<DL><DD>
Returns the class used to create double formats by the
<CODE><A HREF="vformat-x.html#vformatCreateDouble"><CODE>vformatCreateDouble</CODE></A></CODE> and <CODE><A HREF="vformat-x.html#vformatInitDouble"><CODE>vformatInitDouble</CODE></A></CODE>
functions. This class can be modified to alter the behavior of all double
formats subsequently created by these functions. Changes to this class
are not visible to any other applications in the same process. This function
can be called to explicitly register the default double format class with the
Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultDoubleSegmentClass"><HR><H4>vformatGetDefaultDoubleSegmentClass</H4></A>
<PRE>
        vformatDoubleSegmentClass * <B>vformatGetDefaultDoubleSegmentClass</B>();
</PRE>

<DL><DD>
Returns the class used to create double format segments by the
<CODE><A HREF="vformat-x.html#vformatCreateDoubleSegment"><CODE>vformatCreateDoubleSegment</CODE></A></CODE> and
<CODE><A HREF="vformat-x.html#vformatInitDoubleSegment"><CODE>vformatInitDoubleSegment</CODE></A></CODE> functions. This class can be modified
to alter the behavior of all double format segments subsequently created by
these functions. Changes to this class are not visible to any other
applications in the same process. This function can be called to explicitly
register the default double format segment class with the Class Manager 
classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultDoubleSegmentIteratorClass"><HR><H4>vformatGetDefaultDoubleSegmentIteratorClass</H4></A>
<PRE>
        void <B>vformatGetDefaultDoubleSegmentIteratorClass</B>();
</PRE>

<DL><DD>
Returns the class used to create double format segment iterators with the
<CODE><A HREF="vformat-x.html#vformatInitDoubleSegmentIterator"><CODE>vformatInitDoubleSegmentIterator</CODE></A></CODE> function. This class can be
modified to alter the behavior of all double format segments subsequently
created by this function. Changes to this class are not visible to any other
applications in the same process. This function can be called to explicitly
register the default double format segment iterator class with the Class
Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultLong"><HR><H4>vformatGetDefaultLong</H4></A>
<PRE>
        vformatLong * <B>vformatGetDefaultLong</B>();
</PRE>

<DL><DD>
This should be considered a constructor reference.
</DD></DL>
<P>
<A NAME="vformatGetDefaultLongClass"><HR><H4>vformatGetDefaultLongClass</H4></A>
<PRE>
        vformatLongClass * <B>vformatGetDefaultLongClass</B>();
</PRE>

<DL><DD>
Returns the class used to create long integer formats by the
<CODE><A HREF="vformat-x.html#vformatCreateLong"><CODE>vformatCreateLong</CODE></A></CODE> and <CODE><A HREF="vformat-x.html#vformatInitLong"><CODE>vformatInitLong</CODE></A></CODE>
functions. This class can be modified to alter the behavior of all long integer
formats subsequently created by these functions. Changes to this class are not
visible to any other applications in the same process. This function can be
called to explicitly register the default long integer format class with the
Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultLongSegmentClass"><HR><H4>vformatGetDefaultLongSegmentClass</H4></A>
<PRE>
        vformatLongSegmentClass * <B>vformatGetDefaultLongSegmentClass</B>();
</PRE>

<DL><DD>
Returns the class used to create long integer format segments by the
<CODE><A HREF="vformat-x.html#vformatCreateLongSegment"><CODE>vformatCreateLongSegment</CODE></A></CODE> and <CODE><A HREF="vformat-x.html#vformatInitLongSegment"><CODE>vformatInitLongSegment</CODE></A></CODE>
functions. This class can be modified to alter the behavior of all long integer
format segments subsequently created by these functions. Changes to this class
are not visible to any other applications in the same process. This function
can be called to explicitly register the default long integer format segment
class with the Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultLongSegmentIteratorClass"><HR><H4>vformatGetDefaultLongSegmentIteratorClass</H4></A>
<PRE>
        void <B>vformatGetDefaultLongSegmentIteratorClass</B>();
</PRE>

<DL><DD>
Returns the class used to create long integer format segment iterators with the
<CODE><A HREF="vformat-x.html#vformatInitLongSegmentIterator"><CODE>vformatInitLongSegmentIterator</CODE></A></CODE> function. This class can be
modified to alter the behavior of all long integer format segments subsequently
created by this function. Changes to this class are not visible to any other
applications in the same process. This function can be called to explicitly
register the default long integer format segment iterator class with the Class
Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultNamedFormat"><HR><H4>vformatGetDefaultNamedFormat</H4></A>
<PRE>
        vformat * <B>vformatGetDefaultNamedFormat</B>(
                const vname * name);
</PRE>

<DL><DD>
The globally shared, default formats are meant to be initialized
for operation within the current locale and should be useful for
most parsing/display operations.
</DD></DL>
<P>
<A NAME="vformatGetDefaultNumberClass"><HR><H4>vformatGetDefaultNumberClass</H4></A>
<PRE>
        vformatNumberClass * <B>vformatGetDefaultNumberClass</B>();
</PRE>

<DL><DD>
Returns the class used to create number formats by the
<CODE><A HREF="vformat-x.html#vformatCreateNumber"><CODE>vformatCreateNumber</CODE></A></CODE> and <CODE><A HREF="vformat-x.html#vformatInitNumber"><CODE>vformatInitNumber</CODE></A></CODE>
functions. This class can be modified to alter the behavior of all number
formats subsequently created by these functions. Changes to this class are not
visible to any other applications in the same process. This function can be
called to explicitly register the default number format class with the Class
Manager classes.
<P>
Note that the Base <code><A HREF="vformat-x.html#vformatNumber"><CODE>vformatNumber</CODE></A></code> class contains 
no type-specific interface. Use one of the type-specific extensions 
to <code><A HREF="vformat-x.html#vformatNumber"><CODE>vformatNumber</CODE></A></code> to parse or scribe number values.
</DD></DL>
<P>
<A NAME="vformatGetDefaultNumberSegmentClass"><HR><H4>vformatGetDefaultNumberSegmentClass</H4></A>
<PRE>
        vformatNumberSegmentClass * <B>vformatGetDefaultNumberSegmentClass</B>();
</PRE>

<DL><DD>
Returns the class used to create number format segments by the
<CODE><A HREF="vformat-x.html#vformatCreateNumberSegment"><CODE>vformatCreateNumberSegment</CODE></A></CODE> and
<CODE><A HREF="vformat-x.html#vformatInitNumberSegment"><CODE>vformatInitNumberSegment</CODE></A></CODE> functions. This class can be modified to
alter the behavior of all number format segments subsequently created by these
functions. Changes to this class are not visible to any other applications in
the same process. This function can be called to explicitly register the
default number format segment class with the Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultNumberSegmentIteratorClass"><HR><H4>vformatGetDefaultNumberSegmentIteratorClass</H4></A>
<PRE>
        void <B>vformatGetDefaultNumberSegmentIteratorClass</B>();
</PRE>

<DL><DD>
Returns the class used to create number format segment iterators with the
<CODE><A HREF="vformat-x.html#vformatInitNumberSegmentIterator"><CODE>vformatInitNumberSegmentIterator</CODE></A></CODE> function. This class can be
modified to alter the behavior of all number format segment iterators
subsequently created by this function. Changes to this class are not visible
to any other applications in the same process. This function can be called to
explicitly register the default number format segment iterator class with the
Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultParseRangeClass"><HR><H4>vformatGetDefaultParseRangeClass</H4></A>
<PRE>
        vformatParseRangeClass * <B>vformatGetDefaultParseRangeClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatGetDefaultSegmentClass"><HR><H4>vformatGetDefaultSegmentClass</H4></A>
<PRE>
        vformatSegmentClass * <B>vformatGetDefaultSegmentClass</B>();
</PRE>

<DL><DD>
Returns the class used to create format segments by the
<CODE><A HREF="vformat-x.html#vformatCreateSegment"><CODE>vformatCreateSegment</CODE></A></CODE> and <CODE><A HREF="vformat-x.html#vformatInitSegment"><CODE>vformatInitSegment</CODE></A></CODE>
functions. This class can be modified to alter the behavior of all format
segments subsequently created by these functions. Changes to this class are
not visible to any other applications in the same process. This function can
be called to explicitly register the default format segment class with the
Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultSegmentIteratorClass"><HR><H4>vformatGetDefaultSegmentIteratorClass</H4></A>
<PRE>
        void <B>vformatGetDefaultSegmentIteratorClass</B>();
</PRE>

<DL><DD>
Returns the class used to create format segment iterators with the
<CODE><A HREF="vformat-x.html#vformatInitSegmentIterator"><CODE>vformatInitSegmentIterator</CODE></A></CODE> function. This class can be
modified to alter the behavior of all format segment iterators subsequently
created by this function. Changes to this class are not visible to any other
applications in the same process. This function can be called to explicitly
register the default number format segment iterator class with the Class
Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultULong"><HR><H4>vformatGetDefaultULong</H4></A>
<PRE>
        vformatULong * <B>vformatGetDefaultULong</B>();
</PRE>

<DL><DD>
This should be considered a constructor reference.
</DD></DL>
<P>
<A NAME="vformatGetDefaultULongClass"><HR><H4>vformatGetDefaultULongClass</H4></A>
<PRE>
        vformatULongClass * <B>vformatGetDefaultULongClass</B>();
</PRE>

<DL><DD>
Returns the class used to create unsigned long integer formats by the
<CODE><A HREF="vformat-x.html#vformatCreateULong"><CODE>vformatCreateULong</CODE></A></CODE> and <CODE><A HREF="vformat-x.html#vformatInitULong"><CODE>vformatInitULong</CODE></A></CODE>
functions. This class can be modified to alter the behavior of all unsigned
long integer formats subsequently created by these functions. Changes to this
class are not visible to any other applications in the same process. This
function can be called to explicitly register the default unsigned long
integer format class with the Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultULongSegmentClass"><HR><H4>vformatGetDefaultULongSegmentClass</H4></A>
<PRE>
        vformatULongSegmentClass * <B>vformatGetDefaultULongSegmentClass</B>();
</PRE>

<DL><DD>
Returns the class used to create unsigned long integer format segments by the
<CODE><A HREF="vformat-x.html#vformatCreateULongSegment"><CODE>vformatCreateULongSegment</CODE></A></CODE> and <CODE><A HREF="vformat-x.html#vformatInitULongSegment"><CODE>vformatInitULongSegment</CODE></A></CODE>
functions. This class can be modified to alter the behavior of all unsigned
long integer format segments subsequently created by these functions. Changes
to this class are not visible to any other applications in the same process.
This function can be called to explicitly register the default unsigned long
integer format segment class with the Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDefaultULongSegmentIteratorClass"><HR><H4>vformatGetDefaultULongSegmentIteratorClass</H4></A>
<PRE>
        void <B>vformatGetDefaultULongSegmentIteratorClass</B>();
</PRE>

<DL><DD>
Returns the class used to create unsigned long integer format segment
iterators with the <CODE><A HREF="vformat-x.html#vformatInitULongSegmentIterator"><CODE>vformatInitULongSegmentIterator</CODE></A></CODE> function.
This class can be modified to alter the behavior of all unsigned long integer
format segment iterators subsequently created by this function. Changes to
this class are not visible to any other applications in the same process.
This function can be called to explicitly register the default unsigned long
integer format segment iterator class with the Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDoubleBase"><HR><H4>vformatGetDoubleBase</H4></A>
<PRE>
        vformat * <B>vformatGetDoubleBase</B>(
                vformatDouble * format);
</PRE>

<DL><DD>
Returns a pointer to the <code>vformat</code> portion 
of the double format object.
</DD></DL>
<P>
<A NAME="vformatGetDoubleClass"><HR><H4>vformatGetDoubleClass</H4></A>
<PRE>
        vformatDoubleClass * <B>vformatGetDoubleClass</B>(
                vformatDouble * format);
</PRE>

<DL><DD>
Returns the class used to create double formats by the
<CODE><A HREF="vformat-x.html#vformatCreateDouble"><CODE>vformatCreateDouble</CODE></A></CODE> and <CODE><A HREF="vformat-x.html#vformatInitDouble"><CODE>vformatInitDouble</CODE></A></CODE>
functions. This class can be modified to alter the behavior of all double
formats subsequently created by these functions. Changes to this class are not
visible to any other applications in the same process. This function can be
called to explicitly register the default double format class with the Class
Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDoubleLoadable"><HR><H4>vformatGetDoubleLoadable</H4></A>
<PRE>
        vloadable * <B>vformatGetDoubleLoadable</B>(
                vformatDouble * format);
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vloadable-x.html#vloadable"><CODE>vloadable</CODE></A></code> 
portion of the double format object.
</DD></DL>
<P>
<A NAME="vformatGetDoubleNumber"><HR><H4>vformatGetDoubleNumber</H4></A>
<PRE>
        vformatNumber * <B>vformatGetDoubleNumber</B>(
                vformatDouble * format);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatGetDoubleOutputPatternIndex"><HR><H4>vformatGetDoubleOutputPatternIndex</H4></A>
<PRE>
        int <B>vformatGetDoubleOutputPatternIndex</B>(
                vformatDouble * format);
</PRE>

<DL><DD>
The returned value is the index of the pattern used by
<code><A HREF="vformat-x.html#vformatScribeDouble"><CODE>vformatScribeDouble</CODE></A></code> for creating output strings 
for an arbitrary double value. The value returned is greater-than 
or equal to zero and less than the
result of calling <code><A HREF="vformat-x.html#vformatGetDoublePatternCount"><CODE>vformatGetDoublePatternCount</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatGetDoubleOutputSegment"><HR><H4>vformatGetDoubleOutputSegment</H4></A>
<PRE>
        const vformatDoubleSegment * <B>vformatGetDoubleOutputSegment</B>(
                vformatDouble * format,
                double value);
</PRE>

<DL><DD>
When represented values change, dialog items that hold an associated 
<code><A HREF="vformat-x.html#vformatDouble"><CODE>vformatDouble</CODE></A></code>, such as <code><A HREF="vdoubleitem-x.html#vdoubleitem"><CODE>vdoubleitem</CODE></A></code>, 
can make use of this method to update any graphical characteristics 
bound to the value, such as the foreground color, or text alignment.
</DD></DL>
<P>
<A NAME="vformatGetDoubleOutputSegmentIndex"><HR><H4>vformatGetDoubleOutputSegmentIndex</H4></A>
<PRE>
        int <B>vformatGetDoubleOutputSegmentIndex</B>(
                vformatDouble * format,
                double value);
</PRE>

<DL><DD>
Used internally by the Scribe class.
</DD></DL>
<P>
<A NAME="vformatGetDoublePatternCount"><HR><H4>vformatGetDoublePatternCount</H4></A>
<PRE>
        long <B>vformatGetDoublePatternCount</B>(
                const vformatDouble * format);
</PRE>

<DL><DD>
There is no practical limit to the number of patterns a double format can
contain. However, the worst-case efficiency of a parse operation is linearly
related (O(n)) to the number of patterns. The returned value is 
equal to or greater-than zero.
</DD></DL>
<P>
<A NAME="vformatGetDoublePatternSegmentAt"><HR><H4>vformatGetDoublePatternSegmentAt</H4></A>
<PRE>
        const vformatDoubleSegment * <B>vformatGetDoublePatternSegmentAt</B>(
                vformatDouble * format,
                int patternIndex,
                int segmentIndex);
</PRE>

<DL><DD>
The <SAMP>patternIndex</SAMP> must be greater-than or equal-to zero and less
than the result of calling <code><A HREF="vformat-x.html#vformatGetDoublePatternCount"><CODE>vformatGetDoublePatternCount</CODE></A></code>. The
<SAMP>segmentIndex</SAMP> must be greater-than or equal to zero and less than
the result of calling <code><A HREF="vformat-x.html#vformatGetDateSegmentCount"><CODE>vformatGetDateSegmentCount</CODE></A></code>. 
This call always returns a non-null object.
</DD></DL>
<P>
<A NAME="vformatGetDoubleSegmentAlignment"><HR><H4>vformatGetDoubleSegmentAlignment</H4></A>
<PRE>
        int <B>vformatGetDoubleSegmentAlignment</B>(
                const vformatDoubleSegment * segment);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatDoubleSegment"><CODE>vformatDoubleSegment</CODE></A></code> class supports the 
ability to specify color and text alignment. A text alignment 
may be specified with the following pattern syntax.

<Pre>
    "{#,###.00" // left-aligned double value
    "}#,###.00" // right-aligned double value
    "|#,###.00" // centered double value
</Pre>

<P>
The text alignment codes returned are:

<ul>
<li>vformatALIGN_LEFT [default]
<li>vformatALIGN_RIGHT
<li>vformatALIGN_CENTER
</ul>
</DD></DL>
<P>
<A NAME="vformatGetDoubleSegmentBase"><HR><H4>vformatGetDoubleSegmentBase</H4></A>
<PRE>
        vformatNumberSegment * <B>vformatGetDoubleSegmentBase</B>(
                vformatDoubleSegment * segment);
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vformat-x.html#vformatNumberSegment"><CODE>vformatNumberSegment</CODE></A></code> 
portion of the double format segment object.
</DD></DL>
<P>
<A NAME="vformatGetDoubleSegmentColor"><HR><H4>vformatGetDoubleSegmentColor</H4></A>
<PRE>
        vcolor * <B>vformatGetDoubleSegmentColor</B>(
                const vformatDoubleSegment * segment);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> class supports the 
ability to specify color and text alignment for a segment. 
For example, to specify that a <code><A HREF="vformat-x.html#vformatDoubleSegment"><CODE>vformatDoubleSegment</CODE></A></code> 
have a red color attribute, use the following pattern.

<Pre>
  "[red]#,###.00"
</Pre>

<p>
The segment's color and alignment attributes are not used by the classes
derived from <code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code>, 
but are meant to be used by higher-level, user-interface constructs, 
such as a spreadsheet cell formatter, or database form.
</DD></DL>
<P>
<A NAME="vformatGetDoubleSegmentCount"><HR><H4>vformatGetDoubleSegmentCount</H4></A>
<PRE>
        int <B>vformatGetDoubleSegmentCount</B>(
                vformatDouble * format);
</PRE>

<DL><DD>
A double format pattern contains three segments representing, in order, 
a positive; negative; and zero-value.
</DD></DL>
<P>
<A NAME="vformatGetDoubleSegmentIteratorBase"><HR><H4>vformatGetDoubleSegmentIteratorBase</H4></A>
<PRE>
        void <B>vformatGetDoubleSegmentIteratorBase</B>();
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vformat-x.html#vformatNumberSegmentIterator"><CODE>vformatNumberSegmentIterator</CODE></A></code> 
portion of the double format segment iterator.
</DD></DL>
<P>
<A NAME="vformatGetDoubleSegmentIteratorClass"><HR><H4>vformatGetDoubleSegmentIteratorClass</H4></A>
<PRE>
        void <B>vformatGetDoubleSegmentIteratorClass</B>();
</PRE>

<DL><DD>
Returns the class used to create double format segment iterators with the
<CODE><A HREF="vformat-x.html#vformatInitDoubleSegmentIterator"><CODE>vformatInitDoubleSegmentIterator</CODE></A></CODE> function. This class can be
modified to alter the behavior of all double format segment iterators
subsequently created by this function. Changes to this class are not visible
to any other applications in the same process. This function can be called to
explicitly register the default double format segment iterator class with the
Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetDoubleSegmentIteratorFormat"><HR><H4>vformatGetDoubleSegmentIteratorFormat</H4></A>
<PRE>
        void <B>vformatGetDoubleSegmentIteratorFormat</B>();
</PRE>

<DL><DD>
A <code><A HREF="vformat-x.html#vformatDoubleSegmentIterator"><CODE>vformatDoubleSegmentIterator</CODE></A></code> is initialized by a call to
<code><A HREF="vformat-x.html#vformatInitDoubleSegmentIterator"><CODE>vformatInitDoubleSegmentIterator</CODE></A></code>, taking as a parameter 
a pointer to the <code><A HREF="vformat-x.html#vformatDouble"><CODE>vformatDouble</CODE></A></code> over whose segments 
the iterator passes. This accessor method returns a pointer 
to that double format.
</DD></DL>
<P>
<A NAME="vformatGetDoubleSegmentIteratorInstance"><HR><H4>vformatGetDoubleSegmentIteratorInstance</H4></A>
<PRE>
        void <B>vformatGetDoubleSegmentIteratorInstance</B>();
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></code> portion of the 
double format segment iterator object.
</DD></DL>
<P>
<A NAME="vformatGetDoubleSegmentIteratorIterator"><HR><H4>vformatGetDoubleSegmentIteratorIterator</H4></A>
<PRE>
        void <B>vformatGetDoubleSegmentIteratorIterator</B>();
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="viterator-x.html#viterator"><CODE>viterator</CODE></A></code> portion of 
the double format segment iterator object.
</DD></DL>
<P>
<A NAME="vformatGetDoubleSegmentIteratorPatternIndex"><HR><H4>vformatGetDoubleSegmentIteratorPatternIndex</H4></A>
<PRE>
        void <B>vformatGetDoubleSegmentIteratorPatternIndex</B>();
</PRE>

<DL><DD>
Returns the index of the current double format pattern in the sequence.
</DD></DL>
<P>
<A NAME="vformatGetDoubleSegmentIteratorSegment"><HR><H4>vformatGetDoubleSegmentIteratorSegment</H4></A>
<PRE>
        void <B>vformatGetDoubleSegmentIteratorSegment</B>();
</PRE>

<DL><DD>
Returns a pointer to the current <code><A HREF="vformat-x.html#vformatDoubleSegment"><CODE>vformatDoubleSegment</CODE></A></code> 
in the sequence.
</DD></DL>
<P>
<A NAME="vformatGetDoubleSegmentIteratorSegmentIndex"><HR><H4>vformatGetDoubleSegmentIteratorSegmentIndex</H4></A>
<PRE>
        void <B>vformatGetDoubleSegmentIteratorSegmentIndex</B>();
</PRE>

<DL><DD>
Returns the pattern-relative index of the current 
<code><A HREF="vformat-x.html#vformatDoubleSegment"><CODE>vformatDoubleSegment</CODE></A></code> in the sequence.
</DD></DL>
<P>
<A NAME="vformatGetDoubleSegmentPrefix"><HR><H4>vformatGetDoubleSegmentPrefix</H4></A>
<PRE>
        const vchar * <B>vformatGetDoubleSegmentPrefix</B>(
                const vformatDoubleSegment * segment);
</PRE>

<DL><DD>
Each double format can have an optional prefix and/or suffix string that is
literal text at the beginning of ending of a double segment pattern. This
literal text must be matched indentically by the input string for a parsing
operation to succeed. The literal text is also used when constructing
an output form of a given double value.
</DD></DL>
<P>
<A NAME="vformatGetDoubleSegmentScale"><HR><H4>vformatGetDoubleSegmentScale</H4></A>
<PRE>
        double <B>vformatGetDoubleSegmentScale</B>(
                const vformatDoubleSegment * segment);
</PRE>

<DL><DD>
Sets the scale factor the segment uses for parsing and for conversion
of a double value to a string.
</DD></DL>
<P>
<A NAME="vformatGetDoubleSegmentString"><HR><H4>vformatGetDoubleSegmentString</H4></A>
<PRE>
        const vchar * <B>vformatGetDoubleSegmentString</B>(
                const vformatDoubleSegment * segment);
</PRE>

<DL><DD>
This is the segment's portion of the original pattern strings set by
<code><A HREF="vformat-x.html#vformatAppendDoublePattern"><CODE>vformatAppendDoublePattern</CODE></A></code> or <code><A HREF="vformat-x.html#vformatInsertDoublePattern"><CODE>vformatInsertDoublePattern</CODE></A></code>. This function is used internally by 
<code>vformatGetDoublePatternAt</code> to reconstruct 
the original pattern string.
</DD></DL>
<P>
<A NAME="vformatGetDoubleSegmentSuffix"><HR><H4>vformatGetDoubleSegmentSuffix</H4></A>
<PRE>
        const vchar * <B>vformatGetDoubleSegmentSuffix</B>(
                const vformatDoubleSegment * segment);
</PRE>

<DL><DD>
Each double format can have an optional prefix and/or suffix string that is
literal text at the beginning of ending of a double segment pattern. This
literal text must be matched indentically by the input string for a parsing
operation to succeed.  The literal text is also used when constructing
an output form of a given double value.
</DD></DL>
<P>
<A NAME="vformatGetInstance"><HR><H4>vformatGetInstance</H4></A>
<PRE>
        vinstance * <B>vformatGetInstance</B>(
                vformat * format);
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></code> portion of the format.
</DD></DL>
<P>
<A NAME="vformatGetLoadable"><HR><H4>vformatGetLoadable</H4></A>
<PRE>
        vloadable * <B>vformatGetLoadable</B>(
                vformat * format);
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vloadable-x.html#vloadable"><CODE>vloadable</CODE></A></code> portion of the format.
</DD></DL>
<P>
<A NAME="vformatGetLongBase"><HR><H4>vformatGetLongBase</H4></A>
<PRE>
        vformat * <B>vformatGetLongBase</B>(
                vformatLong * format);
</PRE>

<DL><DD>
Returns a pointer to the base-class <code>vformat</code> 
portion of the long format object.
</DD></DL>
<P>
<A NAME="vformatGetLongClass"><HR><H4>vformatGetLongClass</H4></A>
<PRE>
        vformatLongClass * <B>vformatGetLongClass</B>(
                vformatLong * format);
</PRE>

<DL><DD>
Returns the class used to create long integer formats by the
<CODE><A HREF="vformat-x.html#vformatCreateLong"><CODE>vformatCreateLong</CODE></A></CODE> and <CODE><A HREF="vformat-x.html#vformatInitLong"><CODE>vformatInitLong</CODE></A></CODE>
functions. This class can be modified to alter the behavior of all long integer
formats subsequently created by these functions. Changes to this class are not
visible to any other applications in the same process. This function can be
called to explicitly register the default long integer format class with the
Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetLongLoadable"><HR><H4>vformatGetLongLoadable</H4></A>
<PRE>
        vloadable * <B>vformatGetLongLoadable</B>(
                vformatLong * format);
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vloadable-x.html#vloadable"><CODE>vloadable</CODE></A></code> portion of the long format.
</DD></DL>
<P>
<A NAME="vformatGetLongNumber"><HR><H4>vformatGetLongNumber</H4></A>
<PRE>
        vformatNumber * <B>vformatGetLongNumber</B>(
                vformatLong * format);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatGetLongOutputPatternIndex"><HR><H4>vformatGetLongOutputPatternIndex</H4></A>
<PRE>
        int <B>vformatGetLongOutputPatternIndex</B>(
                vformatLong * format);
</PRE>

<DL><DD>
The returned value is the index of the pattern used by
<code><A HREF="vformat-x.html#vformatScribeLong"><CODE>vformatScribeLong</CODE></A></code> 
for creating output strings for an arbitrary long integer value.
The value returned is greater-than or equal to zero and less than the
result of calling <code><A HREF="vformat-x.html#vformatGetLongPatternCount"><CODE>vformatGetLongPatternCount</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatGetLongOutputSegment"><HR><H4>vformatGetLongOutputSegment</H4></A>
<PRE>
        const vformatLongSegment * <B>vformatGetLongOutputSegment</B>(
                vformatLong * format,
                long value);
</PRE>

<DL><DD>
When represented values change, dialog items that hold an associated 
<code><A HREF="vformat-x.html#vformatLong"><CODE>vformatLong</CODE></A></code>, such as
<code><A HREF="vlongitem-x.html#vlongitem"><CODE>vlongitem</CODE></A></code>, can make use of this method to update any 
graphical characteristics bound to the
value, such as foreground color, or text alignment.
</DD></DL>
<P>
<A NAME="vformatGetLongOutputSegmentIndex"><HR><H4>vformatGetLongOutputSegmentIndex</H4></A>
<PRE>
        int <B>vformatGetLongOutputSegmentIndex</B>(
                vformatLong * format,
                long value);
</PRE>

<DL><DD>
Used internally by the Scribe class.
</DD></DL>
<P>
<A NAME="vformatGetLongPatternCount"><HR><H4>vformatGetLongPatternCount</H4></A>
<PRE>
        long <B>vformatGetLongPatternCount</B>(
                const vformatLong * format);
</PRE>

<DL><DD>
There is no practical limit to the number of patterns a long integer format can
contain. However, the worst-case efficiency of a parse operation 
is linearly related (O(n)) to the number of patterns. The returned value 
is equal-to or greater-than zero.
</DD></DL>
<P>
<A NAME="vformatGetLongPatternSegmentAt"><HR><H4>vformatGetLongPatternSegmentAt</H4></A>
<PRE>
        const vformatLongSegment * <B>vformatGetLongPatternSegmentAt</B>(
                vformatLong * format,
                int patternIndex,
                int segmentIndex);
</PRE>

<DL><DD>
The <SAMP>patternIndex</SAMP> must be greater-than or equal-to zero and less
than the result of calling <code><A HREF="vformat-x.html#vformatGetLongPatternCount"><CODE>vformatGetLongPatternCount</CODE></A></code>. The
<SAMP>segmentIndex</SAMP> must be greater-than or equal to zero and less than
the result of calling <code><A HREF="vformat-x.html#vformatGetLongSegmentCount"><CODE>vformatGetLongSegmentCount</CODE></A></code>. 
This call always returns a non-null object.
</DD></DL>
<P>
<A NAME="vformatGetLongSegmentAlignment"><HR><H4>vformatGetLongSegmentAlignment</H4></A>
<PRE>
        int <B>vformatGetLongSegmentAlignment</B>(
                const vformatLongSegment * segment);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatLongSegment"><CODE>vformatLongSegment</CODE></A></code> class supports 
the ability to specify color and text alignment. 
Text alignment may be specified with the 
following pattern syntax:

<Pre>
    "{#,###" // left-aligned long integer value 
    "}#,###" // right-aligned long integer value
    "|#,###" // centered long integer value
</Pre>

<P>
The text alignment codes returned are:

<ul>
<li>vformatALIGN_LEFT [default]
<li>vformatALIGN_RIGHT
<li>vformatALIGN_CENTER
</ul>
</DD></DL>
<P>
<A NAME="vformatGetLongSegmentBase"><HR><H4>vformatGetLongSegmentBase</H4></A>
<PRE>
        vformatNumberSegment * <B>vformatGetLongSegmentBase</B>(
                vformatLongSegment * segment);
</PRE>

<DL><DD>
Returns a pointer to the Base class <code><A HREF="vformat-x.html#vformatNumberSegment"><CODE>vformatNumberSegment</CODE></A></code> 
portion of a long integer format segment object.
</DD></DL>
<P>
<A NAME="vformatGetLongSegmentColor"><HR><H4>vformatGetLongSegmentColor</H4></A>
<PRE>
        vcolor * <B>vformatGetLongSegmentColor</B>(
                const vformatLongSegment * segment);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> class supports the ability 
to specify color and textutal alignment for a segment. For example, 
to specify that a <code><A HREF="vformat-x.html#vformatLongSegment"><CODE>vformatLongSegment</CODE></A></code> have a red 
color attribute, use the pattern below:

<Pre>
  "[red]#,###"
</Pre>

<P>
The segment's color and alignment attributes are not used by the classes 
derived from <code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code>, 
but are meant to be used by higher-level, user-interface constructs, 
such as a spreadsheet cell formatter, or database form.
</DD></DL>
<P>
<A NAME="vformatGetLongSegmentCount"><HR><H4>vformatGetLongSegmentCount</H4></A>
<PRE>
        int <B>vformatGetLongSegmentCount</B>(
                vformatLong * format);
</PRE>

<DL><DD>
A long integer format pattern contains three segments representing, in order, 
a positive; negative; and zero-value.
</DD></DL>
<P>
<A NAME="vformatGetLongSegmentIteratorBase"><HR><H4>vformatGetLongSegmentIteratorBase</H4></A>
<PRE>
        void <B>vformatGetLongSegmentIteratorBase</B>();
</PRE>

<DL><DD>
Returns a pointer to the base-class 
<code><A HREF="vformat-x.html#vformatNumberSegmentIterator"><CODE>vformatNumberSegmentIterator</CODE></A></code> portion
of the long integer format segment iterator object.
</DD></DL>
<P>
<A NAME="vformatGetLongSegmentIteratorClass"><HR><H4>vformatGetLongSegmentIteratorClass</H4></A>
<PRE>
        void <B>vformatGetLongSegmentIteratorClass</B>();
</PRE>

<DL><DD>
Returns the class used to initialize long integer format segment iterators by
the <CODE><A HREF="vformat-x.html#vformatInitLongSegmentIterator"><CODE>vformatInitLongSegmentIterator</CODE></A></CODE> function. This class can be
modified to alter the behavior of all long integer format segment iterators
subsequently initialized by this function. Changes to this class are not
visible to any other applications in the same process. This function can be
called to explicitly register the default long integer format segment iterator
class with the Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetLongSegmentIteratorFormat"><HR><H4>vformatGetLongSegmentIteratorFormat</H4></A>
<PRE>
        void <B>vformatGetLongSegmentIteratorFormat</B>();
</PRE>

<DL><DD>
A <code><A HREF="vformat-x.html#vformatLongSegmentIterator"><CODE>vformatLongSegmentIterator</CODE></A></code> is initialized by a call to
<code><A HREF="vformat-x.html#vformatInitLongSegmentIterator"><CODE>vformatInitLongSegmentIterator</CODE></A><code>, taking as a parameter a 
pointer to the <code><A HREF="vformat-x.html#vformatLong"><CODE>vformatLong</CODE></A></code> over whose segments 
the iterator passes. This accessor method returns a 
pointer to that long integer format.
</DD></DL>
<P>
<A NAME="vformatGetLongSegmentIteratorInstance"><HR><H4>vformatGetLongSegmentIteratorInstance</H4></A>
<PRE>
        void <B>vformatGetLongSegmentIteratorInstance</B>();
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></code> portion of the 
long integer format segment iterator object.
</DD></DL>
<P>
<A NAME="vformatGetLongSegmentIteratorIterator"><HR><H4>vformatGetLongSegmentIteratorIterator</H4></A>
<PRE>
        void <B>vformatGetLongSegmentIteratorIterator</B>();
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="viterator-x.html#viterator"><CODE>viterator</CODE></A></code> portion of 
the long integer format segment iterator object.
</DD></DL>
<P>
<A NAME="vformatGetLongSegmentIteratorPatternIndex"><HR><H4>vformatGetLongSegmentIteratorPatternIndex</H4></A>
<PRE>
        void <B>vformatGetLongSegmentIteratorPatternIndex</B>();
</PRE>

<DL><DD>
Returns the index of the current 
long integer format pattern in the sequence.
</DD></DL>
<P>
<A NAME="vformatGetLongSegmentIteratorSegment"><HR><H4>vformatGetLongSegmentIteratorSegment</H4></A>
<PRE>
        void <B>vformatGetLongSegmentIteratorSegment</B>();
</PRE>

<DL><DD>
Returns a pointer to the current <code><A HREF="vformat-x.html#vformatLongSegment"><CODE>vformatLongSegment</CODE></A></code> 
in the sequence.
</DD></DL>
<P>
<A NAME="vformatGetLongSegmentIteratorSegmentIndex"><HR><H4>vformatGetLongSegmentIteratorSegmentIndex</H4></A>
<PRE>
        void <B>vformatGetLongSegmentIteratorSegmentIndex</B>();
</PRE>

<DL><DD>
Returns the pattern-relative index of the current 
<code><A HREF="vformat-x.html#vformatLongSegment"><CODE>vformatLongSegment</CODE></A></code> in the sequence.
</DD></DL>
<P>
<A NAME="vformatGetLongSegmentPrefix"><HR><H4>vformatGetLongSegmentPrefix</H4></A>
<PRE>
        const vchar * <B>vformatGetLongSegmentPrefix</B>(
                const vformatLongSegment * segment);
</PRE>

<DL><DD>
Each long integer format can have an optional prefix and/or suffix string that
is literal text at the beginning of ending of a long integer segment pattern.
This literal text must be matched indentically by the input string for a
parsing operation to succeed.  The literal text is also used when
constructing an output form of a given long integer value.
</DD></DL>
<P>
<A NAME="vformatGetLongSegmentScale"><HR><H4>vformatGetLongSegmentScale</H4></A>
<PRE>
        long <B>vformatGetLongSegmentScale</B>(
                const vformatLongSegment * segment);
</PRE>

<DL><DD>
Gets the scale factor the segment uses for parsing and for conversion
of a long integer value to a string.
</DD></DL>
<P>
<A NAME="vformatGetLongSegmentString"><HR><H4>vformatGetLongSegmentString</H4></A>
<PRE>
        const vchar * <B>vformatGetLongSegmentString</B>(
                const vformatLongSegment * segment);
</PRE>

<DL><DD>
This is the segment's portion of the original pattern strings set by
<code><A HREF="vformat-x.html#vformatAppendLongPattern"><CODE>vformatAppendLongPattern</CODE></A></code> or 
</code><A HREF="vformat-x.html#vformatInsertLongPattern"><CODE>vformatInsertLongPattern</CODE></A><code>.
This function is used internally by <code>vformatGetLongPatternAt</code> to
reconstruct the original pattern string.
</DD></DL>
<P>
<A NAME="vformatGetLongSegmentSuffix"><HR><H4>vformatGetLongSegmentSuffix</H4></A>
<PRE>
        const vchar * <B>vformatGetLongSegmentSuffix</B>(
                const vformatLongSegment * segment);
</PRE>

<DL><DD>
Each long integer format segment can have an optional prefix and/or suffix
string that is literal text at the beginning of ending of a long integer
segment pattern. This literal text must be matched indentically by the input
string for a parsing operation to succeed. The literal text is also used
when constructing an output form of a given long integer value.
</DD></DL>
<P>
<A NAME="vformatGetNumberBase"><HR><H4>vformatGetNumberBase</H4></A>
<PRE>
        vformat * <B>vformatGetNumberBase</B>(
                vformatNumber * format);
</PRE>

<DL><DD>
Returns a pointer to the Base class <code>vformat</code> 
portion of the number format object.
</DD></DL>
<P>
<A NAME="vformatGetNumberClass"><HR><H4>vformatGetNumberClass</H4></A>
<PRE>
        vformatNumberClass * <B>vformatGetNumberClass</B>(
                vformatNumber * format);
</PRE>

<DL><DD>
Returns the class of the number format <SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatGetNumberLoadable"><HR><H4>vformatGetNumberLoadable</H4></A>
<PRE>
        vloadable * <B>vformatGetNumberLoadable</B>(
                vformatNumber * format);
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vloadable-x.html#vloadable"><CODE>vloadable</CODE></A></code> portion of 
the number format object.
</DD></DL>
<P>
<A NAME="vformatGetNumberOutputPatternIndex"><HR><H4>vformatGetNumberOutputPatternIndex</H4></A>
<PRE>
        int <B>vformatGetNumberOutputPatternIndex</B>(
                vformatNumber * format);
</PRE>

<DL><DD>
The returned value is the index of the pattern used by
the Scribe routines for creating output strings for an arbitrary numeric value.
The value returned is greater-than or equal-to zero and less than the
result of calling <code><A HREF="vformat-x.html#vformatGetNumberPatternCount"><CODE>vformatGetNumberPatternCount</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatGetNumberPatternCount"><HR><H4>vformatGetNumberPatternCount</H4></A>
<PRE>
        long <B>vformatGetNumberPatternCount</B>(
                const vformatNumber * format);
</PRE>

<DL><DD>
There is no practical limit to the number of patterns a numeric format can
contain but the worst-case efficiency of a parse operation is linearly related
(O(n)) to the number of patterns. The returned value is 
equal-to or greater-than zero.
</DD></DL>
<P>
<A NAME="vformatGetNumberPatternSegmentAt"><HR><H4>vformatGetNumberPatternSegmentAt</H4></A>
<PRE>
        const vformatNumberSegment * <B>vformatGetNumberPatternSegmentAt</B>(
                vformatNumber * format,
                int patternIndex,
                int segmentIndex);
</PRE>

<DL><DD>
The <SAMP>patternIndex</SAMP> must be greater-than or equal-to zero and less
than the result of calling </code><A HREF="vformat-x.html#vformatGetNumberPatternCount"><CODE>vformatGetNumberPatternCount</CODE></A></code>. 
The <SAMP>segmentIndex</SAMP> must be greater-than or equal-to zero 
and less than the result of calling 
<code><A HREF="vformat-x.html#vformatGetNumberSegmentCount"><CODE>vformatGetNumberSegmentCount</CODE></A></code>. This call always returns 
a non-null object.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentAlignment"><HR><H4>vformatGetNumberSegmentAlignment</H4></A>
<PRE>
        int <B>vformatGetNumberSegmentAlignment</B>(
                const vformatNumberSegment * segment);
</PRE>

<DL><DD>
Returns the alignment code associated with the number format segment.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentBase"><HR><H4>vformatGetNumberSegmentBase</H4></A>
<PRE>
        vformatSegment * <B>vformatGetNumberSegmentBase</B>(
                vformatNumberSegment * segment);
</PRE>

<DL><DD>
Returns a pointer to the base-class <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> 
portion of the number format segment.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentColor"><HR><H4>vformatGetNumberSegmentColor</H4></A>
<PRE>
        vcolor * <B>vformatGetNumberSegmentColor</B>(
                const vformatNumberSegment * segment);
</PRE>

<DL><DD>
Gets the <SAMP>color</SAMP> associated with the number format segment.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentCount"><HR><H4>vformatGetNumberSegmentCount</H4></A>
<PRE>
        int <B>vformatGetNumberSegmentCount</B>(
                vformatNumber * format);
</PRE>

<DL><DD>
Returns the natural number of segments contained 
by a number format pattern.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentInstance"><HR><H4>vformatGetNumberSegmentInstance</H4></A>
<PRE>
        vinstance * <B>vformatGetNumberSegmentInstance</B>(
                vformatNumberSegment * segment);
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></code> portion of 
the number format segment object.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentIteratorBase"><HR><H4>vformatGetNumberSegmentIteratorBase</H4></A>
<PRE>
        void <B>vformatGetNumberSegmentIteratorBase</B>();
</PRE>

<DL><DD>
Returns a pointer to the Base class <code><A HREF="vformat-x.html#vformatSegmentIterator"><CODE>vformatSegmentIterator</CODE></A></code> 
portion of the number format segment iterator.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentIteratorClass"><HR><H4>vformatGetNumberSegmentIteratorClass</H4></A>
<PRE>
        void <B>vformatGetNumberSegmentIteratorClass</B>();
</PRE>

<DL><DD>
Returns the class used to initialize number format segment iterators by
the <CODE><A HREF="vformat-x.html#vformatInitNumberSegmentIterator"><CODE>vformatInitNumberSegmentIterator</CODE></A></CODE> function. This class can be
modified to alter the behavior of all number format segment iterators
subsequently initialized by this function. Changes to this class are not
visible to any other applications in the same process. This function can be
called to explicitly register the default number format segment iterator class
with the Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentIteratorFormat"><HR><H4>vformatGetNumberSegmentIteratorFormat</H4></A>
<PRE>
        void <B>vformatGetNumberSegmentIteratorFormat</B>();
</PRE>

<DL><DD>
A <code><A HREF="vformat-x.html#vformatNumberSegmentIterator"><CODE>vformatNumberSegmentIterator</CODE></A></code> is initialized by a call to
<code><A HREF="vformat-x.html#vformatInitNumberSegmentIterator"><CODE>vformatInitNumberSegmentIterator</CODE></A></code>, 
taking as a parameter a pointer to the <code><A HREF="vformat-x.html#vformatNumber"><CODE>vformatNumber</CODE></A></code> 
over whose segments the iterator passes. This accessor method 
returns a pointer to that number format.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentIteratorInstance"><HR><H4>vformatGetNumberSegmentIteratorInstance</H4></A>
<PRE>
        void <B>vformatGetNumberSegmentIteratorInstance</B>();
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></code> portion of the 
number segment iterator object.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentIteratorIterator"><HR><H4>vformatGetNumberSegmentIteratorIterator</H4></A>
<PRE>
        void <B>vformatGetNumberSegmentIteratorIterator</B>();
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="viterator-x.html#viterator"><CODE>viterator</CODE></A></code> portion of the 
number segment iterator object.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentIteratorPatternIndex"><HR><H4>vformatGetNumberSegmentIteratorPatternIndex</H4></A>
<PRE>
        void <B>vformatGetNumberSegmentIteratorPatternIndex</B>();
</PRE>

<DL><DD>
Returns the index of the number format pattern in the sequence.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentIteratorSegment"><HR><H4>vformatGetNumberSegmentIteratorSegment</H4></A>
<PRE>
        void <B>vformatGetNumberSegmentIteratorSegment</B>();
</PRE>

<DL><DD>
Returns a pointer to the current <code><A HREF="vformat-x.html#vformatNumberSegment"><CODE>vformatNumberSegment</CODE></A></code> 
in the sequence.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentIteratorSegmentIndex"><HR><H4>vformatGetNumberSegmentIteratorSegmentIndex</H4></A>
<PRE>
        void <B>vformatGetNumberSegmentIteratorSegmentIndex</B>();
</PRE>

<DL><DD>
Returns the pattern-relative index of the current 
<code><A HREF="vformat-x.html#vformatNumberSegment"><CODE>vformatNumberSegment</CODE></A></code> in the sequence.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentPrefix"><HR><H4>vformatGetNumberSegmentPrefix</H4></A>
<PRE>
        const vchar * <B>vformatGetNumberSegmentPrefix</B>(
                const vformatNumberSegment * segment);
</PRE>

<DL><DD>
Each number format can have an optional prefix and/or suffix string that is
literal text at the beginning or ending of a number segment pattern. This
literal text must be matched indentically by the input string for a parsing
operation to succeed. Galaxy also uses the literal text when constructing
an output form of a given number value.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentScale"><HR><H4>vformatGetNumberSegmentScale</H4></A>
<PRE>
        double <B>vformatGetNumberSegmentScale</B>(
                const vformatNumberSegment * segment);
</PRE>

<DL><DD>
Returns the scale factor the segment uses for parsing and for conversion
of a numeric value to a string.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentString"><HR><H4>vformatGetNumberSegmentString</H4></A>
<PRE>
        const vchar * <B>vformatGetNumberSegmentString</B>(
                const vformatNumberSegment * segment);
</PRE>

<DL><DD>
This is the segment's portion of the original pattern strings set by
<code><A HREF="vformat-x.html#vformatAppendNumberPattern"><CODE>vformatAppendNumberPattern</CODE></A></code> or 
<code><A HREF="vformat-x.html#vformatInsertNumberPattern"><CODE>vformatInsertNumberPattern</CODE></A></code>. This function is 
used internally by <code>vformatGetNumberPatternAt</code> to
reconstruct the original pattern string.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentSuffix"><HR><H4>vformatGetNumberSegmentSuffix</H4></A>
<PRE>
        const vchar * <B>vformatGetNumberSegmentSuffix</B>(
                const vformatNumberSegment * segment);
</PRE>

<DL><DD>
Each number format can have an optional prefix and/or suffix string that is
literal text at the beginning of ending of a number segment pattern. This
literal text must be matched indentically by the input string for a parsing
operation to succeed. Galaxy also uses the literal text when constructing
an output form of a given number value.
</DD></DL>
<P>
<A NAME="vformatGetOutputPatternIndex"><HR><H4>vformatGetOutputPatternIndex</H4></A>
<PRE>
        int <B>vformatGetOutputPatternIndex</B>(
                vformat * format);
</PRE>

<DL><DD>
The returned value is the index of the pattern used by
scribe methods for creating output strings for a given typed-value.
</DD></DL>
<P>
<A NAME="vformatGetParseException"><HR><H4>vformatGetParseException</H4></A>
<PRE>
        vformatParseException * <B>vformatGetParseException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatGetParseExceptionClass"><HR><H4>vformatGetParseExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vformatGetParseExceptionClass</B>();
</PRE>

<DL><DD>
Returns a pointer to the <SAMP>/Parse</SAMP> exception class.
This is used primarily when creating a new class to specify
<SAMP>/Parse</SAMP> as the new class's parent.
</DD></DL>
<P>
<A NAME="vformatGetParseExceptionCode"><HR><H4>vformatGetParseExceptionCode</H4></A>
<PRE>
        int <B>vformatGetParseExceptionCode</B>(
                vformatParseException * exception);
</PRE>

<DL><DD>
This value can be used to lookup a locale-specific error string to present
to the end-user. The ordering of the locale-specific strings should match
that of the string dictionary resource specified by
vgalaxy.vr/vformat/Error Messages/Format, where vgalaxy.vr is the System
Resource file located in $GALAXYHOME/lib.
</DD></DL>
<P>
<A NAME="vformatGetParseExceptionOffset"><HR><H4>vformatGetParseExceptionOffset</H4></A>
<PRE>
        int <B>vformatGetParseExceptionOffset</B>(
                vformatParseException * exception);
</PRE>

<DL><DD>
This value can be used by higher-level, user-interface items to 
provide the end-user with graphical feedback on the exact 
validation state of an input operation.
</DD></DL>
<P>
<A NAME="vformatGetParseRange"><HR><H4>vformatGetParseRange</H4></A>
<PRE>
        void <B>vformatGetParseRange</B>(
                vformatParseRange * range,
                int * pos,
                int * len);
</PRE>

<DL><DD>
This is a convenience for making two calls to 
<code><A HREF="vformat-x.html#vformatGetParseRangeStart"><CODE>vformatGetParseRangeStart</CODE></A></code> and
<code><A HREF="vformat-x.html#vformatGetParseRangeLength"><CODE>vformatGetParseRangeLength</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatGetParseRangeClass"><HR><H4>vformatGetParseRangeClass</H4></A>
<PRE>
        vformatParseRangeClass * <B>vformatGetParseRangeClass</B>(
                vformatParseRange * range);
</PRE>

<DL><DD>
Returns the class used to create format parse ranges with the
<CODE><A HREF="vformat-x.html#vformatCreateParseRange"><CODE>vformatCreateParseRange</CODE></A></CODE> and <CODE><A HREF="vformat-x.html#vformatInitParseRange"><CODE>vformatInitParseRange</CODE></A></CODE>
functions. This class can be modified to alter the behavior of all parse ranges
subsequently initialized by these functions. Changes to this class are not
visible to any other applications in the same process. This function can be
called to explicitly register the default format parse range class with the
Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetParseRangeInstance"><HR><H4>vformatGetParseRangeInstance</H4></A>
<PRE>
        vinstance * <B>vformatGetParseRangeInstance</B>(
                vformatParseRange * range);
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></code> portion of the 
parse range object.
</DD></DL>
<P>
<A NAME="vformatGetParseRangeLength"><HR><H4>vformatGetParseRangeLength</H4></A>
<PRE>
        int <B>vformatGetParseRangeLength</B>(
                vformatParseRange * range);
</PRE>

<DL><DD>
This method is used by the various type-specific format pattern parsing
methods to determine what portion of the segment's pattern string is left to be
parsed.
</DD></DL>
<P>
<A NAME="vformatGetParseRangeStart"><HR><H4>vformatGetParseRangeStart</H4></A>
<PRE>
        int <B>vformatGetParseRangeStart</B>(
                vformatParseRange * range);
</PRE>

<DL><DD>
Returns the starting offset of the parse range.
</DD></DL>
<P>
<A NAME="vformatGetPatternAt"><HR><H4>vformatGetPatternAt</H4></A>
<PRE>
        vstr * <B>vformatGetPatternAt</B>(
                vformat * format,
                int index);
</PRE>

<DL><DD>
The <SAMP>index</SAMP> argument must refer to a valid pattern 
location or Galaxy throws a <samp>RangeException</samp>. 
<SAMP>Index</SAMP> should be greater-than
or equal to zero, and less than the result of 
<code><A HREF="vformat-x.html#vformatGetPatternCount"><CODE>vformatGetPatternCount</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatGetPatternCount"><HR><H4>vformatGetPatternCount</H4></A>
<PRE>
        int <B>vformatGetPatternCount</B>(
                const vformat * format);
</PRE>

<DL><DD>
There is no practical limit to the number of patterns a format
can contain but the worst-case efficiency of a parse operation
is linearly related (O(n)) to the number of patterns.
</DD></DL>
<P>
<A NAME="vformatGetPatternSegmentAt"><HR><H4>vformatGetPatternSegmentAt</H4></A>
<PRE>
        const vformatSegment * <B>vformatGetPatternSegmentAt</B>(
                vformat * format,
                int patternIndex,
                int segmentIndex);
</PRE>

<DL><DD>
This method is primarily used by the segment iterators during a parse
operation. Both <SAMP>patternIndex</SAMP> and <SAMP>Index</SAMP> 
must refer to valid patterns and pattern segments. 
<SAMP>patternIndex</SAMP> should be greater-than or equal to zero and less
than the result of calling <code><A HREF="vformat-x.html#vformatGetPatternCount"><CODE>vformatGetPatternCount</CODE></A></code>.
<SAMP>Index</SAMP> should be greater-than or equal to zero and less than
the result of calling <code><A HREF="vformat-x.html#vformatGetSegmentCount"><CODE>vformatGetSegmentCount</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatGetSegmentAlignment"><HR><H4>vformatGetSegmentAlignment</H4></A>
<PRE>
        int <B>vformatGetSegmentAlignment</B>(
                vformatSegment * segment);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> class supports the ability 
to specify color and text alignment. 
A text alignment may be specified with the 
following pattern syntax shown below.

<pre>
  "{this is a left aligned string"
  "}this is a right aligned string"
  "|this is a centered string"
</pre>

<P>
The text alignment codes returned are:

<ul>
<li>vformatALIGN_LEFT [default]
<li>vformatALIGN_RIGHT
<li>vformatALIGN_CENTER
</ul>

</DD></DL>
<P>
<A NAME="vformatGetSegmentClass"><HR><H4>vformatGetSegmentClass</H4></A>
<PRE>
        vformatSegmentClass * <B>vformatGetSegmentClass</B>(
                vformatSegment * segment);
</PRE>

<DL><DD>
Returns the class used to create format segments with the
<CODE><A HREF="vformat-x.html#vformatCreateSegment"><CODE>vformatCreateSegment</CODE></A></CODE> and <CODE><A HREF="vformat-x.html#vformatInitSegment"><CODE>vformatInitSegment</CODE></A></CODE>
functions. This class can be modified to alter the behavior of all format
segments subsequently initialized by these functions. Changes to this class are
not visible to any other applications in the same process. 
This function can be called to explicitly register the 
default format segment class with the Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetSegmentColor"><HR><H4>vformatGetSegmentColor</H4></A>
<PRE>
        vcolor * <B>vformatGetSegmentColor</B>(
                vformatSegment * segment);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> class supports the ability 
to specify color and textutal alignment for a segment. 
For example, to specify that a <code><A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A></code>'s "negative" 
segment have a red color attribute, use the pattern below.

<pre>
  "true:[red]false"
</pre>

<P>
The segment's color and alignment attributes are not used by the 
<code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes, 
but are meant to be used by higher-level,
user-interface constructs, such as a spreadsheet cell formatter, or database
form.
</DD></DL>
<P>
<A NAME="vformatGetSegmentCount"><HR><H4>vformatGetSegmentCount</H4></A>
<PRE>
        int <B>vformatGetSegmentCount</B>(
                vformat * format);
</PRE>

<DL><DD>
A <A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A> has two segments: the positive and the negative.
A <A HREF="vformat-x.html#vformatDouble"><CODE>vformatDouble</CODE></A> has three segments: the positive, negative, and zero.
This value is primarily used by the format segment iterators.
</DD></DL>
<P>
<A NAME="vformatGetSegmentInstance"><HR><H4>vformatGetSegmentInstance</H4></A>
<PRE>
        vinstance * <B>vformatGetSegmentInstance</B>(
                vformatSegment * segment);
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></code> portion 
of the format segment object.
</DD></DL>
<P>
<A NAME="vformatGetSegmentIteratorClass"><HR><H4>vformatGetSegmentIteratorClass</H4></A>
<PRE>
        void <B>vformatGetSegmentIteratorClass</B>();
</PRE>

<DL><DD>
Returns the class used to initialize format segment iterators by
the <CODE><A HREF="vformat-x.html#vformatInitSegmentIterator"><CODE>vformatInitSegmentIterator</CODE></A></CODE> function. This class can be
modified to alter the behavior of all format segment iterators subsequently
initialized by this function. Changes to this class are not 
visible to any other applications in the same process. 
This function can be called to explicitly
register the default format segment iterator 
class with the Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetSegmentIteratorFormat"><HR><H4>vformatGetSegmentIteratorFormat</H4></A>
<PRE>
        const vformat * <B>vformatGetSegmentIteratorFormat</B>(
                vformatSegmentIterator * iterator);
</PRE>

<DL><DD>
A <code><A HREF="vformat-x.html#vformatSegmentIterator"><CODE>vformatSegmentIterator</CODE></A></code> traverses the ordered set 
of pattern segments held within a format. This entry-point returns a 
constructor reference to that format. These iterators are primarily
used by the parsing routines to convert strings to a typed-values.
</DD></DL>
<P>
<A NAME="vformatGetSegmentIteratorInstance"><HR><H4>vformatGetSegmentIteratorInstance</H4></A>
<PRE>
        void <B>vformatGetSegmentIteratorInstance</B>();
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></code> 
portion of the format segment iterator object.
</DD></DL>
<P>
<A NAME="vformatGetSegmentIteratorIterator"><HR><H4>vformatGetSegmentIteratorIterator</H4></A>
<PRE>
        void <B>vformatGetSegmentIteratorIterator</B>();
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="viterator-x.html#viterator"><CODE>viterator</CODE></A></code> 
portion of the format segment iterator.
object.
</DD></DL>
<P>
<A NAME="vformatGetSegmentIteratorPatternIndex"><HR><H4>vformatGetSegmentIteratorPatternIndex</H4></A>
<PRE>
        int <B>vformatGetSegmentIteratorPatternIndex</B>(
                vformatSegmentIterator * iterator);
</PRE>

<DL><DD>
A format can be thought of as an array of segments, where the pattern index
represents the row and the segment index indicates the column.
Calls to <code><A HREF="vformat-x.html#vformatSegmentIterator"><CODE>vformatSegmentIterator</CODE></A></code> are primarily made 
during parsing operations when an arbitrary input string is converted 
to a typed-value.
</DD></DL>
<P>
<A NAME="vformatGetSegmentIteratorSegment"><HR><H4>vformatGetSegmentIteratorSegment</H4></A>
<PRE>
        const vformatSegment * <B>vformatGetSegmentIteratorSegment</B>(
                vformatSegmentIterator * iterator);
</PRE>

<DL><DD>
Calls to <code><A HREF="vformat-x.html#vformatSegmentIterator"><CODE>vformatSegmentIterator</CODE></A></code> are primarily made 
during parsing operations when an arbitrary input string is 
converted to a typed-value.
</DD></DL>
<P>
<A NAME="vformatGetSegmentIteratorSegmentIndex"><HR><H4>vformatGetSegmentIteratorSegmentIndex</H4></A>
<PRE>
        int <B>vformatGetSegmentIteratorSegmentIndex</B>(
                vformatSegmentIterator * iterator);
</PRE>

<DL><DD>
Calls to <code><A HREF="vformat-x.html#vformatSegmentIterator"><CODE>vformatSegmentIterator</CODE></A></code> are primarily made 
during parsing operations when an arbitrary input string
is converted to a typed-value.
</DD></DL>
<P>
<A NAME="vformatGetSegmentString"><HR><H4>vformatGetSegmentString</H4></A>
<PRE>
        const vchar * <B>vformatGetSegmentString</B>(
                vformatSegment * segment);
</PRE>

<DL><DD>
Each segment contains a string from which it generates type-specific artifacts
during the call to <code><A HREF="vformat-x.html#vformatParseSegmentPattern"><CODE>vformatParseSegmentPattern</CODE></A></code>. 
This string is initially extracted from a multi-segmented pattern string 
during a call to <code><A HREF="vformat-x.html#vformatInsertPattern"><CODE>vformatInsertPattern</CODE></A></code>. Calls to 
<code><A HREF="vformat-x.html#vformatGetPatternAt"><CODE>vformatGetPatternAt</CODE></A></code> also make use of this
method to reconstruct the original pattern string.  
</DD></DL>
<P>
<A NAME="vformatGetSharedAlias"><HR><H4>vformatGetSharedAlias</H4></A>
<PRE>
        const vname * <B>vformatGetSharedAlias</B>(
                vformat * format);
</PRE>

<DL><DD>
A non-NULL shared alias name indicates that the format is one of the
set of globally shared default formats.
</DD></DL>
<P>
<A NAME="vformatGetULongBase"><HR><H4>vformatGetULongBase</H4></A>
<PRE>
        vformat * <B>vformatGetULongBase</B>(
                vformatULong * format);
</PRE>

<DL><DD>
Returns a pointer to the Base class <code>vformat</code> 
portion of the unsigned long integer format.
</DD></DL>
<P>
<A NAME="vformatGetULongClass"><HR><H4>vformatGetULongClass</H4></A>
<PRE>
        vformatULongClass * <B>vformatGetULongClass</B>(
                vformatULong * format);
</PRE>

<DL><DD>
Returns the class used to create unsigned long integer formats with the
<CODE><A HREF="vformat-x.html#vformatCreateULong"><CODE>vformatCreateULong</CODE></A></CODE> and <CODE><A HREF="vformat-x.html#vformatInitULong"><CODE>vformatInitULong</CODE></A></CODE>
functions. This class can be modified to alter the behavior of all 
unsigned long integer formats subsequently initialized by these functions. 
Changes to this class are not visible to any other applications 
in the same process. This function can be called to explicitly 
register the default unsigned long integer
format class with the Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetULongLoadable"><HR><H4>vformatGetULongLoadable</H4></A>
<PRE>
        vloadable * <B>vformatGetULongLoadable</B>(
                vformatULong * format);
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vloadable-x.html#vloadable"><CODE>vloadable</CODE></A></code> portion of the 
unsigned long integer format object.
</DD></DL>
<P>
<A NAME="vformatGetULongNumber"><HR><H4>vformatGetULongNumber</H4></A>
<PRE>
        vformatNumber * <B>vformatGetULongNumber</B>(
                vformatULong * format);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatGetULongOutputPatternIndex"><HR><H4>vformatGetULongOutputPatternIndex</H4></A>
<PRE>
        int <B>vformatGetULongOutputPatternIndex</B>(
                vformatULong * format);
</PRE>

<DL><DD>
The returned value is the index of the pattern used by
<code><A HREF="vformat-x.html#vformatScribeULong"><CODE>vformatScribeULong</CODE></A></code> for creating output strings 
for an arbitrary unsigned long integer value.
The value returned is greater-than or equal-to zero and less than the
result of calling <code><A HREF="vformat-x.html#vformatGetULongPatternCount"><CODE>vformatGetULongPatternCount</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatGetULongOutputSegment"><HR><H4>vformatGetULongOutputSegment</H4></A>
<PRE>
        const vformatULongSegment * <B>vformatGetULongOutputSegment</B>(
                vformatULong * format,
                long value);
</PRE>

<DL><DD>
When the value they are representing changes, dialog items that 
hold an associated <code><A HREF="vformat-x.html#vformatULong"><CODE>vformatULong</CODE></A></code>, 
such as <code><A HREF="vulongitem-x.html#vulongitem"><CODE>vulongitem</CODE></A></code>, can make use of this method to
update any graphical characteristics bound to the value, such as the
foreground color, or text alignment.
</DD></DL>
<P>
<A NAME="vformatGetULongOutputSegmentIndex"><HR><H4>vformatGetULongOutputSegmentIndex</H4></A>
<PRE>
        int <B>vformatGetULongOutputSegmentIndex</B>(
                vformatULong * format,
                unsigned long value);
</PRE>

<DL><DD>
Used internally by the Scribe class.
</DD></DL>
<P>
<A NAME="vformatGetULongPatternCount"><HR><H4>vformatGetULongPatternCount</H4></A>
<PRE>
        long <B>vformatGetULongPatternCount</B>(
                const vformatULong * format);
</PRE>

<DL><DD>
There is no practical limit to the number of patterns an unsigned long integer
format can contain but the worst-case efficiency of a parse operation is
linearly related (O(n)) to the number of patterns.
The returned value is equal-to or greater-than zero.
</DD></DL>
<P>
<A NAME="vformatGetULongPatternSegmentAt"><HR><H4>vformatGetULongPatternSegmentAt</H4></A>
<PRE>
        const vformatULongSegment * <B>vformatGetULongPatternSegmentAt</B>(
                vformatULong * format,
                int patternIndex,
                int segmentIndex);
</PRE>

<DL><DD>
The <SAMP>patternIndex</SAMP> must be greater-than or equal-to zero, and less
than the result of calling <code><A HREF="vformat-x.html#vformatGetULongPatternCount"><CODE>vformatGetULongPatternCount</CODE></A></code>. The
<SAMP>segmentIndex</SAMP> must be greater-than or equal to zero, and less than
the result of calling <code><A HREF="vformat-x.html#vformatGetULongSegmentCount"><CODE>vformatGetULongSegmentCount</CODE></A></code>.
This call always returns a <samp>non-null</samp> object.
</DD></DL>
<P>
<A NAME="vformatGetULongSegmentAlignment"><HR><H4>vformatGetULongSegmentAlignment</H4></A>
<PRE>
        int <B>vformatGetULongSegmentAlignment</B>(
                const vformatULongSegment * segment);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatULongSegment"><CODE>vformatULongSegment</CODE></A></code> class supports the 
ability to specify color and text alignment. 
Text alignment may be specified with the 
following pattern syntax.

<PRE>

  "{#,###" // left-aligned unsigned long integer value
  "}#,###" // right-aligned unsigned long integer value
  "|#,###" // centered unsigned long integer value

</Pre>

<P>
The text alignment codes returned are:

<ul>
<li>vformatALIGN_LEFT [default]
<li>vformatALIGN_RIGHT
<li>vformatALIGN_CENTER
</ul>
</DD></DL>
<P>
<A NAME="vformatGetULongSegmentBase"><HR><H4>vformatGetULongSegmentBase</H4></A>
<PRE>
        vformatNumberSegment * <B>vformatGetULongSegmentBase</B>(
                vformatULongSegment * segment);
</PRE>

<DL><DD>
Returns a pointer to the base-class <code><A HREF="vformat-x.html#vformatNumberSegment"><CODE>vformatNumberSegment</CODE></A></code> 
portion of the unsigned long integer format segment.
</DD></DL>
<P>
<A NAME="vformatGetULongSegmentColor"><HR><H4>vformatGetULongSegmentColor</H4></A>
<PRE>
        vcolor * <B>vformatGetULongSegmentColor</B>(
                const vformatULongSegment * segment);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatULongSegment"><CODE>vformatULongSegment</CODE></A></code> class supports 
the ability to specify color and textutal alignment for a segment. 
For example, to specify that a <code><A HREF="vformat-x.html#vformatULongSegment"><CODE>vformatULongSegment</CODE></A></code> 
have a red color attribute, use the pattern below.

<Pre>
  "[red]#,###"
</Pre>

<P>
The segment's color and alignment attributes are not used by the 
classes derived from <code>vformat</code>
or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code>, but are meant to be used by higher-level, 
user-interface constructs, such as a spreadsheet cell formatter, or database
form.
</DD></DL>
<P>
<A NAME="vformatGetULongSegmentCount"><HR><H4>vformatGetULongSegmentCount</H4></A>
<PRE>
        int <B>vformatGetULongSegmentCount</B>(
                vformatULong * format);
</PRE>

<DL><DD>
An unsigned long integer format pattern contains two segments representing a
positive and a zero-value, in that order.
</DD></DL>
<P>
<A NAME="vformatGetULongSegmentIteratorBase"><HR><H4>vformatGetULongSegmentIteratorBase</H4></A>
<PRE>
        void <B>vformatGetULongSegmentIteratorBase</B>();
</PRE>

<DL><DD>
Returns a pointer to the Base class <code><A HREF="vformat-x.html#vformatNumberSegmentIterator"><CODE>vformatNumberSegmentIterator</CODE></A></code> 
portion of the unsigned long integer format segment iterator.
</DD></DL>
<P>
<A NAME="vformatGetULongSegmentIteratorClass"><HR><H4>vformatGetULongSegmentIteratorClass</H4></A>
<PRE>
        void <B>vformatGetULongSegmentIteratorClass</B>();
</PRE>

<DL><DD>
Returns the class used to initialize unsigned long integer format segment
iterators by the <CODE><A HREF="vformat-x.html#vformatInitULongSegmentIterator"><CODE>vformatInitULongSegmentIterator</CODE></A></CODE> function. This
class can be modified to alter the behavior of all unsigned long integer format
segment iterators subsequently initialized by this function. Changes to this
class are not visible to any other applications in the same process. This
function can be called to explicitly register the default unsigned long integer
format segment iterator class with the Class Manager classes.
</DD></DL>
<P>
<A NAME="vformatGetULongSegmentIteratorFormat"><HR><H4>vformatGetULongSegmentIteratorFormat</H4></A>
<PRE>
        void <B>vformatGetULongSegmentIteratorFormat</B>();
</PRE>

<DL><DD>
A <code><A HREF="vformat-x.html#vformatULongSegmentIterator"><CODE>vformatULongSegmentIterator</CODE></A></code> is initialized by a call to
<code><A HREF="vformat-x.html#vformatInitULongSegmentIterator"><CODE>vformatInitULongSegmentIterator</CODE></A></code>, taking as a parameter 
a pointer to the <code><A HREF="vformat-x.html#vformatULong"><CODE>vformatULong</CODE></A></code> over whose segments 
the iterator passes. This accessor method returns a pointer 
to that unsigned long integer format.
</DD></DL>
<P>
<A NAME="vformatGetULongSegmentIteratorInstance"><HR><H4>vformatGetULongSegmentIteratorInstance</H4></A>
<PRE>
        void <B>vformatGetULongSegmentIteratorInstance</B>();
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></code> portion of the 
unsigned long integer format segment iterator object.
</DD></DL>
<P>
<A NAME="vformatGetULongSegmentIteratorIterator"><HR><H4>vformatGetULongSegmentIteratorIterator</H4></A>
<PRE>
        void <B>vformatGetULongSegmentIteratorIterator</B>();
</PRE>

<DL><DD>
Returns a pointer to the <code><A HREF="viterator-x.html#viterator"><CODE>viterator</CODE></A></code> portion of the 
unsigned long integer format segment iterator object.
</DD></DL>
<P>
<A NAME="vformatGetULongSegmentIteratorPatternIndex"><HR><H4>vformatGetULongSegmentIteratorPatternIndex</H4></A>
<PRE>
        void <B>vformatGetULongSegmentIteratorPatternIndex</B>();
</PRE>

<DL><DD>
Returns the index of the current unsigned long integer format pattern in the
sequence.
</DD></DL>
<P>
<A NAME="vformatGetULongSegmentIteratorSegment"><HR><H4>vformatGetULongSegmentIteratorSegment</H4></A>
<PRE>
        void <B>vformatGetULongSegmentIteratorSegment</B>();
</PRE>

<DL><DD>
Returns a pointer to the current <code><A HREF="vformat-x.html#vformatULongSegment"><CODE>vformatULongSegment</CODE></A></code> 
in the sequence.
</DD></DL>
<P>
<A NAME="vformatGetULongSegmentIteratorSegmentIndex"><HR><H4>vformatGetULongSegmentIteratorSegmentIndex</H4></A>
<PRE>
        void <B>vformatGetULongSegmentIteratorSegmentIndex</B>();
</PRE>

<DL><DD>
Returns the pattern-relative index of the current 
<code>vformaUtLongSegment</code> in the sequence.
</DD></DL>
<P>
<A NAME="vformatGetULongSegmentPrefix"><HR><H4>vformatGetULongSegmentPrefix</H4></A>
<PRE>
        const vchar * <B>vformatGetULongSegmentPrefix</B>(
                const vformatULongSegment * segment);
</PRE>

<DL><DD>
Each unsigned long integer format can have an optional prefix and/or suffix
string that is literal text at the beginning of ending of the segment pattern.
This literal text must be matched indentically by the input string for a
parsing operation to succeed. The literal text is also used when
constructing an output form of a given unsigned long integer value.
</DD></DL>
<P>
<A NAME="vformatGetULongSegmentScale"><HR><H4>vformatGetULongSegmentScale</H4></A>
<PRE>
        long <B>vformatGetULongSegmentScale</B>(
                const vformatULongSegment * segment);
</PRE>

<DL><DD>
Gets the scale factor the segment uses for parsing and for conversion
of an unsigned long integer value to a string.
</DD></DL>
<P>
<A NAME="vformatGetULongSegmentString"><HR><H4>vformatGetULongSegmentString</H4></A>
<PRE>
        const vchar * <B>vformatGetULongSegmentString</B>(
                const vformatULongSegment * segment);
</PRE>

<DL><DD>
This is the segment's portion of the original pattern strings set by
<code><A HREF="vformat-x.html#vformatAppendULongPattern"><CODE>vformatAppendULongPattern</CODE></A></code> or 
<code><A HREF="vformat-x.html#vformatInsertULongPattern"><CODE>vformatInsertULongPattern</CODE></A></code>.
This function is used internally by <code>vformatGetULongPatternAt</code> to
reconstruct the original pattern string.
</DD></DL>
<P>
<A NAME="vformatGetULongSegmentSuffix"><HR><H4>vformatGetULongSegmentSuffix</H4></A>
<PRE>
        const vchar * <B>vformatGetULongSegmentSuffix</B>(
                const vformatULongSegment * segment);
</PRE>

<DL><DD>
Each unsigned long integer format segment can have an optional prefix and/or
suffix string that is literal text at the beginning of ending of a segment
pattern. This literal text must be matched indentically by the input
string for a parsing operation to succeed. The literal text is also used
when constructing an output form of a given unsigned long integer value.
</DD></DL>
<P>
<A NAME="vformatIncrementParseRangeStart"><HR><H4>vformatIncrementParseRangeStart</H4></A>
<PRE>
        void <B>vformatIncrementParseRangeStart</B>(
                vformatParseRange * range,
                int len);
</PRE>

<DL><DD>
Moves the starting offset <SAMP>len</SAMP> characters to the right, decrementing
the range length by the same amount.
</DD></DL>
<P>
<A NAME="vformatInit"><HR><H4>vformatInit</H4></A>
<PRE>
        void <B>vformatInit</B>(
                vformat * format);
</PRE>

<DL><DD>
Initializes a format of the default format class in the memory addressed by
<SAMP>format</SAMP>. The new format is not useful in and of itself, but rather,
its type-specific derivatives are those that can be used for parsing and
scribing of specific values. This function stores the default format 
class in the class field of the format
and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitBoolean"><HR><H4>vformatInitBoolean</H4></A>
<PRE>
        void <B>vformatInitBoolean</B>(
                vformatBoolean * format);
</PRE>

<DL><DD>
Initializes a format of the default Boolean format class 
in the memory addressed by <SAMP>format</SAMP>. 
The new Boolean format has no patterns. Use
<CODE><A HREF="vformat-x.html#vformatAppendBooleanPattern"><CODE>vformatAppendBooleanPattern</CODE></A></CODE> or
<CODE><A HREF="vformat-x.html#vformatInsertBooleanPattern"><CODE>vformatInsertBooleanPattern</CODE></A></CODE> to populate the 
Boolean format's pattern set. 
<P>
The address can be used in other 
calls to the Format classes as if they were
created with <CODE><A HREF="vformat-x.html#vformatCreateBoolean"><CODE>vformatCreateBoolean</CODE></A></CODE>. A call to
<CODE><A HREF="vformat-x.html#vformatDestroyBoolean"><CODE>vformatDestroyBoolean</CODE></A></CODE> frees any internal objects allocated by the
Format class but does <I>not</I> free the structure itself. This function
stores the default Boolean Format class in the class field of the format and
sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitBooleanSegment"><HR><H4>vformatInitBooleanSegment</H4></A>
<PRE>
        void <B>vformatInitBooleanSegment</B>(
                vformatBooleanSegment * segment);
</PRE>

<DL><DD>
Initializes a segment of the default Boolean format segment class 
in the memory addressed by <SAMP>segment</SAMP>. The new Boolean 
format segment has no pattern string. 
Use <CODE><A HREF="vformat-x.html#vformatSetBooleanSegmentString"><CODE>vformatSetBooleanSegmentString</CODE></A></CODE> to initialize the
segment's internal attributes from a valid Boolean pattern string.
<P>
The address can be used in other calls to the Format classs as if they were
created with <CODE><A HREF="vformat-x.html#vformatCreateBooleanSegment"><CODE>vformatCreateBooleanSegment</CODE></A></CODE>. A call to
<CODE><A HREF="vformat-x.html#vformatDestroyBooleanSegment"><CODE>vformatDestroyBooleanSegment</CODE></A></CODE> frees any internal objects allocated
by the Format class but does <I>not</I> free the structure itself. This
function stores the default Boolean Format Segment class in the class field of
the segment and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitBooleanSegmentIterator"><HR><H4>vformatInitBooleanSegmentIterator</H4></A>
<PRE>
        void <B>vformatInitBooleanSegmentIterator</B>();
</PRE>

<DL><DD>
Initializes an iterator of the default Boolean format segment iterator class in
the memory addressed by <SAMP>iter</SAMP>. The new segment iterator passes 
over the pattern segments contained by <CODE>format</CODE>. A call to
<CODE><A HREF="vformat-x.html#vformatDestroyBooleanSegmentIterator"><CODE>vformatDestroyBooleanSegmentIterator</CODE></A></CODE> frees any internal objects
allocated by the Format class but does <I>not</I> free the structure itself.
This function stores the default Boolean Format Segment Iterator class in the
class field of the iterator and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitBooleanSegmentIteratorOfClass"><HR><H4>vformatInitBooleanSegmentIteratorOfClass</H4></A>
<PRE>
        void <B>vformatInitBooleanSegmentIteratorOfClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatInitDate"><HR><H4>vformatInitDate</H4></A>
<PRE>
        void <B>vformatInitDate</B>(
                vformatDate * format);
</PRE>

<DL><DD>
Initializes a format of the default date format class in the memory addressed
by <SAMP>format</SAMP>. The new date format has no patterns.  Use
<CODE><A HREF="vformat-x.html#vformatAppendDatePattern"><CODE>vformatAppendDatePattern</CODE></A></CODE> or <CODE><A HREF="vformat-x.html#vformatInsertDatePattern"><CODE>vformatInsertDatePattern</CODE></A></CODE>
to populate the date format's pattern set. The address can be used in other
calls to the Format classes as if they were created with
<CODE><A HREF="vformat-x.html#vformatCreateDate"><CODE>vformatCreateDate</CODE></A></CODE>. A call to <CODE><A HREF="vformat-x.html#vformatDestroyDate"><CODE>vformatDestroyDate</CODE></A></CODE> frees
any internal objects allocated by the Format class but does <I>not</I> free
the structure itself. This function stores the default date format class in the
class field of the format and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitDateSegment"><HR><H4>vformatInitDateSegment</H4></A>
<PRE>
        void <B>vformatInitDateSegment</B>(
                vformatDateSegment * segment);
</PRE>

<DL><DD>
Initializes a segment of the default date format segment class in the memory
addressed by <SAMP>segment</SAMP>. The new date format segment has no pattern
string. Use <CODE><A HREF="vformat-x.html#vformatSetDateSegmentString"><CODE>vformatSetDateSegmentString</CODE></A></CODE> to initialize the
segment's internal attributes from a valid date pattern string.
The address can be used in other calls to the Format classes as if they were
created with <CODE><A HREF="vformat-x.html#vformatCreateDateSegment"><CODE>vformatCreateDateSegment</CODE></A></CODE>. A call to
<CODE><A HREF="vformat-x.html#vformatDestroyDateSegment"><CODE>vformatDestroyDateSegment</CODE></A></CODE> frees any internal objects allocated
by the Format class but does <I>not</I> free the structure itself. This
function stores the default date format segment class in the class field of
the segment and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitDateSegmentIterator"><HR><H4>vformatInitDateSegmentIterator</H4></A>
<PRE>
        void <B>vformatInitDateSegmentIterator</B>();
</PRE>

<DL><DD>
Initializes an iterator of the default date format segment iterator class in
the memory addressed by <SAMP>iter</SAMP>. The new segment iterator passes 
over the pattern segments contained by <CODE>format</CODE>. A call to
<CODE><A HREF="vformat-x.html#vformatDestroyDateSegmentIterator"><CODE>vformatDestroyDateSegmentIterator</CODE></A></CODE> frees any internal objects
allocated by the Format class but does <I>not</I> free the structure itself.
This function stores the default date format segment iterator class in the
class field of the iterator and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitDateSegmentIteratorOfClass"><HR><H4>vformatInitDateSegmentIteratorOfClass</H4></A>
<PRE>
        void <B>vformatInitDateSegmentIteratorOfClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatInitDefaultNamedFormat"><HR><H4>vformatInitDefaultNamedFormat</H4></A>
<PRE>
        void <B>vformatInitDefaultNamedFormat</B>(
                vformat * format,
                const vname * name);
</PRE>

<DL><DD>
A dictionary resource named as the class of the format is found in the
system resource file. In this resource is another dictionary resource
of the given name where an array-of-string resource tagged "patterns"
is located. The patterns resource is used in a call to 
<code><A HREF="vformat-x.html#vformatLoadPatterns"><CODE>vformatLoadPatterns</CODE></A></code> to initialize the default format pattern set.
Galaxy throws a Module exception if any of the listed resources cannot be
found in the system resource file:

<pre>
 <system resource>\<class-of-format>\<name>\patterns
</pre>
</DD></DL>
<P>
<A NAME="vformatInitDouble"><HR><H4>vformatInitDouble</H4></A>
<PRE>
        void <B>vformatInitDouble</B>(
                vformatDouble * format);
</PRE>

<DL><DD>
Initializes a format of the default double format class in the memory addressed
by <SAMP>format</SAMP>. The new double format has no patterns. Use
<CODE><A HREF="vformat-x.html#vformatAppendDoublePattern"><CODE>vformatAppendDoublePattern</CODE></A></CODE> or
<CODE><A HREF="vformat-x.html#vformatInsertDoublePattern"><CODE>vformatInsertDoublePattern</CODE></A></CODE> to populate the double format's pattern
set. The address can be used in other calls to the Format classes as if it were
created with <CODE><A HREF="vformat-x.html#vformatCreateDouble"><CODE>vformatCreateDouble</CODE></A></CODE>. A call to
<CODE><A HREF="vformat-x.html#vformatDestroyDouble"><CODE>vformatDestroyDouble</CODE></A></CODE> frees any internal objects allocated by the
Format class but does <I>not</I> free the structure itself. This function
stores the default double format class in the class field of the format and
sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitDoubleSegment"><HR><H4>vformatInitDoubleSegment</H4></A>
<PRE>
        void <B>vformatInitDoubleSegment</B>(
                vformatDoubleSegment * segment);
</PRE>

<DL><DD>
Initializes a segment of the default double format segment class in the memory
addressed by <SAMP>segment</SAMP>. The new double format segment has no pattern
string. Use <CODE><A HREF="vformat-x.html#vformatSetDoubleSegmentString"><CODE>vformatSetDoubleSegmentString</CODE></A></CODE> to initialize the
segment's internal attributes from a valid double pattern string.
The address can be used in other calls to the Format classes as if they were
created with <CODE><A HREF="vformat-x.html#vformatCreateDoubleSegment"><CODE>vformatCreateDoubleSegment</CODE></A></CODE>. A call to
<CODE><A HREF="vformat-x.html#vformatDestroyDoubleSegment"><CODE>vformatDestroyDoubleSegment</CODE></A></CODE> frees any internal objects allocated
by the Format class but does <I>not</I> free the structure itself. This
function stores the default double format segment class in the class field of
the segment and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitDoubleSegmentIterator"><HR><H4>vformatInitDoubleSegmentIterator</H4></A>
<PRE>
        void <B>vformatInitDoubleSegmentIterator</B>();
</PRE>

<DL><DD>
Initializes an iterator of the default double format segment iterator class in
the memory addressed by <SAMP>iter</SAMP>. The new segment iterator passes 
over the pattern segments contained by <CODE>format</CODE>. A call to
<CODE><A HREF="vformat-x.html#vformatDestroyDoubleSegmentIterator"><CODE>vformatDestroyDoubleSegmentIterator</CODE></A></CODE> frees any internal objects
allocated by the Format class but does <I>not</I> free the structure itself.
This function stores the default double format segment iterator class in the
class field of the iterator and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitDoubleSegmentIteratorOfClass"><HR><H4>vformatInitDoubleSegmentIteratorOfClass</H4></A>
<PRE>
        void <B>vformatInitDoubleSegmentIteratorOfClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatInitLong"><HR><H4>vformatInitLong</H4></A>
<PRE>
        void <B>vformatInitLong</B>(
                vformatLong * format);
</PRE>

<DL><DD>
Initializes a format of the default long integer format class in the memory
addressed by <SAMP>format</SAMP>. The new long integer format has no patterns.
Use <CODE><A HREF="vformat-x.html#vformatAppendLongPattern"><CODE>vformatAppendLongPattern</CODE></A></CODE> or
<CODE><A HREF="vformat-x.html#vformatInsertLongPattern"><CODE>vformatInsertLongPattern</CODE></A></CODE> to populate the long integer format's
pattern set. The address can be used in other calls to the Format classes 
as if they were created with <CODE><A HREF="vformat-x.html#vformatCreateLong"><CODE>vformatCreateLong</CODE></A></CODE>. A call to
<CODE><A HREF="vformat-x.html#vformatDestroyLong"><CODE>vformatDestroyLong</CODE></A></CODE> frees any internal objects allocated by the
Format class but does <I>not</I> free the structure itself. This function
stores the default long integer format class in the class field 
of the format and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitLongSegment"><HR><H4>vformatInitLongSegment</H4></A>
<PRE>
        void <B>vformatInitLongSegment</B>(
                vformatLongSegment * segment);
</PRE>

<DL><DD>
Initializes a segment of the default long integer format segment class in the
memory addressed by <SAMP>segment</SAMP>. The new long integer format segment
has no pattern string. Use <CODE><A HREF="vformat-x.html#vformatSetLongSegmentString"><CODE>vformatSetLongSegmentString</CODE></A></CODE> to
initialize the segment's internal attributes from a valid long integer pattern
string. The address can be used in other calls to the Format classes as if they
were created with <CODE><A HREF="vformat-x.html#vformatCreateLongSegment"><CODE>vformatCreateLongSegment</CODE></A></CODE>. A call to
<CODE><A HREF="vformat-x.html#vformatDestroyLongSegment"><CODE>vformatDestroyLongSegment</CODE></A></CODE> frees any internal objects allocated
by the Format class but does <I>not</I> free the structure itself. This
function stores the default long integer format segment 
class in the class field of the segment and sends it 
the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitLongSegmentIterator"><HR><H4>vformatInitLongSegmentIterator</H4></A>
<PRE>
        void <B>vformatInitLongSegmentIterator</B>();
</PRE>

<DL><DD>
Initializes an iterator of the default long integer format segment iterator
class in the memory addressed by <SAMP>iter</SAMP>. The new segment iterator
passes over the pattern segments contained by <CODE>format</CODE>. A
call to <CODE><A HREF="vformat-x.html#vformatDestroyLongSegmentIterator"><CODE>vformatDestroyLongSegmentIterator</CODE></A></CODE> frees any internal
objects allocated by the Format classes but does <I>not</I> free the structure
itself. This function stores the default long integer format segment iterator
class in the class field of the iterator and sends it the message
<CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitLongSegmentIteratorOfClass"><HR><H4>vformatInitLongSegmentIteratorOfClass</H4></A>
<PRE>
        void <B>vformatInitLongSegmentIteratorOfClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatInitNumber"><HR><H4>vformatInitNumber</H4></A>
<PRE>
        void <B>vformatInitNumber</B>(
                vformatNumber * format);
</PRE>

<DL><DD>
Initializes a format of the default number format class in the memory
addressed by <SAMP>format</SAMP>. The new number format has no patterns.
Use <CODE><A HREF="vformat-x.html#vformatAppendNumberPattern"><CODE>vformatAppendNumberPattern</CODE></A></CODE> or
<CODE><A HREF="vformat-x.html#vformatInsertNumberPattern"><CODE>vformatInsertNumberPattern</CODE></A></CODE> to populate the number format's pattern
set. The address can be used in other calls to the Format class as if
it were created with <CODE><A HREF="vformat-x.html#vformatCreateNumber"><CODE>vformatCreateNumber</CODE></A></CODE>. A call to
<CODE><A HREF="vformat-x.html#vformatDestroyNumber"><CODE>vformatDestroyNumber</CODE></A></CODE> frees any internal objects allocated by the
Format class but does <I>not</I> free the structure itself. This function
stores the default number format class in the class field of the format and
sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitNumberSegment"><HR><H4>vformatInitNumberSegment</H4></A>
<PRE>
        void <B>vformatInitNumberSegment</B>(
                vformatNumberSegment * segment);
</PRE>

<DL><DD>
Initializes a segment of the default number format segment class in the
memory addressed by <SAMP>segment</SAMP>.
The default number format segment class provides functionality 
common to each of type-specific number format segment derivatives 
and it not useful by itself.
The address can be used in other calls to the Format class as if it
were created with <CODE><A HREF="vformat-x.html#vformatCreateNumberSegment"><CODE>vformatCreateNumberSegment</CODE></A></CODE>. A call to
<CODE><A HREF="vformat-x.html#vformatDestroyNumberSegment"><CODE>vformatDestroyNumberSegment</CODE></A></CODE> frees any internal objects allocated
by the Format class, but does <I>not</I> free the structure itself. This
function stores the default number format segment class in the class field
of the segment and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitNumberSegmentIterator"><HR><H4>vformatInitNumberSegmentIterator</H4></A>
<PRE>
        void <B>vformatInitNumberSegmentIterator</B>();
</PRE>

<DL><DD>
Initializes an iterator of the default number format segment iterator
class in the memory addressed by <SAMP>iter</SAMP>. 
The new segment iterator passes over the pattern 
segments contained by <CODE>format</CODE>. A call to
<CODE><A HREF="vformat-x.html#vformatDestroyNumberSegmentIterator"><CODE>vformatDestroyNumberSegmentIterator</CODE></A></CODE> frees any internal objects
allocated by the Format class but does <I>not</I> free the structure itself.
This function stores the default number format segment iterator class in the
class field of the iterator and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitNumberSegmentIteratorOfClass"><HR><H4>vformatInitNumberSegmentIteratorOfClass</H4></A>
<PRE>
        void <B>vformatInitNumberSegmentIteratorOfClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatInitOfClass"><HR><H4>vformatInitOfClass</H4></A>
<PRE>
        void <B>vformatInitOfClass</B>(
                vformat * format,
                vformatClass * clas);
</PRE>

<DL><DD>
Initializes a format of class <SAMP>clas</SAMP> in the memory addressed by
<SAMP>format</SAMP>. The new format has no patterns. The address can be used
in other calls to the Format classes as if they were created with
<CODE><A HREF="vformat-x.html#vformatCreateOfClass"><CODE>vformatCreateOfClass</CODE></A></CODE>. A call to <CODE><A HREF="vformat-x.html#vformatDestroy"><CODE>vformatDestroy</CODE></A></CODE> frees
any internal objects allocated by the Format class, but does <I>not</I> free
the structure itself. This function stores the class in the class field of the
format and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitParseRange"><HR><H4>vformatInitParseRange</H4></A>
<PRE>
        void <B>vformatInitParseRange</B>(
                vformatParseRange * range);
</PRE>

<DL><DD>
Initializes a parse range of the default class in the memory addressed by
<SAMP>range</SAMP>. The address can be used in other calls to the 
Format class as if it is created with <CODE><A HREF="vformat-x.html#vformatCreateParseRange"><CODE>vformatCreateParseRange</CODE></A></CODE>. 
A call to <CODE><A HREF="vformat-x.html#vformatDestroyParseRange"><CODE>vformatDestroyParseRange</CODE></A></CODE> frees any internal 
objects allocated by the Format classes, but does <I>not</I> 
free the structure itself. This function stores the default 
parse range class in the class field of the range and sends
it the message <CODE>vobjectINIT</CODE>.
<P>
Parse ranges are created internally by the Format class 
and passed along during invocation of the various parse methods.
</DD></DL>
<P>
<A NAME="vformatInitSegment"><HR><H4>vformatInitSegment</H4></A>
<PRE>
        void <B>vformatInitSegment</B>(
                vformatSegment * segment);
</PRE>

<DL><DD>
Initializes a segment of the default format segment class in the memory
addressed by <SAMP>segment</SAMP>. The new segment is not useful in and of
itself, but rather, its type-specific derivatives are those that can be used
for parsing and scribing of specific values.
This function stores the default format segment class in the class field of the
segment and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitSegmentIterator"><HR><H4>vformatInitSegmentIterator</H4></A>
<PRE>
        void <B>vformatInitSegmentIterator</B>(
                vformatSegmentIterator * iter,
                const vformat * format);
</PRE>

<DL><DD>
Initializes an iterator of the default format segment iterator class in the
memory addressed by <SAMP>iter</SAMP>. The new segment iterator passes 
over the pattern segments contained by <CODE>format</CODE>. A call to
<CODE><A HREF="vformat-x.html#vformatDestroySegmentIterator"><CODE>vformatDestroySegmentIterator</CODE></A></CODE> frees any internal objects allocated
by the Format class but does <I>not</I> free the structure itself. This
function stores the default format segment iterator class in the class field of
the iterator and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitSegmentIteratorOfClass"><HR><H4>vformatInitSegmentIteratorOfClass</H4></A>
<PRE>
        void <B>vformatInitSegmentIteratorOfClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatInitULong"><HR><H4>vformatInitULong</H4></A>
<PRE>
        void <B>vformatInitULong</B>(
                vformatULong * format);
</PRE>

<DL><DD>
Initializes a format of the default unsigned long integer format class in the
memory addressed by <SAMP>format</SAMP>. The new unsigned long integer format
has no patterns. Use <CODE><A HREF="vformat-x.html#vformatAppendULongPattern"><CODE>vformatAppendULongPattern</CODE></A></CODE> or
<CODE><A HREF="vformat-x.html#vformatInsertULongPattern"><CODE>vformatInsertULongPattern</CODE></A></CODE> to populate the unsigned long integer
format's pattern set. The address can be used in other calls to the Format
classes as if they were created with <CODE><A HREF="vformat-x.html#vformatCreateULong"><CODE>vformatCreateULong</CODE></A></CODE>. A call to
<CODE><A HREF="vformat-x.html#vformatDestroyULong"><CODE>vformatDestroyULong</CODE></A></CODE> frees any internal objects allocated by the
Format class but does <I>not</I> free the structure itself. This function
stores the default unsigned long integer format class in the class field of the
format and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitULongSegment"><HR><H4>vformatInitULongSegment</H4></A>
<PRE>
        void <B>vformatInitULongSegment</B>(
                vformatULongSegment * segment);
</PRE>

<DL><DD>
Initializes a segment of the default unsigned long integer format segment class
in the memory addressed by <SAMP>segment</SAMP>. The new unsigned long integer
format segment has no pattern string. Use
<CODE><A HREF="vformat-x.html#vformatSetULongSegmentString"><CODE>vformatSetULongSegmentString</CODE></A></CODE> to initialize the segment's internal
attributes from a valid unsigned long integer pattern string. The address can
be used in other calls to the Format classes as if they were created with
<CODE><A HREF="vformat-x.html#vformatCreateULongSegment"><CODE>vformatCreateULongSegment</CODE></A></CODE>. A call to
<CODE><A HREF="vformat-x.html#vformatDestroyULongSegment"><CODE>vformatDestroyULongSegment</CODE></A></CODE> frees any internal objects allocated
by the Format class, but does <I>not</I> free the structure itself. This
function stores the default unsigned long integer format segment class in the
class field of the segment and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitULongSegmentIterator"><HR><H4>vformatInitULongSegmentIterator</H4></A>
<PRE>
        void <B>vformatInitULongSegmentIterator</B>();
</PRE>

<DL><DD>
Initializes an iterator of the default unsigned long integer format segment
iterator class in the memory addressed by <SAMP>iter</SAMP>. The iterator
passes over the pattern segments contained by <CODE>format</CODE>. A
call to <CODE><A HREF="vformat-x.html#vformatDestroyULongSegmentIterator"><CODE>vformatDestroyULongSegmentIterator</CODE></A></CODE> frees any internal
objects allocated by the Format class, but does <I>not</I> free the structure
itself. This function stores the default unsigned long integer format segment
iterator class in the class field of the iterator and sends it the message
<CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vformatInitULongSegmentIteratorOfClass"><HR><H4>vformatInitULongSegmentIteratorOfClass</H4></A>
<PRE>
        void <B>vformatInitULongSegmentIteratorOfClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatInsertBooleanPattern"><HR><H4>vformatInsertBooleanPattern</H4></A>
<PRE>
        void <B>vformatInsertBooleanPattern</B>(
                vformatBoolean * format,
                const vchar * string,
                int index);
</PRE>

<DL><DD>
Each pattern string is first broken down into its constituent segment
strings, each segment string being seperated by the semi-colon
character (';'). Next, <samp><A HREF="vformat-x.html#vformatBooleanSegment"><CODE>vformatBooleanSegment</CODE></A></samp> segments of the 
number necessary are created and assigned their
strings by <code><A HREF="vformat-x.html#vformatSetBooleanSegmentString"><CODE>vformatSetBooleanSegmentString</CODE></A></code>. 
Each segment is then called on to parse its string. At this point, 
the segment generates any artifacts needed to determine the validity 
of an arbitrary input string with respect to its pattern. 
Finally, if each segment successfully parses its
pattern string, the segment group is inserted at the specified location in the
ordered set of patterns.
<P>
Galaxy throws a <samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp> if any portion 
of the pattern string is not understood by the format.
</DD></DL>
<P>
<A NAME="vformatInsertBooleanPatternScribed"><HR><H4>vformatInsertBooleanPatternScribed</H4></A>
<PRE>
        void <B>vformatInsertBooleanPatternScribed</B>(
                vformatBoolean * format,
                vscribe * scribe,
                int index);
</PRE>

<DL><DD>
Each pattern string is first broken down into its constituent segment
strings, each segment string being seperated by the semi-colon
character (';'). Next, <samp><A HREF="vformat-x.html#vformatBooleanSegment"><CODE>vformatBooleanSegment</CODE></A></samp> segments of the 
number necessary are created and assigned their
strings by <code><A HREF="vformat-x.html#vformatSetBooleanSegmentString"><CODE>vformatSetBooleanSegmentString</CODE></A></code>. 
Each segment is then called on to parse its string. At this point, 
the segment generates any artifacts needed to determine the validity 
of an arbitrary input string with respect to its pattern. 
Finally, if each segment successfully parses its
pattern string, the segment group is inserted at the specified location in the
ordered set of patterns.
<P>
Galaxy throws a <samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp> if any portion 
of the pattern string is not understood by the format.
</DD></DL>
<P>
<A NAME="vformatInsertDatePattern"><HR><H4>vformatInsertDatePattern</H4></A>
<PRE>
        void <B>vformatInsertDatePattern</B>(
                vformatDate * format,
                const vchar * string,
                int count);
</PRE>

<DL><DD>
A <samp><A HREF="vformat-x.html#vformatDateSegment"><CODE>vformatDateSegment</CODE></A></samp> is created and assigned its 
pattern string by <code><A HREF="vformat-x.html#vformatSetDateSegmentString"><CODE>vformatSetDateSegmentString</CODE></A></code>. 
Then, the segment is called on to parse its pattern string. At this point, 
the segment generates any artifacts it needs
to determine the validity of an arbitrary input string with respect to the
pattern. Finally, if the segment successfully parses its pattern string, the
segment is inserted at the specified location in the ordered set of patterns.
<P>
Galaxy throws a <samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp> if any portion 
of the pattern string is not understood by the format.
</DD></DL>
<P>
<A NAME="vformatInsertDatePatternScribed"><HR><H4>vformatInsertDatePatternScribed</H4></A>
<PRE>
        void <B>vformatInsertDatePatternScribed</B>(
                vformatDate * format,
                vscribe * scribe,
                int count);
</PRE>

<DL><DD>
A <samp><A HREF="vformat-x.html#vformatDateSegment"><CODE>vformatDateSegment</CODE></A></samp> is created and assigned its 
pattern string by <code><A HREF="vformat-x.html#vformatSetDateSegmentString"><CODE>vformatSetDateSegmentString</CODE></A></code>. 
Then, the segment is called on to parse its pattern string. At this point, 
the segment generates any artifacts it needs
to determine the validity of an arbitrary input string with respect to the
pattern. Finally, if the segment successfully parses its pattern string, the
segment is inserted at the specified location in the ordered set of patterns.
<P>
Galaxy throws a <samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp> if any portion 
of the pattern string is not understood by the format.
</DD></DL>
<P>
<A NAME="vformatInsertDoublePattern"><HR><H4>vformatInsertDoublePattern</H4></A>
<PRE>
        void <B>vformatInsertDoublePattern</B>(
                vformatDouble * format,
                const vchar * string,
                int index);
</PRE>

<DL><DD>
The pattern string is first decomposed into its constituent segment strings
and a <samp><A HREF="vformat-x.html#vformatDoubleSegment"><CODE>vformatDoubleSegment</CODE></A></samp> is created for each and associated by
<code><A HREF="vformat-x.html#vformatSetDoubleSegmentString"><CODE>vformatSetDoubleSegmentString</CODE></A></code>. 
Then, each segment is called on to parse its pattern string. At this point, 
the segment generates any artifacts it needs to determine 
the validity of an arbitrary input string with respect to the
pattern. Finally, if each segment successfully parses its pattern string, the
set of segments is inserted at the specified location in the ordered set of
patterns.
<P>
Galaxy throws a <samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp> if any 
portion of the pattern string is not understood by the format.
</DD></DL>
<P>
<A NAME="vformatInsertDoublePatternScribed"><HR><H4>vformatInsertDoublePatternScribed</H4></A>
<PRE>
        void <B>vformatInsertDoublePatternScribed</B>(
                vformatDouble * format,
                vscribe * scribe,
                int index);
</PRE>

<DL><DD>
The pattern string is first decomposed into its constituent segment strings
and a <samp><A HREF="vformat-x.html#vformatDoubleSegment"><CODE>vformatDoubleSegment</CODE></A></samp> is created for each and associated by
<code><A HREF="vformat-x.html#vformatSetDoubleSegmentString"><CODE>vformatSetDoubleSegmentString</CODE></A></code>. 
Then, each segment is called on to parse its pattern string. At this point, 
the segment generates any artifacts it needs to determine 
the validity of an arbitrary input string with respect to the
pattern. Finally, if each segment successfully parses its pattern string, the
set of segments is inserted at the specified location in the ordered set of
patterns.
<P>
Galaxy throws a <samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp> if any 
portion of the pattern string is not understood by the format.
</DD></DL>
<P>
<A NAME="vformatInsertLongPattern"><HR><H4>vformatInsertLongPattern</H4></A>
<PRE>
        void <B>vformatInsertLongPattern</B>(
                vformatLong * format,
                const vchar * string,
                int index);
</PRE>

<DL><DD>
The pattern string is first decomposed into its constituent segment strings
and a <samp><A HREF="vformat-x.html#vformatLongSegment"><CODE>vformatLongSegment</CODE></A></samp> is created for each and associated by
<code><A HREF="vformat-x.html#vformatSetLongSegmentString"><CODE>vformatSetLongSegmentString</CODE></A></code>. Then, each segment is 
called on to parse its pattern string, at which point the segment 
generates any artifacts it needs to determine the validity of an 
arbitrary input string with respect to the
pattern. Finally, if each segment successfully parses its pattern string, the
set of segments is inserted at the specified location in the ordered set of
patterns.
<P>
Galaxy throws a <samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp> if any 
portion of the pattern string is not understood by the format.
</DD></DL>
<P>
<A NAME="vformatInsertLongPatternScribed"><HR><H4>vformatInsertLongPatternScribed</H4></A>
<PRE>
        void <B>vformatInsertLongPatternScribed</B>(
                vformatLong * format,
                vscribe * scribe,
                int index);
</PRE>

<DL><DD>
The pattern string is first decomposed into its constituent segment strings
and a <samp><A HREF="vformat-x.html#vformatLongSegment"><CODE>vformatLongSegment</CODE></A></samp> is created for each and associated by
<code><A HREF="vformat-x.html#vformatSetLongSegmentString"><CODE>vformatSetLongSegmentString</CODE></A></code>. Then, each segment is 
called on to parse its pattern string, at which point the segment 
generates any artifacts it needs to determine the validity `
of an arbitrary input string with respect to the
pattern. Finally, if each segment successfully parses its pattern string, the
set of segments is inserted at the specified location in the ordered set of
patterns.
<P>
Galaxy throws a <samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp> if any portion 
of the pattern string is not understood by the format.
</DD></DL>
<P>
<A NAME="vformatInsertNumberPattern"><HR><H4>vformatInsertNumberPattern</H4></A>
<PRE>
        void <B>vformatInsertNumberPattern</B>(
                vformatNumber * format,
                const vchar * pattern,
                int index);
</PRE>

<DL><DD>
The pattern string is first decomposed into its constituent segment strings
and a <samp><A HREF="vformat-x.html#vformatNumberSegment"><CODE>vformatNumberSegment</CODE></A></samp> of the default number 
segment class is created for each and associated by 
<code><A HREF="vformat-x.html#vformatSetNumberSegmentString"><CODE>vformatSetNumberSegmentString</CODE></A></code>. Then, each
segment is called on to parse its pattern string, at which point the segment
generates whatever artifacts it needs to determine the validity of an arbitrary
input string with respect to the pattern. Finally, if each segment successfully
parses its pattern string, the set of segments is inserted at the specified
location in the ordered set of patterns. Galaxy throws a 
<samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp> if any portion 
of the pattern string is not understood by the format.
</DD></DL>
<P>
<A NAME="vformatInsertNumberPatternScribed"><HR><H4>vformatInsertNumberPatternScribed</H4></A>
<PRE>
        void <B>vformatInsertNumberPatternScribed</B>(
                vformatNumber * format,
                vscribe * scribe,
                int index);
</PRE>

<DL><DD>
The pattern string is first decomposed into its constituent segment strings
and a <samp><A HREF="vformat-x.html#vformatNumberSegment"><CODE>vformatNumberSegment</CODE></A></samp> of the default number 
segment class is created for each and associated by 
<code><A HREF="vformat-x.html#vformatSetNumberSegmentString"><CODE>vformatSetNumberSegmentString</CODE></A></code>. Then, each
segment is called on to parse its pattern string, at which point the segment
generates any artifacts it needs to determine the validity of an arbitrary
input string with respect to the pattern. Finally, if each segment successfully
parses its pattern string, the set of segments is inserted at the specified
location in the ordered set of patterns.
<P>
Galaxy throws a <samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp> if any portion 
of the pattern string is not understood by the format.
</DD></DL>
<P>
<A NAME="vformatInsertPattern"><HR><H4>vformatInsertPattern</H4></A>
<PRE>
        void <B>vformatInsertPattern</B>(
                vformat * format,
                const vchar * string,
                int index);
</PRE>

<DL><DD>
Each pattern string is first broken down into its constituent segment
strings, each segment string being separated by the semi-colon
character (';'). <code>VformatSegments</code> of the proper type 
are created and assigned their strings by 
<code><A HREF="vformat-x.html#vformatSetSegmentString"><CODE>vformatSetSegmentString</CODE></A></code>. Each segment is then called on 
to parse its string at which point the segment generates the artifacts 
needed to determine the validity of an arbitrary input string 
with respect to its pattern.
Finally, if each segment successfully parses its pattern string, the
segment group is inserted at the specified location in the ordered set
of patterns. Refer also to <code><A HREF="vformat-x.html#vformatParseSegment"><CODE>vformatParseSegment</CODE></A></code> 
for more information.
<P>
Galaxy throws a <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code> if any portion of the
pattern string is not understood by the format.
</DD></DL>
<P>
<A NAME="vformatInsertPatternScribed"><HR><H4>vformatInsertPatternScribed</H4></A>
<PRE>
        void <B>vformatInsertPatternScribed</B>(
                vformat * format,
                vscribe * scribe,
                int index);
</PRE>

<DL><DD>
The pattern scribe is first broken down into its constituent segment
strings, each segment string being separated by the semi-colon
character (';'). <code>VformatSegments</code> of the proper type are created and
assigned their strings by <code><A HREF="vformat-x.html#vformatSetSegmentString"><CODE>vformatSetSegmentString</CODE></A></code>. Then, 
each segment is called on to parse its string,
at which point the segment generates the artifacts needed to determine
the validity of an arbitrary input string with respect to its pattern.
Finally, if each segment successfully parses its pattern string, the
segment group is inserted at the specified location in the ordered set
of patterns. Refer to the section <code>formatParseSegment</code> for more
information.
<P>
Galaxy throws a <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code> if any portion of the
pattern string is not understood by the format.
</DD></DL>
<P>
<A NAME="vformatInsertULongPattern"><HR><H4>vformatInsertULongPattern</H4></A>
<PRE>
        void <B>vformatInsertULongPattern</B>(
                vformatULong * format,
                const vchar * string,
                int index);
</PRE>

<DL><DD>
The pattern string is first decomposed into its constituent segment strings
and a <samp><A HREF="vformat-x.html#vformatULongSegment"><CODE>vformatULongSegment</CODE></A></samp> is created for each and associated by
<code><A HREF="vformat-x.html#vformatSetULongSegmentString"><CODE>vformatSetULongSegmentString</CODE></A></code>. 
Then, each segment is called on to parse its pattern string, 
at which point the segment generates whatever artifacts it
needs to determine the validity of an arbitrary input string 
with respect to the pattern. Finally, if each segment successfully 
parses its pattern string, the set of segments is inserted 
at the specified location in the ordered set of patterns.
<P>
Galaxy throws a <samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp> if any portion 
of the pattern string is not understood by the format.
</DD></DL>
<P>
<A NAME="vformatInsertULongPatternScribed"><HR><H4>vformatInsertULongPatternScribed</H4></A>
<PRE>
        void <B>vformatInsertULongPatternScribed</B>(
                vformatULong * format,
                vscribe * scribe,
                int index);
</PRE>

<DL><DD>
The pattern string is first decomposed into its constituent segment strings
and a <samp><A HREF="vformat-x.html#vformatULongSegment"><CODE>vformatULongSegment</CODE></A></samp> is created for each and associated by
<code><A HREF="vformat-x.html#vformatSetULongSegmentString"><CODE>vformatSetULongSegmentString</CODE></A></code>. 
Each segment is then called on to parse its pattern string, 
at which point the segment generates any artifacts needed 
to determine the validity of an arbitrary input string 
with respect to the pattern. Finally, if each segment successfully 
parses its pattern string, the set of segments is inserted 
at the specified location in the ordered set of patterns.
<P>
Galaxy throws a <samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp> if any portion 
of the pattern string is not understood by the format.
</DD></DL>
<P>
<A NAME="vformatIsBooleanPartiallyValid"><HR><H4>vformatIsBooleanPartiallyValid</H4></A>
<PRE>
        vbool <B>vformatIsBooleanPartiallyValid</B>(
                vformatBoolean * format,
                const vchar * string);
</PRE>

<DL><DD>
An input string is considered to be partially valid if its
content is parsable by at least one of the Boolean format's patterns, yet
not enough content is provided to produce a valid Boolean value from the parsed
input.
<P>
The distinction between a "completely" valid and "partially" valid input
is that a format is able to return a value from a completely valid input
while it cannot from a partially valid input. In both cases, the input
string is parsable; therefore, an input that is valid is, by definition,
also partially valid. An invalid input cannot be fully parsed by the
format. For example, a <samp><A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A></samp> may have a 
pattern string "yes;no." An input of "yes" is considered valid, 
while an input of "ye" is considered
partially valid and an input of "foo" would be considered invalid.
Instance of the default format class considers all input to be both valid and
partially valid.
</DD></DL>
<P>
<A NAME="vformatIsBooleanValid"><HR><H4>vformatIsBooleanValid</H4></A>
<PRE>
        vbool <B>vformatIsBooleanValid</B>(
                vformatBoolean * format,
                const vchar * string);
</PRE>

<DL><DD>
This call iterates over each of the format's pattern segments in an attempt to
match the input string, in a case-insensitive alpha-numeric sense. If a match
is found <CODE>vTRUE</CODE> is returned, else <CODE>vFALSE</CODE>.
</DD></DL>
<P>
<A NAME="vformatIsDatePartiallyValid"><HR><H4>vformatIsDatePartiallyValid</H4></A>
<PRE>
        vbool <B>vformatIsDatePartiallyValid</B>(
                vformatDate * format,
                const vchar * string);
</PRE>

<DL><DD>
An input string is considered to be partially valid if its content is parsable
by at least one of the date format's patterns, yet not enough content is
provided to produce a valid <samp><A HREF="vdate-x.html#vdate"><CODE>vdate</CODE></A></samp> value from the parsed input.
<P>
The distinction between a "completely" valid and "partially" valid input
is that a format is able to return a value from a completely valid input
while it cannot from a partially valid input. In both cases, the input
string is parsable; therefore, an input that is valid is, by definition,
also partially valid. An invalid input cannot be fully parsed by the
format. For example, a <samp><A HREF="vformat-x.html#vformatDate"><CODE>vformatDate</CODE></A></samp> may have a 
pattern string "mm/dd/yy". 
An input of "06/02/63"" is considered valid, while an input of "06/02" is
considered partially valid, and an input of "foo" would be considered invalid.
Instance of the default format class considers all input to be both valid and
partially valid.
</DD></DL>
<P>
<A NAME="vformatIsDateValid"><HR><H4>vformatIsDateValid</H4></A>
<PRE>
        vbool <B>vformatIsDateValid</B>(
                vformatDate * format,
                const vchar * string);
</PRE>

<DL><DD>
This call iterates over each of the format's pattern segments in an attempt to
match the input string. If the input string matched at least a single date
pattern, the input is considered valid; otherwise it is invalid.
</DD></DL>
<P>
<A NAME="vformatIsDoublePartiallyValid"><HR><H4>vformatIsDoublePartiallyValid</H4></A>
<PRE>
        vbool <B>vformatIsDoublePartiallyValid</B>(
                vformatDouble * format,
                const vchar * string);
</PRE>

<DL><DD>
An input string is considered to be partially valid if its content is parsable
by at least one of the double format's patterns, yet not enough content is
provided to produce a valid double value from the parsed input.
<P>
The distinction between a "completely" valid and "partially" valid input
is that a format is able to return a value from a completely valid input
while it cannot from a partially valid input. In both cases, the input
string is parsable; therefore, an input that is valid is, by definition,
also partially valid. An invalid input cannot be fully parsed by the
format.
<P>
For example, a <samp><A HREF="vformat-x.html#vformatDouble"><CODE>vformatDouble</CODE></A></samp> may have a pattern string "00"
An input of "03"" is considered valid while an input of "2" is
considered partially valid, and an input of "f" would be considered invalid.
Instance of the default format class considers all input to be both valid and
partially valid.
</DD></DL>
<P>
<A NAME="vformatIsDoubleValid"><HR><H4>vformatIsDoubleValid</H4></A>
<PRE>
        vbool <B>vformatIsDoubleValid</B>(
                vformatDouble * format,
                const vchar * string);
</PRE>

<DL><DD>
This call iterates over each of the format's pattern segments in an attempt to
match the input string. If the input string matched at least a single double
pattern, the input is considered valid; otherwise it is invalid.
</DD></DL>
<P>
<A NAME="vformatIsLongPartiallyValid"><HR><H4>vformatIsLongPartiallyValid</H4></A>
<PRE>
        vbool <B>vformatIsLongPartiallyValid</B>(
                vformatLong * format,
                const vchar * string);
</PRE>

<DL><DD>
An input string is considered to be partially valid if its content is parsable
by at least one of the long integer format's patterns, yet not enough 
content is provided to produce a valid long integer value 
from the parsed input.
<P>
The distinction between a "completely" valid and "partially" valid input
is that a format is able to return a value from a completely valid input
while it cannot from a partially valid input. In both cases the input
string is parsable; therefore, an input that is valid is, by definition,
also partially valid. An invalid input cannot be fully parsed by the
format.
<P>
For example, a <samp><A HREF="vformat-x.html#vformatLong"><CODE>vformatLong</CODE></A></samp> may have a pattern string "00"
An input of "03"" is considered valid, while an input of "2" is
considered partially valid and an input of "f" would be considered invalid.
Instance of the default format class considers all input to be both valid and
partially valid.
</DD></DL>
<P>
<A NAME="vformatIsLongValid"><HR><H4>vformatIsLongValid</H4></A>
<PRE>
        vbool <B>vformatIsLongValid</B>(
                vformatLong * format,
                const vchar * string);
</PRE>

<DL><DD>
This call iterates over each of the format's pattern segments in an attempt to
match the input string. If the input string matched at least a single long
integer pattern the input is considered valid; otherwise it is invalid.
</DD></DL>
<P>
<A NAME="vformatIsNumberPartiallyValid"><HR><H4>vformatIsNumberPartiallyValid</H4></A>
<PRE>
        vbool <B>vformatIsNumberPartiallyValid</B>(
                vformatNumber * format,
                const vchar * string);
</PRE>

<DL><DD>
An input string is considered to be partially valid if its content is parsable
by at least one of the number format's patterns, yet not enough content is
provided to produce a valid numeric value from the parsed input.
<P>
The distinction between a "completely" valid and "partially" valid input
is that a format is able to return a value from a completely valid input
while it cannot from a partially valid input. In both cases the input
string is parsable; therefore, an input that is valid is, by definition,
also partially valid. An invalid input cannot be fully parsed by the
format. For example, a <code><A HREF="vformat-x.html#vformatLong"><CODE>vformatLong</CODE></A></code> may have a pattern string "00"
An input of "03"" is considered valid while an input of "2" is
considered partially valid and an input of "f" would be considered invalid.
Instance of the default format class considers all input to be both valid and
partially valid.
</DD></DL>
<P>
<A NAME="vformatIsNumberStrict"><HR><H4>vformatIsNumberStrict</H4></A>
<PRE>
        vbool <B>vformatIsNumberStrict</B>(
                const vformatNumber * format);
</PRE>

<DL><DD>
Normally, a number format pattern is parsed and scribed
strictly according to the information provided in the pattern.
This, however, can be inconvenient at times so the number
format can be made more lenient with regard to the number
of digits that are accepted or displayed in the whole portion
of the format.  For instance, this pattern "#" would normally
only allow a single digit but when the number format is not
strict, any number of digits would be allowed here.
<P>
By default, all number formats are lenient (not strict) in this
regard.
</DD></DL>
<P>
<A NAME="vformatIsNumberValid"><HR><H4>vformatIsNumberValid</H4></A>
<PRE>
        vbool <B>vformatIsNumberValid</B>(
                vformatNumber * format,
                const vchar * string);
</PRE>

<DL><DD>
This call iterates over each of the format's pattern segments in an attempt to
match the input string. If the input string matched at least a single number
pattern, the input is considered valid; otherwise it is invalid.
</DD></DL>
<P>
<A NAME="vformatIsPartiallyValid"><HR><H4>vformatIsPartiallyValid</H4></A>
<PRE>
        vbool <B>vformatIsPartiallyValid</B>(
                vformat * format,
                const vchar * string);
</PRE>

<DL><DD>
An input string is considered to be partially valid if its
content is parsable by at least one of the format's patterns, yet
not enough content is provided to produce a valid value from the parsed
input.
<P>
The distinction between a "completely" valid and "partially" valid input
is that a format is able to return a value from a completely valid input
while it cannot from a partially valid input. In both cases the input
string is parsable; therefore, an input that is valid is, by definition,
also partially valid. An invalid input cannot be fully parsed by the
format.
<P>
For example, a <code><A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A></code> may have a pattern string "yes;no."
An input of "yes" is considered valid while an input of
"ye" is considered partially valid. An input of "foo" would
be considered invalid. The default format considers all input to be 
both valid and partially valid.
</DD></DL>
<P>
<A NAME="vformatIsULongPartiallyValid"><HR><H4>vformatIsULongPartiallyValid</H4></A>
<PRE>
        vbool <B>vformatIsULongPartiallyValid</B>(
                vformatULong * format,
                const vchar * string);
</PRE>

<DL><DD>
An input string is considered to be partially valid if its content is parsable
by at least one of the unsigned long integer format's patterns, yet not enough
content is provided to produce a valid unsigned long integer value from the
parsed input.
<P>
The distinction between a "completely" valid and "partially" valid input
is that a format is able to return a value from a completely valid input
while it cannot from a partially valid input. In both cases the input
string is parsable; therefore, an input that is valid is, by definition,
also partially valid. An invalid input cannot be fully parsed by the
format.
<P>
For example, a <code><A HREF="vformat-x.html#vformatULong"><CODE>vformatULong</CODE></A></code> may have a pattern string "00"
An input of "03"" is considered valid while an input of "2" is
considered partially valid and an input of "f" would be considered invalid.
Instance of the default format class considers all input to be both valid and
partially valid.
</DD></DL>
<P>
<A NAME="vformatIsULongValid"><HR><H4>vformatIsULongValid</H4></A>
<PRE>
        vbool <B>vformatIsULongValid</B>(
                vformatULong * format,
                const vchar * string);
</PRE>

<DL><DD>
This call iterates over each of the format's pattern segments in an attempt to
match the input string. If the input string matched at least a single unsigned
long integer pattern, the input is considered valid, otherwise it is invalid.
</DD></DL>
<P>
<A NAME="vformatIsValid"><HR><H4>vformatIsValid</H4></A>
<PRE>
        vbool <B>vformatIsValid</B>(
                vformat * format,
                const vchar * string);
</PRE>

<DL><DD>
Iterates over each of its pattern segments
in an attempt to match the input string. The default pattern
segment class <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> always returns true for any
input string. In testing an input string for validity, type-
specific derivatives may use artifacts generated from
parsing the segment's pattern string. For instance, the  
<code>vdateSegmentFormat</code> class generates an instance of a 
<code><A HREF="vdate-x.html#vdateFormat"><CODE>vdateFormat</CODE></A></code> for use in parsing and generating 
the output form of a <samp><A HREF="vdate-x.html#vdate"><CODE>vdate</CODE></A></samp> value.
</DD></DL>
<P>
<A NAME="vformatLoad"><HR><H4>vformatLoad</H4></A>
<PRE>
        vformat * <B>vformatLoad</B>(
                vresource res);
</PRE>

<DL><DD>
Reads a format from the resource <SAMP>resource</SAMP> and
returns a pointer to its contents. Storage for the format
object is allocated by the Format class. The format's
class is determined by the value of the ``Class'' tag. This
function generates
<samp><A HREF="vobject-x.html#vobjectUndefinedClassException"><CODE>vobjectUndefinedClassException</CODE></A></samp> if the name
does not denote a class in the Class Manager class registry. Note
that this function creates an object based on the class of
the resource, even if this class is not a format class. 
<P>
The object pointer is cast to a format pointer, even if the
object represents a different data type. Attributes may be
initialized based on the contents of the resource, or they
may be set to default values, depending on the class. All
of the format's items are read from the resource. This
function essentially allocates space for a new instance and
calls <CODE>vformatLoadInit</CODE> on it.
</DD></DL>
<P>
<A NAME="vformatLoadBoolean"><HR><H4>vformatLoadBoolean</H4></A>
<PRE>
        vformatBoolean * <B>vformatLoadBoolean</B>(
                vresource res);
</PRE>

<DL><DD>
Reads a format from the resource <SAMP>resource</SAMP> and
returns a pointer to its contents. Storage for the format
object is allocated by the Format class. The format's
class is determined by the value of the ``Class'' tag. This
function generates
<samp><A HREF="vobject-x.html#vobjectUndefinedClassException"><CODE>vobjectUndefinedClassException</CODE></A></samp> if the name
does not denote a class in the Class Manager class registry. Note
that this function creates an object based on the class of
the resource, even if this class is not a format class. 
<P>
The object pointer is cast to a Boolean format pointer, even if
the object represents a different data type. Attributes may
be initialized based on the contents of the resource, or
they may be set to default values, depending on the class.
All of the format's items are read from the resource. This
function essentially allocates space for a new instance and
calls <CODE>vformatLoadInit</CODE> on it.
</DD></DL>
<P>
<A NAME="vformatLoadBooleanPatterns"><HR><H4>vformatLoadBooleanPatterns</H4></A>
<PRE>
        void <B>vformatLoadBooleanPatterns</B>(
                vformatBoolean * format,
                vresource res);
</PRE>

<DL><DD>
First, the current set of patterns, if any, is cleared. Next, the new pattern
strings are extracted from <samp>res</samp> and are used in a call to
<code><A HREF="vformat-x.html#vformatSetBooleanPatterns"><CODE>vformatSetBooleanPatterns</CODE></A></code>. If <samp>res</samp> is not 
a string-array resource, a /Module exception
is generated. If any of the new pattern strings are not valid Boolean patterns,
Galaxy throws a /Parse exception.
</DD></DL>
<P>
<A NAME="vformatLoadDate"><HR><H4>vformatLoadDate</H4></A>
<PRE>
        vformatDate * <B>vformatLoadDate</B>(
                vresource res);
</PRE>

<DL><DD>
Reads a format from the resource <SAMP>resource</SAMP> and
returns a pointer to its contents. Storage for the format
object is allocated by the Format class. The format's
class is determined by the value of the ``Class'' tag. This
function generates
<samp><A HREF="vobject-x.html#vobjectUndefinedClassException"><CODE>vobjectUndefinedClassException</CODE></A></samp> if the name
does not denote a class in the Class Manager class registry. Note
that this function creates an object based on the class of
the resource, even if this class is not a format class. 
<P>
The object pointer is cast to a date format pointer, even if
the object represents a different data type. Attributes may
be initialized based on the contents of the resource, or
they may be set to default values, depending on the class.
All of the format's items are read from the resource. This
function essentially allocates space for a new instance and
calls <CODE>vformatLoadInit</CODE> on it.
</DD></DL>
<P>
<A NAME="vformatLoadDatePatterns"><HR><H4>vformatLoadDatePatterns</H4></A>
<PRE>
        void <B>vformatLoadDatePatterns</B>(
                vformatDate * format,
                vresource res);
</PRE>

<DL><DD>
First, the current set of patterns, if any, is cleared. Next, the new pattern
strings are extracted from <samp>res</samp> and are used in a call to
<code><A HREF="vformat-x.html#vformatSetDatePatterns"><CODE>vformatSetDatePatterns</CODE></A></code>.
<P>
If <samp>res</samp> is not a string-array resource, Galaxy generates 
a /Module exception. If any of the new pattern strings 
are not valid date patterns, Galaxy throws a /Parse exception.
</DD></DL>
<P>
<A NAME="vformatLoadDouble"><HR><H4>vformatLoadDouble</H4></A>
<PRE>
        vformatDouble * <B>vformatLoadDouble</B>(
                vresource res);
</PRE>

<DL><DD>
Reads a format from the resource <SAMP>resource</SAMP> and
returns a pointer to its contents. Storage for the format
object is allocated by the Format class. The format's
class is determined by the value of the ``Class'' tag. This
function generates
<samp><A HREF="vobject-x.html#vobjectUndefinedClassException"><CODE>vobjectUndefinedClassException</CODE></A></samp> if the name
does not denote a class in the Class Manager class registry. Note
that this function creates an object based on the class of
the resource, even if this class is not a Format class. 
<P>
The object pointer is cast to a double format pointer, even if
the object represents a different data type. Attributes may
be initialized based on the contents of the resource, or
they may be set to default values, depending on the class.
All of the format's items are read from the resource. This
function essentially allocates space for a new instance and
calls <CODE>vformatLoadInit</CODE> on it.
</DD></DL>
<P>
<A NAME="vformatLoadDoublePatterns"><HR><H4>vformatLoadDoublePatterns</H4></A>
<PRE>
        void <B>vformatLoadDoublePatterns</B>(
                vformatDouble * format,
                vresource res);
</PRE>

<DL><DD>
First, the current set of patterns, if any, is cleared. Next, the new pattern
strings are extracted from <samp>res</samp> and they are used in a call to
<code><A HREF="vformat-x.html#vformatSetDoublePatterns"><CODE>vformatSetDoublePatterns</CODE></A></code>.
If <samp>res</samp> is not a string-array resource, Galaxy generates 
a /Module exception. If any of the new pattern strings are not 
valid double patterns, Galaxy throws a /Parse exception.
</DD></DL>
<P>
<A NAME="vformatLoadLong"><HR><H4>vformatLoadLong</H4></A>
<PRE>
        vformatLong * <B>vformatLoadLong</B>(
                vresource res);
</PRE>

<DL><DD>
Reads a format from the resource <SAMP>resource</SAMP> and
returns a pointer to its contents. Storage for the format
object is allocated by the Format class. The format's
class is determined by the value of the ``Class'' tag. This
function generates
<samp><A HREF="vobject-x.html#vobjectUndefinedClassException"><CODE>vobjectUndefinedClassException</CODE></A></samp> if the name
does not denote a class in the Class Manager class registry. Note
that this function creates an object based on the class of
the resource, even if this class is not a Format class. 
<P>
The object pointer is cast to a long integer format pointer, even
if the object represents a different data type. Attributes
may be initialized based on the contents of the resource, or
they may be set to default values, depending on the class.
All of the format's items are read from the resource. This
function essentially allocates space for a new instance and
calls <CODE>vformatLoadInit</CODE> on it.
</DD></DL>
<P>
<A NAME="vformatLoadLongPatterns"><HR><H4>vformatLoadLongPatterns</H4></A>
<PRE>
        void <B>vformatLoadLongPatterns</B>(
                vformatLong * format,
                vresource res);
</PRE>

<DL><DD>
First, the current set of patterns, if any, is cleared. Next, the new pattern
strings are extracted from <samp>res</samp> and they are used in a call to
<code><A HREF="vformat-x.html#vformatSetLongPatterns"><CODE>vformatSetLongPatterns</CODE></A></code>.
If <samp>res</samp> is not a string-array resource, Galaxy generates 
a /Module exception. If any of the new pattern strings are not 
valid long integer patterns, Galaxy throws a /Parse exception.
</DD></DL>
<P>
<A NAME="vformatLoadNumber"><HR><H4>vformatLoadNumber</H4></A>
<PRE>
        vformatNumber * <B>vformatLoadNumber</B>(
                vresource res);
</PRE>

<DL><DD>
Reads a format from the resource <SAMP>resource</SAMP> and
returns a pointer to its contents. Storage for the format
object is allocated by the Format class. The format's
class is determined by the value of the ``Class'' tag. This
function generates a
<samp><A HREF="vobject-x.html#vobjectUndefinedClassException"><CODE>vobjectUndefinedClassException</CODE></A></samp> if the name
does not denote a class in the Class Manager class registry. Note
that this function creates an object based on the class of
the resource, even if this class is not a format class. 
<P>
The object pointer is cast to a number format pointer, even if
the object represents a different data type. Attributes
may be initialized based on the contents of the resource, or
they may be set to default values, depending on the class.
All of the format's items are read from the resource. This
function essentially allocates space for a new instance and
calls <CODE>vformatLoadInit</CODE> on it.
</DD></DL>
<P>
<A NAME="vformatLoadNumberPatterns"><HR><H4>vformatLoadNumberPatterns</H4></A>
<PRE>
        void <B>vformatLoadNumberPatterns</B>(
                vformatNumber * format,
                vresource res);
</PRE>

<DL><DD>
First, the current set of patterns, if any, is cleared. Next, the new pattern
strings are extracted from <samp>res</samp> and they are used in a call to
<code><A HREF="vformat-x.html#vformatSetNumberPatterns"><CODE>vformatSetNumberPatterns</CODE></A></code>.
If <samp>res</samp> is not a string-array resource, Galaxy  generates 
a /Module exception. If any of the new pattern strings are not valid numeric
patterns, Galaxy throws a /Parse exception.
</DD></DL>
<P>
<A NAME="vformatLoadPatterns"><HR><H4>vformatLoadPatterns</H4></A>
<PRE>
        void <B>vformatLoadPatterns</B>(
                vformat * format,
                vresource res);
</PRE>

<DL><DD>
The current set of patterns is first cleared. Next, the array resource
is converted into an array of pointers to string and used as an argument
to <code><A HREF="vformat-x.html#vformatSetPatterns"><CODE>vformatSetPatterns</CODE></A></code>. If any pattern string is not understood 
by the format, the temporary array of pointers to string is freed 
and Galaxy throws a <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatLoadULong"><HR><H4>vformatLoadULong</H4></A>
<PRE>
        vformatULong * <B>vformatLoadULong</B>(
                vresource res);
</PRE>

<DL><DD>
Reads a format from the resource <SAMP>resource</SAMP> and
returns a pointer to its contents. Storage for the format
object is allocated by the Format class. The format's
class is determined by the value of the ``Class'' tag. This
function generates a
<samp><A HREF="vobject-x.html#vobjectUndefinedClassException"><CODE>vobjectUndefinedClassException</CODE></A></samp> if the name
does not denote a class in the Class Manager class registry. Note
that this function creates an object based on the class of
the resource, even if this class is not a Format class. 
<P>
The object pointer is cast to an unsigned long integer format
pointer, even if the object represents a different data type.
Attributes may be initialized based on the contents of the
resource, or they may be set to default values, depending on
the class. All of the format's items are read from the resource.
This function essentially allocates space for a new instance
and calls <CODE>vformatLoadInit</CODE> on it.
</DD></DL>
<P>
<A NAME="vformatLoadULongPatterns"><HR><H4>vformatLoadULongPatterns</H4></A>
<PRE>
        void <B>vformatLoadULongPatterns</B>(
                vformatULong * format,
                vresource res);
</PRE>

<DL><DD>
First, the current set of patterns, if any, is cleared. Next, 
the new pattern strings are extracted from <samp>res</samp> 
and they are used in a call to <code><A HREF="vformat-x.html#vformatSetULongPatterns"><CODE>vformatSetULongPatterns</CODE></A></code>.
If <samp>res</samp> is not a string-array resource, Galaxy generates 
a /Module exception. If any of the new pattern strings are not valid unsigned
long integer patterns, Galaxy throws a /Parse exception.
</DD></DL>
<P>
<A NAME="vformatNextBooleanSegmentIterator"><HR><H4>vformatNextBooleanSegmentIterator</H4></A>
<PRE>
        void <B>vformatNextBooleanSegmentIterator</B>();
</PRE>

<DL><DD>
This method returns <SAMP>vTRUE</SAMP> until there are no more segments 
to the iteration; at this point, it returns <samp>vFALSE</samp>.
</DD></DL>
<P>
<A NAME="vformatNextDateSegmentIterator"><HR><H4>vformatNextDateSegmentIterator</H4></A>
<PRE>
        void <B>vformatNextDateSegmentIterator</B>();
</PRE>

<DL><DD>
This method returns <SAMP>vTRUE</SAMP> until there are no more segments to
the iteration, at which point it returns <samp>vFALSE</samp>.
</DD></DL>
<P>
<A NAME="vformatNextDoubleSegmentIterator"><HR><H4>vformatNextDoubleSegmentIterator</H4></A>
<PRE>
        void <B>vformatNextDoubleSegmentIterator</B>();
</PRE>

<DL><DD>
This method returns <SAMP>vTRUE</SAMP> until there are no more segments to
the iteration, at which point it returns <samp>vFALSE</samp>.
</DD></DL>
<P>
<A NAME="vformatNextLongSegmentIterator"><HR><H4>vformatNextLongSegmentIterator</H4></A>
<PRE>
        void <B>vformatNextLongSegmentIterator</B>();
</PRE>

<DL><DD>
This method returns <SAMP>vTRUE</SAMP> until there are no more segments to
the iteration; at which point, it returns <samp>vFALSE</samp>.
</DD></DL>
<P>
<A NAME="vformatNextNumberSegmentIterator"><HR><H4>vformatNextNumberSegmentIterator</H4></A>
<PRE>
        void <B>vformatNextNumberSegmentIterator</B>();
</PRE>

<DL><DD>
This method returns <SAMP>vTRUE</SAMP> until there are no more segments to
the iteration; at which point, it returns <samp>vFALSE</samp>.
</DD></DL>
<P>
<A NAME="vformatNextSegmentIterator"><HR><H4>vformatNextSegmentIterator</H4></A>
<PRE>
        vbool <B>vformatNextSegmentIterator</B>(
                vformatSegmentIterator * iterator);
</PRE>

<DL><DD>
This method returns <SAMP>vTRUE</SAMP> until there are no more segments to
the iteration; at which point, it returns <samp>vFALSE</samp>.
</DD></DL>
<P>
<A NAME="vformatNextULongSegmentIterator"><HR><H4>vformatNextULongSegmentIterator</H4></A>
<PRE>
        void <B>vformatNextULongSegmentIterator</B>();
</PRE>

<DL><DD>
This method returns <SAMP>vTRUE</SAMP> until there are no more segments to
the iteration; at which point, it returns <samp>vFALSE</samp>.
</DD></DL>
<P>
<A NAME="vformatOFFSET"><HR><H4>vformatOFFSET</H4></A>
<PRE>
        void <B>vformatOFFSET</B>(
                void * exception,
                va_list * ap);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatParseBoolean"><HR><H4>vformatParseBoolean</H4></A>
<PRE>
        vbool <B>vformatParseBoolean</B>(
                vformatBoolean * format,
                const vchar * string);
</PRE>

<DL><DD>
The input string is compared to each pattern segment string in turn: if a
match is found, the boolean value associated with the matching segment is
returned. Galaxy throws a <samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp> 
if the input string is not fully understood as determined by 
the information contained within at least one
of the format's pattern segments. If at least a single
pattern segment is able to completely parse the input string and generate
a valid value, no exception is thrown. However, Galaxy throws an exception 
if the format is unable to convert the input string to a value.
</DD></DL>
<P>
<A NAME="vformatParseBooleanSegment"><HR><H4>vformatParseBooleanSegment</H4></A>
<PRE>
        void <B>vformatParseBooleanSegment</B>(
                vformatBooleanSegment * segment,
                int segmentIndex);
</PRE>

<DL><DD>
This method is called by <code><A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A></code> after 
first decomposing the pattern string into its constituent 
segment substrings; creating appropriate numbers
of <code><A HREF="vformat-x.html#vformatBooleanSegment"><CODE>vformatBooleanSegment</CODE></A></code>; and assigning their pattern strings.
The <Code>segmentIndex</CODE> denotes which Boolean value the segment
represents.
</DD></DL>
<P>
<A NAME="vformatParseBooleanSegmentPattern"><HR><H4>vformatParseBooleanSegmentPattern</H4></A>
<PRE>
        void <B>vformatParseBooleanSegmentPattern</B>(
                vformatBooleanSegment * segment,
                vformatParseRange * range);
</PRE>

<DL><DD>
This method is called by <code>vformatParseBooleanSegment</code>.
It scans the pattern string, beginning at the range's starting position 
and then creating any artifacts necessary to parse or convert to string a
Boolean value. If the segment finds an unrecognized character, it returns,
leaving <SAMP>range</SAMP> to specify that portion of the remaining input
left to be parsed.
<P>
This method may be called multiple times, as various levels of the class
hierarchy access each character. If no member of the particular format's
class hierarchy recognizes a given character, Galaxy raises 
a <samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp> exception. 
This exception specifies the offset of the first
character that was not understood by the format segment.
</DD></DL>
<P>
<A NAME="vformatParseDate"><HR><H4>vformatParseDate</H4></A>
<PRE>
        vdate * <B>vformatParseDate</B>(
                vformatDate * format,
                const vchar * string);
</PRE>

<DL><DD>
The input string is compared to each pattern segment string in turn; if a
match is found, the date value associated with the matching segment is
returned. Galaxy throws a <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code> if the 
input string is not fully understood as determined by the 
information contained in at least one of the format's pattern segments. 
If at least a single pattern segment is able to completely parse 
the input string and generate a valid value, no exception is thrown. 
Galaxy throws an exception if the format
is unable to convert the input string to a value.
</DD></DL>
<P>
<A NAME="vformatParseDateSegment"><HR><H4>vformatParseDateSegment</H4></A>
<PRE>
        void <B>vformatParseDateSegment</B>(
                vformatDateSegment * segment,
                int segmentIndex);
</PRE>

<DL><DD>
This method is called by <code><A HREF="vformat-x.html#vformatDate"><CODE>vformatDate</CODE></A></code> 
after first decomposing the pattern string into its constituent 
segment substrings, and then creating a
<code><A HREF="vformat-x.html#vformatDateSegment"><CODE>vformatDateSegment</CODE></A></code> and assigning its pattern strings.
The <Code>segmentIndex</CODE> are always zero (0) for a 
date format as it contains only a single pattern segment.
</DD></DL>
<P>
<A NAME="vformatParseDateSegmentPattern"><HR><H4>vformatParseDateSegmentPattern</H4></A>
<PRE>
        void <B>vformatParseDateSegmentPattern</B>(
                vformatDateSegment * segment,
                vformatParseRange * range);
</PRE>

<DL><DD>
This method is called by <code>vformatParseDateSegment</code>.
It scans the pattern string, beginning at the range's starting position,
creating any artifacts necessary to parse or convert to string a
<samp><A HREF="vdate-x.html#vdate"><CODE>vdate</CODE></A></samp> value. If the segment finds an 
unrecognized character, it returns,
leaving <SAMP>range</SAMP> to specify that portion of the remaining input
left to be parsed.
<P>
This method may be called multiple times, as various levels of the class
hierarchy access each character. If no member of the particular format's
class hierarchy recognizes a given character, Galaxy raises a 
<code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code>. 
This exception specifies the offset of the first
character that was not understood by the format segment.
</DD></DL>
<P>
<A NAME="vformatParseDouble"><HR><H4>vformatParseDouble</H4></A>
<PRE>
        double <B>vformatParseDouble</B>(
                vformatDouble * format,
                const vchar * string);
</PRE>

<DL><DD>
If the input in not understood by at least one of the format's pattern
segments, Galaxy throws a <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatParseDoubleSegment"><HR><H4>vformatParseDoubleSegment</H4></A>
<PRE>
        void <B>vformatParseDoubleSegment</B>(
                vformatDoubleSegment * segment,
                int segmentIndex);
</PRE>

<DL><DD>
This method is called by <code><A HREF="vformat-x.html#vformatDouble"><CODE>vformatDouble</CODE></A></code> after 
first decomposing the pattern string into its constituent 
segment substrings; creating appropriate numbers
of <samp><A HREF="vformat-x.html#vformatDoubleSegment"><CODE>vformatDoubleSegment</CODE></A></samp>; and assigning their pattern strings.
The <Code>segmentIndex</CODE> denotes which logical double value the segment
represents; either positive, negative, or zero.
</DD></DL>
<P>
<A NAME="vformatParseDoubleSegmentPattern"><HR><H4>vformatParseDoubleSegmentPattern</H4></A>
<PRE>
        void <B>vformatParseDoubleSegmentPattern</B>(
                vformatDoubleSegment * segment,
                vformatParseRange * range);
</PRE>

<DL><DD>
This method is called by <code>vformatParseDoubleSegment</code>.
It scans the pattern string, beginning at the range's starting position 
and creating any artifacts are necessary to parse or convert to string a
double value. If the segment finds an unrecognized character, it returns,
leaving <SAMP>range</SAMP> to specify that portion of the remaining input
left to be parsed.
<P>
This method may be called multiple times, as various levels of the class
hierarchy access each character. If no member of the particular format's
class hierarchy recognizes a given character, Galaxy raises 
a <samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp>. 
This exception specifies the offset of the first
character that was not understood by the format segment.
</DD></DL>
<P>
<A NAME="vformatParseLong"><HR><H4>vformatParseLong</H4></A>
<PRE>
        long <B>vformatParseLong</B>(
                vformatLong * format,
                const vchar * string);
</PRE>

<DL><DD>
If the input in not understood by at least one of the format's pattern
segments, Galaxy throws a <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatParseLongSegment"><HR><H4>vformatParseLongSegment</H4></A>
<PRE>
        void <B>vformatParseLongSegment</B>(
                vformatLongSegment * segment,
                int segmentIndex);
</PRE>

<DL><DD>
This method is called by <code><A HREF="vformat-x.html#vformatLong"><CODE>vformatLong</CODE></A></code> after first 
decomposing the pattern string into its constituent segment substrings and 
creating appropriate numbers of <code><A HREF="vformat-x.html#vformatLongSegment"><CODE>vformatLongSegment</CODE></A></code> 
and assigning their pattern strings.
The <Code>segmentIndex</CODE> denotes which logical integer 
value the segment represents; either positive, negative, or zero.
</DD></DL>
<P>
<A NAME="vformatParseLongSegmentPattern"><HR><H4>vformatParseLongSegmentPattern</H4></A>
<PRE>
        void <B>vformatParseLongSegmentPattern</B>(
                vformatLongSegment * segment,
                vformatParseRange * range);
</PRE>

<DL><DD>
This method is called by <code>vformatParseLongSegment</code>.
It scans the pattern string, beginning at the range's starting position,
creating any artifacts necessary to parse or convert to string a
long integer value. If the segment finds an unrecognized character, it returns,
leaving <SAMP>range</SAMP> to specify that portion of the remaining input
left to be parsed.
<P>
This method may be called multiple times, as various levels of the class
hierarchy access each character. If no member of the particular format's
class hierarchy recognizes a given character, Galaxy raises a 
<samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp>. This exception 
specifies the offset of the first character that was not 
understood by the format segment.
</DD></DL>
<P>
<A NAME="vformatParseNumberSegment"><HR><H4>vformatParseNumberSegment</H4></A>
<PRE>
        void <B>vformatParseNumberSegment</B>(
                vformatNumberSegment * segment,
                int segmentIndex);
</PRE>

<DL><DD>
This method is called by <code><A HREF="vformat-x.html#vformatNumber"><CODE>vformatNumber</CODE></A></code> after 
first decomposing the pattern string into its constituent 
segment substrings, creating appropriate numbers
of <code><A HREF="vformat-x.html#vformatNumberSegment"><CODE>vformatNumberSegment</CODE></A></code>, and assigning their pattern strings.
The <Code>segmentIndex</CODE> denotes which logical numeric value the segment
represents; either positive, negative, or zero.
</DD></DL>
<P>
<A NAME="vformatParseNumberSegmentPattern"><HR><H4>vformatParseNumberSegmentPattern</H4></A>
<PRE>
        void <B>vformatParseNumberSegmentPattern</B>(
                vformatNumberSegment * segment,
                vformatParseRange * range);
</PRE>

<DL><DD>
This method is called by <code>vformatParseNumberSegment</code>.
It scans the pattern string, beginning at the range's starting position,
creating any artifacts necessary to parse or convert to string a
numeric value. If the segment finds an unrecognized character, it returns,
leaving <SAMP>range</SAMP> to specify that portion of the remaining input
left to be parsed.
<P>
This method may be called multiple times, as various levels of the class
hierarchy access each character. If no member of the particular format's
class hierarchy recognizes a given character, Galaxy raises a 
<code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code> exception. This exception 
specifies the offset of the first
character that was not understood by the format segment.
</DD></DL>
<P>
<A NAME="vformatParseSegment"><HR><H4>vformatParseSegment</H4></A>
<PRE>
        void <B>vformatParseSegment</B>(
                vformatSegment * segment,
                int segmentIndex);
</PRE>

<DL><DD>
This method is called by <code>vformat</code> after first decomposing the pattern
string into its constituent segment substrings, initializing a new
<code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> of the proper class as determined by
<code><A HREF="vformat-x.html#vformatGetSegmentClass"><CODE>vformatGetSegmentClass</CODE></A></code>, and assigning the segment's pattern string.
</DD></DL>
<P>
<A NAME="vformatParseSegmentPattern"><HR><H4>vformatParseSegmentPattern</H4></A>
<PRE>
        void <B>vformatParseSegmentPattern</B>(
                vformatSegment * segment,
                vformatParseRange * range);
</PRE>

<DL><DD>
This method is called by <code>vformatParseSegment</code>. 
It scans its pattern string, beginning at the range's starting position,
creating the artifacts necessary to parse or convert a typed-value to string. 
If the segment finds an unrecognized character, it returns,
leaving <SAMP>range</SAMP> to specify that portion of the remaining input
left to be parsed.
<P>
This method may be called multiple times, as various levels of the class
hierarchy access each character. If no member of the particular format's
class hierarchy recognizes a given character, Galaxy raises a 
<code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code>. This exception specifies the 
offset of the first character that was not understood by the format segment.
</DD></DL>
<P>
<A NAME="vformatParseULong"><HR><H4>vformatParseULong</H4></A>
<PRE>
        unsigned long <B>vformatParseULong</B>(
                vformatULong * format,
                const vchar * string);
</PRE>

<DL><DD>
If the input in not understood by at least one of the format's pattern
segments, Galaxy throws a <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatParseULongSegment"><HR><H4>vformatParseULongSegment</H4></A>
<PRE>
        void <B>vformatParseULongSegment</B>(
                vformatULongSegment * segment,
                int segmentIndex);
</PRE>

<DL><DD>
This method is called by <code><A HREF="vformat-x.html#vformatULong"><CODE>vformatULong</CODE></A></code> after first 
decomposing the pattern string into its constituent segment substrings, 
creating an appropriate number of <code><A HREF="vformat-x.html#vformatULongSegment"><CODE>vformatULongSegment</CODE></A></code> 
and assigning their pattern strings. The <Code>segmentIndex</CODE> 
denotes which logical unsigned integer value the
segment represents; either positive or zero.
</DD></DL>
<P>
<A NAME="vformatParseULongSegmentPattern"><HR><H4>vformatParseULongSegmentPattern</H4></A>
<PRE>
        void <B>vformatParseULongSegmentPattern</B>(
                vformatULongSegment * segment,
                vformatParseRange * range);
</PRE>

<DL><DD>
This method is called by <code>vformatParseULongSegment</code>.
It scans the pattern string, beginning at the range's starting position,
creating any artifacts necessary to parse or convert to string an
unsigned integer value. If the segment finds an unrecognized character, it
returns, leaving <SAMP>range</SAMP> to specify that portion of the remaining
input left to be parsed.
<P>
This method may be called multiple times, as various levels of the class
hierarchy access each character. If no member of the particular format's
class hierarchy recognizes a given character, Galaxy raises a 
<code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code>. This exception specifies 
the offset of the first character that was not understood 
by the format segment.
</DD></DL>
<P>
<A NAME="vformatREMAINDER"><HR><H4>vformatREMAINDER</H4></A>
<PRE>
        void <B>vformatREMAINDER</B>(
                void * exception,
                va_list * ap);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatScribeBoolean"><HR><H4>vformatScribeBoolean</H4></A>
<PRE>
        vscribe * <B>vformatScribeBoolean</B>(
                vformatBoolean * format,
                vbool value);
</PRE>

<DL><DD>
False values are generated using the "false" output pattern segment while true
values are generated from the "true" output pattern segment.
</DD></DL>
<P>
<A NAME="vformatScribeDate"><HR><H4>vformatScribeDate</H4></A>
<PRE>
        vscribe * <B>vformatScribeDate</B>(
                vformatDate * format,
                const vdate * value);
</PRE>

<DL><DD>
Creates a scribed string representation of the given date
<SAMP>value</SAMP> based on the format's current output pattern.
</DD></DL>
<P>
<A NAME="vformatScribeDouble"><HR><H4>vformatScribeDouble</H4></A>
<PRE>
        vscribe * <B>vformatScribeDouble</B>(
                vformatDouble * format,
                double value);
</PRE>

<DL><DD>
Internally, the format determines the <code><A HREF="vformat-x.html#vformatDoubleSegment"><CODE>vformatDoubleSegment</CODE></A></code> 
that maps from the given double <SAMP>value</SAMP> by 
<code><A HREF="vformat-x.html#vformatGetDoubleOutputSegment"><CODE>vformatGetDoubleOutputSegment</CODE></A></code>. Format then uses 
that pattern information to create a string representation of
<SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vformatScribeLong"><HR><H4>vformatScribeLong</H4></A>
<PRE>
        vscribe * <B>vformatScribeLong</B>(
                vformatLong * format,
                long value);
</PRE>

<DL><DD>
Internally, the format determines the <code><A HREF="vformat-x.html#vformatLongSegment"><CODE>vformatLongSegment</CODE></A></code> 
that maps from the given long integer <SAMP>value</SAMP> by
<code><A HREF="vformat-x.html#vformatGetLongOutputSegment"><CODE>vformatGetLongOutputSegment</CODE></A></code>. Format then uses 
that pattern information to create
a string representation of <SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vformatScribeULong"><HR><H4>vformatScribeULong</H4></A>
<PRE>
        vscribe * <B>vformatScribeULong</B>(
                vformatULong * format,
                unsigned long value);
</PRE>

<DL><DD>
Internally, the format determines the <code><A HREF="vformat-x.html#vformatULongSegment"><CODE>vformatULongSegment</CODE></A></code> 
that maps from the given unsigned long integer <SAMP>value</SAMP> by
<code>vformatGetUlongOutputSegment</code>, using that pattern 
information to create a string representation of <SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vformatSetBooleanOutputPatternIndex"><HR><H4>vformatSetBooleanOutputPatternIndex</H4></A>
<PRE>
        void <B>vformatSetBooleanOutputPatternIndex</B>(
                vformatBoolean * format,
                int index);
</PRE>

<DL><DD>
Used to specify which pattern is used by calls to 
<code><A HREF="vformat-x.html#vformatScribeBoolean"><CODE>vformatScribeBoolean</CODE></A></code> for
generating output strings. The specified <SAMP>index</SAMP> must be greater-
than or equal-to zero, and less-than the result of calling
<code><A HREF="vformat-x.html#vformatGetBooleanPatternCount"><CODE>vformatGetBooleanPatternCount</CODE></A></code>.
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_OUTPUT_PATTERN_INDEX"><CODE>vformatSET_OUTPUT_PATTERN_INDEX</CODE></A></CODE> to <CODE>format</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetBooleanPatternIndex"><HR><H4>vformatSetBooleanPatternIndex</H4></A>
<PRE>
        void <B>vformatSetBooleanPatternIndex</B>(
                vformatBoolean * format,
                int oldIndex,
                int newIndex);
</PRE>

<DL><DD>
Used to move an existing pattern to a new location in the Boolean
format's pattern set. Both <SAMP>oldIndex</SAMP> and <SAMP>newIndex</SAMP>
must be within the range of the existing pattern set.
This method is implmented by sending the <SAMP><A HREF="vformat-x.html#vformatSET_PATTERN_INDEX"><CODE>vformatSET_PATTERN_INDEX</CODE></A></SAMP>
to <SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatSetBooleanPatterns"><HR><H4>vformatSetBooleanPatterns</H4></A>
<PRE>
        void <B>vformatSetBooleanPatterns</B>(
                vformatBoolean * format,
                const vchar ** strings,
                int count);
</PRE>

<DL><DD>
A format consists, in part, of an ordered set of multi-segmented,
type-specific pattern strings. The natural number of segments that a
format pattern contains is determined by its type. For instance, the
<code><A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A></code> contains patterns made up of two segments: the
"positive" and the "negative." This method first clears any 
existing patterns the format may have.
Next, each pattern string is appended to the pattern set with a call
to <code><A HREF="vformat-x.html#vformatAppendBooleanPattern"><CODE>vformatAppendBooleanPattern</CODE></A></code>.
<P>
Galaxy raises a <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code> if <code>format</code> 
is unable to understand any portion of the pattern string; 
therefore, this method should be
called only if it is known that all of the pattern strings are valid. Use
<code><A HREF="vformat-x.html#vformatAppendBooleanPattern"><CODE>vformatAppendBooleanPattern</CODE></A></code> or 
<code><A HREF="vformat-x.html#vformatInsertBooleanPattern"><CODE>vformatInsertBooleanPattern</CODE></A></code> if the
validity of the pattern strings is in question.
<P>
If no exception is raised by a call to this method, the Boolean format can
be used to determine the validity of arbitrary input strings, 
as well as to generat the output form of a Boolean value. Refer to 
sections <code><A HREF="vformat-x.html#vformatIsBooleanValid"><CODE>vformatIsBooleanValid</CODE></A></code>, 
<code><A HREF="vformat-x.html#vformatIsBooleanPartiallyValid"><CODE>vformatIsBooleanPartiallyValid</CODE></A></code> and
<code><A HREF="vformat-x.html#vformatDetermineBooleanValidity"><CODE>vformatDetermineBooleanValidity</CODE></A></code> for more information.
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_PATTERNS"><CODE>vformatSET_PATTERNS</CODE></A></CODE> to <CODE>format</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetBooleanSegmentAlignment"><HR><H4>vformatSetBooleanSegmentAlignment</H4></A>
<PRE>
        void <B>vformatSetBooleanSegmentAlignment</B>(
                vformatBooleanSegment * segment,
                int alignment);
</PRE>

<DL><DD>
The text alignment code can be one of:

<ul>
<li>vformatALIGN_LEFT
<li>vformatALIGN_RIGHT
<li>vformatALIGN_CENTER
</ul>

<P>
The default <code><A HREF="vformat-x.html#vformatBooleanSegment"><CODE>vformatBooleanSegment</CODE></A></code> class supports the ability to
specify color and text alignment. For example, to specify that a
<code><A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A></code>'s "negative" segment have a 
right-justified attribute, use the pattern shown below.

<Pre>
  "true:}false"
</Pre>

<P>
The segment's color and alignment attributes are not used by the 
<code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes, 
but are meant to be used by higher-level, user-interface constructs, 
such as a spreadsheet cell formatter, or database form.
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_ALIGNMENT"><CODE>vformatSET_SEGMENT_ALIGNMENT</CODE></A></CODE> to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetBooleanSegmentColor"><HR><H4>vformatSetBooleanSegmentColor</H4></A>
<PRE>
        void <B>vformatSetBooleanSegmentColor</B>(
                vformatBooleanSegment * segment,
                vcolor * color);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatBooleanSegment"><CODE>vformatBooleanSegment</CODE></A></code> class supports 
the ability to specify color and text alignment to be associated 
with a segment. For example, to specify that a <code><A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A></code>s 
"negative" segment have a red color attribute, use the pattern shown
below.

<Pre>
  "true:[red]false"
</Pre>

<P>
The segment's color and alignment attributes are not used by the 
<code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes but 
are meant to be used by higher-level, user-interface constructs, 
such as a spreadsheet cell formatter or database form.
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_COLOR"><CODE>vformatSET_SEGMENT_COLOR</CODE></A></CODE> to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetBooleanSegmentFormat"><HR><H4>vformatSetBooleanSegmentFormat</H4></A>
<PRE>
        void <B>vformatSetBooleanSegmentFormat</B>(
                vformatBooleanSegment * segment,
                const vchar * string);
</PRE>

<DL><DD>
This is the string that is used for comparisons when parsing an input string
to determine its boolean value.
</DD></DL>
<P>
<A NAME="vformatSetBooleanSegmentString"><HR><H4>vformatSetBooleanSegmentString</H4></A>
<PRE>
        void <B>vformatSetBooleanSegmentString</B>(
                vformatBooleanSegment * segment,
                const vchar * string);
</PRE>

<DL><DD>
Represents one possible string form of a Boolean value.
The method <code><A HREF="vformat-x.html#vformatParseBooleanSegmentPattern"><CODE>vformatParseBooleanSegmentPattern</CODE></A></code> is 
called and at that time the segment can interpret the tokens 
that make up the pattern string, generating any artifacts needed 
to match arbitrary input strings against that pattern, or for creating 
an output representation of a Boolean value.
<P>
The default Boolean format class first calls on the Base Segment class to
first parse any color or alignment attribute codes from the pattern string.
The portion of the string that remains is then used to determine the 
validity of arbitrary input strings.
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_STRING"><CODE>vformatSET_SEGMENT_STRING</CODE></A></CODE> to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetDateOutputPatternIndex"><HR><H4>vformatSetDateOutputPatternIndex</H4></A>
<PRE>
        void <B>vformatSetDateOutputPatternIndex</B>(
                vformatDate * format,
                int indx);
</PRE>

<DL><DD>
Used to specify which pattern is used by calls to the parse
methods for generating output strings. The specified <SAMP>index</SAMP>
must be greater-than or equal-to zero and less than the result of
calling <code><A HREF="vformat-x.html#vformatGetDatePatternCount"><CODE>vformatGetDatePatternCount</CODE></A></code>.
This method is implmented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_OUTPUT_PATTERN_INDEX"><CODE>vformatSET_OUTPUT_PATTERN_INDEX</CODE></A></CODE> to <CODE>format</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetDatePatternIndex"><HR><H4>vformatSetDatePatternIndex</H4></A>
<PRE>
        void <B>vformatSetDatePatternIndex</B>(
                vformatDate * format,
                int oldIndex,
                int newIndex);
</PRE>

<DL><DD>
Used to move an existing pattern to a new location in the date
format's pattern set. Both <SAMP>oldIndex</SAMP> and <SAMP>newIndex</SAMP>
must be within the range of the existing pattern set.
This method is implmented by sending the <SAMP><A HREF="vformat-x.html#vformatSET_PATTERN_INDEX"><CODE>vformatSET_PATTERN_INDEX</CODE></A></SAMP>
to <SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatSetDatePatterns"><HR><H4>vformatSetDatePatterns</H4></A>
<PRE>
        void <B>vformatSetDatePatterns</B>(
                vformatDate * format,
                const vchar ** strings,
                int count);
</PRE>

<DL><DD>
A format consists, in part, of an ordered set of multi-segmented,
type-specific pattern strings. The natural number of segments that a
format pattern contains is determined by its type. For instance, the
<code><A HREF="vformat-x.html#vformatDate"><CODE>vformatDate</CODE></A></code> contains patterns made up of a single 
segment, representing a <samp><A HREF="vdate-x.html#vdate"><CODE>vdate</CODE></A></samp> value, while a 
<code><A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A></code> has two segments representing
"true" and "false." This method first clears any existing 
patterns the format may have. Next, each pattern string 
is appended to the pattern set with a call
to <code><A HREF="vformat-x.html#vformatAppendDatePattern"><CODE>vformatAppendDatePattern</CODE></A></code>.
<P>
A <samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp> is raised if <code>format</code> 
is unable to understand any portion of the pattern string; therefore, 
this method should be called only if it is known that all of the 
pattern strings are valid. Use <code><A HREF="vformat-x.html#vformatAppendDatePattern"><CODE>vformatAppendDatePattern</CODE></A></code> 
or <code><A HREF="vformat-x.html#vformatInsertDatePattern"><CODE>vformatInsertDatePattern</CODE></A></code> if the
validity of the pattern strings is in question.
<P>
If no exception is raised by a call to this method, the date format can
be used to determine the validity of arbitrary input strings 
as well as to generated the output form of a <samp><A HREF="vdate-x.html#vdate"><CODE>vdate</CODE></A></samp> value.
For more information refer to sections:

<ul>
<li><code><A HREF="vformat-x.html#vformatIsDateValid"><CODE>vformatIsDateValid</CODE></A></code>, 
<li><code><A HREF="vformat-x.html#vformatIsDatePartiallyValid"><CODE>vformatIsDatePartiallyValid</CODE></A></code>
<li><code><A HREF="vformat-x.html#vformatDetermineDateValidity"><CODE>vformatDetermineDateValidity</CODE></A></code>. 
</ul>

<P>
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_PATTERNS"><CODE>vformatSET_PATTERNS</CODE></A></CODE> to <CODE>format</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetDateSegmentAlignment"><HR><H4>vformatSetDateSegmentAlignment</H4></A>
<PRE>
        void <B>vformatSetDateSegmentAlignment</B>(
                vformatDateSegment * segment,
                int alignment);
</PRE>

<DL><DD>
The text alignment code can be one of:

<ul>
<li>vformatALIGN_LEFT
<li>vformatALIGN_RIGHT
<li>vformatALIGN_CENTER
</ul>

<P>
The default <code><A HREF="vformat-x.html#vformatDateSegment"><CODE>vformatDateSegment</CODE></A></code> class supports the ability to
specify color and text alignment. For example, to specify that a
<code><A HREF="vformat-x.html#vformatDateSegment"><CODE>vformatDateSegment</CODE></A></code> have a right-justified attribute, 
use the following pattern syntax.

<Pre>
  "m/d/yy}"  // right-justified date string
  "m/d/yy{"  // left-
  "m/d/yy|"  // center-
</Pre>

<p>
The segment's color and alignment attributes are not used by the 
<code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes but 
are meant to be used by higher-level, user-interface constructs, 
such as a spreadsheet cell formatter or database
form. This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_ALIGNMENT"><CODE>vformatSET_SEGMENT_ALIGNMENT</CODE></A></CODE> to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetDateSegmentColor"><HR><H4>vformatSetDateSegmentColor</H4></A>
<PRE>
        void <B>vformatSetDateSegmentColor</B>(
                vformatDateSegment * segment,
                vcolor * color);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatDateSegment"><CODE>vformatDateSegment</CODE></A></code> class supports the 
ability to specify color and text alignment to be associated with a segment. 
For example, to specify that a <samp><A HREF="vformat-x.html#vformatDate"><CODE>vformatDate</CODE></A></samp> segment 
have a red color attribute, use the pattern below.

<Pre>
  "[red]mm/dd/yy"
</Pre>

<P>
The segment's color and alignment attributes are not used by the 
<code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes, 
but are meant to be used by higher-level, user-interface constructs, 
such as a spreadsheet cell formatter or database form.
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_COLOR"><CODE>vformatSET_SEGMENT_COLOR</CODE></A></CODE> to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetDateSegmentFormat"><HR><H4>vformatSetDateSegmentFormat</H4></A>
<PRE>
        void <B>vformatSetDateSegmentFormat</B>(
                vformatDateSegment * segment,
                vdateFormat * format);
</PRE>

<DL><DD>
Sets the <code><A HREF="vdate-x.html#vdateFormat"><CODE>vdateFormat</CODE></A></code> the segment uses for parsing and generating
output forms of a <code><A HREF="vdate-x.html#vdate"><CODE>vdate</CODE></A></code> value.
</DD></DL>
<P>
<A NAME="vformatSetDateSegmentString"><HR><H4>vformatSetDateSegmentString</H4></A>
<PRE>
        void <B>vformatSetDateSegmentString</B>(
                vformatDateSegment * segment,
                const vchar * string);
</PRE>

<DL><DD>
Represents one possible string form of a <samp><A HREF="vdate-x.html#vdate"><CODE>vdate</CODE></A></samp> value.
The method <code><A HREF="vformat-x.html#vformatParseDateSegmentPattern"><CODE>vformatParseDateSegmentPattern</CODE></A></code> is called 
and the segment then interprets the tokens that make 
up the pattern string and generats any artifacts it needed to 
match arbitrary input strings against that pattern, or for 
creating an output representation of a <samp><A HREF="vdate-x.html#vdate"><CODE>vdate</CODE></A></samp> value.
<P>
The default date format class first calls on the base segment class to
first parse any color or alignment attribute codes from the pattern string.
The portion of the string that remains is assumed to include only elements from
the date format pattern language. This method is implemented by 
sending the message <CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_STRING"><CODE>vformatSET_SEGMENT_STRING</CODE></A></CODE> 
to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetDoubleOutputPatternIndex"><HR><H4>vformatSetDoubleOutputPatternIndex</H4></A>
<PRE>
        void <B>vformatSetDoubleOutputPatternIndex</B>(
                vformatDouble * format,
                int index);
</PRE>

<DL><DD>
Used to specify which pattern is used by calls to the parse
methods for generating output strings. The specified <SAMP>index</SAMP>
must be greater-than or equal-to zero and less than the result of
calling <code><A HREF="vformat-x.html#vformatGetDoublePatternCount"><CODE>vformatGetDoublePatternCount</CODE></A></code>.
This method is implmented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_OUTPUT_PATTERN_INDEX"><CODE>vformatSET_OUTPUT_PATTERN_INDEX</CODE></A></CODE> to <CODE>format</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetDoublePatternIndex"><HR><H4>vformatSetDoublePatternIndex</H4></A>
<PRE>
        void <B>vformatSetDoublePatternIndex</B>(
                vformatDouble * format,
                int oldIndex,
                int newIndex);
</PRE>

<DL><DD>
Used to move an existing pattern to a new location in the double
format's pattern set. Both <SAMP>oldIndex</SAMP> and <SAMP>newIndex</SAMP>
must be within the range of the existing pattern set.
This method is implmented by sending the <SAMP><A HREF="vformat-x.html#vformatSET_PATTERN_INDEX"><CODE>vformatSET_PATTERN_INDEX</CODE></A></SAMP>
to <SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatSetDoublePatterns"><HR><H4>vformatSetDoublePatterns</H4></A>
<PRE>
        void <B>vformatSetDoublePatterns</B>(
                vformatDouble * format,
                const vchar ** strings,
                int count);
</PRE>

<DL><DD>
A format consists, in part, of an ordered set of multi-segmented,
type-specific pattern strings. The natural number of segments that a
format pattern contains is determined by its type. For instance, the
<code><A HREF="vformat-x.html#vformatDouble"><CODE>vformatDouble</CODE></A></code> contains patterns made up of 3 segments: 
positive; negative; and zero.
This method first clears any existing patterns the format may have.
Next, each pattern string is appended to the pattern set with a call
to <code><A HREF="vformat-x.html#vformatAppendDoublePattern"><CODE>vformatAppendDoublePattern</CODE></A></code>.
<P>
Galaxy raises a <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code> if <code>format</code> 
is unable to understand any portion of the pattern string; therefore, 
this method should be called only if it is known that all of the 
pattern strings are valid. Use
<code><A HREF="vformat-x.html#vformatAppendDoublePattern"><CODE>vformatAppendDoublePattern</CODE></A></code> or 
<code><A HREF="vformat-x.html#vformatInsertDoublePattern"><CODE>vformatInsertDoublePattern</CODE></A></code> if the
validity of the pattern strings is in question.
<P>
If no exception is raised by a call to this method, the Boolean format can
be used to determine the validity of arbitrary input strings, as well as 
to generated the output form of a double value. For more information 
refer to sections:

<ul> 
<li><code><A HREF="vformat-x.html#vformatIsDoubleValid"><CODE>vformatIsDoubleValid</CODE></A></code>
<li><code><A HREF="vformat-x.html#vformatIsDoublePartiallyValid"><CODE>vformatIsDoublePartiallyValid</CODE></A></code>
<li><code><A HREF="vformat-x.html#vformatDetermineDoubleValidity"><CODE>vformatDetermineDoubleValidity</CODE></A></code>
</ul>

<p>
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_PATTERNS"><CODE>vformatSET_PATTERNS</CODE></A></CODE> to <CODE>format</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetDoubleSegmentAlignment"><HR><H4>vformatSetDoubleSegmentAlignment</H4></A>
<PRE>
        void <B>vformatSetDoubleSegmentAlignment</B>(
                vformatDoubleSegment * segment,
                int alignment);
</PRE>

<DL><DD>
The text alignment code can be one of:

<ul>
<li>vformatALIGN_LEFT
<li>vformatALIGN_RIGHT
<li>vformatALIGN_CENTER
</ul>

<P>
The default <code><A HREF="vformat-x.html#vformatDoubleSegment"><CODE>vformatDoubleSegment</CODE></A></code> class supports the ability to
specify color and text alignment. For example, to specify that a
<code><A HREF="vformat-x.html#vformatDoubleSegment"><CODE>vformatDoubleSegment</CODE></A></code> have a right-justified attribute, 
use a pattern like this:

<Pre>
  "#,###.00}"  // right-justified double value
  "#,###.00{"  // left-
  "#,###.00|"  // center-
</Pre>

<P>
The segment's color and alignment attributes are not used by the 
<code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes 
but are meant to be used by higher-level, user-interface constructs, 
such as a spreadsheet cell formatter or database form.
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_ALIGNMENT"><CODE>vformatSET_SEGMENT_ALIGNMENT</CODE></A></CODE> to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetDoubleSegmentColor"><HR><H4>vformatSetDoubleSegmentColor</H4></A>
<PRE>
        void <B>vformatSetDoubleSegmentColor</B>(
                vformatDoubleSegment * segment,
                vcolor * color);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatDoubleSegment"><CODE>vformatDoubleSegment</CODE></A></code> class supports the 
ability to specify color and text alignment to be associated with a segment. 
For example, to specify that a <code><A HREF="vformat-x.html#vformatDoubleSegment"><CODE>vformatDoubleSegment</CODE></A></code> 
have a red color attribute, use a pattern like this:

<Pre>
  "[red]#,###.00"<P>
</Pre>

<P>
The segment's color and alignment attributes are not used by the 
<code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes, 
but are meant to be used by higher-level, user-interface constructs, 
such as a spreadsheet cell formatter or database form.
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_COLOR"><CODE>vformatSET_SEGMENT_COLOR</CODE></A></CODE> to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetDoubleSegmentPrefix"><HR><H4>vformatSetDoubleSegmentPrefix</H4></A>
<PRE>
        void <B>vformatSetDoubleSegmentPrefix</B>(
                vformatDoubleSegment * segment,
                const vchar * prefix);
</PRE>

<DL><DD>
Each number format segment can have an optional prefix and/or suffix string
that is literal text at the beginning or ending of a number segment pattern.
This literal text must be matched indentically by the input string for a
parsing operation to succeed. The literal text is also used when
constructing an output form of a given number value.
</DD></DL>
<P>
<A NAME="vformatSetDoubleSegmentScale"><HR><H4>vformatSetDoubleSegmentScale</H4></A>
<PRE>
        void <B>vformatSetDoubleSegmentScale</B>(
                vformatDoubleSegment * segment,
                double scale);
</PRE>

<DL><DD>
Sets the scale factor the segment uses for parsing and for conversion
of a double value to a string.
</DD></DL>
<P>
<A NAME="vformatSetDoubleSegmentString"><HR><H4>vformatSetDoubleSegmentString</H4></A>
<PRE>
        void <B>vformatSetDoubleSegmentString</B>(
                vformatDoubleSegment * segment,
                const vchar * string);
</PRE>

<DL><DD>
Represents one possible string form of a double value. The method 
<code><A HREF="vformat-x.html#vformatParseDoubleSegmentPattern"><CODE>vformatParseDoubleSegmentPattern</CODE></A></code> is called, and the 
segment interprets the tokens that make up the pattern string,
generating any artifacts needed to match arbitrary input strings
against that pattern, or for creating an output representation of a double
value. The default double format class first calls on the base segment class to
first parse any color or alignment attribute codes from the pattern string.
The portion of the string that remains is assumed to include only elements from
the double format pattern language. This method is implemented by 
sending the message <CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_STRING"><CODE>vformatSET_SEGMENT_STRING</CODE></A></CODE> 
to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetDoubleSegmentSuffix"><HR><H4>vformatSetDoubleSegmentSuffix</H4></A>
<PRE>
        void <B>vformatSetDoubleSegmentSuffix</B>(
                vformatDoubleSegment * segment,
                const vchar * suffix);
</PRE>

<DL><DD>
Each number format segment can have an optional prefix and/or suffix string
that is literal text at the beginning of ending of a number segment pattern.
This literal text must be matched indentically by the input string for a
parsing operation to succeed. The literal text is also used when
constructing an output form of a given number value.
</DD></DL>
<P>
<A NAME="vformatSetLongOutputPatternIndex"><HR><H4>vformatSetLongOutputPatternIndex</H4></A>
<PRE>
        void <B>vformatSetLongOutputPatternIndex</B>(
                vformatLong * format,
                int index);
</PRE>

<DL><DD>
Used to specify which pattern is used by calls to the parse
methods for generating output strings. The specified <SAMP>index</SAMP>
must be greater-than or equal-to zero, and less than the result of
calling <code><A HREF="vformat-x.html#vformatGetLongPatternCount"><CODE>vformatGetLongPatternCount</CODE></A></code>.
This method is implmented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_OUTPUT_PATTERN_INDEX"><CODE>vformatSET_OUTPUT_PATTERN_INDEX</CODE></A></CODE> to <CODE>format</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetLongPatternIndex"><HR><H4>vformatSetLongPatternIndex</H4></A>
<PRE>
        void <B>vformatSetLongPatternIndex</B>(
                vformatLong * format,
                int oldIndex,
                int newIndex);
</PRE>

<DL><DD>
Used to move an existing pattern to a new location in the long integer
format's pattern set. Both <SAMP>oldIndex</SAMP> and <SAMP>newIndex</SAMP>
must be within the range of the existing pattern set.
This method is implmented by sending the <SAMP><A HREF="vformat-x.html#vformatSET_PATTERN_INDEX"><CODE>vformatSET_PATTERN_INDEX</CODE></A></SAMP>
to <SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatSetLongPatterns"><HR><H4>vformatSetLongPatterns</H4></A>
<PRE>
        void <B>vformatSetLongPatterns</B>(
                vformatLong * format,
                const vchar ** strings,
                int count);
</PRE>

<DL><DD>
A format consists, in part, of an ordered set of multi-segmented,
type-specific pattern strings. The natural number of segments that a
format pattern contains is determined by its type. For instance, the
<code><A HREF="vformat-x.html#vformatLong"><CODE>vformatLong</CODE></A></code> contains patterns made up of 3 segments: 
positive; negative; and zero.
<P>
This method first clears any existing patterns the format may have.
Next, each pattern string is appended to the pattern set with a call
to <code><A HREF="vformat-x.html#vformatAppendLongPattern"><CODE>vformatAppendLongPattern</CODE></A></code>.
<P>
A <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code> is raised if <code>format</code> 
is unable to understand any portion of the pattern string; 
therefore, this method should be called only if it is known that 
all of the pattern strings are valid. Use 
<code><A HREF="vformat-x.html#vformatAppendLongPattern"><CODE>vformatAppendLongPattern</CODE></A></code> or <code><A HREF="vformat-x.html#vformatInsertLongPattern"><CODE>vformatInsertLongPattern</CODE></A></code> if the validity of the pattern strings is in question.
<P>
If no exception is raised by a call to this method, the format can
be used to determine the validity of arbitrary input strings, 
as well as to generated the output form of a long integer value. 
For more information refer to sections:

<UL>
<li><code><A HREF="vformat-x.html#vformatIsLongValid"><CODE>vformatIsLongValid</CODE></A></code>
<li><code><A HREF="vformat-x.html#vformatIsLongPartiallyValid"><CODE>vformatIsLongPartiallyValid</CODE></A></code>
<li><code><A HREF="vformat-x.html#vformatDetermineLongValidity"><CODE>vformatDetermineLongValidity</CODE></A></code>
</ul>

This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_PATTERNS"><CODE>vformatSET_PATTERNS</CODE></A></CODE> to <CODE>format</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetLongSegmentAlignment"><HR><H4>vformatSetLongSegmentAlignment</H4></A>
<PRE>
        void <B>vformatSetLongSegmentAlignment</B>(
                vformatLongSegment * segment,
                int alignment);
</PRE>

<DL><DD>
The text alignment code can be one of:

<ul>
<li>vformatALIGN_LEFT
<li>vformatALIGN_RIGHT
<li>vformatALIGN_CENTER
</ul>

<P>
The default <code><A HREF="vformat-x.html#vformatLongSegment"><CODE>vformatLongSegment</CODE></A></code> class supports the ability to
specify color and text alignment. For example, to specify that a
<code><A HREF="vformat-x.html#vformatLongSegment"><CODE>vformatLongSegment</CODE></A></code> have a right-justified attribute, 
use the following syntax.

<Pre>
  "#,###}"  // right-justified long integer value
  "#,###{"  // left-
  "#,###|"  // center-
</Pre>

<P>
The segment's color and alignment attributes are not used by the 
<code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes 
but are meant to be used by higher-level, user-interface constructs, 
such as a spreadsheet cell formatter or database form.
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_ALIGNMENT"><CODE>vformatSET_SEGMENT_ALIGNMENT</CODE></A></CODE> to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetLongSegmentColor"><HR><H4>vformatSetLongSegmentColor</H4></A>
<PRE>
        void <B>vformatSetLongSegmentColor</B>(
                vformatLongSegment * segment,
                vcolor * color);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatLongSegment"><CODE>vformatLongSegment</CODE></A></code> class supports the ability 
to specify color and text alignment to be associated with a segment. 
For example, to specify that a <code><A HREF="vformat-x.html#vformatLongSegment"><CODE>vformatLongSegment</CODE></A></code> 
have a red color attribute, use a the following syntax.

<Pre>
  "[red]#,###"
</Pre>

<p>
The segment's color and alignment attributes are not used by the 
<code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes, 
but are meant to be used by higher-level, user-interface constructs, 
such as a spreadsheet cell formatter or database form.
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_COLOR"><CODE>vformatSET_SEGMENT_COLOR</CODE></A></CODE> to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetLongSegmentPrefix"><HR><H4>vformatSetLongSegmentPrefix</H4></A>
<PRE>
        void <B>vformatSetLongSegmentPrefix</B>(
                vformatLongSegment * segment,
                const vchar * prefix);
</PRE>

<DL><DD>
Each number format segment can have an optional prefix and/or suffix string
that is literal text at the beginning or ending of a number segment pattern.
This literal text must be matched indentically by the input string for a
parsing operation to succeed. The literal text is also used when
constructing an output form of a given number value.
</DD></DL>
<P>
<A NAME="vformatSetLongSegmentScale"><HR><H4>vformatSetLongSegmentScale</H4></A>
<PRE>
        void <B>vformatSetLongSegmentScale</B>(
                vformatLongSegment * segment,
                long scale);
</PRE>

<DL><DD>
Sets the scale factor the segment uses for parsing and for conversion
of a long integer value to a string.
</DD></DL>
<P>
<A NAME="vformatSetLongSegmentString"><HR><H4>vformatSetLongSegmentString</H4></A>
<PRE>
        void <B>vformatSetLongSegmentString</B>(
                vformatLongSegment * segment,
                const vchar * string);
</PRE>

<DL><DD>
Represents one possible string form of a long integer value.
<P>
The method <code><A HREF="vformat-x.html#vformatParseLongSegmentPattern"><CODE>vformatParseLongSegmentPattern</CODE></A></code> is called and 
the segment interprets the tokens that make up the pattern string. It then 
generates any artifacts needed to match arbitrary input strings
against that pattern, or for creating an output 
representation of a long integer value.
<P>
The default long integer format class first calls on the base segment class to
first parse any color or alignment attribute codes from the pattern string.
The portion of the string that remains is assumed to include only elements from
the long format pattern language. This method is implemented 
by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_STRING"><CODE>vformatSET_SEGMENT_STRING</CODE></A></CODE> to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetLongSegmentSuffix"><HR><H4>vformatSetLongSegmentSuffix</H4></A>
<PRE>
        void <B>vformatSetLongSegmentSuffix</B>(
                vformatLongSegment * segment,
                const vchar * suffix);
</PRE>

<DL><DD>
Each number format segment can have an optional prefix and/or suffix string
that is literal text at the beginning of ending of a number segment pattern.
This literal text must be matched indentically by the input string for a
parsing operation to succeed. The literal text is also used when
constructing an output form of a given number value.
</DD></DL>
<P>
<A NAME="vformatSetNumberOutputPatternIndex"><HR><H4>vformatSetNumberOutputPatternIndex</H4></A>
<PRE>
        void <B>vformatSetNumberOutputPatternIndex</B>(
                vformatNumber * format,
                int indx);
</PRE>

<DL><DD>
Used to specify which pattern is used by calls to the parse
methods for generating output strings. The specified <SAMP>index</SAMP>
must be greater-than or equal-to zero and less than the result of
calling <code><A HREF="vformat-x.html#vformatGetNumberPatternCount"><CODE>vformatGetNumberPatternCount</CODE></A></code>.
This method is implmented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_OUTPUT_PATTERN_INDEX"><CODE>vformatSET_OUTPUT_PATTERN_INDEX</CODE></A></CODE> to <CODE>format</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetNumberPatternIndex"><HR><H4>vformatSetNumberPatternIndex</H4></A>
<PRE>
        void <B>vformatSetNumberPatternIndex</B>(
                vformatNumber * format,
                int oldIndex,
                int newIndex);
</PRE>

<DL><DD>
Used to move an existing pattern to a new location in the number
format's pattern set. Both <SAMP>oldIndex</SAMP> and <SAMP>newIndex</SAMP>
must be within the range of the existing pattern set.
This method is implmented by sending the 
<SAMP><A HREF="vformat-x.html#vformatSET_PATTERN_INDEX"><CODE>vformatSET_PATTERN_INDEX</CODE></A></SAMP> to <SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatSetNumberPatterns"><HR><H4>vformatSetNumberPatterns</H4></A>
<PRE>
        void <B>vformatSetNumberPatterns</B>(
                vformatNumber * format,
                const vchar ** strings,
                int count);
</PRE>

<DL><DD>
A format consists, in part, of an ordered set of multi-segmented,
type-specific pattern strings. The natural number of segments that a
format pattern contains is determined by its type. For instance, the
<code><A HREF="vformat-x.html#vformatLong"><CODE>vformatLong</CODE></A></code> contains patterns made up of 3 segments:
positive; negative; and zero. This method first clears 
any existing patterns the format may have.
Next, each pattern string is appended to the pattern set with a call
to <code><A HREF="vformat-x.html#vformatAppendNumberPattern"><CODE>vformatAppendNumberPattern</CODE></A></code>.
<P>
Galaxy raises a <samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp> if <code>format</code> 
is unable to understand any portion of the pattern string; therefore, 
this method should be called only if it is known that 
all of the pattern strings are valid. Use
<code><A HREF="vformat-x.html#vformatAppendNumberPattern"><CODE>vformatAppendNumberPattern</CODE></A></code> or 
<code><A HREF="vformat-x.html#vformatInsertNumberPattern"><CODE>vformatInsertNumberPattern</CODE></A></code> if the validity of 
the pattern strings is in question.
If no exception is raised by a call to this method, the format can
be used to determine the validity of arbitrary input strings.
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_PATTERNS"><CODE>vformatSET_PATTERNS</CODE></A></CODE> to <CODE>format</CODE>.

<P>
For more information refer to sections:

<ul>
<Li><A HREF="vformat-x.html#vformatIsNumberValid"><CODE>vformatIsNumberValid</CODE></A>
<li><A HREF="vformat-x.html#vformatIsNumberPartiallyValid"><CODE>vformatIsNumberPartiallyValid</CODE></A>
<li><A HREF="vformat-x.html#vformatDetermineNumberValidity"><CODE>vformatDetermineNumberValidity</CODE></A>
</ul>
</DD></DL>
<P>
<A NAME="vformatSetNumberSegmentAlignment"><HR><H4>vformatSetNumberSegmentAlignment</H4></A>
<PRE>
        void <B>vformatSetNumberSegmentAlignment</B>(
                vformatNumberSegment * segment,
                int alignment);
</PRE>

<DL><DD>
The text alignment code can be one of:

<UL>
<li>vformatALIGN_LEFT
<li>vformatALIGN_RIGHT
<li>vformatALIGN_CENTER
</ul>

<P>
The default <code><A HREF="vformat-x.html#vformatNumberSegment"><CODE>vformatNumberSegment</CODE></A></code> class supports the ability to
specify color and text alignment. For example, to specify that a
<code><A HREF="vformat-x.html#vformatLongSegment"><CODE>vformatLongSegment</CODE></A></code> have a right-justified attribute, 
use following.

<Pre>
  "#,###}"  // right-justified long integer value
  "#,###{"  // left-
  "#,###|"  // center-
</Pre>

<P>
The segment's color and alignment attributes are not used by the 
<code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes, 
but are meant to be used by higher-level, user-interface constructs, 
such as a spreadsheet cell formatter or database form.
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_ALIGNMENT"><CODE>vformatSET_SEGMENT_ALIGNMENT</CODE></A></CODE> to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetNumberSegmentColor"><HR><H4>vformatSetNumberSegmentColor</H4></A>
<PRE>
        void <B>vformatSetNumberSegmentColor</B>(
                vformatNumberSegment * segment,
                vcolor * color);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatNumberSegment"><CODE>vformatNumberSegment</CODE></A></code> class supports 
the ability to specify color and text alignment to be associated 
with a segment. For example, to specify that a <code><A HREF="vformat-x.html#vformatLongSegment"><CODE>vformatLongSegment</CODE></A></code> 
have a red color attribute, use a pattern like this:

<Pre>
  "[red]#,###"
</Pre>

<p>
The segment's color and alignment attributes are not used by the 
<code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes but are 
meant to be used by higher-level, user-interface constructs, such as 
a spreadsheet cell formatter or database form.
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_COLOR"><CODE>vformatSET_SEGMENT_COLOR</CODE></A></CODE> to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetNumberSegmentPrefix"><HR><H4>vformatSetNumberSegmentPrefix</H4></A>
<PRE>
        void <B>vformatSetNumberSegmentPrefix</B>(
                vformatNumberSegment * segment,
                const vchar * prefix);
</PRE>

<DL><DD>
Each number format can have an optional prefix and/or suffix string that is
literal text at the beginning or ending of a number segment pattern. This
literal text must be matched indentically by the input string for a parsing
operation to succeed. Galaxy also uses the literal text when constructing
an output form of a given number value.
</DD></DL>
<P>
<A NAME="vformatSetNumberSegmentScale"><HR><H4>vformatSetNumberSegmentScale</H4></A>
<PRE>
        void <B>vformatSetNumberSegmentScale</B>(
                vformatNumberSegment * segment,
                double scale);
</PRE>

<DL><DD>
Sets the scale factor the segment uses for parsing and for conversion
of a numeric value to a string.
</DD></DL>
<P>
<A NAME="vformatSetNumberSegmentString"><HR><H4>vformatSetNumberSegmentString</H4></A>
<PRE>
        void <B>vformatSetNumberSegmentString</B>(
                vformatNumberSegment * segment,
                const vchar * string);
</PRE>

<DL><DD>
Represents one possible string form of a numeric value.
The method <code><A HREF="vformat-x.html#vformatParseNumberSegmentPattern"><CODE>vformatParseNumberSegmentPattern</CODE></A></code> is called and 
the segment interprets the tokens that make up the pattern string,
generating any artifacts needed to match arbitrary input strings
against that pattern, or for creating an output representation of a numeric
value.
<P>
The default number format class first calls on the base segment class to
first parse any color or alignment attribute codes from the pattern string.
The portion of the string that remains is assumed to include only elements from
the number pattern language. This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_STRING"><CODE>vformatSET_SEGMENT_STRING</CODE></A></CODE> to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetNumberSegmentSuffix"><HR><H4>vformatSetNumberSegmentSuffix</H4></A>
<PRE>
        void <B>vformatSetNumberSegmentSuffix</B>(
                vformatNumberSegment * segment,
                const vchar * suffix);
</PRE>

<DL><DD>
Each number format can have an optional prefix and/or suffix string that is
literal text at the beginning of ending of a number segment pattern. This
literal text must be matched indentically by the input string for a parsing
operation to succeed.  Galaxy also uses the literal text is used when constructing
an output form of a given number value.
</DD></DL>
<P>
<A NAME="vformatSetNumberStrict"><HR><H4>vformatSetNumberStrict</H4></A>
<PRE>
        void <B>vformatSetNumberStrict</B>(
                vformatNumber * format,
                vbool strict);
</PRE>

<DL><DD>
Normally, a number format pattern is parsed and scribed
strictly according to the information provided in the pattern.
This, however, can be inconvenient at times so the number
format can be made more lenient with regard to the number
of digits that are accepted or displayed in the whole portion
of the format.  For instance, this pattern "#" would normally
only allow a single digit but when the number format is not
strict, any number of digits would be allowed here.
<P>
By default, all number formats are lenient (not strict) in this
regard.
</DD></DL>
<P>
<A NAME="vformatSetOutputPatternIndex"><HR><H4>vformatSetOutputPatternIndex</H4></A>
<PRE>
        void <B>vformatSetOutputPatternIndex</B>(
                vformat * format,
                int indx);
</PRE>

<DL><DD>
Used to specify which pattern is used by calls to the parse
methods for generating output strings. The specified <SAMP>index</SAMP>
must be greater-than or equal to zero and less than the result of
calling <code><A HREF="vformat-x.html#vformatGetPatternCount"><CODE>vformatGetPatternCount</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatSetParseRange"><HR><H4>vformatSetParseRange</H4></A>
<PRE>
        void <B>vformatSetParseRange</B>(
                vformatParseRange * range,
                int pos,
                int len);
</PRE>

<DL><DD>
This is a convenience for making the two calls 
<code><A HREF="vformat-x.html#vformatSetParseRangeStart"><CODE>vformatSetParseRangeStart</CODE></A></code> and <code><A HREF="vformat-x.html#vformatSetParseRangeLength"><CODE>vformatSetParseRangeLength</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatSetParseRangeLength"><HR><H4>vformatSetParseRangeLength</H4></A>
<PRE>
        void <B>vformatSetParseRangeLength</B>(
                vformatParseRange * range,
                int len);
</PRE>

<DL><DD>
Sets the parse range length to <SAMP>len</SAMP>.
</DD></DL>
<P>
<A NAME="vformatSetParseRangeStart"><HR><H4>vformatSetParseRangeStart</H4></A>
<PRE>
        void <B>vformatSetParseRangeStart</B>(
                vformatParseRange * range,
                int pos);
</PRE>

<DL><DD>
Sets the starting offset of the parse range.
</DD></DL>
<P>
<A NAME="vformatSetPatternIndex"><HR><H4>vformatSetPatternIndex</H4></A>
<PRE>
        void <B>vformatSetPatternIndex</B>(
                vformat * format,
                int oldIndex,
                int newIndex);
</PRE>

<DL><DD>
Used to move an existing pattern to a new location
in the format's pattern set. Both <SAMP>oldIndex</SAMP> and
<SAMP>newIndex</SAMP> must be within the range of the existing pattern set.
</DD></DL>
<P>
<A NAME="vformatSetPatterns"><HR><H4>vformatSetPatterns</H4></A>
<PRE>
        void <B>vformatSetPatterns</B>(
                vformat * format,
                const vchar ** string,
                int count);
</PRE>

<DL><DD>
A format consists, in part, of an ordered set of multi-segmented,
type-specific pattern strings. The natural number of segments that a
format pattern contains is determined by its type. For instance, the
<samp><A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A></samp> contains patterns made up of two segments: the
"positive" and the "negative."
This method first clears any existing patterns the format has.
Next, each pattern string is appended to the pattern set with a call
to <code><A HREF="vformat-x.html#vformat"><CODE>vformat</CODE></A></code>.
<P>
Galaxy raises a <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A> </code> when the format is unable to
understand any portion of the pattern string; therefore, this method should be
called only if it is known that all of the pattern strings are valid. Use
<code><A HREF="vformat-x.html#vformat"><CODE>vformat</CODE></A></code> or <code><A HREF="vformat-x.html#vformat"><CODE>vformat</CODE></A></code> 
if the validity of the pattern strings is in question.
<P>
If no exception is raised by a call to this method, the format can
be used to determine the validity of arbitrary input strings 
as well as to generated the output form of a
typed-value by the Scribe methods. For more information, refer to sections:

<ul> 
<li><A HREF="vformat-x.html#vformat"><CODE>vformat</CODE></A>
<li><A HREF="vformat-x.html#vformat"><CODE>vformat</CODE></A>
<li><A HREF="vformat-x.html#vformat"><CODE>vformat</CODE></A>
</ul>
</DD></DL>
<P>
<A NAME="vformatSetSegmentAlignment"><HR><H4>vformatSetSegmentAlignment</H4></A>
<PRE>
        void <B>vformatSetSegmentAlignment</B>(
                vformatSegment * segment,
                int alignment);
</PRE>

<DL><DD>
The text alignment code can be:

<ul>
<li>vformatALIGN_LEFT
<li>vformatALIGN_RIGHT
<li>vformatALIGN_CENTER
</ul>

<P>
The default <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> class supports the ability to specify color
and text alignment. For example, to specify that a 
<code><A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A></code>'s "negative" segment have a right-justified 
attribute, use the pattern shown below.

<Pre>
  "true:}false"
</Pre>

The segment's color and alignment attributes are not used by the 
<code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes, 
but are meant to be used by higher-level,
user-interface constructs, such as a spreadsheet cell formatter, or database
form.
</DD></DL>
<P>
<A NAME="vformatSetSegmentColor"><HR><H4>vformatSetSegmentColor</H4></A>
<PRE>
        void <B>vformatSetSegmentColor</B>(
                vformatSegment * segment,
                vcolor * color);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> class supports the ability to 
specify color and text alignment to be associated with a segment. 
For example, to specify that a <code><A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A></code>'s "negative" 
segment have a red color attribute, use the pattern below.

<Pre>
  "true:[red]false"
</Pre>

The segment's color and alignment attributes are not used by the 
<code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes but 
are meant to be used by higher-level, user-interface constructs, 
such as a spreadsheet cell formatter or database form.
</DD></DL>
<P>
<A NAME="vformatSetSegmentString"><HR><H4>vformatSetSegmentString</H4></A>
<PRE>
        void <B>vformatSetSegmentString</B>(
                vformatSegment * segment,
                const vchar * string);
</PRE>

<DL><DD>
Represents one possible state that a typed-value can have and is in the form
of a type-specific pattern language.
The method <code><A HREF="vformat-x.html#vformatParseSegmentPattern"><CODE>vformatParseSegmentPattern</CODE></A></code> is called 
and the segment interprets the tokens that make up the pattern string, 
generating any artifacts needed to match arbitrary input strings against that
pattern, or for creating an output representation of some typed-value.
</DD></DL>
<P>
<A NAME="vformatSetSharedAlias"><HR><H4>vformatSetSharedAlias</H4></A>
<PRE>
        void <B>vformatSetSharedAlias</B>(
                vformat * format,
                const vname * aliasTag);
</PRE>

<DL><DD>
This accessor method simply sets an instance variable that is the name
of the default format.
</DD></DL>
<P>
<A NAME="vformatSetULongOutputPatternIndex"><HR><H4>vformatSetULongOutputPatternIndex</H4></A>
<PRE>
        void <B>vformatSetULongOutputPatternIndex</B>(
                vformatULong * format,
                int indx);
</PRE>

<DL><DD>
Used to specify which pattern is used by calls to the parse
methods for generating output strings. The specified <SAMP>index</SAMP>
must be greater-than or equal-to zero and less than the result of
calling <code><A HREF="vformat-x.html#vformatGetULongPatternCount"><CODE>vformatGetULongPatternCount</CODE></A></code>.
This method is implmented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_OUTPUT_PATTERN_INDEX"><CODE>vformatSET_OUTPUT_PATTERN_INDEX</CODE></A></CODE> to <CODE>format</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetULongPatternIndex"><HR><H4>vformatSetULongPatternIndex</H4></A>
<PRE>
        void <B>vformatSetULongPatternIndex</B>(
                vformatULong * format,
                int oldIndex,
                int newIndex);
</PRE>

<DL><DD>
Used to move an existing pattern to a new location in the unsigned long integer
format's pattern set. Both <SAMP>oldIndex</SAMP> and <SAMP>newIndex</SAMP>
must be within the range of the existing pattern set.
This method is implmented by sending the <SAMP><A HREF="vformat-x.html#vformatSET_PATTERN_INDEX"><CODE>vformatSET_PATTERN_INDEX</CODE></A></SAMP>
to <SAMP>format</SAMP>.
</DD></DL>
<P>
<A NAME="vformatSetULongPatterns"><HR><H4>vformatSetULongPatterns</H4></A>
<PRE>
        void <B>vformatSetULongPatterns</B>(
                vformatULong * format,
                const vchar ** strings,
                int count);
</PRE>

<DL><DD>
A format consists, in part, of an ordered set of multi-segmented,
type-specific pattern strings. The natural number of segments that a
format pattern contains is determined by its type. For instance, the
<code><A HREF="vformat-x.html#vformatULong"><CODE>vformatULong</CODE></A></code> contains patterns made up of 2 segments: 
positive and negative.
<P>
This method first clears any existing patterns the format may have.
Next, each pattern string is appended to the pattern set with a call
to <code><A HREF="vformat-x.html#vformatAppendULongPattern"><CODE>vformatAppendULongPattern</CODE></A></code>.
Galaxy raises a <samp><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></samp> is raised if 
<code>format</code> is unable to
understand any portion of the pattern string; therefore, this method should be
called only if it is known that all of the pattern strings are valid. Use
<code><A HREF="vformat-x.html#vformatAppendULongPattern"><CODE>vformatAppendULongPattern</CODE></A></code> or 
<code><A HREF="vformat-x.html#vformatInsertULongPattern"><CODE>vformatInsertULongPattern</CODE></A></code> if the validity of the 
pattern strings is in question.
<P>
If no exception is raised by a call to this method, the format can
be used to determine the validity of arbitrary input strings as well 
as to generated the output form of an unsigned long integer value.
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_PATTERNS"><CODE>vformatSET_PATTERNS</CODE></A></CODE> to <CODE>format</CODE>.
For more information refer to sections: 

<ul>
<li><A HREF="vformat-x.html#vformatIsULongValid"><CODE>vformatIsULongValid</CODE></A>
<li><A HREF="vformat-x.html#vformatIsULongPartiallyValid"><CODE>vformatIsULongPartiallyValid</CODE></A>
<li><A HREF="vformat-x.html#vformatDetermineULongValidity"><CODE>vformatDetermineULongValidity</CODE></A>
</ul>
</DD></DL>
<P>
<A NAME="vformatSetULongSegmentAlignment"><HR><H4>vformatSetULongSegmentAlignment</H4></A>
<PRE>
        void <B>vformatSetULongSegmentAlignment</B>(
                vformatULongSegment * segment,
                int alignment);
</PRE>

<DL><DD>
The text alignment code can be one of:

<ul>
<li>vformatALIGN_LEFT
<li>vformatALIGN_RIGHT
<li>vformatALIGN_CENTER
</ul>

<P>
The default <code><A HREF="vformat-x.html#vformatULongSegment"><CODE>vformatULongSegment</CODE></A></code> class supports the ability to
specify color and text alignment. For example, to specify that a
<code><A HREF="vformat-x.html#vformatULongSegment"><CODE>vformatULongSegment</CODE></A></code> have a right-justified attribute, 
use the following pattern.

<Pre>
  "#,###}"  // right-justified ulong integer value
  "#,###{"  // left-
  "#,###|"  // center-
</Pre>

<P>
The segment's color and alignment attributes are not used by the 
<code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes, 
but are meant to be used by higher-level, user-interface constructs, 
such as a spreadsheet cell formatter or database form.
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_ALIGNMENT"><CODE>vformatSET_SEGMENT_ALIGNMENT</CODE></A></CODE> to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetULongSegmentColor"><HR><H4>vformatSetULongSegmentColor</H4></A>
<PRE>
        void <B>vformatSetULongSegmentColor</B>(
                vformatULongSegment * segment,
                vcolor * color);
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatULongSegment"><CODE>vformatULongSegment</CODE></A></code> class supports the ability 
to specify color and text alignment to be associated with a segment. 
For example, to specify that a <code><A HREF="vformat-x.html#vformatULongSegment"><CODE>vformatULongSegment</CODE></A></code> 
have a red color attribute, use the following pattern.

<Pre>
  "[red]#,###"
</Pre>

<P>
The segment's color and alignment attributes are not used by the 
<code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes, 
but are meant to be used by higher-level, user-interface constructs, 
such as a spreadsheet cell formatter or database form.
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_COLOR"><CODE>vformatSET_SEGMENT_COLOR</CODE></A></CODE> to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetULongSegmentPrefix"><HR><H4>vformatSetULongSegmentPrefix</H4></A>
<PRE>
        void <B>vformatSetULongSegmentPrefix</B>(
                vformatULongSegment * segment,
                const vchar * prefix);
</PRE>

<DL><DD>
Each number format segment can have an optional prefix and/or suffix string
that is literal text at the beginning of ending of a number segment pattern.
This literal text must be matched indentically by the input string for a
parsing operation to succeed. The literal text is also used when
constructing an output form of a given number value.
</DD></DL>
<P>
<A NAME="vformatSetULongSegmentScale"><HR><H4>vformatSetULongSegmentScale</H4></A>
<PRE>
        void <B>vformatSetULongSegmentScale</B>(
                vformatULongSegment * segment,
                long scale);
</PRE>

<DL><DD>
Sets the scale factor the segment uses for parsing and for conversion
of an unsigned long integer value to a string.
</DD></DL>
<P>
<A NAME="vformatSetULongSegmentString"><HR><H4>vformatSetULongSegmentString</H4></A>
<PRE>
        void <B>vformatSetULongSegmentString</B>(
                vformatULongSegment * segment,
                const vchar * string);
</PRE>

<DL><DD>
Represents one possible string form of an unsigned long integer value.
The method <code><A HREF="vformat-x.html#vformatParseULongSegmentPattern"><CODE>vformatParseULongSegmentPattern</CODE></A></code> is called 
and the segment can interpret the tokens that make up the pattern string then
generate any artifacts needed to match arbitrary input strings
against that pattern, or for creating an output representation of an unsigned
long integer value.
<P>
The default unsigned long integer format class first calls on the base segment
class to parse any color or alignment attribute codes from the pattern
string. The portion of the string that remains is assumed to include only
elements from the unsigned long format pattern language.
This method is implemented by sending the message
<CODE><A HREF="vformat-x.html#vformatSET_SEGMENT_STRING"><CODE>vformatSET_SEGMENT_STRING</CODE></A></CODE> to <CODE>segment</CODE>.
</DD></DL>
<P>
<A NAME="vformatSetULongSegmentSuffix"><HR><H4>vformatSetULongSegmentSuffix</H4></A>
<PRE>
        void <B>vformatSetULongSegmentSuffix</B>(
                vformatULongSegment * segment,
                const vchar * suffix);
</PRE>

<DL><DD>
Each number format segment can have an optional prefix and/or suffix string
that is literal text at the beginning or ending of a number segment pattern.
This literal text must be matched indentically by the input string for a
parsing operation to succeed. The literal text is also used when
constructing an output form of a given number value.
</DD></DL>
<P>
<A NAME="vformatStartup"><HR><H4>vformatStartup</H4></A>
<PRE>
        void <B>vformatStartup</B>();
</PRE>

<DL><DD>
Initializes the Format class. Has no effect if the Format
class is already initialized.
</DD></DL>
<P>
<A NAME="vformatStartupBoolean"><HR><H4>vformatStartupBoolean</H4></A>
<PRE>
        void <B>vformatStartupBoolean</B>();
</PRE>

<DL><DD>
Initializes the boolean Format class. Has no effect if the
boolean Format class is already initialized.
</DD></DL>
<P>
<A NAME="vformatStartupDate"><HR><H4>vformatStartupDate</H4></A>
<PRE>
        void <B>vformatStartupDate</B>();
</PRE>

<DL><DD>
Initializes the date Format class. Has no effect if
the date Format class is already initialized.
</DD></DL>
<P>
<A NAME="vformatStartupDouble"><HR><H4>vformatStartupDouble</H4></A>
<PRE>
        void <B>vformatStartupDouble</B>();
</PRE>

<DL><DD>
Initializes the double Format class. Has no effect if the
double Format class is already initialized.
</DD></DL>
<P>
<A NAME="vformatStartupLong"><HR><H4>vformatStartupLong</H4></A>
<PRE>
        void <B>vformatStartupLong</B>();
</PRE>

<DL><DD>
Initializes the long integer Format class. Has no effect
if the long integer format class is already initialized.
</DD></DL>
<P>
<A NAME="vformatStartupNumber"><HR><H4>vformatStartupNumber</H4></A>
<PRE>
        void <B>vformatStartupNumber</B>();
</PRE>

<DL><DD>
Initializes the number Format class. Has no effect if the
Number Format class is already initialized.
</DD></DL>
<P>
<A NAME="vformatStartupULong"><HR><H4>vformatStartupULong</H4></A>
<PRE>
        void <B>vformatStartupULong</B>();
</PRE>

<DL><DD>
Initializes the unsigned long integer Format class. Has
no effect if the unsigned long integer Format class is
already initialized.
</DD></DL>
<P>
<A NAME="vformatStore"><HR><H4>vformatStore</H4></A>
<PRE>
        void <B>vformatStore</B>(
                vformat * format,
                vresource res);
</PRE>

<DL><DD>
Writes the contents of the format <SAMP>format</SAMP> into
the resource <SAMP>res</SAMP>. The format can be
recovered from the resource at a later time (perhaps by
another program) with <CODE><A HREF="vformat-x.html#vformatLoad"><CODE>vformatLoad</CODE></A></CODE> or
<CODE>vformatLoadInit</CODE>. It generates
<CODE><A HREF="vobject-x.html#vobjectUnnamedClassException"><CODE>vobjectUnnamedClassException</CODE></A></CODE> if the format's
class is not named. This function is implemented by sending
the message <CODE>vobjectSTORE</CODE> to <SAMP>format</SAMP>.
 <P>
To store a format in a resource, first call
<CODE><A HREF="vresource-x.html#vresourceMake"><CODE>vresourceMake</CODE></A></CODE> to create an untyped resource in
the desired location, then call <CODE>vformatStore</CODE>
to write the format into the resource. For example:

<P>
<BLOCKQUOTE>
<PRE>

vformat *format;    /* contains a format */
<A HREF="vresource-x.html#vresource"><CODE>vresource</CODE></A> fileResource, formatResource;

fileResource   = <A HREF="vresource-x.html#vresourceOpenFile"><CODE>vresourceOpenFile</CODE></A>( ... );
formatResource = <A HREF="vresource-x.html#vresourceMake"><CODE>vresourceMake</CODE></A>(fileResource, 
                               <A HREF="vname-x.html#vnameInternGlobalLiteral"><CODE>vnameInternGlobalLiteral</CODE></A>("MyFormat"));

vformatStore(format, formatResource);
<A HREF="vresource-x.html#vresourceCloseFile"><CODE>vresourceCloseFile</CODE></A>(fileResource);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vformatStoreBoolean"><HR><H4>vformatStoreBoolean</H4></A>
<PRE>
        void <B>vformatStoreBoolean</B>(
                vformatBoolean * format,
                vresource res);
</PRE>

<DL><DD>
Writes the contents of the Boolean format <SAMP>format</SAMP>
into the resource <SAMP>res</SAMP>. The format can be
recovered from the resource at a later time (perhaps by
another program) with <CODE><A HREF="vformat-x.html#vformatLoadBoolean"><CODE>vformatLoadBoolean</CODE></A></CODE> or
<CODE>vformatLoadInitBoolean</CODE>. It generates
<CODE><A HREF="vobject-x.html#vobjectUnnamedClassException"><CODE>vobjectUnnamedClassException</CODE></A></CODE> if the format's
class is not named. This function is implemented by sending
the message <CODE>vobjectSTORE</CODE> to <SAMP>format</SAMP>.
<P>
To store a Boolean format in a resource, first call
<CODE><A HREF="vresource-x.html#vresourceMake"><CODE>vresourceMake</CODE></A></CODE> to create an untyped resource in
the desired location, then call <CODE>vformatStoreBoolean</CODE>
to write the format into the resource. For example:

<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A> *format;    /* contains a Boolean format */
<A HREF="vresource-x.html#vresource"><CODE>vresource</CODE></A> fileResource, formatResource;

fileResource   = <A HREF="vresource-x.html#vresourceOpenFile"><CODE>vresourceOpenFile</CODE></A>( ... );
formatResource = <A HREF="vresource-x.html#vresourceMake"><CODE>vresourceMake</CODE></A>(fileResource, 
                               <A HREF="vname-x.html#vnameInternGlobalLiteral"><CODE>vnameInternGlobalLiteral</CODE></A>("MyFormat"));

vformatStoreBoolean(format, formatResource);
<A HREF="vresource-x.html#vresourceCloseFile"><CODE>vresourceCloseFile</CODE></A>(fileResource);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vformatStoreDate"><HR><H4>vformatStoreDate</H4></A>
<PRE>
        void <B>vformatStoreDate</B>(
                vformatDate * format,
                vresource res);
</PRE>

<DL><DD>
Writes the contents of the date format <SAMP>format</SAMP>
into the resource <SAMP>res</SAMP>. The format can be
recovered from the resource at a later time (perhaps by
another program) with <CODE><A HREF="vformat-x.html#vformatLoadDate"><CODE>vformatLoadDate</CODE></A></CODE> or
<CODE>vformatLoadInitDate</CODE>. It generates
<CODE><A HREF="vobject-x.html#vobjectUnnamedClassException"><CODE>vobjectUnnamedClassException</CODE></A></CODE> if the format's
class is not named. This function is implemented by sending
the message <CODE>vobjectSTORE</CODE> to <SAMP>format</SAMP>.
<P>
To store a date format in a resource, first call
<CODE><A HREF="vresource-x.html#vresourceMake"><CODE>vresourceMake</CODE></A></CODE> to create an untyped resource in
the desired location, then call <CODE>vformatStoreDate</CODE>
to write the format into the resource. For example:

<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vformat-x.html#vformatDate"><CODE>vformatDate</CODE></A> *format;    /* contains a date format */
<A HREF="vresource-x.html#vresource"><CODE>vresource</CODE></A> fileResource, formatResource;

fileResource   = <A HREF="vresource-x.html#vresourceOpenFile"><CODE>vresourceOpenFile</CODE></A>( ... );
formatResource = <A HREF="vresource-x.html#vresourceMake"><CODE>vresourceMake</CODE></A>(fileResource, 
                               <A HREF="vname-x.html#vnameInternGlobalLiteral"><CODE>vnameInternGlobalLiteral</CODE></A>("MyFormat"));

vformatStoreDate(format, formatResource);
<A HREF="vresource-x.html#vresourceCloseFile"><CODE>vresourceCloseFile</CODE></A>(fileResource);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vformatStoreDouble"><HR><H4>vformatStoreDouble</H4></A>
<PRE>
        void <B>vformatStoreDouble</B>(
                vformatDouble * format,
                vresource res);
</PRE>

<DL><DD>
Writes the contents of the double format <SAMP>format</SAMP>
into the resource <SAMP>res</SAMP>. The format can be
recovered from the resource at a later time (perhaps by
another program) with <CODE><A HREF="vformat-x.html#vformatLoadDouble"><CODE>vformatLoadDouble</CODE></A></CODE> or
<CODE>vformatLoadInitDouble</CODE>. It generates
<CODE><A HREF="vobject-x.html#vobjectUnnamedClassException"><CODE>vobjectUnnamedClassException</CODE></A></CODE> if the format's
class is not named. This function is implemented by sending
the message <CODE>vobjectSTORE</CODE> to <SAMP>format</SAMP>.
<P>
To store a double format in a resource, first call
<CODE><A HREF="vresource-x.html#vresourceMake"><CODE>vresourceMake</CODE></A></CODE> to create an untyped resource in
the desired location, then call <CODE>vformatStoreDouble</CODE>
to write the format into the resource. For example:

<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vformat-x.html#vformatDouble"><CODE>vformatDouble</CODE></A> *format;    /* contains a double format */
<A HREF="vresource-x.html#vresource"><CODE>vresource</CODE></A> fileResource, formatResource;

fileResource   = <A HREF="vresource-x.html#vresourceOpenFile"><CODE>vresourceOpenFile</CODE></A>( ... );
formatResource = <A HREF="vresource-x.html#vresourceMake"><CODE>vresourceMake</CODE></A>(fileResource, 
                               <A HREF="vname-x.html#vnameInternGlobalLiteral"><CODE>vnameInternGlobalLiteral</CODE></A>("MyFormat"));

vformatStoreDouble(format, formatResource);
<A HREF="vresource-x.html#vresourceCloseFile"><CODE>vresourceCloseFile</CODE></A>(fileResource);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vformatStoreLong"><HR><H4>vformatStoreLong</H4></A>
<PRE>
        void <B>vformatStoreLong</B>(
                vformatLong * format,
                vresource res);
</PRE>

<DL><DD>
Writes the contents of the long integer format <SAMP>format</SAMP>
into the resource <SAMP>res</SAMP>. The format can be
recovered from the resource at a later time (perhaps by
another program) with <CODE><A HREF="vformat-x.html#vformatLoadLong"><CODE>vformatLoadLong</CODE></A></CODE> or
<CODE>vformatLoadInitLong</CODE>. It generates
<CODE><A HREF="vobject-x.html#vobjectUnnamedClassException"><CODE>vobjectUnnamedClassException</CODE></A></CODE> if the format's
class is not named. This function is implemented by sending
the message <CODE>vobjectSTORE</CODE> to <SAMP>format</SAMP>.
<P>
To store a long integer format in a resource, first call
<CODE><A HREF="vresource-x.html#vresourceMake"><CODE>vresourceMake</CODE></A></CODE> to create an untyped resource in
the desired location, then call <CODE>vformatStoreLong</CODE>
to write the format into the resource. For example:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vformat-x.html#vformatLong"><CODE>vformatLong</CODE></A> *format;    /* contains a long integer format */
<A HREF="vresource-x.html#vresource"><CODE>vresource</CODE></A> fileResource, formatResource;

fileResource   = <A HREF="vresource-x.html#vresourceOpenFile"><CODE>vresourceOpenFile</CODE></A>( ... );
formatResource = <A HREF="vresource-x.html#vresourceMake"><CODE>vresourceMake</CODE></A>(fileResource, 
                               <A HREF="vname-x.html#vnameInternGlobalLiteral"><CODE>vnameInternGlobalLiteral</CODE></A>("MyFormat"));

vformatStoreLong(format, formatResource);
<A HREF="vresource-x.html#vresourceCloseFile"><CODE>vresourceCloseFile</CODE></A>(fileResource);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vformatStoreNumber"><HR><H4>vformatStoreNumber</H4></A>
<PRE>
        void <B>vformatStoreNumber</B>(
                vformatNumber * format,
                vresource res);
</PRE>

<DL><DD>
Writes the contents of the number format <SAMP>format</SAMP>
into the resource <SAMP>res</SAMP>. The format can be
recovered from the resource at a later time (perhaps by
another program) with <CODE><A HREF="vformat-x.html#vformatLoadNumber"><CODE>vformatLoadNumber</CODE></A></CODE> or
<CODE>vformatLoadInitNumber</CODE>. It generates
<CODE><A HREF="vobject-x.html#vobjectUnnamedClassException"><CODE>vobjectUnnamedClassException</CODE></A></CODE> if the format's
class is not named. This function is implemented by sending
the message <CODE>vobjectSTORE</CODE> to <SAMP>format</SAMP>.
<P>
To store a number format in a resource, first call
<CODE><A HREF="vresource-x.html#vresourceMake"><CODE>vresourceMake</CODE></A></CODE> to create an untyped resource in
the desired location, then call <CODE>vformatStoreNumber</CODE>
to write the format into the resource. For example:

<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vformat-x.html#vformatNumber"><CODE>vformatNumber</CODE></A> *format;    /* contains a number format */
<A HREF="vresource-x.html#vresource"><CODE>vresource</CODE></A> fileResource, formatResource;

fileResource   = <A HREF="vresource-x.html#vresourceOpenFile"><CODE>vresourceOpenFile</CODE></A>( ... );
formatResource = <A HREF="vresource-x.html#vresourceMake"><CODE>vresourceMake</CODE></A>(fileResource, 
                               <A HREF="vname-x.html#vnameInternGlobalLiteral"><CODE>vnameInternGlobalLiteral</CODE></A>("MyFormat"));

vformatStoreNumber(format, formatResource);
<A HREF="vresource-x.html#vresourceCloseFile"><CODE>vresourceCloseFile</CODE></A>(fileResource);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vformatStoreULong"><HR><H4>vformatStoreULong</H4></A>
<PRE>
        void <B>vformatStoreULong</B>(
                vformatULong * format,
                vresource res);
</PRE>

<DL><DD>
Writes the contents of the unsigned long integer format
<SAMP>format</SAMP> into the resource <SAMP>res</SAMP>. The
format can be recovered from the resource at a later time
(perhaps by another program) with <CODE><A HREF="vformat-x.html#vformatLoadULong"><CODE>vformatLoadULong</CODE></A></CODE>
or <CODE>vformatLoadInitUlong</CODE>. It generates
<CODE><A HREF="vobject-x.html#vobjectUnnamedClassException"><CODE>vobjectUnnamedClassException</CODE></A></CODE> if the format's
class is not named. This function is implemented by sending
the message <CODE>vobjectSTORE</CODE> to <SAMP>format</SAMP>.
<P>
To store an unsigned long integer format in a resource, first call
<CODE><A HREF="vresource-x.html#vresourceMake"><CODE>vresourceMake</CODE></A></CODE> to create an untyped resource in
the desired location, then call <CODE>vformatStoreULong</CODE>
to write the format into the resource. For example:

<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vformat-x.html#vformatULong"><CODE>vformatULong</CODE></A> *format;    /* contains an unsigned long integer format */
<A HREF="vresource-x.html#vresource"><CODE>vresource</CODE></A> fileResource, formatResource;

fileResource   = <A HREF="vresource-x.html#vresourceOpenFile"><CODE>vresourceOpenFile</CODE></A>( ... );
formatResource = <A HREF="vresource-x.html#vresourceMake"><CODE>vresourceMake</CODE></A>(fileResource, 
                               <A HREF="vname-x.html#vnameInternGlobalLiteral"><CODE>vnameInternGlobalLiteral</CODE></A>("MyFormat"));

vformatStoreULong(format, formatResource);
<A HREF="vresource-x.html#vresourceCloseFile"><CODE>vresourceCloseFile</CODE></A>(fileResource);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="section_Message"><HR>
<CENTER><H2>Messages</H2></CENTER></A><P>
<A NAME="vformatDESTROY_PATTERN_AT"><HR><H4>vformatDESTROY_PATTERN_AT</H4></A>
<PRE>
        &lt;<B>vformatDESTROY_PATTERN_AT</B>&gt;
</PRE>

<DL><DD>
The specified pattern must exist in the format's ordered set of patterns
or Galaxy raises a <samp>BadArgument</samp> exception.
</DD></DL>
<P>
<A NAME="vformatDETERMINE_VALIDITY"><HR><H4>vformatDETERMINE_VALIDITY</H4></A>
<PRE>
        &lt;<B>vformatDETERMINE_VALIDITY</B>&gt;
</PRE>

<DL><DD>
The format returns an indication of the validity of the input string
with respect to its constituent patterns. Possible return values include:

<ul>
<li>vformatVALID
<li>vformatPARTIALLY_VALID
<li>vformatINVALID
</ul>

Invoking this message never raises an exception. It is  a 
convenience message that makes use of <samp>vformatIS_VALID</samp>
and <samp>vformatIS_PARTIALLY_VALID</samp>.
</DD></DL>
<P>
<A NAME="vformatDUMP_SEGMENT"><HR><H4>vformatDUMP_SEGMENT</H4></A>
<PRE>
        &lt;<B>vformatDUMP_SEGMENT</B>&gt;
</PRE>

<DL><DD>
This method can only be successfully used in a debug environment.
</DD></DL>
<P>
<A NAME="vformatINSERT_PATTERN_SCRIBED"><HR><H4>vformatINSERT_PATTERN_SCRIBED</H4></A>
<PRE>
        &lt;<B>vformatINSERT_PATTERN_SCRIBED</B>&gt;
</PRE>

<DL><DD>
The pattern scribe is first broken down into its constituent segment
strings, each segment string being seperated by the semi-colon
character (';'). <code>VformatSegments</code> of the proper type 
are created and assigned their strings by <code><A HREF="vformat-x.html#vformatSetSegmentString"><CODE>vformatSetSegmentString</CODE></A></code>. 
Then, each segment is called on to parse its string,
at which point the segment generates the artifacts needed to determine
the validity of an arbitrary input string with respect to its pattern.
Finally, if each segment successfully parses its pattern string, the
segment group is inserted at the specified location in the ordered set
of patterns. Refer to the section <code><A HREF="vformat-x.html#vformatParseSegment"><CODE>vformatParseSegment</CODE></A></code> for 
more information.
<P>
Galaxy throws a <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code> if any portion of the
pattern string is not understood by the format.
</DD></DL>
<P>
<A NAME="vformatLOAD_PATTERNS"><HR><H4>vformatLOAD_PATTERNS</H4></A>
<PRE>
        &lt;<B>vformatLOAD_PATTERNS</B>&gt;
</PRE>

<DL><DD>
The current set of patterns is first cleared. Next, the array resource
is converted into an array of pointers to string and used as an argument
to <code><A HREF="vformat-x.html#vformatSetPatterns"><CODE>vformatSetPatterns</CODE></A></code>. If any pattern string is not 
understood by the format, the temporary array of pointers to string 
is freed and Galaxy throws a <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatNUMBER_SEGMENT_DIGIT_SYMBOLS"><HR><H4>vformatNUMBER_SEGMENT_DIGIT_SYMBOLS</H4></A>
<PRE>
        &lt;<B>vformatNUMBER_SEGMENT_DIGIT_SYMBOLS</B>&gt;
</PRE>

<DL><DD>
These characters are used internally to help determine a match for a pattern
prefix or suffix. They constitute those characters that can be used to
specify the numeric content portion of the pattern. Subclasses of the 
numeric formats need to ensure that all characters used to
represent the numeric content portion of pattern are included in this string.
</DD></DL>
<P>
<A NAME="vformatPARSE_BOOLEAN"><HR><H4>vformatPARSE_BOOLEAN</H4></A>
<PRE>
        &lt;<B>vformatPARSE_BOOLEAN</B>&gt;
</PRE>

<DL><DD>
The input string is compared to each pattern segment string in turn: if a
match is found, the boolean value associated with the matching segment is
returned.
A <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code> is thrown if the input string was not fully
understood as determined by the information contained within at least one
of the format's pattern segments. Put another way, if at least a single
pattern segment is able to completely parse the input string and generate
a valid value, no exception is thrown. However, Galaxy throws an exception 
if the format is unable to convert the input string to a value.
</DD></DL>
<P>
<A NAME="vformatPARSE_DATE"><HR><H4>vformatPARSE_DATE</H4></A>
<PRE>
        &lt;<B>vformatPARSE_DATE</B>&gt;
</PRE>

<DL><DD>
Compares the input string to each pattern segment string in turn; if a
match is found, returns the date value associated with the matching segment.
Galaxy throws a <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code> if the input string 
is not fully understood as determined by the information contained 
within at least one of the format's pattern segments. No exception is thrown 
if at least a single pattern segment is able to completely parse 
the input string and generate a valid value. Galaxy throws an exception 
if the format is unable to convert the input string to a value.
</DD></DL>
<P>
<A NAME="vformatPARSE_DOUBLE"><HR><H4>vformatPARSE_DOUBLE</H4></A>
<PRE>
        &lt;<B>vformatPARSE_DOUBLE</B>&gt;
</PRE>

<DL><DD>
If the input in not understood by at least one of the format's pattern
segments, Galaxy throws a <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatPARSE_LONG"><HR><H4>vformatPARSE_LONG</H4></A>
<PRE>
        &lt;<B>vformatPARSE_LONG</B>&gt;
</PRE>

<DL><DD>
If the input in not understood by at least one of the format's pattern
segments, Galaxy throws a <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatPARSE_SEGMENT"><HR><H4>vformatPARSE_SEGMENT</H4></A>
<PRE>
        &lt;<B>vformatPARSE_SEGMENT</B>&gt;
</PRE>

<DL><DD>
This method is called by <code>vformat</code> after first decomposing the pattern
string into its constituent segment substrings, initializing a new
<code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> of the proper class as determined by
<code><A HREF="vformat-x.html#vformatGetSegmentClass"><CODE>vformatGetSegmentClass</CODE></A></code>, and assigning the segment's pattern string.
</DD></DL>
<P>
<A NAME="vformatPARSE_SEGMENT_PATTERN"><HR><H4>vformatPARSE_SEGMENT_PATTERN</H4></A>
<PRE>
        &lt;<B>vformatPARSE_SEGMENT_PATTERN</B>&gt;
</PRE>

<DL><DD>
This method is called by <code><A HREF="vformat-x.html#vformatParseSegment"><CODE>vformatParseSegment</CODE></A></code>. 
It scans its pattern string, beginning at the range's starting position,
creating the artifacts necessary to parse or convert a typed-value to string. 
If the segment finds an unrecognized character, it returns,
leaving <SAMP>range</SAMP> to specify that portion of the remaining input
left to be parsed.
<P>
This method may be called multiple times, as various levels of the class
hierarchy access each character. If no member of the particular format's
class hierarchy recognizes a given character, Galaxy raises a 
<code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code>. This exception specifies the 
offset of the first character that was not understood by the format segment.
</DD></DL>
<P>
<A NAME="vformatPARSE_ULONG"><HR><H4>vformatPARSE_ULONG</H4></A>
<PRE>
        &lt;<B>vformatPARSE_ULONG</B>&gt;
</PRE>

<DL><DD>
If the input in not understood by at least one of the format's pattern
segments, Galaxy throws a <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatSCRIBE_BOOLEAN"><HR><H4>vformatSCRIBE_BOOLEAN</H4></A>
<PRE>
        &lt;<B>vformatSCRIBE_BOOLEAN</B>&gt;
</PRE>

<DL><DD>
False values are generated using the "false" output pattern segment while true
values are generated from the "true" output pattern segment.
</DD></DL>
<P>
<A NAME="vformatSCRIBE_DATE"><HR><H4>vformatSCRIBE_DATE</H4></A>
<PRE>
        &lt;<B>vformatSCRIBE_DATE</B>&gt;
</PRE>

<DL><DD>
Calls on the format to create a scribed, string representation of the given
date <SAMP>value</SAMP> based on the format's current output pattern.
</DD></DL>
<P>
<A NAME="vformatSCRIBE_DOUBLE"><HR><H4>vformatSCRIBE_DOUBLE</H4></A>
<PRE>
        &lt;<B>vformatSCRIBE_DOUBLE</B>&gt;
</PRE>

<DL><DD>
Internally, the format determines the <code><A HREF="vformat-x.html#vformatDoubleSegment"><CODE>vformatDoubleSegment</CODE></A></code> 
that maps from the given double <SAMP>value</SAMP> by 
<code><A HREF="vformat-x.html#vformatGetDoubleOutputSegment"><CODE>vformatGetDoubleOutputSegment</CODE></A></code>. Format then uses 
that pattern information to create a string representation of
<SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vformatSCRIBE_LONG"><HR><H4>vformatSCRIBE_LONG</H4></A>
<PRE>
        &lt;<B>vformatSCRIBE_LONG</B>&gt;
</PRE>

<DL><DD>
Internally, the format determines the <CODE><A HREF="vformat-x.html#vformatLongSegment"><CODE>vformatLongSegment</CODE></A></code> 
that maps from the given long integer <SAMP>value</SAMP> by
<code><A HREF="vformat-x.html#vformatGetLongOutputSegment"><CODE>vformatGetLongOutputSegment</CODE></A></code>. Format then uses that 
pattern information to create
a string representation of <SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vformatSCRIBE_ULONG"><HR><H4>vformatSCRIBE_ULONG</H4></A>
<PRE>
        &lt;<B>vformatSCRIBE_ULONG</B>&gt;
</PRE>

<DL><DD>
Internally, the format determines the <code><A HREF="vformat-x.html#vformatULongSegment"><CODE>vformatULongSegment</CODE></A></code> 
that maps from the given unsigned long integer <SAMP>value</SAMP> by
<code>vformatGetUlongOutputSegment</code>, using that pattern 
information to create a string representation of <SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vformatSEGMENT_CLASS"><HR><H4>vformatSEGMENT_CLASS</H4></A>
<PRE>
        &lt;<B>vformatSEGMENT_CLASS</B>&gt;
</PRE>

<DL><DD>
When a format needs to add a new segment to its collection,
it instantiates a segment of this type.
</DD></DL>
<P>
<A NAME="vformatSEGMENT_COUNT"><HR><H4>vformatSEGMENT_COUNT</H4></A>
<PRE>
        &lt;<B>vformatSEGMENT_COUNT</B>&gt;
</PRE>

<DL><DD>
A <A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A> has two segments: the positive and the negative.
A <A HREF="vformat-x.html#vformatDouble"><CODE>vformatDouble</CODE></A> has three segments: the positive, negative, and zero.
This value is primarily used by the format segment iterators.
</DD></DL>
<P>
<A NAME="vformatSET_NUMBER_STRICT"><HR><H4>vformatSET_NUMBER_STRICT</H4></A>
<PRE>
        &lt;<B>vformatSET_NUMBER_STRICT</B>&gt;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatSET_OUTPUT_PATTERN_INDEX"><HR><H4>vformatSET_OUTPUT_PATTERN_INDEX</H4></A>
<PRE>
        &lt;<B>vformatSET_OUTPUT_PATTERN_INDEX</B>&gt;
</PRE>

<DL><DD>
Used to specify which pattern is used by calls to the parse
methods for generating output strings. The specified <SAMP>index</SAMP>
must be greater-than or equal to zero and less than the result of
calling <code><A HREF="vformat-x.html#vformatGetPatternCount"><CODE>vformatGetPatternCount</CODE></A></code>.
</DD></DL>
<P>
<A NAME="vformatSET_PATTERNS"><HR><H4>vformatSET_PATTERNS</H4></A>
<PRE>
        &lt;<B>vformatSET_PATTERNS</B>&gt;
</PRE>

<DL><DD>
A format consists, in part, of an ordered set of multi-segmented,
type-specific pattern strings. The natural number of segments that a
format pattern contains is determined by its type. For instance, the
<samp><A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A></samp> contains patterns made up of two segments: the
"positive" and the "negative."
This method first clears any existing patterns the format has.
Next, each pattern string is appended to the pattern set with a call
to <code><A HREF="vformat-x.html#vformat"><CODE>vformat</CODE></A></code>.
<P>
Galaxy raises a <code><A HREF="vformat-x.html#vformatParseException"><CODE>vformatParseException</CODE></A> </code> when the format is unable to
understand any portion of the pattern string; therefore, this method should be
called only if it is known that all of the pattern strings are valid. Use
<code><A HREF="vformat-x.html#vformat"><CODE>vformat</CODE></A></code> or <code><A HREF="vformat-x.html#vformat"><CODE>vformat</CODE></A></code> 
if the validity of the pattern strings is in question.
<P>
If no exception is raised by a call to this method, the format can
be used to determine the validity of arbitrary input strings 
as well as to generated the output form of a
typed-value by the Scribe methods. For more information, refer to sections:

<ul> 
<li><A HREF="vformat-x.html#vformat"><CODE>vformat</CODE></A>
<li><A HREF="vformat-x.html#vformat"><CODE>vformat</CODE></A>
<li><A HREF="vformat-x.html#vformat"><CODE>vformat</CODE></A>
</ul>
</DD></DL>
<P>
<A NAME="vformatSET_PATTERN_INDEX"><HR><H4>vformatSET_PATTERN_INDEX</H4></A>
<PRE>
        &lt;<B>vformatSET_PATTERN_INDEX</B>&gt;
</PRE>

<DL><DD>
Used to move an existing pattern to a new location
in the format's pattern set. Both <SAMP>oldIndex</SAMP> and
<SAMP>newIndex</SAMP> must be within the range of the existing pattern set.
</DD></DL>
<P>
<A NAME="vformatSET_SEGMENT_ALIGNMENT"><HR><H4>vformatSET_SEGMENT_ALIGNMENT</H4></A>
<PRE>
        &lt;<B>vformatSET_SEGMENT_ALIGNMENT</B>&gt;
</PRE>

<DL><DD>
The text alignment code can be:

<ul>
<li>vformatALIGN_LEFT
<li>vformatALIGN_RIGHT
<li>vformatALIGN_CENTER
</ul>

<P>
The default <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> class supports the ability to specify color
and textutal alignment. For example, to specify that a 
<code><A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A></code>'s "negative" segment have a right-justified 
attribute, use the pattern shown below.

<Pre>
  "true:}false"
</Pre>

The segment's color and alignment attributes are not used by the 
<code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes but are 
meant to be used by higher-level, user-interface constructs, 
such as a spreadsheet cell formatter, or database form.
</DD></DL>
<P>
<A NAME="vformatSET_SEGMENT_COLOR"><HR><H4>vformatSET_SEGMENT_COLOR</H4></A>
<PRE>
        &lt;<B>vformatSET_SEGMENT_COLOR</B>&gt;
</PRE>

<DL><DD>
The default <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> class supports the ability to specify color
and text alignment to be associated with a segment. For example, to
specify that a <code><A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A></code>'s "negative" segment have a red color
attribute, use the pattern below.

<Pre>
  "true:[red]false"
</Pre>

The segment's color and alignment attributes are not used by the 
<code>vformat</code> or <code><A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A></code> classes but are meant 
to be used by higher-level, user-interface constructs, such as a 
spreadsheet cell formatter or database form.
</DD></DL>
<P>
<A NAME="vformatSET_SEGMENT_STRING"><HR><H4>vformatSET_SEGMENT_STRING</H4></A>
<PRE>
        &lt;<B>vformatSET_SEGMENT_STRING</B>&gt;
</PRE>

<DL><DD>
Represents one possible state that a typed-value can have and is in the form
of a type-specific pattern language.
The method <code><A HREF="vformat-x.html#vformatParseSegmentPattern"><CODE>vformatParseSegmentPattern</CODE></A></code> is called 
and the segment interprets the tokens that 
make up the pattern string, generating
any artifacts needed to match arbitrary input strings against that
pattern, or for creating an output representation of some typed-value.
</DD></DL>
<P>
<A NAME="section_Constant"><HR>
<CENTER><H2>Constants</H2></CENTER></A><P>
<A NAME="vformatALIGN_CENTER"><HR><H4>vformatALIGN_CENTER</H4></A>
<PRE>
        <B>vformatALIGN_CENTER</B>
</PRE>

<DL><DD>
Format segment alignment attribute denoting that a string form of an
intrinic value should be displayed centered.
</DD></DL>
<P>
<A NAME="vformatALIGN_LEFT"><HR><H4>vformatALIGN_LEFT</H4></A>
<PRE>
        <B>vformatALIGN_LEFT</B>
</PRE>

<DL><DD>
Format segment alignment attribute denoting that a string form of an
intrinic value should be displayed left-aligned.
</DD></DL>
<P>
<A NAME="vformatALIGN_RIGHT"><HR><H4>vformatALIGN_RIGHT</H4></A>
<PRE>
        <B>vformatALIGN_RIGHT</B>
</PRE>

<DL><DD>
Format segment alignment attribute denoting that a string form of an
intrinic value should be displayed right-aligned.
</DD></DL>
<P>
<A NAME="vformatINCLUDED"><HR><H4>vformatINCLUDED</H4></A>
<PRE>
        <B>vformatINCLUDED</B>
</PRE>

<DL><DD>
Defined when the header file <SAMP>vformat.h</SAMP> is
included.
</DD></DL>
<P>
<A NAME="vformatINVALID"><HR><H4>vformatINVALID</H4></A>
<PRE>
        <B>vformatINVALID</B>
</PRE>

<DL><DD>
Symbol that may be returned from <code><A HREF="vformat-x.html#vformatDetermineValidity"><CODE>vformatDetermineValidity</CODE></A>>/code> 
that indicates the input string was considered invalid according to at 
least a single format segment pattern.
</DD></DL>
<P>
<A NAME="vformatPARTIALLY_VALID"><HR><H4>vformatPARTIALLY_VALID</H4></A>
<PRE>
        <B>vformatPARTIALLY_VALID</B>
</PRE>

<DL><DD>
Symbol that may be returned from <code><A HREF="vformat-x.html#vformatDetermineValidity"><CODE>vformatDetermineValidity</CODE></A></code> 
that indicates the input string was considered partially valid 
according to at least a single format segment pattern.
</DD></DL>
<P>
<A NAME="vformatVALID"><HR><H4>vformatVALID</H4></A>
<PRE>
        <B>vformatVALID</B>
</PRE>

<DL><DD>
Symbol that may be returned from <code><A HREF="vformat-x.html#vformatDetermineValidity"><CODE>vformatDetermineValidity</CODE></A></code> 
that indicates the input string was considered valid according to at 
least a single format segment pattern.
</DD></DL>
<P>
<A NAME="section_Macro"><HR>
<CENTER><H2>Macros</H2></CENTER></A><P>
<A NAME="vformatBOOLEAN_CLASS"><HR><H4>vformatBOOLEAN_CLASS</H4></A>
<PRE>
        #define <B>vformatBOOLEAN_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for the <A HREF="vformat-x.html#vformatBoolean"><CODE>vformatBoolean</CODE></A> class.
</DD></DL>
<P>
<A NAME="vformatBOOLEAN_SEGMENT_CLASS"><HR><H4>vformatBOOLEAN_SEGMENT_CLASS</H4></A>
<PRE>
        #define <B>vformatBOOLEAN_SEGMENT_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for the <A HREF="vformat-x.html#vformatBooleanSegment"><CODE>vformatBooleanSegment</CODE></A> class.
</DD></DL>
<P>
<A NAME="vformatCLASS"><HR><H4>vformatCLASS</H4></A>
<PRE>
        #define <B>vformatCLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for the vformat class.
</DD></DL>
<P>
<A NAME="vformatDATE_CLASS"><HR><H4>vformatDATE_CLASS</H4></A>
<PRE>
        #define <B>vformatDATE_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for the <A HREF="vformat-x.html#vformatDate"><CODE>vformatDate</CODE></A> class.
</DD></DL>
<P>
<A NAME="vformatDATE_SEGMENT_CLASS"><HR><H4>vformatDATE_SEGMENT_CLASS</H4></A>
<PRE>
        #define <B>vformatDATE_SEGMENT_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for the <A HREF="vformat-x.html#vformatDateSegment"><CODE>vformatDateSegment</CODE></A> class.
</DD></DL>
<P>
<A NAME="vformatDOUBLE_CLASS"><HR><H4>vformatDOUBLE_CLASS</H4></A>
<PRE>
        #define <B>vformatDOUBLE_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for the <A HREF="vformat-x.html#vformatDouble"><CODE>vformatDouble</CODE></A> class.
</DD></DL>
<P>
<A NAME="vformatDOUBLE_SEGMENT_CLASS"><HR><H4>vformatDOUBLE_SEGMENT_CLASS</H4></A>
<PRE>
        #define <B>vformatDOUBLE_SEGMENT_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for the <A HREF="vformat-x.html#vformatDoubleSegment"><CODE>vformatDoubleSegment</CODE></A> class.
</DD></DL>
<P>
<A NAME="vformatGetNumberSegmentClass"><HR><H4>vformatGetNumberSegmentClass</H4></A>
<PRE>
        #define <B>vformatGetNumberSegmentClass</B>(...) ...
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatGetSegmentFlags"><HR><H4>vformatGetSegmentFlags</H4></A>
<PRE>
        #define <B>vformatGetSegmentFlags</B>(...) ...
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatInitParseRangeOfClass"><HR><H4>vformatInitParseRangeOfClass</H4></A>
<PRE>
        #define <B>vformatInitParseRangeOfClass</B>(...) ...
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatInitSegmentOfClass"><HR><H4>vformatInitSegmentOfClass</H4></A>
<PRE>
        #define <B>vformatInitSegmentOfClass</B>(...) ...
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vformatLONG_CLASS"><HR><H4>vformatLONG_CLASS</H4></A>
<PRE>
        #define <B>vformatLONG_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for the <A HREF="vformat-x.html#vformatLong"><CODE>vformatLong</CODE></A> class.
</DD></DL>
<P>
<A NAME="vformatLONG_SEGMENT_CLASS"><HR><H4>vformatLONG_SEGMENT_CLASS</H4></A>
<PRE>
        #define <B>vformatLONG_SEGMENT_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for the <A HREF="vformat-x.html#vformatLongSegment"><CODE>vformatLongSegment</CODE></A> class.
</DD></DL>
<P>
<A NAME="vformatNUMBER_CLASS"><HR><H4>vformatNUMBER_CLASS</H4></A>
<PRE>
        #define <B>vformatNUMBER_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for the <A HREF="vformat-x.html#vformatNumber"><CODE>vformatNumber</CODE></A> class.
</DD></DL>
<P>
<A NAME="vformatNUMBER_SEGMENT_CLASS"><HR><H4>vformatNUMBER_SEGMENT_CLASS</H4></A>
<PRE>
        #define <B>vformatNUMBER_SEGMENT_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for the <A HREF="vformat-x.html#vformatNumberSegment"><CODE>vformatNumberSegment</CODE></A> class.
</DD></DL>
<P>
<A NAME="vformatPARSE_RANGE_CLASS"><HR><H4>vformatPARSE_RANGE_CLASS</H4></A>
<PRE>
        #define <B>vformatPARSE_RANGE_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for the <A HREF="vformat-x.html#vformatParseRange"><CODE>vformatParseRange</CODE></A> class.
</DD></DL>
<P>
<A NAME="vformatSEGMENT_CLASS"><HR><H4>vformatSEGMENT_CLASS</H4></A>
<PRE>
        #define <B>vformatSEGMENT_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for the <A HREF="vformat-x.html#vformatSegment"><CODE>vformatSegment</CODE></A> class.
</DD></DL>
<P>
<A NAME="vformatSEGMENT_ITERATOR_CLASS"><HR><H4>vformatSEGMENT_ITERATOR_CLASS</H4></A>
<PRE>
        #define <B>vformatSEGMENT_ITERATOR_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for the <A HREF="vformat-x.html#vformatSegmentIterator"><CODE>vformatSegmentIterator</CODE></A> class.
</DD></DL>
<P>
<A NAME="vformatULONG_CLASS"><HR><H4>vformatULONG_CLASS</H4></A>
<PRE>
        #define <B>vformatULONG_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for the <A HREF="vformat-x.html#vformatULong"><CODE>vformatULong</CODE></A> class.
</DD></DL>
<P>
<A NAME="vformatULONG_SEGMENT_CLASS"><HR><H4>vformatULONG_SEGMENT_CLASS</H4></A>
<PRE>
        #define <B>vformatULONG_SEGMENT_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for the <A HREF="vformat-x.html#vformatULongSegment"><CODE>vformatULongSegment</CODE></A> class.
</DD></DL>
<P>

<P>
<!--[[/CONTENT]]-->

<HR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">
		<TD>
		<CENTER>
<!--[[NAVIGATE_ICONIC]]-->
<!--[[/NAVIGATE_ICONIC]]-->
		</CENTER>
		</TD>
		    
		<TD>
		<BR>
		<FONT SIZE=-1>
	        <A HREF="#Top">Top of This Page</A> <BR>
	        <A HREF="index.html">Table of Contents</A> <BR>
		<A HREF="../index.html">Switch to Another Document</A><BR>
		<BR>
		</FONT>
		</TD>

		<TD>
		<BR>
		<FONT SIZE=-1>
		Need help?
		<A HREF="../contact-visix.html">
		Contact Visix</A>.
		<BR> <BR>
	        <A HREF="../copyright.html">Copyright &#169; 1996-97</A>,
		<A HREF="http://www.visix.com/">Visix Software Inc.</A><BR>
		<BR>
		</FONT>
		</TD>

	</TR>

</TABLE>
		
</BODY>
</HTML>



