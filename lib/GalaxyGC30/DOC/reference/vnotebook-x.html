<HTML>
  <HEAD>
<!--[[HEADING]]-->
<title>vnotebook prefix</title><!--[[/HEADING]]-->
  </HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<A NAME="Top"><IMG SRC="../graphics/trans.gif" WIDTH=2 HEIGHT=2></A><BR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">

		<TD>
		<CENTER>
		<A HREF="../index.html">
		<IMG SRC="../graphics/logo.gif" BORDER=0></A>
		</CENTER>
		</TD>

	        <TD VALIGN=TOP>
	        <BR><H1>
<!--[[TITLE]]-->
vnotebook prefix<!--[[/TITLE]]-->
	        </H1><BR>
		</TD>
      
	</TR>

</TABLE>

<HR>

<BR>

<!--[[PREAMBLE]]-->
<TABLE>
<TR>
<TD><A HREF="vnotebook-x.html#section_DataType">Types</A> [13]</TD>
<TD><A HREF="vnotebook-x.html#section_Function">Functions</A> [254]</TD>
<TD><A HREF="vnotebook-x.html#section_Message">Messages</A> [50]</TD>
<TD><A HREF="vnotebook-x.html#section_Constant">Constants</A> [14]</TD>
<TD><A HREF="vnotebook-x.html#section_Macro">Macros</A> [5]</TD>
</TR>
</TABLE>
<!--[[/PREAMBLE]]-->

<!--[[CONTENT]]-->

<P>
<A NAME="section_DataType"><HR>
<CENTER><H2>Types</H2></CENTER></A><P>
<A NAME="vnotebook"><HR><H4>vnotebook</H4></A>
<PRE>
        typedef ... <B>vnotebook</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a single
notebook. Objects of this type have classes derived from
<CODE><A HREF="vnotebook-x.html#vnotebookClass"><CODE>vnotebookClass</CODE></A></CODE>. Notebooks are referenced by a
pointer to this type. Notebooks can be created dynamically
with <CODE><A HREF="vnotebook-x.html#vnotebookCreate"><CODE>vnotebookCreate</CODE></A></CODE>, statically initialized
with <CODE><A HREF="vnotebook-x.html#vnotebookInit"><CODE>vnotebookInit</CODE></A></CODE>. Notebooks can be created
statically, dynamically or loaded from a resource. A
<CODE>vnotebook</CODE> is a subclass of a
<CODE><A HREF="vnotebook-x.html#vnotebookSection"><CODE>vnotebookSection</CODE></A></CODE>, which is a subclass of a
<CODE><A HREF="vnotebook-x.html#vnotebookPage"><CODE>vnotebookPage</CODE></A></CODE> which is subclassed from a
<CODE><A HREF="vcontainer-x.html#vcontainer"><CODE>vcontainer</CODE></A></CODE>. To set the contents of the notebook you
should only use the Notebook class's entry points. Refer
to the Notebook chapter of the <I>Galaxy
Programmer's Guide</I> for a
complete description of notebook attributes. All object
types with classes that directly inherit from
<CODE><A HREF="vnotebook-x.html#vnotebookClass"><CODE>vnotebookClass</CODE></A></CODE> <I>must</I> declare a
<CODE>vnotebook</CODE> as their first field so that
<CODE>vnotebook</CODE> pointers can be interchanged with pointers
to the new data type.
</DD></DL>
<P>
<A NAME="vnotebookClass"><HR><H4>vnotebookClass</H4></A>
<PRE>
        typedef ... <B>vnotebookClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vnotebook</CODE>. Classes declared with this type contain
the same set of methods and variables as the default
notebook class, but the behavior of the methods and the
contents of variables may vary. This class type is derived
from <CODE><A HREF="vnotebook-x.html#vnotebookSectionClass"><CODE>vnotebookSectionClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookNoteProc"><HR><H4>vnotebookNoteProc</H4></A>
<PRE>
        typedef ... <B>vnotebookNoteProc</B>;
</PRE>

<DL><DD>
Denotes a notification function that is called when a
notebook handles an event of some importance.
<SAMP>notebook</SAMP> is the notebook handling the event,
and <SAMP>event</SAMP> is the event being handled.
Importance is determined by the event handlers in the
notebook's class. The default notebook class gives no
notification. If additional notification is required, you
should override the appropriate handler.
</DD></DL>
<P>
<A NAME="vnotebookPage"><HR><H4>vnotebookPage</H4></A>
<PRE>
        typedef ... <B>vnotebookPage</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a single page.
Objects of this type have classes derived from
<CODE><A HREF="vnotebook-x.html#vnotebookPageClass"><CODE>vnotebookPageClass</CODE></A></CODE>. Pages are referenced by a
pointer to this type. Pages can be created dynamically with
<CODE><A HREF="vnotebook-x.html#vnotebookCreatePage"><CODE>vnotebookCreatePage</CODE></A></CODE>, or statically initialized with
<CODE><A HREF="vnotebook-x.html#vnotebookInitPage"><CODE>vnotebookInitPage</CODE></A></CODE>. Pages can also be loaded from a resource.
<p>
A <CODE>vnotebookPage</CODE> is subclassed from a
<CODE><A HREF="vcontainer-x.html#vcontainer"><CODE>vcontainer</CODE></A></CODE>. To set the contents of the page you
should retrieve the container and use the container's entry points.
Refer to the Notebook chapter of the <I>Galaxy
Programmer's Guide</I> for a
complete description of page attributes. All object types
with classes that directly inherit from
<CODE><A HREF="vnotebook-x.html#vnotebookPageClass"><CODE>vnotebookPageClass</CODE></A></CODE> <I>must</I> declare a
<CODE>vnotebookPage</CODE> as their first field so that
<CODE>vnotebookPage</CODE> pointers can be interchanged with
pointers to the new data type.
</DD></DL>
<P>
<A NAME="vnotebookPageClass"><HR><H4>vnotebookPageClass</H4></A>
<PRE>
        typedef ... <B>vnotebookPageClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vnotebookPage</CODE>. Classes declared with this type
contain the same set of methods and variables as the
default page class, but the behavior of the methods and the
contents of variables may vary. This class type is derived
from <CODE><A HREF="vcontainer-x.html#vcontainerClass"><CODE>vcontainerClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookPageNoteProc"><HR><H4>vnotebookPageNoteProc</H4></A>
<PRE>
        typedef ... <B>vnotebookPageNoteProc</B>;
</PRE>

<DL><DD>
Denotes a notification function that is called when a page
handles an event of some importance. <SAMP>page</SAMP> is
the page handling the event, and <SAMP>event</SAMP> is the
event being handled. Importance is determined by the event
handlers in the page's class. The default page class gives
no notification. If additional notification is required,
you should override the appropriate handler.
</DD></DL>
<P>
<A NAME="vnotebookSection"><HR><H4>vnotebookSection</H4></A>
<PRE>
        typedef ... <B>vnotebookSection</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a single
section. Objects of this type have classes derived from
<CODE><A HREF="vnotebook-x.html#vnotebookSectionClass"><CODE>vnotebookSectionClass</CODE></A></CODE>. Sections are referenced by a
pointer to this type. Sections can be created dynamically
with <CODE><A HREF="vnotebook-x.html#vnotebookCreateSection"><CODE>vnotebookCreateSection</CODE></A></CODE>, statically initialized
with <CODE><A HREF="vnotebook-x.html#vnotebookInitSection"><CODE>vnotebookInitSection</CODE></A></CODE>. Sections can be created
statically, dynamically or loaded from a resource. A
<CODE>vnotebookSection</CODE> is subclassed from a
<CODE><A HREF="vnotebook-x.html#vnotebookPage"><CODE>vnotebookPage</CODE></A></CODE>. Refer to the Notebook
chapter of the <I>Galaxy
Programmer's Guide</I> for a complete description of
section attributes. All object types with classes that
directly inherit from <CODE><A HREF="vnotebook-x.html#vnotebookSectionClass"><CODE>vnotebookSectionClass</CODE></A></CODE>
<I>must</I> declare a <CODE>vnotebookSection</CODE> as their
first field so that <CODE>vnotebookSection</CODE> pointers can be
interchanged with pointers to the new data type.
</DD></DL>
<P>
<A NAME="vnotebookSectionClass"><HR><H4>vnotebookSectionClass</H4></A>
<PRE>
        typedef ... <B>vnotebookSectionClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vnotebookSection</CODE>. Classes declared with this type
contain the same set of methods and variables as the
default section class, but the behavior of the methods and
the contents of variables may vary. This class type is
derived from <CODE><A HREF="vnotebook-x.html#vnotebookPageClass"><CODE>vnotebookPageClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookSectionNoteProc"><HR><H4>vnotebookSectionNoteProc</H4></A>
<PRE>
        typedef ... <B>vnotebookSectionNoteProc</B>;
</PRE>

<DL><DD>
Denotes a notification function that is called when a
section handles an event of some importance.
<SAMP>section</SAMP> is the section handling the event, and
<SAMP>event</SAMP> is the event being handled. Importance
is determined by the event handlers in the section's class.
The default section class gives no notification. If
additional notification is required, you should override
the appropriate handler.
</DD></DL>
<P>
<A NAME="vnotebookStyle"><HR><H4>vnotebookStyle</H4></A>
<PRE>
        typedef ... <B>vnotebookStyle</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a single
style. Styles can be created dynamically with
<CODE><A HREF="vnotebook-x.html#vnotebookCreateStyle"><CODE>vnotebookCreateStyle</CODE></A></CODE>, statically initialized with
<CODE><A HREF="vnotebook-x.html#vnotebookInitStyle"><CODE>vnotebookInitStyle</CODE></A></CODE>. Styles can be created
statically, dynamically or loaded from a resource. A
<CODE>vnotebookStyle</CODE> is a series of flags, defaults and
attributes. Refer to the Notebook chapter of the
<I>Galaxy Programmer's Guide</I>
for a complete description of style attributes. All object
types with classes that directly inherit from
<CODE><A HREF="vnotebook-x.html#vnotebookStyleClass"><CODE>vnotebookStyleClass</CODE></A></CODE> <I>must</I> declare a
<CODE>vnotebookStyle</CODE> as their first field so that
<CODE>vnotebookStyle</CODE> pointers can be interchanged with
pointers to the new data type.
</DD></DL>
<P>
<A NAME="vnotebookStyleClass"><HR><H4>vnotebookStyleClass</H4></A>
<PRE>
        typedef ... <B>vnotebookStyleClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vnotebookStyle</CODE>. Classes declared with this type
contain the same set of methods and variables as the
default style class, but the behavior of the methods  and
the contents of variables may vary. This class type is
derived from <CODE><A HREF="vobject-x.html#vobject"><CODE>vobject</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookTab"><HR><H4>vnotebookTab</H4></A>
<PRE>
        typedef ... <B>vnotebookTab</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a single Tab.
Objects of this type have classes derived from
<CODE><A HREF="vnotebook-x.html#vnotebookTabClass"><CODE>vnotebookTabClass</CODE></A></CODE>. Tabs are referenced by a pointer
to this type. Tabs can be created dynamically with
<CODE>vnotebookCreatetab</CODE>, statically initialized with
<CODE><A HREF="vnotebook-x.html#vnotebookInitTab"><CODE>vnotebookInitTab</CODE></A></CODE>, or loaded from a resource.
<p>
A <CODE>vnotebookTab</CODE> is subclassed from a
<CODE><A HREF="vdialog-x.html#vdialogItem"><CODE>vdialogItem</CODE></A></CODE>. To set the contents of the tab you
should retrieve the item and use its entry points. Refer to
the Notebook chapter of the <I>Galaxy
Programmer's Guide</I> for a complete
description of tab attributes. All object types with
classes that directly inherit from <CODE><A HREF="vnotebook-x.html#vnotebookTabClass"><CODE>vnotebookTabClass</CODE></A></CODE>
<I>must</I> declare a <CODE>vnotebookTab</CODE> as their first
field so that <CODE>vnotebookTab</CODE> pointers can be
interchanged with pointers to the new data type.
</DD></DL>
<P>
<A NAME="vnotebookTabClass"><HR><H4>vnotebookTabClass</H4></A>
<PRE>
        typedef ... <B>vnotebookTabClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vnotebookTab</CODE>. Classes declared with this type
contain the same set of methods and variables as the
default tab class, but the behavior of the methods and the
contents of variables may vary. This class type is derived
from <CODE><A HREF="vdialog-x.html#vdialogItemClass"><CODE>vdialogItemClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="section_Function"><HR>
<CENTER><H2>Functions</H2></CENTER></A><P>
<A NAME="vnotebookAddTabSetTab"><HR><H4>vnotebookAddTabSetTab</H4></A>
<PRE>
        void <B>vnotebookAddTabSetTab</B>(
                vnotebook * notebook,
                vdialogItem * tabset,
                vnotebookTab * tab);
</PRE>

<DL><DD>
Adds the tab <SAMP>tab</SAMP> to the tabset
<SAMP>tabset</SAMP> for the notebook <SAMP>notebook</SAMP>.
This function is normally called internal to the Notebook
class and should not be used as the standard method for
adding a tab to a tabset. When a page is added to a
notebook, the tab associated with the page is automatically
added to the tabset when it sends a
<CODE><A HREF="vnotebook-x.html#vnotebookRECALC_TABSET_TABS"><CODE>vnotebookRECALC_TABSET_TABS</CODE></A></CODE>. This method is implemented
by sending a <CODE><A HREF="vnotebook-x.html#vnotebookADD_TABSET_TAB"><CODE>vnotebookADD_TABSET_TAB</CODE></A></CODE> message
to the notebook. The tabset does not take ownership of the
tab. The page that owns the tab is responsible for
destroying it.
</DD></DL>
<P>
<A NAME="vnotebookAppendPage"><HR><H4>vnotebookAppendPage</H4></A>
<PRE>
        void <B>vnotebookAppendPage</B>(
                vnotebook * notebook,
                vnotebookPage * page);
</PRE>

<DL><DD>
Adds the page <SAMP>page</SAMP> to the notebook
<SAMP>notebook</SAMP>. It adds the page to the end of the main
notebook section. The position of the page can be changed
with <CODE><A HREF="vnotebook-x.html#vnotebookSetPageIndex"><CODE>vnotebookSetPageIndex</CODE></A></CODE>. The notebook will
take ownership of the page and the Notebook class is
responsible for reclaiming any allocated memory for the
page.
</DD></DL>
<P>
<A NAME="vnotebookAppendSectionPage"><HR><H4>vnotebookAppendSectionPage</H4></A>
<PRE>
        void <B>vnotebookAppendSectionPage</B>(
                vnotebookSection * section,
                vnotebookPage * Page);
</PRE>

<DL><DD>
Adds the page <SAMP>page</SAMP> to the end of the
section <SAMP>section</SAMP>. The position of the page can
be changed with <CODE><A HREF="vnotebook-x.html#vnotebookSetSectionPageIndex"><CODE>vnotebookSetSectionPageIndex</CODE></A></CODE>.
The section will take ownership of the page making
Notebook class responsible for reclaiming any
allocated memory for the page.
</DD></DL>
<P>
<A NAME="vnotebookCalcFolioRect"><HR><H4>vnotebookCalcFolioRect</H4></A>
<PRE>
        void <B>vnotebookCalcFolioRect</B>(
                vnotebook * notebook,
                vrect * rect);
</PRE>

<DL><DD>
Calculates the size and position of the folio rect
associated with the notebook <SAMP>notebook</SAMP>. It then
calls <CODE><A HREF="vrect-x.html#vrectSet"><CODE>vrectSet</CODE></A></CODE> with the proper size and
coordinates. This will store the calculated rect in
<SAMP>rect</SAMP>. This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookCALC_FOLIO_RECT"><CODE>vnotebookCALC_FOLIO_RECT</CODE></A></CODE> message to the
notebook.
</DD></DL>
<P>
<A NAME="vnotebookCalcPageButtonRects"><HR><H4>vnotebookCalcPageButtonRects</H4></A>
<PRE>
        void <B>vnotebookCalcPageButtonRects</B>(
                vnotebook * notebook,
                vrect * nextRect,
                vrect * prevRect);
</PRE>

<DL><DD>
Calculates the size and position of the bounding rects for
the page buttons associated with the notebook
<SAMP>notebook</SAMP>. It then calls <CODE><A HREF="vrect-x.html#vrectSet"><CODE>vrectSet</CODE></A></CODE> with
the proper size and coordinates for each page button. The
previous page button rect will be stored in
<SAMP>prevRect</SAMP> and the next page button rect will be
stored in <SAMP>nextRect</SAMP>. This function is
implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookCALC_PAGE_BUTTON_RECTS"><CODE>vnotebookCALC_PAGE_BUTTON_RECTS</CODE></A></CODE> message to the
notebook.
</DD></DL>
<P>
<A NAME="vnotebookCalcPageContentRect"><HR><H4>vnotebookCalcPageContentRect</H4></A>
<PRE>
        void <B>vnotebookCalcPageContentRect</B>(
                vnotebookPage * page,
                vrect * rect);
</PRE>

<DL><DD>
Calculates the size and position of the content rect for
the page <SAMP>page</SAMP>. The newly calculated content
rect is returned in <SAMP>rect</SAMP>. This method is implemented by
sending a <CODE><A HREF="vnotebook-x.html#vnotebookCALC_PAGE_CONTENT_RECT"><CODE>vnotebookCALC_PAGE_CONTENT_RECT</CODE></A></CODE>
message to the page.
</DD></DL>
<P>
<A NAME="vnotebookCalcPageRect"><HR><H4>vnotebookCalcPageRect</H4></A>
<PRE>
        void <B>vnotebookCalcPageRect</B>(
                vnotebook * notebook,
                vrect * rect);
</PRE>

<DL><DD>
Calculates the size and position of the page rect for the
notebook <SAMP>notebook</SAMP>. It calls
<CODE><A HREF="vrect-x.html#vrectSet"><CODE>vrectSet</CODE></A></CODE> with the size and coordinates. This
will store the page rect in <SAMP>rect</SAMP>. This method
is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookCALC_PAGE_RECT"><CODE>vnotebookCALC_PAGE_RECT</CODE></A></CODE> message to the
notebook.
</DD></DL>
<P>
<A NAME="vnotebookCalcPageRectAt"><HR><H4>vnotebookCalcPageRectAt</H4></A>
<PRE>
        void <B>vnotebookCalcPageRectAt</B>(
                vnotebook * notebook,
                int page,
                vrect * rect);
</PRE>

<DL><DD>
Calculates a new size and position based on the page rect
of the notebook <SAMP>notebook</SAMP>. The new offset
values will be the previous offset values multiplied by
<SAMP>page</SAMP>. This is accomplished in a call to
<CODE><A HREF="vrect-x.html#vrectOffset"><CODE>vrectOffset</CODE></A></CODE>. This will store the calculated
rect in <SAMP>rect</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookCalcSectionPageNumbers"><HR><H4>vnotebookCalcSectionPageNumbers</H4></A>
<PRE>
        int <B>vnotebookCalcSectionPageNumbers</B>(
                vnotebookSection * section,
                int start);
</PRE>

<DL><DD>
Calculates the page numbers in the section
<SAMP>section</SAMP> with start as the initial page number in the
section. It returns the start page number for the next
section or page.
</DD></DL>
<P>
<A NAME="vnotebookCalcTabSetRect"><HR><H4>vnotebookCalcTabSetRect</H4></A>
<PRE>
        void <B>vnotebookCalcTabSetRect</B>(
                vnotebook * notebook,
                vdialogItem * tabset,
                vrect * rect);
</PRE>

<DL><DD>
Calculates the size and position of the tabset rect for the
tabset <SAMP>tabset</SAMP> of the notebook
<SAMP>notebook</SAMP>. It calls <CODE><A HREF="vrect-x.html#vrectSet"><CODE>vrectSet</CODE></A></CODE> with the
proper size and coordinates. This will store the tabset
rect in <SAMP>rect</SAMP>. This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookCALC_TABSET_RECT"><CODE>vnotebookCALC_TABSET_RECT</CODE></A> </CODE>message to the
notebook.
</DD></DL>
<P>
<A NAME="vnotebookCalcTabSetTabRect"><HR><H4>vnotebookCalcTabSetTabRect</H4></A>
<PRE>
        void <B>vnotebookCalcTabSetTabRect</B>(
                vnotebook * notebook,
                vdialogItem * tabset,
                vnotebookTab * tab,
                vrect * rect);
</PRE>

<DL><DD>
Calculates the size and position of the tab rect for the
tab <SAMP>tab</SAMP> inside the tabset <SAMP>tabset</SAMP>
for the notebook <SAMP>notebook</SAMP>. It calls
<CODE><A HREF="vrect-x.html#vrectSet"><CODE>vrectSet</CODE></A></CODE> with the proper size and coordinates.
This will store the tab rect in <SAMP>rect</SAMP>. This method
is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookCALC_TABSET_TAB_RECT"><CODE>vnotebookCALC_TABSET_TAB_RECT</CODE></A></CODE> message to the
notebook.
</DD></DL>
<P>
<A NAME="vnotebookChangedStyle"><HR><H4>vnotebookChangedStyle</H4></A>
<PRE>
        void <B>vnotebookChangedStyle</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Indicates that the style for the notebook
<SAMP>notebook</SAMP> has changed. It re-determines all styles
and sets the necessary flags. This method is implemented by sending
a <CODE><A HREF="vnotebook-x.html#vnotebookCHANGED_STYLE"><CODE>vnotebookCHANGED_STYLE</CODE></A></CODE> message to the
notebook.
</DD></DL>
<P>
<A NAME="vnotebookClone"><HR><H4>vnotebookClone</H4></A>
<PRE>
        vnotebook * <B>vnotebookClone</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Creates a copy of the notebook <SAMP>notebook</SAMP> and
returns a pointer to its contents. It makes a call to
<CODE><A HREF="vdialog-x.html#vdialogCloneItem"><CODE>vdialogCloneItem</CODE></A></CODE> which allocates the storage,
copies it, and then it is cast as a notebook. The storage
will be reclaimed when <CODE><A HREF="vnotebook-x.html#vnotebookDestroy"><CODE>vnotebookDestroy</CODE></A></CODE> is
called on the notebook.
</DD></DL>
<P>
<A NAME="vnotebookClonePage"><HR><H4>vnotebookClonePage</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookClonePage</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Creates a copy of the page <SAMP>page</SAMP> and returns a
pointer to its contents. It makes a call to
<CODE><A HREF="vdialog-x.html#vdialogCloneItem"><CODE>vdialogCloneItem</CODE></A></CODE> which allocates the storage,
copies it, then it is cast as a page. The storage will be
reclaimed when <CODE><A HREF="vnotebook-x.html#vnotebookDestroyPage"><CODE>vnotebookDestroyPage</CODE></A></CODE> is called
on the page.
</DD></DL>
<P>
<A NAME="vnotebookCloneSection"><HR><H4>vnotebookCloneSection</H4></A>
<PRE>
        vnotebook * <B>vnotebookCloneSection</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Creates a copy of the section <SAMP>section</SAMP> and
returns a pointer to its contents. It makes a call to
<CODE><A HREF="vdialog-x.html#vdialogCloneItem"><CODE>vdialogCloneItem</CODE></A></CODE> which allocates the storage,
copies it, and then it is cast as a section. The storage
will be reclaimed when <CODE><A HREF="vnotebook-x.html#vnotebookDestroySection"><CODE>vnotebookDestroySection</CODE></A></CODE>
is called on the section.
</DD></DL>
<P>
<A NAME="vnotebookCloneStyle"><HR><H4>vnotebookCloneStyle</H4></A>
<PRE>
        vnotebookStyle * <B>vnotebookCloneStyle</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Creates a copy of the style <SAMP>style</SAMP> and returns
a pointer to its contents. It makes a call to
<CODE><A HREF="vobject-x.html#vobjectClone"><CODE>vobjectClone</CODE></A></CODE> which allocates the storage,
copies it, then it is cast as a style. The storage will be
reclaimed when <CODE><A HREF="vnotebook-x.html#vnotebookDestroyStyle"><CODE>vnotebookDestroyStyle</CODE></A></CODE> is called
on the style.
</DD></DL>
<P>
<A NAME="vnotebookCloneTab"><HR><H4>vnotebookCloneTab</H4></A>
<PRE>
        vnotebookTab * <B>vnotebookCloneTab</B>(
                vnotebookTab * tab);
</PRE>

<DL><DD>
Creates a copy of the tab <SAMP>tab</SAMP> and returns a
pointer to its contents. It makes a call to
<CODE><A HREF="vdialog-x.html#vdialogCloneItem"><CODE>vdialogCloneItem</CODE></A></CODE> which allocates the storage,
copies it, and then it is cast as a tab. The storage will
be reclaimed when <CODE><A HREF="vnotebook-x.html#vnotebookDestroyTab"><CODE>vnotebookDestroyTab</CODE></A></CODE> is
called on the tab.
</DD></DL>
<P>
<A NAME="vnotebookCopy"><HR><H4>vnotebookCopy</H4></A>
<PRE>
        void <B>vnotebookCopy</B>(
                vnotebook * src,
                vnotebook * dest);
</PRE>

<DL><DD>
Copies the information in <SAMP>src</SAMP> into
<SAMP>dest</SAMP> so that the two notebooks represent
equivalent objects. <SAMP>dest</SAMP> must have been
created or initialized by a Notebook class function. This
function is implemented by sending a <CODE>vobjectCOPY</CODE>
message to <SAMP>src</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookCopyInit"><HR><H4>vnotebookCopyInit</H4></A>
<PRE>
        void <B>vnotebookCopyInit</B>(
                vnotebook * src,
                vnotebook * dest);
</PRE>

<DL><DD>
Copies the information in <SAMP>src</SAMP> into
<SAMP>dest</SAMP> so that the two notebooks represent
equivalent objects. <SAMP>dest</SAMP> will first be
initialized by the Notebook class. This function is
implemented by sending a <CODE>vobjectCOPY_INIT</CODE> message to
<SAMP>src</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookCopyInitPage"><HR><H4>vnotebookCopyInitPage</H4></A>
<PRE>
        void <B>vnotebookCopyInitPage</B>(
                vnotebookPage * src,
                vnotebookPage * dest);
</PRE>

<DL><DD>
Copies the information in <SAMP>src</SAMP> into
<SAMP>dest</SAMP> so that the two pages represent
equivalent objects. <SAMP>dest</SAMP> must will first be
initialized by the Notebook class. This function is
implemented by sending a <CODE>vobjectCOPY_INIT</CODE>
message to <SAMP>src</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookCopyInitSection"><HR><H4>vnotebookCopyInitSection</H4></A>
<PRE>
        void <B>vnotebookCopyInitSection</B>(
                vnotebookSection * src,
                vnotebookSection * dest);
</PRE>

<DL><DD>
Copies the information in <SAMP>src</SAMP> into
<SAMP>dest</SAMP> so that the two sections represent
equivalent objects. <SAMP>dest</SAMP> will first be
initialized by the Notebook class. This function is
implemented by sending a <CODE>vobjectCOPY_INIT</CODE>
message to <SAMP>src</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookCopyInitStyle"><HR><H4>vnotebookCopyInitStyle</H4></A>
<PRE>
        void <B>vnotebookCopyInitStyle</B>(
                vnotebookStyle * src,
                vnotebookStyle * dest);
</PRE>

<DL><DD>
Copies the information in <SAMP>src</SAMP> into
<SAMP>dest</SAMP> so that the two styles represent
equivalent objects. <SAMP>dest</SAMP> must will first be
initialized by the Notebook class. This function is
implemented by sending a <CODE>vobjectCOPY_INIT</CODE>
message to <SAMP>src</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookCopyInitTab"><HR><H4>vnotebookCopyInitTab</H4></A>
<PRE>
        void <B>vnotebookCopyInitTab</B>(
                vnotebookTab * src,
                vnotebookTab * dest);
</PRE>

<DL><DD>
Copies the information in <SAMP>src</SAMP> into
<SAMP>dest</SAMP> so that the two tabs represent equivalent
objects. <SAMP>dest</SAMP> will first be initialized by the
Notebook class. This function is implemented by sending a
<CODE>vobjectCOPY_INIT</CODE> message to <SAMP>src</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookCopyPage"><HR><H4>vnotebookCopyPage</H4></A>
<PRE>
        void <B>vnotebookCopyPage</B>(
                vnotebookPage * src,
                vnotebookPage * dest);
</PRE>

<DL><DD>
Copies the information in <SAMP>src</SAMP> into
<SAMP>dest</SAMP> so that the two pages represent
equivalent objects. <SAMP>dest</SAMP> must have been
created or initialized by a Notebook class function. This
function is implemented by sending a
<CODE>vobjectCOPY</CODE> message to <SAMP>src</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookCopySection"><HR><H4>vnotebookCopySection</H4></A>
<PRE>
        void <B>vnotebookCopySection</B>(
                vnotebookSection * src,
                vnotebookSection * dest);
</PRE>

<DL><DD>
Copies the information in <SAMP>src</SAMP> into
<SAMP>dest</SAMP> so that the two sections represent
equivalent objects. <SAMP>dest</SAMP> must have been
created or initialized by a Notebook class function. This
function is implemented by sending a
<CODE>vobjectCOPY</CODE> message to <SAMP>src</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookCopyStyle"><HR><H4>vnotebookCopyStyle</H4></A>
<PRE>
        void <B>vnotebookCopyStyle</B>(
                vnotebookStyle * src,
                vnotebookStyle * dest);
</PRE>

<DL><DD>
Copies the information in <SAMP>src</SAMP> into
<SAMP>dest</SAMP> so that the two styles represent
equivalent objects. <SAMP>dest</SAMP> must have been
created or initialized by a Notebook class function.
</DD></DL>
<P>
<A NAME="vnotebookCopyTab"><HR><H4>vnotebookCopyTab</H4></A>
<PRE>
        void <B>vnotebookCopyTab</B>(
                vnotebookTab * src,
                vnotebookTab * dest);
</PRE>

<DL><DD>
Copies the information in <SAMP>src</SAMP> into
<SAMP>dest</SAMP> so that the two tabs represent equivalent
objects. <SAMP>dest</SAMP> must have been created or
initialized by a Notebook class function. This function
is implemented by sending a <CODE>vobjectCOPY</CODE>
message to <SAMP>src</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookCreate"><HR><H4>vnotebookCreate</H4></A>
<PRE>
        vnotebook * <B>vnotebookCreate</B>();
</PRE>

<DL><DD>
Creates a new notebook of the default notebook class and
returns a pointer to its contents. This method is implemented by
calling <CODE><A HREF="vnotebook-x.html#vnotebookCreateOfClass"><CODE>vnotebookCreateOfClass</CODE></A></CODE> with the
default notebook class. The Notebook class will reclaim
the storage occupied by the notebook when
<CODE><A HREF="vnotebook-x.html#vnotebookDestroy"><CODE>vnotebookDestroy</CODE></A></CODE> is called.
</DD></DL>
<P>
<A NAME="vnotebookCreateOfClass"><HR><H4>vnotebookCreateOfClass</H4></A>
<PRE>
        vnotebook * <B>vnotebookCreateOfClass</B>(
                vnotebookClass * clas);
</PRE>

<DL><DD>
Creates a new notebook of the class <SAMP>clas</SAMP> and
returns a pointer to its contents. This method is implemented by
calling <CODE><A HREF="vdialog-x.html#vdialogCreateItemOfClass"><CODE>vdialogCreateItemOfClass</CODE></A></CODE> with the
appropriate item class to create a notebook. The Notebook
class will reclaim the storage occupied by the notebook
when <CODE><A HREF="vnotebook-x.html#vnotebookDestroy"><CODE>vnotebookDestroy</CODE></A></CODE> is called.
</DD></DL>
<P>
<A NAME="vnotebookCreatePage"><HR><H4>vnotebookCreatePage</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookCreatePage</B>();
</PRE>

<DL><DD>
Creates a new page of the default page class and returns a
pointer to its contents. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookCreatePageOfClass"><CODE>vnotebookCreatePageOfClass</CODE></A></CODE> with the default
page class. The Notebook class will reclaim the storage
occupied by the page when <CODE><A HREF="vnotebook-x.html#vnotebookDestroyPage"><CODE>vnotebookDestroyPage</CODE></A></CODE>
is called.
</DD></DL>
<P>
<A NAME="vnotebookCreatePageOfClass"><HR><H4>vnotebookCreatePageOfClass</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookCreatePageOfClass</B>(
                vnotebookPageClass * clas);
</PRE>

<DL><DD>
Creates a new page of the class <SAMP>clas</SAMP> and
returns a pointer to its contents. This method is implemented by
calling <CODE><A HREF="vdialog-x.html#vdialogCreateItemOfClass"><CODE>vdialogCreateItemOfClass</CODE></A></CODE> with the
appropriate item class to create a page. The Notebook
class will reclaim the storage occupied by the notebook
when <CODE><A HREF="vnotebook-x.html#vnotebookDestroyPage"><CODE>vnotebookDestroyPage</CODE></A></CODE> is called.
</DD></DL>
<P>
<A NAME="vnotebookCreatePageTab"><HR><H4>vnotebookCreatePageTab</H4></A>
<PRE>
        vnotebookTab * <B>vnotebookCreatePageTab</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Creates a new tab for the page <SAMP>page</SAMP> and
returns a pointer to its contents. It is implemented with a
call to <CODE><A HREF="vnotebook-x.html#vnotebookCreateTab"><CODE>vnotebookCreateTab</CODE></A></CODE>. The Notebook
class will reclaim the storage occupied by the tab when
the tab is destroyed. This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookCREATE_PAGE_TAB"><CODE>vnotebookCREATE_PAGE_TAB</CODE></A></CODE> message to the page.
</DD></DL>
<P>
<A NAME="vnotebookCreateSection"><HR><H4>vnotebookCreateSection</H4></A>
<PRE>
        vnotebookSection * <B>vnotebookCreateSection</B>();
</PRE>

<DL><DD>
Creates a new section of the default section class and
returns a pointer to its contents. This method is implemented by
calling <CODE><A HREF="vnotebook-x.html#vnotebookCreateSectionOfClass"><CODE>vnotebookCreateSectionOfClass</CODE></A></CODE> with the
default section class. The Notebook class will reclaim
the storage occupied by the notebook when
<CODE><A HREF="vnotebook-x.html#vnotebookDestroySection"><CODE>vnotebookDestroySection</CODE></A></CODE> is called.
</DD></DL>
<P>
<A NAME="vnotebookCreateSectionOfClass"><HR><H4>vnotebookCreateSectionOfClass</H4></A>
<PRE>
        vnotebookSection * <B>vnotebookCreateSectionOfClass</B>(
                vnotebookSectionClass * clas);
</PRE>

<DL><DD>
Creates a new section of the class <SAMP>clas</SAMP> and
returns a pointer to its contents. This method is implemented by
calling <CODE><A HREF="vdialog-x.html#vdialogCreateItemOfClass"><CODE>vdialogCreateItemOfClass</CODE></A></CODE> with the
appropriate item class to create a section. The Notebook
class will reclaim the storage occupied by the notebook
when <CODE><A HREF="vnotebook-x.html#vnotebookDestroySection"><CODE>vnotebookDestroySection</CODE></A></CODE> is called.
</DD></DL>
<P>
<A NAME="vnotebookCreateStyle"><HR><H4>vnotebookCreateStyle</H4></A>
<PRE>
        vnotebookStyle * <B>vnotebookCreateStyle</B>();
</PRE>

<DL><DD>
Creates a new style and returns a pointer to its contents.
The storage for the style is allocated in this function and
will be reclaimed by the Notebook class when
<CODE><A HREF="vnotebook-x.html#vnotebookDestroyStyle"><CODE>vnotebookDestroyStyle</CODE></A></CODE> is called.
</DD></DL>
<P>
<A NAME="vnotebookCreateStyleOfClass"><HR><H4>vnotebookCreateStyleOfClass</H4></A>
<PRE>
        vnotebookStyle * <B>vnotebookCreateStyleOfClass</B>(
                vnotebookStyleClass * clas);
</PRE>

<DL><DD>
Creates a new style of the class <SAMP>clas</SAMP> and
returns a pointer to its contents. This method is implemented by
calling <CODE><A HREF="vobject-x.html#vobjectCreateOfClass"><CODE>vobjectCreateOfClass</CODE></A></CODE> with the
appropriate object class to create a style. The Notebook
class will reclaim the storage occupied by the notebook
when <CODE><A HREF="vnotebook-x.html#vnotebookDestroyStyle"><CODE>vnotebookDestroyStyle</CODE></A></CODE> is called.
</DD></DL>
<P>
<A NAME="vnotebookCreateTab"><HR><H4>vnotebookCreateTab</H4></A>
<PRE>
        vnotebookTab * <B>vnotebookCreateTab</B>();
</PRE>

<DL><DD>
Creates a new tab of the default tab class and returns a
pointer to its contents. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookCreateTabOfClass"><CODE>vnotebookCreateTabOfClass</CODE></A></CODE> with the default tab
class. The Notebook class will reclaim the storage
occupied by the notebook when
<CODE><A HREF="vnotebook-x.html#vnotebookDestroyTab"><CODE>vnotebookDestroyTab</CODE></A></CODE> is called.
</DD></DL>
<P>
<A NAME="vnotebookCreateTabOfClass"><HR><H4>vnotebookCreateTabOfClass</H4></A>
<PRE>
        vnotebookTab * <B>vnotebookCreateTabOfClass</B>(
                vnotebookTabClass * clas);
</PRE>

<DL><DD>
Creates a new tab of the class <SAMP>clas</SAMP> and
returns a pointer to its contents. This method is implemented by
calling <CODE><A HREF="vdialog-x.html#vdialogCreateItemOfClass"><CODE>vdialogCreateItemOfClass</CODE></A></CODE> with the
appropriate item class to create a tab. The Notebook
class will reclaim the storage occupied by the notebook
when <CODE><A HREF="vnotebook-x.html#vnotebookDestroyTab"><CODE>vnotebookDestroyTab</CODE></A></CODE> is called.
</DD></DL>
<P>
<A NAME="vnotebookDeletePage"><HR><H4>vnotebookDeletePage</H4></A>
<PRE>
        void <B>vnotebookDeletePage</B>(
                vnotebook * notebook,
                vnotebookPage * page);
</PRE>

<DL><DD>
Removes the page <SAMP>page</SAMP> from the notebook
<SAMP>notebook</SAMP>. The page is not destroyed. The user
is responsible for destroying the page. This function is
implemented by calling <CODE><A HREF="vcontainer-x.html#vcontainerDeleteItem"><CODE>vcontainerDeleteItem</CODE></A></CODE>.
If the page is a section then the entire section will be
deleted. To delete a section you must first retrieve the
page object from the section by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetSectionPage"><CODE>vnotebookGetSectionPage</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookDeleteSectionPage"><HR><H4>vnotebookDeleteSectionPage</H4></A>
<PRE>
        void <B>vnotebookDeleteSectionPage</B>(
                vnotebookSection * section,
                vnotebookPage * Page);
</PRE>

<DL><DD>
Removes the page <SAMP>page</SAMP> from the section
<SAMP>section</SAMP>. The page is not destroyed. The user is
responsible for destroying the page. This function is
implemented by calling <CODE><A HREF="vcontainer-x.html#vcontainerDeleteItem"><CODE>vcontainerDeleteItem</CODE></A></CODE>.
If the page is a section then the entire section will be
deleted. To delete a section you must first retrieve the
page object from the section by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetSectionPage"><CODE>vnotebookGetSectionPage</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookDeleteTabSetTab"><HR><H4>vnotebookDeleteTabSetTab</H4></A>
<PRE>
        void <B>vnotebookDeleteTabSetTab</B>(
                vnotebook * notebook,
                vdialogItem * tabset,
                vnotebookTab * tab);
</PRE>

<DL><DD>
Removes the tab <SAMP>tab</SAMP> from the tabset
<SAMP>tabset</SAMP> for the notebook <SAMP>notebook</SAMP>.
The default method sends a
<CODE><A HREF="vnotebook-x.html#vnotebookDELETE_TABSET_TAB"><CODE>vnotebookDELETE_TABSET_TAB</CODE></A></CODE> message to the
notebook. This will not destroy the tab.
</DD></DL>
<P>
<A NAME="vnotebookDestroy"><HR><H4>vnotebookDestroy</H4></A>
<PRE>
        void <B>vnotebookDestroy</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Destroys the notebook represented by <SAMP>notebook</SAMP>,
which must have been created or initialized by a Notebook
class function. Use this function to reclaim the storage
occupied by the notebook. The notebook should not be
referenced by another object when it is destroyed. The
storage is only released when it was allocated by one of the
Notebook class functions. It destroys the page buttons,
tabset and the style if it is owned by the notebook. The
notebook is destroyed by sending a
<CODE>vobjectDESTROY</CODE> message to
<SAMP>notebook</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookDestroyPage"><HR><H4>vnotebookDestroyPage</H4></A>
<PRE>
        void <B>vnotebookDestroyPage</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Destroys the page represented by <SAMP>page</SAMP>, which
must have been created or initialized by a Notebook class
function. Use this function to reclaim the storage occupied
by the page. The page should not be referenced by another
object when it is destroyed. The storage is only released when
it was allocated by one of the Notebook class functions.
It destroys the tab associated with that page. The page is
destroyed by sending a <CODE>vobjectDESTROY</CODE> message to
<SAMP>page</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookDestroySection"><HR><H4>vnotebookDestroySection</H4></A>
<PRE>
        void <B>vnotebookDestroySection</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Destroys the section represented by <SAMP>section</SAMP>,
which must have been created or initialized by a Notebook
class function. Use this function to reclaim the storage
occupied by the section. The section should not be
referenced by another object when it is destroyed. The
storage is only released when it was allocated by one of the
Notebook class functions. The section is destroyed by
sending a <CODE>vobjectDESTROY</CODE> message to
<SAMP>section</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookDestroyStyle"><HR><H4>vnotebookDestroyStyle</H4></A>
<PRE>
        void <B>vnotebookDestroyStyle</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Destroys the style represented by <SAMP>style</SAMP>, which
must have been created or initialized by a Notebook class
function. Use this function to reclaim the storage occupied
by the style. The style should not be referenced by another
object when it is destroyed. The storage is only released when
it was allocated by one of the Notebook class functions.
</DD></DL>
<P>
<A NAME="vnotebookDestroyTab"><HR><H4>vnotebookDestroyTab</H4></A>
<PRE>
        void <B>vnotebookDestroyTab</B>(
                vnotebookTab * tab);
</PRE>

<DL><DD>
Destroys the tab represented by <SAMP>tab</SAMP>, which
must have been created or initialized by a Notebook class
function. Use this function to reclaim the storage occupied
by the tab. The section should not be referenced by another
object when it is destroyed. The storage is only released when
it was allocated by one of the Notebook class functions.
The tab is destroyed by sending a <CODE>vobjectDESTROY</CODE>
message to <SAMP>tab</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookDetermineCurrentPage"><HR><H4>vnotebookDetermineCurrentPage</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookDetermineCurrentPage</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Returns the page that is currently active in the
notebook <SAMP>notebook</SAMP>. This function is different
from <CODE><A HREF="vnotebook-x.html#vnotebookGetCurrentPage"><CODE>vnotebookGetCurrentPage</CODE></A></CODE> in that it
recursively iterates over sections until it finds the
actual page that is active.
</DD></DL>
<P>
<A NAME="vnotebookDeterminePageNotebook"><HR><H4>vnotebookDeterminePageNotebook</H4></A>
<PRE>
        vnotebook * <B>vnotebookDeterminePageNotebook</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Returns the notebook object that is built on the page
<SAMP>page</SAMP>. If the page is not a notebook, as
determined by <CODE>vnotebookPageIsNoteboook</CODE> it will
return <SAMP>NULL</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookDetermineStyle"><HR><H4>vnotebookDetermineStyle</H4></A>
<PRE>
        void <B>vnotebookDetermineStyle</B>(
                vnotebook * notebook,
                vnotebookStyle * style,
                int whichSettings);
</PRE>

<DL><DD>
Returns the style <SAMP>style</SAMP> for notebook
<SAMP>notebook</SAMP> only for the style based on those that are
requested in <SAMP>whichSettings</SAMP>.
<SAMP>whichSettings</SAMP> can be any of the
<CODE>vnotebookSTYLE</CODE> constants. This method is implemented by
sending a <CODE><A HREF="vnotebook-x.html#vnotebookDETERMINE_STYLE"><CODE>vnotebookDETERMINE_STYLE</CODE></A></CODE> message to
the notebook.
</DD></DL>
<P>
<A NAME="vnotebookDetermineTabFont"><HR><H4>vnotebookDetermineTabFont</H4></A>
<PRE>
        vfont * <B>vnotebookDetermineTabFont</B>(
                vnotebookTab * tab);
</PRE>

<DL><DD>
Determines which font is to be used for the tab
<SAMP>tab</SAMP>. It first calls <CODE><A HREF="vdialog-x.html#vdialogGetItemFont"><CODE>vdialogGetItemFont</CODE></A></CODE>
on the tab's dialog item and returns the font if it exists.
Else, if the page associated with the tab is the notebook
then it returns the font from the notebook's dialog item.
If it is not, it will recursively search up the notebook's
tree structure and calls itself with the tab of each
section it encounters until it finds a tab whose dialog
item has the font set. If no such tab is found, the font of
the original tab's page is returned.
</DD></DL>
<P>
<A NAME="vnotebookDetermineTabImage"><HR><H4>vnotebookDetermineTabImage</H4></A>
<PRE>
        vimage * <B>vnotebookDetermineTabImage</B>(
                vnotebookTab * tab,
                int * isMask);
</PRE>

<DL><DD>
Returns the image that the tab <SAMP>tab</SAMP> is
inheriting from parent objects. If the user had previously
indicated that no image should be inherited for the tab by
calling <CODE>vimageSetImageTabNone</CODE> then
<SAMP>NULL</SAMP> is returned. If the image returned is a
mask, then <SAMP>TRUE</SAMP> will be returned in
<SAMP>isMask</SAMP>. The image will be inherited from the
dialog item object from which the tab is derived. If that
image is not set, then the image will be inherited from the
first section above the page that the tab is associated
with. It will recursively look for up the notebook tree for
a section that has the tab image set. If it reaches the
root notebook section and one is not found it returns
<SAMP>NULL</SAMP>.
<p>
Therefore, if you want to set an image
for all pages in the notebook you would get the page object
from the notebook with <CODE><A HREF="vnotebook-x.html#vnotebookGetSection"><CODE>vnotebookGetSection</CODE></A></CODE> and
<CODE><A HREF="vnotebook-x.html#vnotebookGetSectionPage"><CODE>vnotebookGetSectionPage</CODE></A></CODE>. Then set the image of the pages
tab by calling <CODE><A HREF="vnotebook-x.html#vnotebookGetPageTab"><CODE>vnotebookGetPageTab</CODE></A></CODE> and
<CODE><A HREF="vnotebook-x.html#vnotebookSetTabImage"><CODE>vnotebookSetTabImage</CODE></A></CODE>. Similar actions can be done for any
section in the notebook to inherit an image to the tabs of
the pages belonging to that section.
</DD></DL>
<P>
<A NAME="vnotebookDrawBinder"><HR><H4>vnotebookDrawBinder</H4></A>
<PRE>
        void <B>vnotebookDrawBinder</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Draws the binder of the notebook <SAMP>notebook</SAMP> into
the current graphics state. It will draw the default binder
with the default size unless it was changed with a call to
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleBinding"><CODE>vnotebookSetStyleBinding</CODE></A></CODE> or
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleBindingSize"><CODE>vnotebookSetStyleBindingSize</CODE></A></CODE>. This method
is implemented by sending a <CODE><A HREF="vnotebook-x.html#vnotebookDRAW_BINDER"><CODE>vnotebookDRAW_BINDER</CODE></A></CODE>
message to the notebook. You should override this function
if you want to define a notebook class with a different
binding.
</DD></DL>
<P>
<A NAME="vnotebookDrawBinderWith"><HR><H4>vnotebookDrawBinderWith</H4></A>
<PRE>
        void <B>vnotebookDrawBinderWith</B>(
                vnotebook * notebook,
                vdrawcontext * context);
</PRE>

<DL><DD>
Draws the binder of the notebook <SAMP>notebook</SAMP> into
the drawing context <SAMP>context</SAMP>. It will draw the default binder
with the default size unless it was changed with a call to
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleBinding"><CODE>vnotebookSetStyleBinding</CODE></A></CODE> or
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleBindingSize"><CODE>vnotebookSetStyleBindingSize</CODE></A></CODE>.  You should override this
function if you want to define a notebook class with a
different binding.  This function is implemented by sending the
message <SAMP><A HREF="vnotebook-x.html#vnotebookDRAW_BINDER_WITH"><CODE>vnotebookDRAW_BINDER_WITH</CODE></A></SAMP> to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookDrawFolio"><HR><H4>vnotebookDrawFolio</H4></A>
<PRE>
        void <B>vnotebookDrawFolio</B>(
                vnotebook * notebook,
                vrect * rect);
</PRE>

<DL><DD>
Draws the folio of the notebook <SAMP>notebook</SAMP> into
the current graphics state with the dimensions defined by
<SAMP>rect</SAMP>. It will draw the default folio unless it
was changed with a call to
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleFolio"><CODE>vnotebookSetStyleFolio</CODE></A></CODE>. This method is implemented by
sending a <CODE><A HREF="vnotebook-x.html#vnotebookDRAW_FOLIO"><CODE>vnotebookDRAW_FOLIO</CODE></A></CODE> message to the
notebook. You should override this function if you want to
define a notebook class with a different folio.
</DD></DL>
<P>
<A NAME="vnotebookDrawFolioWith"><HR><H4>vnotebookDrawFolioWith</H4></A>
<PRE>
        void <B>vnotebookDrawFolioWith</B>(
                vnotebook * notebook,
                vrect * rect,
                vdrawcontext * context);
</PRE>

<DL><DD>
Draws the folio of the notebook <SAMP>notebook</SAMP> into
the drawing context <SAMP>context</SAMP> with the dimensions defined by
<SAMP>rect</SAMP>. It will draw the default folio unless it
was changed with a call to
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleFolio"><CODE>vnotebookSetStyleFolio</CODE></A></CODE>. This method is implemented by
sending a <CODE><A HREF="vnotebook-x.html#vnotebookDRAW_FOLIO_WITH"><CODE>vnotebookDRAW_FOLIO_WITH</CODE></A></CODE> message to the
notebook. You should override this function if you want to
define a notebook class with a different folio.
</DD></DL>
<P>
<A NAME="vnotebookDrawPageAt"><HR><H4>vnotebookDrawPageAt</H4></A>
<PRE>
        void <B>vnotebookDrawPageAt</B>(
                vnotebook * notebook,
                int pageNum,
                vrect * rect);
</PRE>

<DL><DD>
Draws the virtual page <SAMP>pageNum</SAMP> of the
notebook <SAMP>notebook</SAMP> into the current graphics
state with the dimensions defined by <SAMP>rect</SAMP>. This
method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookDRAW_PAGE_AT"><CODE>vnotebookDRAW_PAGE_AT</CODE></A></CODE> message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookDrawPageAtWith"><HR><H4>vnotebookDrawPageAtWith</H4></A>
<PRE>
        void <B>vnotebookDrawPageAtWith</B>(
                vnotebook * notebook,
                int pageNum,
                vrect * rect,
                vdrawcontext * context);
</PRE>

<DL><DD>
Draws the virtual page <SAMP>pageNum</SAMP> of the notebook
into the drawing context <SAMP>context</SAMP> with the dimensions defined
by <SAMP>rect</SAMP>.  This function is implemented by sending the
message <CODE><A HREF="vnotebook-x.html#vnotebookDRAW_PAGE_AT_WITH"><CODE>vnotebookDRAW_PAGE_AT_WITH</CODE></A></CODE> to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookDrawPageBorder"><HR><H4>vnotebookDrawPageBorder</H4></A>
<PRE>
        void <B>vnotebookDrawPageBorder</B>(
                vnotebookPage * page,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the border of the page <SAMP>page</SAMP> into the
current graphics state with the dimensions defined by
<SAMP>rect</SAMP>. This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookDRAW_PAGE_BORDER"><CODE>vnotebookDRAW_PAGE_BORDER</CODE></A></CODE> message to the page.
You should override this function if you want to define a page
class with a different border.
</DD></DL>
<P>
<A NAME="vnotebookDrawPageBorderWith"><HR><H4>vnotebookDrawPageBorderWith</H4></A>
<PRE>
        void <B>vnotebookDrawPageBorderWith</B>(
                vnotebookPage * page,
                const vrect * rect,
                vdrawcontext * context);
</PRE>

<DL><DD>
Draws the border of the page into the drawing context
<SAMP>context</SAMP> with the dimensions defined by <SAMP>rect</SAMP>. You
should override this function if you want to define a page
class with a different border.  This function is implemented by
sending the message <CODE><A HREF="vnotebook-x.html#vnotebookDRAW_PAGE_BORDER_WITH"><CODE>vnotebookDRAW_PAGE_BORDER_WITH</CODE></A></CODE> to the
page.
</DD></DL>
<P>
<A NAME="vnotebookDrawPageContent"><HR><H4>vnotebookDrawPageContent</H4></A>
<PRE>
        void <B>vnotebookDrawPageContent</B>(
                vnotebookPage * page,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the content of the page <SAMP>page</SAMP> into the
current graphics state with the dimensions defined by
<SAMP>rect</SAMP>. This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookDRAW_PAGE_CONTENT"><CODE>vnotebookDRAW_PAGE_CONTENT</CODE></A></CODE> message to the
page. You should override this function if you want to define a
page class with a different content.
</DD></DL>
<P>
<A NAME="vnotebookDrawPageContentWith"><HR><H4>vnotebookDrawPageContentWith</H4></A>
<PRE>
        void <B>vnotebookDrawPageContentWith</B>(
                vnotebookPage * page,
                const vrect * rect,
                vdrawcontext * context);
</PRE>

<DL><DD>
Draws the content of the page into the drawing context
<SAMP>context</SAMP> with the dimensions defined by <SAMP>rect</SAMP>. You
should override this function if you want to define a page
class with a different content.  This function is implemented by
sending the message <CODE><A HREF="vnotebook-x.html#vnotebookDRAW_PAGE_CONTENT_WITH"><CODE>vnotebookDRAW_PAGE_CONTENT_WITH</CODE></A></CODE> 
to the page.
</DD></DL>
<P>
<A NAME="vnotebookDrawTabBorder"><HR><H4>vnotebookDrawTabBorder</H4></A>
<PRE>
        void <B>vnotebookDrawTabBorder</B>(
                vnotebookTab * tab);
</PRE>

<DL><DD>
Draws the border of the tab <SAMP>tab</SAMP> into the
current graphics state. This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookDRAW_TAB_BORDER"><CODE>vnotebookDRAW_TAB_BORDER</CODE></A></CODE> message to the tab.
You should override this function if you want to define a tab
class with a different border.
</DD></DL>
<P>
<A NAME="vnotebookDrawTabBorderWith"><HR><H4>vnotebookDrawTabBorderWith</H4></A>
<PRE>
        void <B>vnotebookDrawTabBorderWith</B>(
                vnotebookTab * tab,
                vdrawcontext * context);
</PRE>

<DL><DD>
Draws the border of the tab into the drawing context
<SAMP>context</SAMP>. This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookDRAW_TAB_BORDER_WITH"><CODE>vnotebookDRAW_TAB_BORDER_WITH</CODE></A></CODE> message to the tab.
You should override this function if you want to define a tab 
with a different border.
</DD></DL>
<P>
<A NAME="vnotebookDrawTabContent"><HR><H4>vnotebookDrawTabContent</H4></A>
<PRE>
        void <B>vnotebookDrawTabContent</B>(
                vnotebookTab * tab,
                vrect * rect);
</PRE>

<DL><DD>
Draws the contents of the tab <SAMP>tab</SAMP> into the
current graphics state with the dimensions defined by
<SAMP>rect</SAMP>. This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookDRAW_TAB_CONTENT"><CODE>vnotebookDRAW_TAB_CONTENT</CODE></A></CODE> message to the tab.
You should override this function if you want to define a tab
class with a different content.
</DD></DL>
<P>
<A NAME="vnotebookDrawTabContentWith"><HR><H4>vnotebookDrawTabContentWith</H4></A>
<PRE>
        void <B>vnotebookDrawTabContentWith</B>(
                vnotebookTab * tab,
                vrect * rect,
                vdrawcontext * context);
</PRE>

<DL><DD>
Draws the contents of the tab <SAMP>tab</SAMP> into the
drawing context <SAMP>context</SAMP> with the dimensions defined by
<SAMP>rect</SAMP>. This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookDRAW_TAB_CONTENT_WITH"><CODE>vnotebookDRAW_TAB_CONTENT_WITH</CODE></A></CODE> message to the tab.
You should override this function if you want to define a tab
class with a different content.
</DD></DL>
<P>
<A NAME="vnotebookFindPage"><HR><H4>vnotebookFindPage</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookFindPage</B>(
                vnotebook * notebook,
                const vname * name);
</PRE>

<DL><DD>
Returns the page in the notebook <SAMP>notebook</SAMP> with
the name <SAMP>name</SAMP>. This method is implemented by calling
<CODE><A HREF="vcontainer-x.html#vcontainerFindItem"><CODE>vcontainerFindItem</CODE></A></CODE> with container object of
the notebook. <SAMP>NULL</SAMP> is returned if the page
does not exist.
</DD></DL>
<P>
<A NAME="vnotebookFindSectionPage"><HR><H4>vnotebookFindSectionPage</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookFindSectionPage</B>(
                vnotebookSection * section,
                const vname * name);
</PRE>

<DL><DD>
Returns the page in the section <SAMP>section</SAMP> with
the name <SAMP>name</SAMP>. This method is implemented by calling
<CODE><A HREF="vcontainer-x.html#vcontainerFindItem"><CODE>vcontainerFindItem</CODE></A></CODE> with container object of
the section. <SAMP>NULL</SAMP> is returned if the page does
not exist.
</DD></DL>
<P>
<A NAME="vnotebookGetClass"><HR><H4>vnotebookGetClass</H4></A>
<PRE>
        vnotebookClass * <B>vnotebookGetClass</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Returns the notebook class of the notebook
<SAMP>notebook</SAMP>. This method is implemented by calling
<CODE><A HREF="vcontainer-x.html#vcontainerGetClass"><CODE>vcontainerGetClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookGetClassStyle"><HR><H4>vnotebookGetClassStyle</H4></A>
<PRE>
        vnotebookStyle * <B>vnotebookGetClassStyle</B>(
                vnotebookClass * clas);
</PRE>

<DL><DD>
Returns the style for the notebook class <SAMP>clas</SAMP>.
This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookCLASS_STYLE"><CODE>vnotebookCLASS_STYLE</CODE></A></CODE> message to the notebook
to get the style. The address of which is returned.
</DD></DL>
<P>
<A NAME="vnotebookGetContainer"><HR><H4>vnotebookGetContainer</H4></A>
<PRE>
        vcontainer * <B>vnotebookGetContainer</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Returns the container object that the notebook
<SAMP>notebook</SAMP> was subclassed from.
</DD></DL>
<P>
<A NAME="vnotebookGetCurrentPage"><HR><H4>vnotebookGetCurrentPage</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookGetCurrentPage</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Returns the page of the notebook <SAMP>notebook</SAMP> that
is currently being displayed. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetSectionCurrentPage"><CODE>vnotebookGetSectionCurrentPage</CODE></A></CODE>. If your
notebook has sections, you should test to see if the page
that is returned is a section using
<CODE><A HREF="vnotebook-x.html#vnotebookPageIsSection"><CODE>vnotebookPageIsSection</CODE></A></CODE>. If a section is
returned and you want to get the actual page that is
current, you should recursively call
<CODE><A HREF="vnotebook-x.html#vnotebookGetSectionCurrentPage"><CODE>vnotebookGetSectionCurrentPage</CODE></A></CODE> with the
section that is returned until a page that is not a section
is returned.
</DD></DL>
<P>
<A NAME="vnotebookGetCurrentPageNumber"><HR><H4>vnotebookGetCurrentPageNumber</H4></A>
<PRE>
        void <B>vnotebookGetCurrentPageNumber</B>(
                vnotebook * notebook,
                int * pageNum,
                int * total);
</PRE>

<DL><DD>
Returns the values of the page number <SAMP>pageNum</SAMP>
and the total number of pages <SAMP>total</SAMP> given the
current page that is active in the notebook
<SAMP>notebook</SAMP>. This information is generally useful for
displaying in the folio.
</DD></DL>
<P>
<A NAME="vnotebookGetData"><HR><H4>vnotebookGetData</H4></A>
<PRE>
        const void * <B>vnotebookGetData</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Returns the generic data pointer attached to the notebook
<SAMP>notebook</SAMP>, which can be <SAMP>NULL</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookGetDefaultClass"><HR><H4>vnotebookGetDefaultClass</H4></A>
<PRE>
        vnotebookClass * <B>vnotebookGetDefaultClass</B>();
</PRE>

<DL><DD>
Returns the default class used to create notebooks by the
<CODE><A HREF="vnotebook-x.html#vnotebookCreate"><CODE>vnotebookCreate</CODE></A></CODE> and <CODE><A HREF="vnotebook-x.html#vnotebookInit"><CODE>vnotebookInit</CODE></A></CODE>
functions. This class can be modified to alter the behavior
of all notebooks subsequently created by these functions.
</DD></DL>
<P>
<A NAME="vnotebookGetDefaultPageClass"><HR><H4>vnotebookGetDefaultPageClass</H4></A>
<PRE>
        vnotebookPageClass * <B>vnotebookGetDefaultPageClass</B>();
</PRE>

<DL><DD>
Returns the default class used to create pages by the
<CODE><A HREF="vnotebook-x.html#vnotebookCreatePage"><CODE>vnotebookCreatePage</CODE></A></CODE> and
<CODE><A HREF="vnotebook-x.html#vnotebookInitPage"><CODE>vnotebookInitPage</CODE></A></CODE> functions. This class can be
modified to alter the behavior of all pages subsequently
created by these functions.
</DD></DL>
<P>
<A NAME="vnotebookGetDefaultSectionClass"><HR><H4>vnotebookGetDefaultSectionClass</H4></A>
<PRE>
        vnotebookSectionClass * <B>vnotebookGetDefaultSectionClass</B>();
</PRE>

<DL><DD>
Returns the default class used to create sections by the
<CODE><A HREF="vnotebook-x.html#vnotebookCreateSection"><CODE>vnotebookCreateSection</CODE></A></CODE> and
<CODE><A HREF="vnotebook-x.html#vnotebookInitSection"><CODE>vnotebookInitSection</CODE></A></CODE> functions. This class can
be modified to alter the behavior of all sections
subsequently created by these functions.
</DD></DL>
<P>
<A NAME="vnotebookGetDefaultStyleClass"><HR><H4>vnotebookGetDefaultStyleClass</H4></A>
<PRE>
        vnotebookStyleClass * <B>vnotebookGetDefaultStyleClass</B>();
</PRE>

<DL><DD>
Returns the default class used to create styles by the
<CODE><A HREF="vnotebook-x.html#vnotebookCreateStyle"><CODE>vnotebookCreateStyle</CODE></A></CODE> and
<CODE><A HREF="vnotebook-x.html#vnotebookInitStyle"><CODE>vnotebookInitStyle</CODE></A></CODE> functions. This class can
be modified to alter the behavior of all styles
subsequently created by these functions.
</DD></DL>
<P>
<A NAME="vnotebookGetDefaultTabClass"><HR><H4>vnotebookGetDefaultTabClass</H4></A>
<PRE>
        vnotebookTabClass * <B>vnotebookGetDefaultTabClass</B>();
</PRE>

<DL><DD>
Returns the default class used to create tabs by the
<CODE><A HREF="vnotebook-x.html#vnotebookCreateTab"><CODE>vnotebookCreateTab</CODE></A></CODE> and
<CODE><A HREF="vnotebook-x.html#vnotebookInitTab"><CODE>vnotebookInitTab</CODE></A></CODE> functions. This class can be
modified to alter the behavior of all tabs subsequently
created by these functions.
</DD></DL>
<P>
<A NAME="vnotebookGetFolioSize"><HR><H4>vnotebookGetFolioSize</H4></A>
<PRE>
        void <B>vnotebookGetFolioSize</B>(
                vnotebook * notebook,
                int * w,
                int * h);
</PRE>

<DL><DD>
Returns the width <SAMP>w</SAMP>, and the height
<SAMP>h</SAMP> of the folio rect for the notebook
<SAMP>notebook</SAMP>. This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookGET_FOLIO_SIZE"><CODE>vnotebookGET_FOLIO_SIZE</CODE></A></CODE> message to the
notebook.
</DD></DL>
<P>
<A NAME="vnotebookGetItem"><HR><H4>vnotebookGetItem</H4></A>
<PRE>
        vdialogItem * <B>vnotebookGetItem</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Returns the dialog Item from which the notebook
<SAMP>notebook</SAMP> was subclassed from.
</DD></DL>
<P>
<A NAME="vnotebookGetMajorTabSet"><HR><H4>vnotebookGetMajorTabSet</H4></A>
<PRE>
        vdialogItem * <B>vnotebookGetMajorTabSet</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Returns the tabset for the notebook <SAMP>notebook</SAMP>
that contains the major tabs.
</DD></DL>
<P>
<A NAME="vnotebookGetMaxTabSetTabSize"><HR><H4>vnotebookGetMaxTabSetTabSize</H4></A>
<PRE>
        void <B>vnotebookGetMaxTabSetTabSize</B>(
                vnotebook * notebook,
                vdialogItem * tabset,
                int * w,
                int * h);
</PRE>

<DL><DD>
Returns the maximum width <SAMP>w</SAMP>, and height
<SAMP>h</SAMP>, of tabs in the tabset <SAMP>tabset</SAMP>
for the notebook <SAMP>notebook</SAMP>. This method is implemented by
sending a <CODE><A HREF="vnotebook-x.html#vnotebookGET_MAX_TABSET_TAB_SIZE"><CODE>vnotebookGET_MAX_TABSET_TAB_SIZE</CODE></A></CODE>
message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookGetMinorTabSet"><HR><H4>vnotebookGetMinorTabSet</H4></A>
<PRE>
        vdialogItem * <B>vnotebookGetMinorTabSet</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Returns the tabset for the notebook <SAMP>notebook</SAMP>
that contains the minor tabs.
</DD></DL>
<P>
<A NAME="vnotebookGetNotify"><HR><H4>vnotebookGetNotify</H4></A>
<PRE>
        vnotebookNoteProc <B>vnotebookGetNotify</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Returns the notification procedure attached to the
notebook <SAMP>notebook</SAMP>, or <SAMP>NULL</SAMP> if
there is no notification procedure.
</DD></DL>
<P>
<A NAME="vnotebookGetPageAt"><HR><H4>vnotebookGetPageAt</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookGetPageAt</B>(
                vnotebook * notebook,
                int index);
</PRE>

<DL><DD>
Returns the page at <SAMP>index</SAMP> from the item list
of the notebook <SAMP>notebook</SAMP>. This method is implemented by
calling <CODE><A HREF="vcontainer-x.html#vcontainerGetItemAt"><CODE>vcontainerGetItemAt</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookGetPageBorderSizes"><HR><H4>vnotebookGetPageBorderSizes</H4></A>
<PRE>
        void <B>vnotebookGetPageBorderSizes</B>(
                vnotebookPage * page,
                int * top,
                int * left,
                int * bottom,
                int * right);
</PRE>

<DL><DD>
Returns the border sizes for the page <SAMP>page</SAMP>. This
method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookGET_PAGE_BORDER_SIZES"><CODE>vnotebookGET_PAGE_BORDER_SIZES</CODE></A></CODE> message to the
page. The default method will return the line width for
each of the sizes.
</DD></DL>
<P>
<A NAME="vnotebookGetPageButtonSize"><HR><H4>vnotebookGetPageButtonSize</H4></A>
<PRE>
        void <B>vnotebookGetPageButtonSize</B>(
                vnotebook * notebook,
                int * w,
                int * h);
</PRE>

<DL><DD>
Returns the width <SAMP>w</SAMP> and the height
<SAMP>h</SAMP> of the page buttons for the notebook
<SAMP>notebook</SAMP>. This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookGET_PAGE_BUTTON_SIZE"><CODE>vnotebookGET_PAGE_BUTTON_SIZE</CODE></A></CODE> message to the
notebook.
</DD></DL>
<P>
<A NAME="vnotebookGetPageClass"><HR><H4>vnotebookGetPageClass</H4></A>
<PRE>
        vnotebookPageClass * <B>vnotebookGetPageClass</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Returns the page class of the page <SAMP>page</SAMP>.
This method is implemented by calling <CODE><A HREF="vcontainer-x.html#vcontainerGetClass"><CODE>vcontainerGetClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookGetPageContainer"><HR><H4>vnotebookGetPageContainer</H4></A>
<PRE>
        vcontainer * <B>vnotebookGetPageContainer</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Returns the container object that the page
<SAMP>page</SAMP> was subclassed from.
</DD></DL>
<P>
<A NAME="vnotebookGetPageContentMinSize"><HR><H4>vnotebookGetPageContentMinSize</H4></A>
<PRE>
        void <B>vnotebookGetPageContentMinSize</B>(
                vnotebookPage * page,
                int * w,
                int * h);
</PRE>

<DL><DD>
Returns the width <SAMP>w</SAMP> and height <SAMP>h</SAMP>
of the minimum size for the page content of the page
<SAMP>page</SAMP>. This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookGET_PAGE_CONTENT_MIN_SIZE"><CODE>vnotebookGET_PAGE_CONTENT_MIN_SIZE</CODE></A></CODE> message to
the page. The default method retrieves the
<CODE><A HREF="vdialog-x.html#vdialogItemList"><CODE>vdialogItemList</CODE></A></CODE> from the container object that
the page was derived from. It then determines the minimum
size by calling <CODE><A HREF="vdialog-x.html#vdialogCalcItemListMinSize"><CODE>vdialogCalcItemListMinSize</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookGetPageContentNaturalSize"><HR><H4>vnotebookGetPageContentNaturalSize</H4></A>
<PRE>
        void <B>vnotebookGetPageContentNaturalSize</B>(
                vnotebookPage * page,
                int * w,
                int * h);
</PRE>

<DL><DD>
Returns the natural width <SAMP>w</SAMP>, and the natural
height <SAMP>h</SAMP>, for the page content of the page
<SAMP>page</SAMP>. This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookGET_PAGE_CONTENT_NATURAL_SIZE"><CODE>vnotebookGET_PAGE_CONTENT_NATURAL_SIZE</CODE></A></CODE> message
to the page.
</DD></DL>
<P>
<A NAME="vnotebookGetPageCount"><HR><H4>vnotebookGetPageCount</H4></A>
<PRE>
        int <B>vnotebookGetPageCount</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Returns the number of pages and sections in the
notebook <SAMP>notebook</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookGetPageData"><HR><H4>vnotebookGetPageData</H4></A>
<PRE>
        const void * <B>vnotebookGetPageData</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Returns the generic data pointer attached to the page
<SAMP>page</SAMP>, which can be <SAMP>NULL</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookGetPageDecorationSizes"><HR><H4>vnotebookGetPageDecorationSizes</H4></A>
<PRE>
        void <B>vnotebookGetPageDecorationSizes</B>(
                vnotebookPage * page,
                int * top,
                int * left,
                int * bottom,
                int * right);
</PRE>

<DL><DD>
Returns the decoration sizes for the page
<SAMP>page</SAMP>. This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookGET_PAGE_DECORATION_SIZES"><CODE>vnotebookGET_PAGE_DECORATION_SIZES</CODE></A></CODE> message to
the page. The default method will return 0 for all
instances.
</DD></DL>
<P>
<A NAME="vnotebookGetPageIndex"><HR><H4>vnotebookGetPageIndex</H4></A>
<PRE>
        int <B>vnotebookGetPageIndex</B>(
                vnotebook * notebook,
                vnotebookPage * page);
</PRE>

<DL><DD>
Returns the index of the page <SAMP>page</SAMP> in the item
list of the notebook <SAMP>notebook</SAMP>, or -1 if the
page is not in the notebook. The page index starts at 0.
</DD></DL>
<P>
<A NAME="vnotebookGetPageItem"><HR><H4>vnotebookGetPageItem</H4></A>
<PRE>
        vdialogItem * <B>vnotebookGetPageItem</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Returns the dialog item from which the page
<SAMP>page</SAMP> was subclassed.
</DD></DL>
<P>
<A NAME="vnotebookGetPageNotify"><HR><H4>vnotebookGetPageNotify</H4></A>
<PRE>
        vnotebookPageNoteProc <B>vnotebookGetPageNotify</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Returns the notification procedure attached to the
page <SAMP>page</SAMP>, or <SAMP>NULL</SAMP> if there is no
notification procedure.
</DD></DL>
<P>
<A NAME="vnotebookGetPageNumber"><HR><H4>vnotebookGetPageNumber</H4></A>
<PRE>
        int <B>vnotebookGetPageNumber</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Returns the page number associated with the page
<SAMP>page</SAMP>. This does not return the ordering of the page,
but merely an associated page number.
</DD></DL>
<P>
<A NAME="vnotebookGetPageSection"><HR><H4>vnotebookGetPageSection</H4></A>
<PRE>
        vnotebookSection * <B>vnotebookGetPageSection</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Returns the section that contains the page
<SAMP>page</SAMP>. If the page is not contained in a section,
<SAMP>NULL</SAMP> is returned.
</DD></DL>
<P>
<A NAME="vnotebookGetPageTab"><HR><H4>vnotebookGetPageTab</H4></A>
<PRE>
        vnotebookTab * <B>vnotebookGetPageTab</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Returns the tab that is associated with the page
<SAMP>page</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookGetSection"><HR><H4>vnotebookGetSection</H4></A>
<PRE>
        vnotebookSection * <B>vnotebookGetSection</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Returns the section from which the notebook
<SAMP>notebook</SAMP> was subclassed.
</DD></DL>
<P>
<A NAME="vnotebookGetSectionClass"><HR><H4>vnotebookGetSectionClass</H4></A>
<PRE>
        vnotebookSectionClass * <B>vnotebookGetSectionClass</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Returns the section class of the section
<SAMP>section</SAMP>. This method is implemented by calling
<CODE><A HREF="vcontainer-x.html#vcontainerGetClass"><CODE>vcontainerGetClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookGetSectionContainer"><HR><H4>vnotebookGetSectionContainer</H4></A>
<PRE>
        vcontainer * <B>vnotebookGetSectionContainer</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Returns the container object that the section <SAMP>section
</SAMP>was subclassed from.
</DD></DL>
<P>
<A NAME="vnotebookGetSectionCurrentPage"><HR><H4>vnotebookGetSectionCurrentPage</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookGetSectionCurrentPage</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Returns the page of the section <SAMP>section</SAMP> that
is currently being displayed. This method is implemented by
calling <CODE><A HREF="vcontainer-x.html#vcontainerGetSelection"><CODE>vcontainerGetSelection</CODE></A></CODE>. It returns the
current page or section. If your section has sections, you
should test to see if the page that is returned is a
section using <CODE><A HREF="vnotebook-x.html#vnotebookPageIsSection"><CODE>vnotebookPageIsSection</CODE></A></CODE>. If a
section is returned and you want to get the actual page
that is current, you should recursively call this function
with the section that is returned until a page that is not
a section is returned.
</DD></DL>
<P>
<A NAME="vnotebookGetSectionData"><HR><H4>vnotebookGetSectionData</H4></A>
<PRE>
        const void * <B>vnotebookGetSectionData</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Returns the generic data pointer attached to the
section <SAMP>section</SAMP>, which can be
<SAMP>NULL</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookGetSectionFirstPage"><HR><H4>vnotebookGetSectionFirstPage</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookGetSectionFirstPage</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Returns the first page of the section <SAMP>section</SAMP>.
This method is implemented by first calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetSectionPageAt"><CODE>vnotebookGetSectionPageAt</CODE></A></CODE> of the first indexed
item and determining if the page returned is a section
through <CODE><A HREF="vnotebook-x.html#vnotebookPageIsSection"><CODE>vnotebookPageIsSection</CODE></A></CODE>. If the page is
a section it continues recursively until the actual first
page is found.
</DD></DL>
<P>
<A NAME="vnotebookGetSectionItem"><HR><H4>vnotebookGetSectionItem</H4></A>
<PRE>
        vdialogItem * <B>vnotebookGetSectionItem</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Returns the dialog Item from which the section
<SAMP>section</SAMP> was subclassed from.
</DD></DL>
<P>
<A NAME="vnotebookGetSectionLastPage"><HR><H4>vnotebookGetSectionLastPage</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookGetSectionLastPage</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Returns the last page of the section <SAMP>section</SAMP>.
This method is implemented by first calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetSectionPageCount"><CODE>vnotebookGetSectionPageCount</CODE></A></CODE> and then
<CODE><A HREF="vnotebook-x.html#vnotebookGetSectionPageAt"><CODE>vnotebookGetSectionPageAt</CODE></A></CODE> with that count - 1
value. It determines if the page returned is a section
through <CODE><A HREF="vnotebook-x.html#vnotebookPageIsSection"><CODE>vnotebookPageIsSection</CODE></A></CODE>. If the page is
a section it continues recursively until the actual last
page is found.
</DD></DL>
<P>
<A NAME="vnotebookGetSectionNextPage"><HR><H4>vnotebookGetSectionNextPage</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookGetSectionNextPage</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Returns the page after the current page in the
section <SAMP>section</SAMP>. It will do a in-order
traversal of the tree to get the next actual page. If there
is no current page in the section then the first actual
page of the section is returned. If a next page does not
exist then <SAMP>NULL</SAMP> is returned.
    <P>
The notebook can be passed in after retrieving the section
object from the notebook with a call to
<CODE>vnotebookGetSection</CODE>. It will be treated as any
other section except when wrapping is enabled. If the pages
of notebook wrap there will always be a next page. This can
be set by calling <CODE><A HREF="vnotebook-x.html#vnotebookSetStylePagesWrap"><CODE>vnotebookSetStylePagesWrap</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookGetSectionNotify"><HR><H4>vnotebookGetSectionNotify</H4></A>
<PRE>
        vnotebookSectionNoteProc <B>vnotebookGetSectionNotify</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Returns the notification procedure attached to the
section <SAMP>section</SAMP>, or <SAMP>NULL</SAMP> if there
is no notification procedure.
</DD></DL>
<P>
<A NAME="vnotebookGetSectionPage"><HR><H4>vnotebookGetSectionPage</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookGetSectionPage</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Returns the page from which the section
<SAMP>section</SAMP> was subclassed from.
</DD></DL>
<P>
<A NAME="vnotebookGetSectionPageAt"><HR><H4>vnotebookGetSectionPageAt</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookGetSectionPageAt</B>(
                vnotebookSection * section,
                int index);
</PRE>

<DL><DD>
Returns the page indexed by <SAMP>index</SAMP> in the
section <SAMP>section</SAMP>. This method is implemented by calling
<CODE><A HREF="vcontainer-x.html#vcontainerGetItemAt"><CODE>vcontainerGetItemAt</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookGetSectionPageCount"><HR><H4>vnotebookGetSectionPageCount</H4></A>
<PRE>
        int <B>vnotebookGetSectionPageCount</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Returns the number of pages and sections in the
section <SAMP>section</SAMP>. This method is implemented by calling
<CODE><A HREF="vcontainer-x.html#vcontainerGetItemCount"><CODE>vcontainerGetItemCount</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookGetSectionPageIndex"><HR><H4>vnotebookGetSectionPageIndex</H4></A>
<PRE>
        int <B>vnotebookGetSectionPageIndex</B>(
                vnotebookSection * section,
                vnotebookPage * page);
</PRE>

<DL><DD>
Returns the index number of the page <SAMP>page</SAMP> in
the section <SAMP>section</SAMP>. This method is implemented by calling
<CODE><A HREF="vcontainer-x.html#vcontainerGetItemIndex"><CODE>vcontainerGetItemIndex</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookGetSectionPreviousPage"><HR><H4>vnotebookGetSectionPreviousPage</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookGetSectionPreviousPage</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Returns the page before the current page in the
section <SAMP>section</SAMP>. It will do a backwards
in-order traversal of the tree to get the previous actual
page. If there is no current page in the section then the
last actual page of the section is returned. If a previous
page does not exist then <SAMP>NULL</SAMP> is returned.
    <P>
The notebook can be passed in after retrieving the section
object from the notebook with a call to
<CODE>vnotebookGetSection</CODE>. It will be treated as any
other section except when wrapping is enabled. If the pages
of notebook wrap there will always be a previous page. This
can be set by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStylePagesWrap"><CODE>vnotebookSetStylePagesWrap</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookGetStyle"><HR><H4>vnotebookGetStyle</H4></A>
<PRE>
        vnotebookStyle * <B>vnotebookGetStyle</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Returns the style associated with the notebook
<SAMP>notebook</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleBinding"><HR><H4>vnotebookGetStyleBinding</H4></A>
<PRE>
        int <B>vnotebookGetStyleBinding</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the type of the binding for the style
<SAMP>style</SAMP>. The return value can be
<CODE>vnotebookBINDING_PERFECT</CODE> for hard-cover or
<CODE>vnotebookBINDING_SPIRAL</CODE> for spiral. This method
is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_BINDING</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleBindingSize"><HR><H4>vnotebookGetStyleBindingSize</H4></A>
<PRE>
        int <B>vnotebookGetStyleBindingSize</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the pixel size of the binding for the style
<SAMP>style</SAMP>. This will determine the height of the binding
to be displayed with the notebook. This method is implemented by
calling <CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_BINDING_SIZE</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleButtonBorderMargin"><HR><H4>vnotebookGetStyleButtonBorderMargin</H4></A>
<PRE>
        int <B>vnotebookGetStyleButtonBorderMargin</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the pixel margin between the page buttons and the
border of the page for the style <SAMP>style</SAMP>. This method
is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_BUTTON_BORDER_MARGIN</CODE>
constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleButtonMargin"><HR><H4>vnotebookGetStyleButtonMargin</H4></A>
<PRE>
        int <B>vnotebookGetStyleButtonMargin</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the pixel margin between the page buttons for the
style <SAMP>style</SAMP>. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_BUTTON_MARGIN</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleClass"><HR><H4>vnotebookGetStyleClass</H4></A>
<PRE>
        vnotebookStyleClass * <B>vnotebookGetStyleClass</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the style class of the style <SAMP>style</SAMP>.
This method is implemented by calling <CODE><A HREF="vobject-x.html#vobjectGetClass"><CODE>vobjectGetClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleFolio"><HR><H4>vnotebookGetStyleFolio</H4></A>
<PRE>
        int <B>vnotebookGetStyleFolio</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the folio is being displayed
with the notebook for the style <SAMP>style</SAMP>,
<SAMP>FALSE</SAMP> if it is not. This method is implemented by
calling <CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_FOLIO</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleFolioButtonMargin"><HR><H4>vnotebookGetStyleFolioButtonMargin</H4></A>
<PRE>
        int <B>vnotebookGetStyleFolioButtonMargin</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the pixel margin between the page buttons and the
folio rect for the style <SAMP>style</SAMP>. This method
is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_FOLIO_BUTTON_MARGIN</CODE>
constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleFolioJustification"><HR><H4>vnotebookGetStyleFolioJustification</H4></A>
<PRE>
        int <B>vnotebookGetStyleFolioJustification</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the type folio justification for the style
<SAMP>style</SAMP>. This will determine if the folio messages are
to being justified to the left, center or right side of the
folio rect. The returned constant can be:
<ul>
<li><CODE>vnotebookFOLIO_JUSTIFY_LEFT</CODE>
<li><CODE>vnotebookFOLIO_JUSTIFY_CENTER</CODE>
<li><CODE>vnotebookFOLIO_JUSTIFY_RIGHT</CODE>
</ul>

This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_FOLIO_JUSTIFY</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleLoadable"><HR><H4>vnotebookGetStyleLoadable</H4></A>
<PRE>
        vloadable * <B>vnotebookGetStyleLoadable</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vnotebookGetStyleMajorTabSetSide"><HR><H4>vnotebookGetStyleMajorTabSetSide</H4></A>
<PRE>
        int <B>vnotebookGetStyleMajorTabSetSide</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the constant that determines which side of the page
the major tabs will be drawn for the style
<SAMP>style</SAMP>. The possible constants are:

<ul>
<li><CODE>vnotebookTABSET_LEFT</CODE>
<li><CODE>vnotebookTABSET_RIGHT</CODE>
<li><CODE>vnotebookTABSET_TOP</CODE>
<li><CODE>vnotebookTABSET_BOTTOM</CODE>
</ul>

This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_MAJOR_TABSET_SIDE</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleMinorTabSetSide"><HR><H4>vnotebookGetStyleMinorTabSetSide</H4></A>
<PRE>
        int <B>vnotebookGetStyleMinorTabSetSide</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the constant that determines which side of the page
the minor tabs will be drawn for the style
<SAMP>style</SAMP>. The possible constants are:

<ul>
<li><CODE>vnotebookTABSET_LEFT</CODE>
<li><CODE>vnotebookTABSET_RIGHT</CODE>
<li><CODE>vnotebookTABSET_TOP</CODE>
<li><CODE>vnotebookTABSET_BOTTOM</CODE>
</ul>

This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_MINOR_TABSET_SIDE</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleObject"><HR><H4>vnotebookGetStyleObject</H4></A>
<PRE>
        vobject * <B>vnotebookGetStyleObject</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the object that the style <SAMP>style</SAMP> was
subclassed from.
</DD></DL>
<P>
<A NAME="vnotebookGetStylePageBorders"><HR><H4>vnotebookGetStylePageBorders</H4></A>
<PRE>
        int <B>vnotebookGetStylePageBorders</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if a border is being drawn with
the page for the style <SAMP>style</SAMP>,
<SAMP>FALSE</SAMP> if not. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_PAGE_BORDERS</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStylePageButtons"><HR><H4>vnotebookGetStylePageButtons</H4></A>
<PRE>
        int <B>vnotebookGetStylePageButtons</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the page buttons are being
displayed with the notebook for the style
<SAMP>style</SAMP>. Returns <SAMP>FALSE</SAMP> if they are not
being drawn with the notebook. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_PAGE_BUTTONS</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStylePageCount"><HR><H4>vnotebookGetStylePageCount</H4></A>
<PRE>
        int <B>vnotebookGetStylePageCount</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the number of pages that are being drawn for the
style <SAMP>style</SAMP>. These are the graphical pages
that are drawn to represent the pages of the notebook. This
method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_PAGE_COUNT</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStylePageInset"><HR><H4>vnotebookGetStylePageInset</H4></A>
<PRE>
        int <B>vnotebookGetStylePageInset</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the number of pixels that the content rect is being
inset from the page for style <SAMP>style</SAMP>. This method
is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_PAGE_INSET</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStylePageInsetBorder"><HR><H4>vnotebookGetStylePageInsetBorder</H4></A>
<PRE>
        int <B>vnotebookGetStylePageInsetBorder</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the number of pixels that the content rect is being
inset from the page, given the page has a border, for the
style <SAMP>style</SAMP>. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_PAGE_INSET_BORDER</CODE>
constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStylePageStep"><HR><H4>vnotebookGetStylePageStep</H4></A>
<PRE>
        int <B>vnotebookGetStylePageStep</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the number of pixels between the graphical pages
that are drawn to represent the notebook for the
style <SAMP>style</SAMP>. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_PAGE_STEP</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStylePagesWrap"><HR><H4>vnotebookGetStylePagesWrap</H4></A>
<PRE>
        int <B>vnotebookGetStylePagesWrap</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the pages should wrap for the
style <SAMP>style</SAMP>, <SAMP>FALSE if not</SAMP>. If
<SAMP>TRUE</SAMP>, the first page will follow the last
page. If <SAMP>FALSE</SAMP>, the last page will disable the
<CODE>next</CODE> page button so that there is not a next page.
To get back to the first page you must back through all the
previous pages. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_PAGES_WRAP</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleScalarValue"><HR><H4>vnotebookGetStyleScalarValue</H4></A>
<PRE>
        int <B>vnotebookGetStyleScalarValue</B>(
                vnotebookStyle * style,
                int whichValue);
</PRE>

<DL><DD>
Returns a value associated with with the
<SAMP>whichValue</SAMP> for the style <SAMP>style</SAMP>.
<SAMP>whichValue</SAMP> can be any of the
<CODE>vnotebookSTYLE</CODE> constants. This function is not
necessary in that all possible values can be retrieved with
a specific <CODE>vnotebookGetStyle</CODE>  constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleTabInsetX"><HR><H4>vnotebookGetStyleTabInsetX</H4></A>
<PRE>
        int <B>vnotebookGetStyleTabInsetX</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the x pixel size that the content rect of a tab is
being inset from the tab rect for style <SAMP>style</SAMP>.
This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TAB_INSET_X</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleTabInsetY"><HR><H4>vnotebookGetStyleTabInsetY</H4></A>
<PRE>
        int <B>vnotebookGetStyleTabInsetY</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the y pixel size that the content rect of a tab is
being inset from the tab rect for style <SAMP>style</SAMP>.
This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TAB_INSET_Y</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleTabSelectRaise"><HR><H4>vnotebookGetStyleTabSelectRaise</H4></A>
<PRE>
        int <B>vnotebookGetStyleTabSelectRaise</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the pixel height that the tab is raised when the
tab is selected for a style <SAMP>style</SAMP>. This method
is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TAB_SELECT_RAISE</CODE>
constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleTabSelectResize"><HR><H4>vnotebookGetStyleTabSelectResize</H4></A>
<PRE>
        int <B>vnotebookGetStyleTabSelectResize</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the pixel amount that each side of the tab rect is
widened when the tab is selected for a style
<SAMP>style</SAMP>. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TAB_SELECT_RESIZE</CODE>
constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleTabSetButtonsCentered"><HR><H4>vnotebookGetStyleTabSetButtonsCentered</H4></A>
<PRE>
        int <B>vnotebookGetStyleTabSetButtonsCentered</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the tabset buttons are being
centered inside the tabset for the style
<SAMP>style</SAMP>. If it returns <SAMP>FALSE</SAMP> the tabset
buttons are being drawn closer to the page. This method
is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TABSET_BUTTONS_CENTERED</CODE>
constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleTabSetButtonsPlacement"><HR><H4>vnotebookGetStyleTabSetButtonsPlacement</H4></A>
<PRE>
        int <B>vnotebookGetStyleTabSetButtonsPlacement</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the type of tabset button placement for the
style <SAMP>style</SAMP>. This will determine if the tabset
buttons are being placed adjacent to each other or on
opposite ends of the tabset. The returned constant can be
<CODE>vnotebookTABSET_BUTTONS_SEPARATE</CODE>, or
<CODE>vnotebookTABSET_BUTTONS_ADJACENT</CODE>. This method
is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TABSET_BUTTONS_PLACEMENT</CODE>
constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleTabSetPartialTabs"><HR><H4>vnotebookGetStyleTabSetPartialTabs</H4></A>
<PRE>
        int <B>vnotebookGetStyleTabSetPartialTabs</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the tabs that do not entirely
fit in the tabset are being shown as partial tabs for the
style <SAMP>style</SAMP>. If it returns <SAMP>FALSE</SAMP>
any tab that cannot fit into the tabset will not be shown
at all. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TABSET_PARTIAL_TABS</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleTabSpacing"><HR><H4>vnotebookGetStyleTabSpacing</H4></A>
<PRE>
        int <B>vnotebookGetStyleTabSpacing</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the pixel distance between the tabs for a
style <SAMP>style</SAMP>. The pixel distance may be
negative for overlapping tabs. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TAB_SPACING</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleTabStyle"><HR><H4>vnotebookGetStyleTabStyle</H4></A>
<PRE>
        int <B>vnotebookGetStyleTabStyle</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the border style for the tabs from the style
<SAMP>style</SAMP>. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TAB_STYLE</CODE> constant. The return
value can be:
<dl>
<dt><CODE>vnotebookTAB_STYLE_RECT</CODE>
<dd>Tabs will be drawn with a rectangle for a border.

<dt><CODE>vnotebookTAB_STYLE_ROUND_RECT</CODE>
<dd>Tabs will be drawn with a round rectangle for a border.

<dt><CODE>vnotebookTAB_STYLE_BEVELED</CODE>
<dd>Tabs will be drawn with a polygon with beveled corners for a border.
</dl>
</DD></DL>
<P>
<A NAME="vnotebookGetStyleTabs"><HR><H4>vnotebookGetStyleTabs</H4></A>
<PRE>
        int <B>vnotebookGetStyleTabs</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns the type of tabs for the style <SAMP>style</SAMP>.
The returned constant can be:

<dl>
<dt><CODE>vnotebookTABS_NONE</CODE>
<dd>Tabs will not be
shown.

<dt><CODE>vnotebookTABS_PAGE</CODE>
<dd>Tabs will be shown as having a one-to-one correspondence with pages.

<dt><CODE>vnotebookTABS_MAJOR</CODE>
<dd>Only major tabs will be shown. These are top level pages and sections.

<dt><CODE>vnotebookTABS_MAJOR_AND_MINOR</CODE>
<dd>Both major and minor tabs will be shown. Each top level section
will have a separate group of tabs for its pages.
</dl>

This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TABS</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetStyleVerticalTabs"><HR><H4>vnotebookGetStyleVerticalTabs</H4></A>
<PRE>
        int <B>vnotebookGetStyleVerticalTabs</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the tabs on either side of the
page are being drawn vertically for the style
<SAMP>style</SAMP>. If the return value is
<CODE>vnotebookVERTICAL_TABS_ROTATED</CODE> the tabs on
either side of the page are drawn vertically with rotated
text. If the return value is
<CODE>vnotebookVERTICAL_TABS_NORMAL</CODE> the
side tabs are drawn horizontally with upright non-rotated
text. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_VERTICAL_TABS</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookGetTabClass"><HR><H4>vnotebookGetTabClass</H4></A>
<PRE>
        vnotebookTabClass * <B>vnotebookGetTabClass</B>(
                vnotebookTab * tab);
</PRE>

<DL><DD>
Returns the tab class of the tab <SAMP>tab</SAMP>.
This method is implemented by calling <CODE><A HREF="vdialog-x.html#vdialogGetItemClass"><CODE>vdialogGetItemClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookGetTabContentSize"><HR><H4>vnotebookGetTabContentSize</H4></A>
<PRE>
        void <B>vnotebookGetTabContentSize</B>(
                vnotebookTab * tab,
                int * w,
                int * h);
</PRE>

<DL><DD>
Returns the width <SAMP>w</SAMP>, and the height
<SAMP>h</SAMP>, of the content of the tab <SAMP>tab</SAMP>.
This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookGET_TAB_CONTENT_SIZE"><CODE>vnotebookGET_TAB_CONTENT_SIZE</CODE></A></CODE> message to the
tab.
</DD></DL>
<P>
<A NAME="vnotebookGetTabData"><HR><H4>vnotebookGetTabData</H4></A>
<PRE>
        const void * <B>vnotebookGetTabData</B>(
                vnotebookTab * tab);
</PRE>

<DL><DD>
Returns the generic data pointer attached to the tab
<SAMP>tab</SAMP>, which can be <SAMP>NULL</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookGetTabImage"><HR><H4>vnotebookGetTabImage</H4></A>
<PRE>
        vimage * <B>vnotebookGetTabImage</B>(
                vnotebookTab * tab);
</PRE>

<DL><DD>
Returns the image displayed with the tab <SAMP>tab</SAMP>.
This method is implemented by retrieving the dialog item through
<CODE><A HREF="vnotebook-x.html#vnotebookGetTabItem"><CODE>vnotebookGetTabItem</CODE></A></CODE> and calling
<CODE><A HREF="vdialog-x.html#vdialogGetItemImage"><CODE>vdialogGetItemImage</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookGetTabImageNone"><HR><H4>vnotebookGetTabImageNone</H4></A>
<PRE>
        int <B>vnotebookGetTabImageNone</B>(
                vnotebookTab * tab);
</PRE>

<DL><DD>
Returns whether the tab <SAMP>tab</SAMP> should
inherit an image. <SAMP>TRUE</SAMP> is returned if the tab
will inherit it's image from its own dialog item or from
the tab of a section in which the page associated with the
tab belongs.
</DD></DL>
<P>
<A NAME="vnotebookGetTabItem"><HR><H4>vnotebookGetTabItem</H4></A>
<PRE>
        vdialogItem * <B>vnotebookGetTabItem</B>(
                vnotebookTab * tab);
</PRE>

<DL><DD>
Returns the dialog item from which the tab <SAMP>tab</SAMP>
was subclassed.
</DD></DL>
<P>
<A NAME="vnotebookGetTabPage"><HR><H4>vnotebookGetTabPage</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookGetTabPage</B>(
                vnotebookTab * tab);
</PRE>

<DL><DD>
Returns the page associated with the tab <SAMP>tab</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookGetTabSetClipRects"><HR><H4>vnotebookGetTabSetClipRects</H4></A>
<PRE>
        vrect * <B>vnotebookGetTabSetClipRects</B>(
                vnotebook * notebook,
                vdialogItem * tabset,
                int * rectCount);
</PRE>

<DL><DD>
Returns the count <SAMP>rectCount</SAMP> and a set of
rectangles that define the area of the notebook
<SAMP>notebook</SAMP> that is clipped out by the tabset
<SAMP>tabset</SAMP>. The rectangle set should have been
allocated by the <CODE>vrectSET</CODE> family of functions. The
rectangle set should be destroyed by the user. This method
is implemented by sending the message
<CODE><A HREF="vnotebook-x.html#vnotebookGET_TABSET_CLIP_RECTS"><CODE>vnotebookGET_TABSET_CLIP_RECTS</CODE></A></CODE> to the
notebook.
</DD></DL>
<P>
<A NAME="vnotebookGetTabSetSize"><HR><H4>vnotebookGetTabSetSize</H4></A>
<PRE>
        void <B>vnotebookGetTabSetSize</B>(
                vnotebook * notebook,
                vdialogItem * tabset,
                int * w,
                int * h);
</PRE>

<DL><DD>
Returns the width <SAMP>w</SAMP>, and the height
<SAMP>h</SAMP> of the tabset <SAMP>tabset</SAMP> for the
notebook <SAMP>notebook</SAMP>. This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookGET_TABSET_SIZE"><CODE>vnotebookGET_TABSET_SIZE</CODE></A></CODE> message to the
notebook.
</DD></DL>
<P>
<A NAME="vnotebookGetTabSetTabAt"><HR><H4>vnotebookGetTabSetTabAt</H4></A>
<PRE>
        vnotebookTab * <B>vnotebookGetTabSetTabAt</B>(
                vnotebook * notebook,
                vdialogItem * tabset,
                int index);
</PRE>

<DL><DD>
Returns the tab indexed at <SAMP>index</SAMP> inside the
tabset <SAMP>tabset</SAMP> for the notebook
<SAMP>notebook</SAMP>. This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookGET_TABSET_TAB_AT"><CODE>vnotebookGET_TABSET_TAB_AT</CODE></A></CODE> message to the
notebook.
</DD></DL>
<P>
<A NAME="vnotebookGetTabSetTabCount"><HR><H4>vnotebookGetTabSetTabCount</H4></A>
<PRE>
        int <B>vnotebookGetTabSetTabCount</B>(
                vnotebook * notebook,
                vdialogItem * tabset);
</PRE>

<DL><DD>
Returns the number of tabs inside the tabset
<SAMP>tabset</SAMP> for the notebook <SAMP>notebook</SAMP>.
This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookGET_TABSET_TAB_COUNT"><CODE>vnotebookGET_TABSET_TAB_COUNT</CODE></A></CODE> message to the
notebook.
</DD></DL>
<P>
<A NAME="vnotebookGetTabTabSet"><HR><H4>vnotebookGetTabTabSet</H4></A>
<PRE>
        vdialogItem * <B>vnotebookGetTabTabSet</B>(
                vnotebookTab * tab);
</PRE>

<DL><DD>
Returns the tabset associated with the tab
<SAMP>tab</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookGetTabTitle"><HR><H4>vnotebookGetTabTitle</H4></A>
<PRE>
        const vchar * <B>vnotebookGetTabTitle</B>(
                vnotebookTab * tab);
</PRE>

<DL><DD>
Returns the title of the tab <SAMP>tab</SAMP>. If one
does not exist it will return the title of the page
associated with the tab. This method is implemented by retrieving the
dialog item of the tab or page by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetTabItem"><CODE>vnotebookGetTabItem</CODE></A></CODE> or
<SAMP><A HREF="vnotebook-x.html#vnotebookGetPageItem"><CODE>vnotebookGetPageItem</CODE></A></SAMP> respectively.
<CODE><A HREF="vdialog-x.html#vdialogGetItemTitle"><CODE>vdialogGetItemTitle</CODE></A></CODE> is then called with the
dialog item.
</DD></DL>
<P>
<A NAME="vnotebookInit"><HR><H4>vnotebookInit</H4></A>
<PRE>
        void <B>vnotebookInit</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Initializes a notebook of the default notebook class in the
memory addressed by <SAMP>notebook</SAMP>. The new notebook
has no pages or sections. The attributes of the notebook
are set to their default values, according to the default
notebook class. A call to <CODE><A HREF="vnotebook-x.html#vnotebookDestroy"><CODE>vnotebookDestroy</CODE></A></CODE>
will free any internal or owned objects but will not free
the initial storage. This method is implemented with a call to
<CODE><A HREF="vnotebook-x.html#vnotebookInitOfClass"><CODE>vnotebookInitOfClass</CODE></A></CODE> with the default notebook
class.
</DD></DL>
<P>
<A NAME="vnotebookInitOfClass"><HR><H4>vnotebookInitOfClass</H4></A>
<PRE>
        void <B>vnotebookInitOfClass</B>(
                vnotebook * notebook,
                vnotebookClass * clas);
</PRE>

<DL><DD>
Initializes a notebook of the notebook class
<SAMP>clas</SAMP> in the memory addressed by
<SAMP>notebook</SAMP>. The new notebook has no pages or sections.
The attributes of the notebook are set to their default
values. A call to <CODE><A HREF="vnotebook-x.html#vnotebookDestroy"><CODE>vnotebookDestroy</CODE></A></CODE> will free
any internal or owned objects but will not free the initial
storage. This method is implemented with a call to
<CODE><A HREF="vdialog-x.html#vdialogInitItemOfClass"><CODE>vdialogInitItemOfClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookInitPage"><HR><H4>vnotebookInitPage</H4></A>
<PRE>
        void <B>vnotebookInitPage</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Initializes a page of the default page class in the memory
addressed by <SAMP>page</SAMP>. The attributes of the page
are set to their default values, according to the default
page class. A call to <CODE><A HREF="vnotebook-x.html#vnotebookDestroyPage"><CODE>vnotebookDestroyPage</CODE></A></CODE>
will free any internal or owned objects but will not free
the initial storage. This method is implemented with a call to
<CODE><A HREF="vnotebook-x.html#vnotebookInitPageOfClass"><CODE>vnotebookInitPageOfClass</CODE></A></CODE> with the default page
class.
</DD></DL>
<P>
<A NAME="vnotebookInitPageOfClass"><HR><H4>vnotebookInitPageOfClass</H4></A>
<PRE>
        void <B>vnotebookInitPageOfClass</B>(
                vnotebookPage * page,
                vnotebookPageClass * clas);
</PRE>

<DL><DD>
Initializes a page of the page class <SAMP>clas</SAMP> in
the memory addressed by <SAMP>page</SAMP>. The attributes
of the page are set to their default values. A call to
<CODE><A HREF="vnotebook-x.html#vnotebookDestroyPage"><CODE>vnotebookDestroyPage</CODE></A></CODE> will free any internal or
owned objects but will not free the initial storage. This
method is implemented with a call to
<CODE><A HREF="vdialog-x.html#vdialogInitItemOfClass"><CODE>vdialogInitItemOfClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookInitSection"><HR><H4>vnotebookInitSection</H4></A>
<PRE>
        void <B>vnotebookInitSection</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Initializes a section of the default section class in the
memory addressed by <SAMP>section</SAMP>. The attributes of
the section are set to their default values, according to
the default section class. A call to
<CODE><A HREF="vnotebook-x.html#vnotebookDestroySection"><CODE>vnotebookDestroySection</CODE></A></CODE> will free any internal
or owned objects but will not free the initial storage.
This method is implemented with a call to
<CODE><A HREF="vnotebook-x.html#vnotebookInitSectionOfClass"><CODE>vnotebookInitSectionOfClass</CODE></A></CODE> with the default
section class.
</DD></DL>
<P>
<A NAME="vnotebookInitSectionOfClass"><HR><H4>vnotebookInitSectionOfClass</H4></A>
<PRE>
        void <B>vnotebookInitSectionOfClass</B>(
                vnotebookSection * section,
                vnotebookSectionClass * clas);
</PRE>

<DL><DD>
Initializes a section of the section class
<SAMP>clas</SAMP> in the memory addressed by
<SAMP>section</SAMP>. The attributes of the section are set to
their default values. A call to
<CODE><A HREF="vnotebook-x.html#vnotebookDestroySection"><CODE>vnotebookDestroySection</CODE></A></CODE> will free any internal
or owned objects but will not free the initial storage.
This method is implemented with a call to
<CODE><A HREF="vdialog-x.html#vdialogInitItemOfClass"><CODE>vdialogInitItemOfClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookInitStyle"><HR><H4>vnotebookInitStyle</H4></A>
<PRE>
        void <B>vnotebookInitStyle</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Initializes a style of the default style class in the
memory addressed by <SAMP>style</SAMP>. The attributes of
the style are set to their default values, according to the
default style class. A call to
<CODE><A HREF="vnotebook-x.html#vnotebookDestroyStyle"><CODE>vnotebookDestroyStyle</CODE></A></CODE> will free any internal
or owned objects but will not free the initial storage.
</DD></DL>
<P>
<A NAME="vnotebookInitStyleOfClass"><HR><H4>vnotebookInitStyleOfClass</H4></A>
<PRE>
        void <B>vnotebookInitStyleOfClass</B>(
                vnotebookStyle * style,
                vnotebookStyleClass * clas);
</PRE>

<DL><DD>
Initializes a style of the style class <SAMP>clas</SAMP> in
the memory addressed by <SAMP>style</SAMP>. The attributes
of the style are set to their default values. A call to
<CODE><A HREF="vnotebook-x.html#vnotebookDestroyStyle"><CODE>vnotebookDestroyStyle</CODE></A></CODE> will free any internal
or owned objects but will not free the initial storage.
This method is implemented with a call to
<CODE><A HREF="vobject-x.html#vobjectInitOfClass"><CODE>vobjectInitOfClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookInitTab"><HR><H4>vnotebookInitTab</H4></A>
<PRE>
        void <B>vnotebookInitTab</B>(
                vnotebookTab * tab);
</PRE>

<DL><DD>
Initializes a tab of the default tab class in the memory
addressed by <SAMP>tab</SAMP>. The attributes of the tab
are set to their default values, according to the default
tab class. A call to <CODE><A HREF="vnotebook-x.html#vnotebookDestroyTab"><CODE>vnotebookDestroyTab</CODE></A></CODE> will
free any internal or owned objects but will not free the
initial storage. This method is implemented with a call to
<CODE><A HREF="vnotebook-x.html#vnotebookInitTabOfClass"><CODE>vnotebookInitTabOfClass</CODE></A></CODE> with the default tab
class.
</DD></DL>
<P>
<A NAME="vnotebookInitTabOfClass"><HR><H4>vnotebookInitTabOfClass</H4></A>
<PRE>
        void <B>vnotebookInitTabOfClass</B>(
                vnotebookTab * tab,
                vnotebookTabClass * clas);
</PRE>

<DL><DD>
Initializes a tab of the tab class <SAMP>clas</SAMP> in the
memory addressed by <SAMP>tab</SAMP>. The attributes of the
tab are set to their default values. A call to
<CODE><A HREF="vnotebook-x.html#vnotebookDestroyTab"><CODE>vnotebookDestroyTab</CODE></A></CODE> will free any internal or
owned objects but will not free the initial storage. This
method is implemented with a call to
<CODE><A HREF="vdialog-x.html#vdialogInitItemOfClass"><CODE>vdialogInitItemOfClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookIsTabImageMask"><HR><H4>vnotebookIsTabImageMask</H4></A>
<PRE>
        int <B>vnotebookIsTabImageMask</B>(
                vnotebookTab * tab);
</PRE>

<DL><DD>
Returns whether the tab <SAMP>tab</SAMP> has an
image that is a mask. Returns <SAMP>TRUE</SAMP> if the
image of the tab <SAMP>tab</SAMP> is actually a mask.
</DD></DL>
<P>
<A NAME="vnotebookLoad"><HR><H4>vnotebookLoad</H4></A>
<PRE>
        vnotebook * <B>vnotebookLoad</B>(
                vresource resource);
</PRE>

<DL><DD>
Reads a notebook from the resource <SAMP>resource</SAMP>
and returns a pointer to its contents. Storage for the
notebook object is allocated by the Notebook class. This
function essentially allocates space for a new instance and
calls <CODE><A HREF="vnotebook-x.html#vnotebookLoadInit"><CODE>vnotebookLoadInit</CODE></A></CODE> on it.
</DD></DL>
<P>
<A NAME="vnotebookLoadInit"><HR><H4>vnotebookLoadInit</H4></A>
<PRE>
        void <B>vnotebookLoadInit</B>(
                vnotebook * notebook,
                vresource resource);
</PRE>

<DL><DD>
Reads a notebook from the resource <SAMP>resource</SAMP>
and stores it in the uninitialized memory addressed by
<SAMP>notebook</SAMP>. The user is responsible for
allocating the necessary memory into which the notebook
will be initialized.
</DD></DL>
<P>
<A NAME="vnotebookLoadInitPage"><HR><H4>vnotebookLoadInitPage</H4></A>
<PRE>
        void <B>vnotebookLoadInitPage</B>(
                vnotebookPage * page,
                vresource resource);
</PRE>

<DL><DD>
Reads a notebook from the resource <SAMP>resource</SAMP>
and stores it in the uninitialized memory addressed by
<SAMP>page.</SAMP> The user is responsible for allocating
the necessary memory into which the page will be
initialized.
</DD></DL>
<P>
<A NAME="vnotebookLoadInitSection"><HR><H4>vnotebookLoadInitSection</H4></A>
<PRE>
        void <B>vnotebookLoadInitSection</B>(
                vnotebookSection * section,
                vresource resource);
</PRE>

<DL><DD>
Reads a notebook from the resource <SAMP>resource</SAMP>
and stores it in the uninitialized memory addressed by
<SAMP>section.</SAMP> The user is responsible for
allocating the necessary memory into which the section will
be initialized.
</DD></DL>
<P>
<A NAME="vnotebookLoadInitStyle"><HR><H4>vnotebookLoadInitStyle</H4></A>
<PRE>
        void <B>vnotebookLoadInitStyle</B>(
                vnotebookStyle * style,
                vresource resource);
</PRE>

<DL><DD>
Reads a notebook from the resource <SAMP>resource</SAMP>
and stores it in the uninitialized memory addressed by
<SAMP>style.</SAMP> The user is responsible for allocating
the necessary memory into which the style will be
initialized.
</DD></DL>
<P>
<A NAME="vnotebookLoadInitTab"><HR><H4>vnotebookLoadInitTab</H4></A>
<PRE>
        void <B>vnotebookLoadInitTab</B>(
                vnotebookTab * tab,
                vresource resource);
</PRE>

<DL><DD>
Reads a notebook from the resource <SAMP>resource</SAMP>
and stores it in the uninitialized memory addressed by
<SAMP>tab.</SAMP> The user is responsible for allocating
the necessary memory into which the tab will be
initialized.
</DD></DL>
<P>
<A NAME="vnotebookLoadPage"><HR><H4>vnotebookLoadPage</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookLoadPage</B>(
                vresource resource);
</PRE>

<DL><DD>
Reads a page from the resource <SAMP>resource</SAMP> and
returns a pointer to its contents. Storage for the page
object is allocated by the Notebook class. This function
essentially allocates space for a new instance and calls
<CODE><A HREF="vnotebook-x.html#vnotebookLoadInitPage"><CODE>vnotebookLoadInitPage</CODE></A></CODE> on it.
</DD></DL>
<P>
<A NAME="vnotebookLoadSection"><HR><H4>vnotebookLoadSection</H4></A>
<PRE>
        vnotebookSection * <B>vnotebookLoadSection</B>(
                vresource resource);
</PRE>

<DL><DD>
Reads a section from the resource <SAMP>resource</SAMP> and
returns a pointer to its contents. Storage for the section
object is allocated by the Notebook class. This function
essentially allocates space for a new instance and calls
<CODE><A HREF="vnotebook-x.html#vnotebookLoadInitSection"><CODE>vnotebookLoadInitSection</CODE></A></CODE> on it.
</DD></DL>
<P>
<A NAME="vnotebookLoadStyle"><HR><H4>vnotebookLoadStyle</H4></A>
<PRE>
        vnotebookStyle * <B>vnotebookLoadStyle</B>(
                vresource resource);
</PRE>

<DL><DD>
Reads a style from the resource <SAMP>resource</SAMP> and
returns a pointer to its contents. Storage for the style
object is allocated by the Notebook class. This function
essentially allocates space for a new instance and calls
<CODE><A HREF="vnotebook-x.html#vnotebookLoadInitStyle"><CODE>vnotebookLoadInitStyle</CODE></A></CODE> on it.
</DD></DL>
<P>
<A NAME="vnotebookLoadTab"><HR><H4>vnotebookLoadTab</H4></A>
<PRE>
        vnotebookTab * <B>vnotebookLoadTab</B>(
                vresource resource);
</PRE>

<DL><DD>
Reads a tab from the resource <SAMP>resource</SAMP> and
returns a pointer to its contents. Storage for the tab
object is allocated by the Notebook class. This function
essentially allocates space for a new instance and calls
<CODE><A HREF="vnotebook-x.html#vnotebookLoadInitTab"><CODE>vnotebookLoadInitTab</CODE></A></CODE> on it.
</DD></DL>
<P>
<A NAME="vnotebookPageIsNotebook"><HR><H4>vnotebookPageIsNotebook</H4></A>
<PRE>
        int <B>vnotebookPageIsNotebook</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the page <SAMP>page</SAMP> is
a notebook, <SAMP>FALSE</SAMP> if it is not. This method is implemented by
calling <CODE><A HREF="vclass-x.html#vclassIsKindOf"><CODE>vclassIsKindOf</CODE></A></CODE> with the default
notebook class. This will determine if the page is derived
from the default notebook class.
</DD></DL>
<P>
<A NAME="vnotebookPageIsSection"><HR><H4>vnotebookPageIsSection</H4></A>
<PRE>
        int <B>vnotebookPageIsSection</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the page <SAMP>page</SAMP> is
a section, <SAMP>FALSE</SAMP> if it is not. This method is implemented by
calling <CODE><A HREF="vclass-x.html#vclassIsKindOf"><CODE>vclassIsKindOf</CODE></A></CODE> with the default
section class. This will determine if the page is derived
from the default section class.
</DD></DL>
<P>
<A NAME="vnotebookPageIsSelected"><HR><H4>vnotebookPageIsSelected</H4></A>
<PRE>
        int <B>vnotebookPageIsSelected</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the page <SAMP>page</SAMP> is
currently selected, <SAMP>FALSE</SAMP> if not.
</DD></DL>
<P>
<A NAME="vnotebookPageIsValid"><HR><H4>vnotebookPageIsValid</H4></A>
<PRE>
        int <B>vnotebookPageIsValid</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the page <SAMP>page</SAMP> is
in a valid state, <SAMP>FALSE</SAMP> if not. This method
is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookPAGE_IS_VALID"><CODE>vnotebookPAGE_IS_VALID</CODE></A></CODE> message to the page.
The default function always returns <SAMP>TRUE</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookRecalc"><HR><H4>vnotebookRecalc</H4></A>
<PRE>
        void <B>vnotebookRecalc</B>(
                vnotebook * notebook);
</PRE>

<DL><DD>
Recalculates the positions, sizes, and state of all the
various elements that comprise the notebook
<SAMP>notebook</SAMP>. This function is called when the size of
the notebook changes or the styles associated with a
notebook changes. This method is implemented by sending the message
<CODE><A HREF="vnotebook-x.html#vnotebookRECALC"><CODE>vnotebookRECALC</CODE></A></CODE> to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookRecalcTabSetTabs"><HR><H4>vnotebookRecalcTabSetTabs</H4></A>
<PRE>
        void <B>vnotebookRecalcTabSetTabs</B>(
                vnotebook * notebook,
                vdialogItem * tabset);
</PRE>

<DL><DD>
Recalculates the tabs that belong in the tabset
<SAMP>tabset</SAMP> from the notebook <SAMP>notebook</SAMP>. The
Notebook class uses this function internally when a page
or section is added, deleted, or moved. This method is implemented
by sending the message
<CODE><A HREF="vnotebook-x.html#vnotebookRECALC_TABSET_TABS"><CODE>vnotebookRECALC_TABSET_TABS</CODE></A></CODE> to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookRemovePage"><HR><H4>vnotebookRemovePage</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookRemovePage</B>(
                vnotebook * notebook,
                vnotebookPage * page);
</PRE>

<DL><DD>
Removes the page <SAMP>page</SAMP> from the notebook. The
page is not destroyed. The user is responsible for
destroying the page. This function is implemented by
calling <CODE><A HREF="vcontainer-x.html#vcontainerDeleteItem"><CODE>vcontainerDeleteItem</CODE></A></CODE>. If the page is a
section then the entire section will be deleted. To delete
a section you must first retrieve the page object from the
notebook by calling <CODE>vnotebookGetPage</CODE>.
</DD></DL>
<P>
<A NAME="vnotebookRemoveSectionPage"><HR><H4>vnotebookRemoveSectionPage</H4></A>
<PRE>
        vnotebookPage * <B>vnotebookRemoveSectionPage</B>(
                vnotebookSection * section,
                vnotebookPage * Page);
</PRE>

<DL><DD>
Removes the page <SAMP>page</SAMP> from the section
<SAMP>section</SAMP>. The page is not destroyed. The user is
responsible for destroying the page. This function is
implemented by calling <CODE><A HREF="vcontainer-x.html#vcontainerDeleteItem"><CODE>vcontainerDeleteItem</CODE></A></CODE>.
If the page is a section then the entire section will be
deleted. To delete a section you must first retrieve the
page object from the section by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetSectionPage"><CODE>vnotebookGetSectionPage</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookRemoveTabSetTab"><HR><H4>vnotebookRemoveTabSetTab</H4></A>
<PRE>
        vnotebookTab * <B>vnotebookRemoveTabSetTab</B>(
                vnotebook * notebook,
                vdialogItem * tabset,
                vnotebookTab * tab);
</PRE>

<DL><DD>
Removes the tab <SAMP>tab</SAMP> from the tabset
<SAMP>tabset</SAMP> of the notebook <SAMP>notebook</SAMP>. This function is
normally called internal to the Notebook class and should
not be used as the standard method for removing a tab from a
tabset. When a page is removed from a notebook, the tab
associated with the page is automatically removed from the
tabset. The tab is not destroyed because it is owned by the
page.  This method is implemented by sending a
<CODE><A HREF="vnotebook-x.html#vnotebookREMOVE_TABSET_TAB"><CODE>vnotebookREMOVE_TABSET_TAB</CODE></A></CODE> message to the notebook. 
</DD></DL>
<P>
<A NAME="vnotebookScrollTabSetTabIntoView"><HR><H4>vnotebookScrollTabSetTabIntoView</H4></A>
<PRE>
        void <B>vnotebookScrollTabSetTabIntoView</B>(
                vnotebook * notebook,
                vdialogItem * tabset,
                vnotebookTab * tab);
</PRE>

<DL><DD>
Scrolls the tabset <SAMP>tabset</SAMP> of the
notebook <SAMP>notebook</SAMP> until the tab
<SAMP>tab</SAMP> is completely visible. If the tab is
already in view then it does nothing. This method is implemented by
sending a <CODE><A HREF="vnotebook-x.html#vnotebookSCROLL_TABSET_TAB_INTO_VIEW"><CODE>vnotebookSCROLL_TABSET_TAB_INTO_VIEW</CODE></A></CODE>
message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookSetCurrentPage"><HR><H4>vnotebookSetCurrentPage</H4></A>
<PRE>
        void <B>vnotebookSetCurrentPage</B>(
                vnotebook * notebook,
                vnotebookPage * page);
</PRE>

<DL><DD>
Changes the current page of the notebook
<SAMP>notebook</SAMP> to <SAMP>current</SAMP>. This method is implemented
by calling <CODE><A HREF="vnotebook-x.html#vnotebookSetSectionCurrentPage"><CODE>vnotebookSetSectionCurrentPage</CODE></A></CODE> with
the section object of the notebook.
</DD></DL>
<P>
<A NAME="vnotebookSetData"><HR><H4>vnotebookSetData</H4></A>
<PRE>
        void <B>vnotebookSetData</B>(
                vnotebook * notebook,
                const void * data);
</PRE>

<DL><DD>
Sets the generic data pointer of the notebook
<SAMP>notebook</SAMP> to <SAMP>data</SAMP>. This can be set to
any pointer the user chooses to attach to the notebook and
may be <SAMP>NULL</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookSetNotify"><HR><H4>vnotebookSetNotify</H4></A>
<PRE>
        void <B>vnotebookSetNotify</B>(
                vnotebook * notebook,
                vnotebookNoteProc noteProc);
</PRE>

<DL><DD>
Changes the instance notification procedure for the
notebook <SAMP>notebook</SAMP> to <SAMP>noteProc</SAMP>.
This function is called when the notebook handles an event
of some importance. In the default notebook, no
notification is currently given. If notification is needed,
you should override the appropriate event handler. This
function is implemented by calling
<CODE><A HREF="vdialog-x.html#vdialogSetItemNotify"><CODE>vdialogSetItemNotify</CODE></A></CODE> with the dialog item
object of the notebook.
</DD></DL>
<P>
<A NAME="vnotebookSetPageCurrent"><HR><H4>vnotebookSetPageCurrent</H4></A>
<PRE>
        void <B>vnotebookSetPageCurrent</B>(
                vnotebookPage * page);
</PRE>

<DL><DD>
Sets the page <SAMP>page</SAMP> to be the current page. If
the page is a section and the section does not have a
current page, it will set the first page of the section to
be the current page. This method is implemented by calling either
<CODE><A HREF="vnotebook-x.html#vnotebookSetSectionFirstPage"><CODE>vnotebookSetSectionFirstPage</CODE></A></CODE> or
<CODE><A HREF="vnotebook-x.html#vnotebookSetSectionCurrentPage"><CODE>vnotebookSetSectionCurrentPage</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookSetPageData"><HR><H4>vnotebookSetPageData</H4></A>
<PRE>
        void <B>vnotebookSetPageData</B>(
                vnotebookPage * page,
                const void * data);
</PRE>

<DL><DD>
Sets the generic data pointer of the page <SAMP>page</SAMP>
to <SAMP>data</SAMP>. This can be set to any pointer the
user chooses to attach to the page and may be
<SAMP>NULL</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookSetPageIndex"><HR><H4>vnotebookSetPageIndex</H4></A>
<PRE>
        void <B>vnotebookSetPageIndex</B>(
                vnotebook * notebook,
                vnotebookPage * page,
                int index);
</PRE>

<DL><DD>
Changes the index for the page <SAMP>page</SAMP> in the
notebook <SAMP>notebook</SAMP> to <SAMP>index</SAMP>. If
the original index of page is less than <SAMP>index</SAMP>,
the page originally at position <SAMP>index</SAMP> and all
pages below it will slide down one position. If the
original index of page is higher than <SAMP>index</SAMP>,
the page originally at position <SAMP>index</SAMP> and all
pages above it will move up by one position. This method
is implemented with a call to
<CODE><A HREF="vcontainer-x.html#vcontainerSetItemIndex"><CODE>vcontainerSetItemIndex</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookSetPageNotify"><HR><H4>vnotebookSetPageNotify</H4></A>
<PRE>
        void <B>vnotebookSetPageNotify</B>(
                vnotebookPage * page,
                vnotebookPageNoteProc noteProc);
</PRE>

<DL><DD>
Changes the instance notification procedure for the
page <SAMP>page</SAMP> to <SAMP>noteProc</SAMP>. This
function is called when the page handles an event of some
importance. In the default page, no notification is
currently given. If notification is needed, you should
override the appropriate event handler. This function is
implemented by calling <CODE><A HREF="vdialog-x.html#vdialogSetItemNotify"><CODE>vdialogSetItemNotify</CODE></A></CODE>
with the dialog item object of the page.
</DD></DL>
<P>
<A NAME="vnotebookSetPageNumber"><HR><H4>vnotebookSetPageNumber</H4></A>
<PRE>
        void <B>vnotebookSetPageNumber</B>(
                vnotebookPage * page,
                int number);
</PRE>

<DL><DD>
Sets the page number of the page <SAMP>page</SAMP> to
<SAMP>number</SAMP>. This function is usually called for
internal use of the Notebook class. It is not called for
setting the ordering of a page, but merely attaches a
number to a page.
</DD></DL>
<P>
<A NAME="vnotebookSetPageTab"><HR><H4>vnotebookSetPageTab</H4></A>
<PRE>
        void <B>vnotebookSetPageTab</B>(
                vnotebookPage * page,
                vnotebookTab * tab);
</PRE>

<DL><DD>
Changes the tab of the page <SAMP>page</SAMP> to be
<SAMP>tab</SAMP>. The page will take ownership of the new
tab and will destroy the tab being replaced.
</DD></DL>
<P>
<A NAME="vnotebookSetSectionCurrentPage"><HR><H4>vnotebookSetSectionCurrentPage</H4></A>
<PRE>
        void <B>vnotebookSetSectionCurrentPage</B>(
                vnotebookSection * section,
                vnotebookPage * page);
</PRE>

<DL><DD>
Changes the current page of the section
<SAMP>section</SAMP> to <SAMP>current</SAMP>. This method is implemented
by sending a <CODE><A HREF="vcontainer-x.html#vcontainerSET_SELECTION"><CODE>vcontainerSET_SELECTION</CODE></A></CODE> message
to the section. To override this function you should
retrieve the container from the section with
<CODE><A HREF="vnotebook-x.html#vnotebookGetSectionContainer"><CODE>vnotebookGetSectionContainer</CODE></A></CODE> and override the
container's <CODE><A HREF="vcontainer-x.html#vcontainerSetSelection"><CODE>vcontainerSetSelection</CODE></A></CODE> method.
</DD></DL>
<P>
<A NAME="vnotebookSetSectionData"><HR><H4>vnotebookSetSectionData</H4></A>
<PRE>
        void <B>vnotebookSetSectionData</B>(
                vnotebookSection * section,
                const void * data);
</PRE>

<DL><DD>
Sets the generic data pointer of the section
<SAMP>section</SAMP> to <SAMP>data</SAMP>. This can be set to any
pointer the user chooses to attach to the section and may
be <SAMP>NULL</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookSetSectionFirstPage"><HR><H4>vnotebookSetSectionFirstPage</H4></A>
<PRE>
        void <B>vnotebookSetSectionFirstPage</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Changes the current page to be the first page of the
section <SAMP>section</SAMP>. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetSectionFirstPage"><CODE>vnotebookGetSectionFirstPage</CODE></A></CODE> and
<CODE><A HREF="vnotebook-x.html#vnotebookSetPageCurrent"><CODE>vnotebookSetPageCurrent</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookSetSectionLastPage"><HR><H4>vnotebookSetSectionLastPage</H4></A>
<PRE>
        void <B>vnotebookSetSectionLastPage</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Changes the current page to be the first page of the
section <SAMP>section</SAMP>. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetSectionLastPage"><CODE>vnotebookGetSectionLastPage</CODE></A></CODE> and
<CODE><A HREF="vnotebook-x.html#vnotebookSetPageCurrent"><CODE>vnotebookSetPageCurrent</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookSetSectionNextPage"><HR><H4>vnotebookSetSectionNextPage</H4></A>
<PRE>
        void <B>vnotebookSetSectionNextPage</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Changes the page after the current page in the
section <SAMP>section</SAMP> to be the current page. This
function does nothing if
<CODE><A HREF="vnotebook-x.html#vnotebookGetSectionNextPage"><CODE>vnotebookGetSectionNextPage</CODE></A></CODE> return
<SAMP>NULL</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookSetSectionNotify"><HR><H4>vnotebookSetSectionNotify</H4></A>
<PRE>
        void <B>vnotebookSetSectionNotify</B>(
                vnotebookSection * section,
                vnotebookSectionNoteProc noteProc);
</PRE>

<DL><DD>
Changes the instance notification procedure for the
section <SAMP>section</SAMP> to <SAMP>noteProc</SAMP>. This
function is called when the section handles an event of
some importance. In the default section, no notification is
currently given. If notification is needed, you should
override the appropriate event handler. This function is
implemented by calling <CODE><A HREF="vdialog-x.html#vdialogSetItemNotify"><CODE>vdialogSetItemNotify</CODE></A></CODE>
with the dialog item object of the section.
</DD></DL>
<P>
<A NAME="vnotebookSetSectionPageIndex"><HR><H4>vnotebookSetSectionPageIndex</H4></A>
<PRE>
        void <B>vnotebookSetSectionPageIndex</B>(
                vnotebookSection * section,
                vnotebookPage * page,
                int index);
</PRE>

<DL><DD>
Changes the index for the page <SAMP>page</SAMP> in the
section <SAMP>section</SAMP> to <SAMP>index</SAMP>. If the
original index of page is less than <SAMP>index</SAMP>, the
page originally at position <SAMP>index</SAMP> and all
pages below it will slide down one position. If the
original index of page is higher than <SAMP>index</SAMP>,
the page originally at position <SAMP>index</SAMP> and all
pages above it will move up by one position. This method
is implemented with a call to
<CODE><A HREF="vcontainer-x.html#vcontainerSetItemIndex"><CODE>vcontainerSetItemIndex</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookSetSectionPreviousPage"><HR><H4>vnotebookSetSectionPreviousPage</H4></A>
<PRE>
        void <B>vnotebookSetSectionPreviousPage</B>(
                vnotebookSection * section);
</PRE>

<DL><DD>
Changes the page before the current page in the
section <SAMP>section</SAMP> to be the current page. This
function does nothing if
<CODE><A HREF="vnotebook-x.html#vnotebookGetSectionPreviousPage"><CODE>vnotebookGetSectionPreviousPage</CODE></A></CODE> returns
<SAMP>NULL</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookSetStyle"><HR><H4>vnotebookSetStyle</H4></A>
<PRE>
        void <B>vnotebookSetStyle</B>(
                vnotebook * notebook,
                vnotebookStyle * style);
</PRE>

<DL><DD>
Sets the style <SAMP>style</SAMP> to the notebook
<SAMP>notebook</SAMP>. The style can be retrieved through
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyle"><CODE>vnotebookGetStyle</CODE></A></CODE>. This method is implemented by
sending a <CODE><A HREF="vnotebook-x.html#vnotebookSET_STYLE"><CODE>vnotebookSET_STYLE</CODE></A></CODE> message to the
notebook.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleBinding"><HR><H4>vnotebookSetStyleBinding</H4></A>
<PRE>
        void <B>vnotebookSetStyleBinding</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the type of the binding for the style
<SAMP>style</SAMP>. to be <SAMP>value</SAMP>. <SAMP>value</SAMP>
can be <CODE>vnotebookBINDING_PERFECT</CODE> for hard-cover
or <CODE>vnotebookBINDING_SPIRAL</CODE> for spiral. This method
is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_BINDING</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleBindingSize"><HR><H4>vnotebookSetStyleBindingSize</H4></A>
<PRE>
        void <B>vnotebookSetStyleBindingSize</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the pixel size of the binding for the style
<SAMP>style</SAMP> to <SAMP>value</SAMP>. This will determine the
height of the binding to be displayed with the notebook. This
method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_BINDING_SIZE</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleButtonBorderMargin"><HR><H4>vnotebookSetStyleButtonBorderMargin</H4></A>
<PRE>
        void <B>vnotebookSetStyleButtonBorderMargin</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the pixel margin between the page buttons and the
border of the page for the style <SAMP>style</SAMP> to
<SAMP>value</SAMP>. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_BUTTON_BORDER_MARGIN</CODE>
constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleButtonMargin"><HR><H4>vnotebookSetStyleButtonMargin</H4></A>
<PRE>
        void <B>vnotebookSetStyleButtonMargin</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the pixel margin between the page buttons for the
style <SAMP>style</SAMP> to <SAMP>value</SAMP>. This method
is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_BUTTON_MARGIN</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleFolio"><HR><H4>vnotebookSetStyleFolio</H4></A>
<PRE>
        void <B>vnotebookSetStyleFolio</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Designates if the folio will be displayed with the notebook
for style <SAMP>style</SAMP>. <SAMP>value</SAMP> can either
be <SAMP>TRUE</SAMP> or <SAMP>FALSE</SAMP>. If <SAMP>value</SAMP> is
<SAMP>TRUE</SAMP> the folio will be displayed. This method
is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_FOLIO</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleFolioButtonMargin"><HR><H4>vnotebookSetStyleFolioButtonMargin</H4></A>
<PRE>
        void <B>vnotebookSetStyleFolioButtonMargin</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the pixel margin between the page buttons and the
folio rect for the style <SAMP>style</SAMP> to
<SAMP>value</SAMP>. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_FOLIO_BUTTON_MARGIN</CODE>
constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleFolioJustification"><HR><H4>vnotebookSetStyleFolioJustification</H4></A>
<PRE>
        void <B>vnotebookSetStyleFolioJustification</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the folio justification for the style
<SAMP>style</SAMP> to <SAMP>value</SAMP>. This will determine if
the folio messages are to be justified to the left, center
or right side of the folio rect. <SAMP>value</SAMP> can be

<ul>
<li><CODE>vnotebookFOLIO_JUSTIFY_LEFT</CODE>
<li><CODE>vnotebookFOLIO_JUSTIFY_CENTER</CODE>
<li><CODE>vnotebookFOLIO_JUSTIFY_RIGHT</CODE>
</ul>

This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyleScalarValue"><CODE>vnotebookGetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_FOLIO_JUSTIFY</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleMajorTabSetSide"><HR><H4>vnotebookSetStyleMajorTabSetSide</H4></A>
<PRE>
        void <B>vnotebookSetStyleMajorTabSetSide</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the side of the page on which the major tabs will be
drawn for the style <SAMP>style</SAMP> to
<SAMP>value</SAMP>. <SAMP>value</SAMP> can be:

<ul>
<li><CODE>vnotebookTABSET_LEFT</CODE>
<li><CODE>vnotebookTABSET_RIGHT</CODE>
<li><CODE>vnotebookTABSET_TOP</CODE>
<li><CODE>vnotebookTABSET_BOTTOM</CODE>
</ul>

This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_MAJOR_TABSET_SIDE</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleMinorTabSetSide"><HR><H4>vnotebookSetStyleMinorTabSetSide</H4></A>
<PRE>
        void <B>vnotebookSetStyleMinorTabSetSide</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the side of the page on which the minor tabs will be
drawn for the style <SAMP>style</SAMP> to
<SAMP>value</SAMP>. <SAMP>value</SAMP> can be:

<ul>
<li><CODE>vnotebookTABSET_LEFT</CODE>
<li><CODE>vnotebookTABSET_RIGHT</CODE>
<li><CODE>vnotebookTABSET_TOP</CODE>
<li><CODE>vnotebookTABSET_BOTTOM</CODE>
</ul>

This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_MINOR_TABSET_SIDE</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleOwned"><HR><H4>vnotebookSetStyleOwned</H4></A>
<PRE>
        void <B>vnotebookSetStyleOwned</B>(
                vnotebook * notebook,
                vnotebookStyle * style);
</PRE>

<DL><DD>
Sets the style <SAMP>style</SAMP> to the notebook
<SAMP>notebook</SAMP> and gives ownership of the style to the
notebook. This means that the responsibility for destroying
the style now belongs to the Notebook class. It will
destroy the style when the notebook is destroyed. The style can be
retrieved through <CODE><A HREF="vnotebook-x.html#vnotebookGetStyle"><CODE>vnotebookGetStyle</CODE></A></CODE>. This method
is implemented by sending a <CODE><A HREF="vnotebook-x.html#vnotebookSET_STYLE"><CODE>vnotebookSET_STYLE</CODE></A></CODE>
message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookSetStylePageBorders"><HR><H4>vnotebookSetStylePageBorders</H4></A>
<PRE>
        void <B>vnotebookSetStylePageBorders</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Designates if a border will be drawn on the pages in a
notebook for style <SAMP>style</SAMP>. <SAMP>value</SAMP>
can either be <SAMP>TRUE</SAMP> or <SAMP>FALSE</SAMP>. If
it is <SAMP>TRUE</SAMP> the border will be drawn on each
page. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_PAGE_BORDERS</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStylePageButtons"><HR><H4>vnotebookSetStylePageButtons</H4></A>
<PRE>
        void <B>vnotebookSetStylePageButtons</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Designates if the page buttons will be displayed with the
notebook for the style <SAMP>style</SAMP>.
<SAMP>value</SAMP> can either be <SAMP>TRUE</SAMP> or
<SAMP>FALSE</SAMP>. If it is <SAMP>TRUE</SAMP> the page
buttons will be displayed with the notebook. This method
is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_PAGE_BUTTONS</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStylePageCount"><HR><H4>vnotebookSetStylePageCount</H4></A>
<PRE>
        void <B>vnotebookSetStylePageCount</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the number of pages that will be drawn for the
style <SAMP>style</SAMP> to <SAMP>value</SAMP>. These are
the graphical pages that are drawn to represent the pages
of the notebook. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_PAGE_COUNT</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStylePageInset"><HR><H4>vnotebookSetStylePageInset</H4></A>
<PRE>
        void <B>vnotebookSetStylePageInset</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the number of pixels that the content rect is being
inset from the page for style <SAMP>style</SAMP> to
<SAMP>value</SAMP>. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_PAGE_INSET</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStylePageInsetBorder"><HR><H4>vnotebookSetStylePageInsetBorder</H4></A>
<PRE>
        void <B>vnotebookSetStylePageInsetBorder</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the number of pixels that the content rect is being
inset from the page, given the page has a border, to
<SAMP>value</SAMP> for the style <SAMP>style</SAMP>.
This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<SAMP>vnotebookSTYLE_PAGE_INSET_BORDER</SAMP> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStylePageStep"><HR><H4>vnotebookSetStylePageStep</H4></A>
<PRE>
        void <B>vnotebookSetStylePageStep</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the number of pixels between the graphical pages that
are drawn to represent the notebook for the style
<SAMP>style</SAMP> to <SAMP>value</SAMP>. This method is implemented by
calling <CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_PAGE_STEP</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStylePagesWrap"><HR><H4>vnotebookSetStylePagesWrap</H4></A>
<PRE>
        void <B>vnotebookSetStylePagesWrap</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Designates if the pages should wrap for the style
<SAMP>style</SAMP>. <SAMP>value</SAMP> can either be
<SAMP>TRUE</SAMP> or <SAMP>FALSE</SAMP>.. If
<SAMP>TRUE</SAMP>, the first page will follow the last
page. If <SAMP>FALSE</SAMP>, the last page will disable the
<CODE>next</CODE> page button so that there is not a next page.
To get back to the first page you must back through all the
previous pages. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_PAGES_WRAP</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleScalarValue"><HR><H4>vnotebookSetStyleScalarValue</H4></A>
<PRE>
        void <B>vnotebookSetStyleScalarValue</B>(
                vnotebookStyle * style,
                int whichValue,
                int value);
</PRE>

<DL><DD>
Sets a value <SAMP>value</SAMP> of the given type of value
<SAMP>whichValue</SAMP> for the style <SAMP>style</SAMP>.
<SAMP>whichValue</SAMP> can be any of the
<CODE>vnotebookSTYLE</CODE> constants. This function is not
necessary in that all possible values can be set with a
specific <CODE>vnotebookSetStyle</CODE>  function.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleTabInsetX"><HR><H4>vnotebookSetStyleTabInsetX</H4></A>
<PRE>
        void <B>vnotebookSetStyleTabInsetX</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the x pixel size that the content rect of a tab is
being inset from the rect for style <SAMP>style</SAMP> to
<SAMP>value</SAMP>. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TAB_INSET_X</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleTabInsetY"><HR><H4>vnotebookSetStyleTabInsetY</H4></A>
<PRE>
        void <B>vnotebookSetStyleTabInsetY</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the y pixel size that the content rect of a tab is
being inset from the rect for style <SAMP>style</SAMP> to
<SAMP>value</SAMP>. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TAB_INSET_Y</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleTabSelectRaise"><HR><H4>vnotebookSetStyleTabSelectRaise</H4></A>
<PRE>
        void <B>vnotebookSetStyleTabSelectRaise</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the pixel height that the tab is raised when the tab
is selected for a style <SAMP>style</SAMP>. This method
is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TAB_SELECT_RAISE</CODE>
constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleTabSelectResize"><HR><H4>vnotebookSetStyleTabSelectResize</H4></A>
<PRE>
        void <B>vnotebookSetStyleTabSelectResize</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the pixel amount that each side of the tab rect is
widened when selected for a style <SAMP>style</SAMP>. This method
is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TAB_SELECT_RESIZE</CODE>
constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleTabSetButtonsCentered"><HR><H4>vnotebookSetStyleTabSetButtonsCentered</H4></A>
<PRE>
        void <B>vnotebookSetStyleTabSetButtonsCentered</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Designates if the tabset buttons should be centered inside
the tabset rect for style <SAMP>style</SAMP>.
<SAMP>value</SAMP> can be <SAMP>TRUE</SAMP> or
<SAMP>FALSE</SAMP>. If <SAMP>TRUE</SAMP> the tabset buttons
will be centered with respect to the side of the tabset
that is not touching the page. If <SAMP>FALSE</SAMP>, the
tabset buttons will be drawn nearer to the page. This method
is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TABSET_BUTTONS_CENTERED</CODE>
constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleTabSetButtonsPlacement"><HR><H4>vnotebookSetStyleTabSetButtonsPlacement</H4></A>
<PRE>
        void <B>vnotebookSetStyleTabSetButtonsPlacement</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the type of tabset button placement for the
style <SAMP>style</SAMP>. This will determine if the tabset
buttons are being placed adjacent to each other or on
opposite ends of the tabset. <SAMP>value</SAMP> can be
<CODE>vnotebookTABSET_BUTTONS_SEPARATE</CODE>, or
<CODE>vnotebookTABSET_BUTTONS_ADJACENT</CODE>. This method
is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TABSET_BUTTONS_PLACEMENT</CODE>
constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleTabSetPartialTabs"><HR><H4>vnotebookSetStyleTabSetPartialTabs</H4></A>
<PRE>
        void <B>vnotebookSetStyleTabSetPartialTabs</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Designates if partial tabs are to be displayed inside the
tabset for the style <SAMP>style</SAMP>. <SAMP>value</SAMP>
can be <SAMP>TRUE</SAMP> or <SAMP>FALSE</SAMP>. If
<SAMP>TRUE</SAMP>, the tabs that do not entirely fit in the
tabset will be shown as partial tabs. If
<SAMP>FALSE</SAMP>, any tab that cannot fit into the tabset
will not be shown at all. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TABSET_PARTIAL_TABS</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleTabSpacing"><HR><H4>vnotebookSetStyleTabSpacing</H4></A>
<PRE>
        void <B>vnotebookSetStyleTabSpacing</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the pixel distance between the tabs for a style
<SAMP>style</SAMP> to <SAMP>value</SAMP>. <SAMP>value</SAMP> may
be negative for overlapping tabs. This method is implemented by
calling <CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TAB_SPACING</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleTabStyle"><HR><H4>vnotebookSetStyleTabStyle</H4></A>
<PRE>
        void <B>vnotebookSetStyleTabStyle</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the border style of tabs for the style
<SAMP>style</SAMP> to <SAMP>value</SAMP>. <SAMP>value</SAMP> can
be:

<dl>
<dt><CODE>vnotebookTAB_STYLE_RECT</CODE>
<dd>Tabs will be drawn
with a rectangle for a border.

<dt><CODE>vnotebookTAB_STYLE_ROUND_RECT</CODE>
<dd>Tabs will be
drawn with a round rectangle for a border.

<dt><CODE>vnotebookTAB_STYLE_BEVELED</CODE>
<dd>Tabs will be drawn
with a polygon with beveled corners for a border.
</dl>

This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TAB_STYLE</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleTabs"><HR><H4>vnotebookSetStyleTabs</H4></A>
<PRE>
        void <B>vnotebookSetStyleTabs</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Sets the type of tabs for the style <SAMP>style</SAMP> to
<SAMP>value</SAMP>. <SAMP>value</SAMP> can be:

<dl>
<dt><CODE>vnotebookTABS_NONE</CODE>
<dd>Tabs will not be
shown.

<dt><CODE>vnotebookTABS_PAGE</CODE>
<dd>Tabs will be
shown as having a one-to-one correspondence with pages.

<dt><CODE>vnotebookTABS_MAJOR</CODE>
<dd>Only major tabs
will be shown. These are top level pages and sections.

<dt><CODE>vnotebookTABS_MAJOR_AND_MINOR</CODE>
<dd>Both
major and minor tabs will be shown. Each top level section
will have a separate group of tabs for its pages.
</dl>

This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_TABS</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetStyleVerticalTabs"><HR><H4>vnotebookSetStyleVerticalTabs</H4></A>
<PRE>
        void <B>vnotebookSetStyleVerticalTabs</B>(
                vnotebookStyle * style,
                int value);
</PRE>

<DL><DD>
Designates whether the side tabs should be drawn
vertically for the style <SAMP>style.</SAMP> <SAMP>value</SAMP> can be
<CODE>vnotebookVERTICAL_TABS_NORMAL</CODE> or
<CODE>vnotebookVERTICAL_TABS_ROTATED</CODE>. If <SAMP>value</SAMP> is
<CODE>vnotebookVERTICAL_TABS_ROTATED</CODE> the tabs on
either side of the page are drawn vertically with rotated
text. If <SAMP>value</SAMP> is
<CODE>vnotebookVERTICAL_TABS_NORMAL</CODE> the
side tabs are drawn horizontally with upright non-rotated
text. This method is implemented by calling
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleScalarValue"><CODE>vnotebookSetStyleScalarValue</CODE></A></CODE> with a
<CODE>vnotebookSTYLE_VERTICAL_TABS</CODE> constant.
</DD></DL>
<P>
<A NAME="vnotebookSetTabData"><HR><H4>vnotebookSetTabData</H4></A>
<PRE>
        void <B>vnotebookSetTabData</B>(
                vnotebookTab * tab,
                const void * data);
</PRE>

<DL><DD>
Sets the generic data pointer of the tab <SAMP>tab</SAMP>
to <SAMP>data</SAMP>. This can be set to any pointer the
user chooses to attach to the tab and may be
<SAMP>NULL</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookSetTabImage"><HR><H4>vnotebookSetTabImage</H4></A>
<PRE>
        void <B>vnotebookSetTabImage</B>(
                vnotebookTab * tab,
                vimage * image);
</PRE>

<DL><DD>
Changes the image of the tab <SAMP>tab</SAMP> to
<SAMP>image</SAMP>. This method is implemented by setting the image
of the parent dialog item object with
<CODE><A HREF="vdialog-x.html#vdialogSetItemImage"><CODE>vdialogSetItemImage</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookSetTabImageMask"><HR><H4>vnotebookSetTabImageMask</H4></A>
<PRE>
        void <B>vnotebookSetTabImageMask</B>(
                vnotebookTab * tab,
                int mask);
</PRE>

<DL><DD>
Sets whether the image of the tab <SAMP>tab</SAMP>
is to be used as a mask. If mask is <SAMP>TRUE</SAMP>, the
image will be used as a mask. This method is implemented by calling
<CODE><A HREF="vdialog-x.html#vdialogSetItemImageMask"><CODE>vdialogSetItemImageMask</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookSetTabImageNone"><HR><H4>vnotebookSetTabImageNone</H4></A>
<PRE>
        void <B>vnotebookSetTabImageNone</B>(
                vnotebookTab * tab,
                int value);
</PRE>

<DL><DD>
Sets the appropriate flags for the tab <SAMP>tab</SAMP> to
the value <SAMP>value</SAMP>. <SAMP>value</SAMP> can be
<SAMP>TRUE</SAMP> or <SAMP>FALSE</SAMP>. If it is
<SAMP>TRUE</SAMP> the tab will not inherit any image from
parent objects. If <SAMP>FALSE</SAMP>, the Notebook class
will search the dialog item object that the tab is derived
from for an image to inherit.
</DD></DL>
<P>
<A NAME="vnotebookSetTabImageOwned"><HR><H4>vnotebookSetTabImageOwned</H4></A>
<PRE>
        void <B>vnotebookSetTabImageOwned</B>(
                vnotebookTab * tab,
                vimage * image);
</PRE>

<DL><DD>
Changes the image of the tab <SAMP>tab</SAMP> to
<SAMP>image</SAMP>. It also turns over ownership of the tab
to the Notebook class which will be responsible for
destroying the image. This method is implemented by setting the
image of the parent dialog item object with
<CODE><A HREF="vdialog-x.html#vdialogSetItemImageOwned"><CODE>vdialogSetItemImageOwned</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookSetTabSetTabSelected"><HR><H4>vnotebookSetTabSetTabSelected</H4></A>
<PRE>
        void <B>vnotebookSetTabSetTabSelected</B>(
                vnotebook * notebook,
                vdialogItem * tabset,
                vnotebookTab * tab);
</PRE>

<DL><DD>
Sets the the selected tab of the tabset <SAMP>tabset</SAMP>
for the notebook <SAMP>notebook</SAMP> to <SAMP>tab</SAMP>.
If the tab is already the selected tab in the tabset, this
function does nothing. This method is implemented by sending the
message <CODE><A HREF="vnotebook-x.html#vnotebookSET_TABSET_TAB_SELECTED"><CODE>vnotebookSET_TABSET_TAB_SELECTED</CODE></A></CODE> to
the notebook.
</DD></DL>
<P>
<A NAME="vnotebookSetTabTabSet"><HR><H4>vnotebookSetTabTabSet</H4></A>
<PRE>
        void <B>vnotebookSetTabTabSet</B>(
                vnotebookTab * tab,
                vdialogItem * tabset);
</PRE>

<DL><DD>
Changes the tabset of the tab <SAMP>tab</SAMP> to the
<A HREF="vdialog-x.html#vdialogItem"><CODE>vdialogItem</CODE></A> <SAMP>tabset</SAMP>. The tabset does not belong
to the tab and will not be released when the tab is destroyed.
The notebook owns the tabset.
</DD></DL>
<P>
<A NAME="vnotebookSetTabTitle"><HR><H4>vnotebookSetTabTitle</H4></A>
<PRE>
        void <B>vnotebookSetTabTitle</B>(
                vnotebookTab * tab,
                const vchar * title);
</PRE>

<DL><DD>
Changes the title of the tab <SAMP>tab</SAMP> to
<SAMP>title</SAMP>. This method is implemented by setting the title
of the parent dialog item object with
<CODE><A HREF="vdialog-x.html#vdialogSetItemTitle"><CODE>vdialogSetItemTitle</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookSetTabTitleScribed"><HR><H4>vnotebookSetTabTitleScribed</H4></A>
<PRE>
        void <B>vnotebookSetTabTitleScribed</B>(
                vnotebookTab * tab,
                vscribe * scribe);
</PRE>

<DL><DD>
Changes the title of the tab <SAMP>tab</SAMP> to
<SAMP>scribe</SAMP>. This method is implemented by setting the title
of the parent dialog item object with
<CODE><A HREF="vdialog-x.html#vdialogSetItemTitleScribed"><CODE>vdialogSetItemTitleScribed</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookStartup"><HR><H4>vnotebookStartup</H4></A>
<PRE>
        void <B>vnotebookStartup</B>();
</PRE>

<DL><DD>
Initializes the Galaxy Notebook module. You must do this
before loading any notebooks. This function is
automatically called from <CODE><A HREF="vstartup-x.html#vstartup"><CODE>vstartup</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookStore"><HR><H4>vnotebookStore</H4></A>
<PRE>
        void <B>vnotebookStore</B>(
                vnotebook * notebook,
                vresource resource);
</PRE>

<DL><DD>
Writes the contents of the notebook <SAMP>notebook</SAMP>
into the resource <SAMP>resource</SAMP>. The item can be
recovered from the resource at a later time with
<CODE><A HREF="vnotebook-x.html#vnotebookLoad"><CODE>vnotebookLoad</CODE></A></CODE> or
<CODE><A HREF="vnotebook-x.html#vnotebookLoadInit"><CODE>vnotebookLoadInit</CODE></A></CODE>. This method is implemented by
sending a <CODE>vobjectSTORE</CODE> message to the
notebook.
</DD></DL>
<P>
<A NAME="vnotebookStorePage"><HR><H4>vnotebookStorePage</H4></A>
<PRE>
        void <B>vnotebookStorePage</B>(
                vnotebookPage * page,
                vresource resource);
</PRE>

<DL><DD>
Writes the contents of the page <SAMP>page</SAMP> into the
resource <SAMP>resource</SAMP>. The item can be recovered
from the resource at a later time with
<CODE><A HREF="vnotebook-x.html#vnotebookLoadPage"><CODE>vnotebookLoadPage</CODE></A></CODE> or
<CODE><A HREF="vnotebook-x.html#vnotebookLoadInitPage"><CODE>vnotebookLoadInitPage</CODE></A></CODE>. This method is implemented by
sending a <CODE>vobjectSTORE</CODE> message to the page.
</DD></DL>
<P>
<A NAME="vnotebookStoreSection"><HR><H4>vnotebookStoreSection</H4></A>
<PRE>
        void <B>vnotebookStoreSection</B>(
                vnotebookSection * section,
                vresource resource);
</PRE>

<DL><DD>
Writes the contents of the section <SAMP>section</SAMP>
into the resource <SAMP>resource</SAMP>. The item can be
recovered from the resource at a later time with
<CODE><A HREF="vnotebook-x.html#vnotebookLoadSection"><CODE>vnotebookLoadSection</CODE></A></CODE> or
<CODE><A HREF="vnotebook-x.html#vnotebookLoadInitSection"><CODE>vnotebookLoadInitSection</CODE></A></CODE>. This method is implemented by
sending a <CODE>vobjectSTORE</CODE> message to the section.
</DD></DL>
<P>
<A NAME="vnotebookStoreStyle"><HR><H4>vnotebookStoreStyle</H4></A>
<PRE>
        void <B>vnotebookStoreStyle</B>(
                vnotebookStyle * style,
                vresource resource);
</PRE>

<DL><DD>
Writes the contents of the style <SAMP>style</SAMP> into
the resource <SAMP>resource</SAMP>. The item can be
recovered from the resource at a later time with
<CODE><A HREF="vnotebook-x.html#vnotebookLoadStyle"><CODE>vnotebookLoadStyle</CODE></A></CODE> or
<CODE><A HREF="vnotebook-x.html#vnotebookLoadInitStyle"><CODE>vnotebookLoadInitStyle</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookStoreTab"><HR><H4>vnotebookStoreTab</H4></A>
<PRE>
        void <B>vnotebookStoreTab</B>(
                vnotebookTab * tab,
                vresource resource);
</PRE>

<DL><DD>
Writes the contents of the tab <SAMP>tab</SAMP> into the
resource <SAMP>resource</SAMP>. The item can be recovered
from the resource at a later time with
<CODE><A HREF="vnotebook-x.html#vnotebookLoadTab"><CODE>vnotebookLoadTab</CODE></A></CODE> or
<CODE><A HREF="vnotebook-x.html#vnotebookLoadInitTab"><CODE>vnotebookLoadInitTab</CODE></A></CODE>. This method is implemented by
sending a <CODE>vobjectSTORE</CODE> message to
<SAMP>tab</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookStyleIsEmpty"><HR><H4>vnotebookStyleIsEmpty</H4></A>
<PRE>
        int <B>vnotebookStyleIsEmpty</B>(
                vnotebookStyle * style);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if no attributes in the style
<SAMP>style</SAMP>  have been set. When a style has been
inserted with one of the <CODE><A HREF="vnotebook-x.html#vnotebookSetStyle"><CODE>vnotebookSetStyle</CODE></A></CODE> functions
it returns <SAMP>FALSE</SAMP>.
</DD></DL>
<P>
<A NAME="section_Message"><HR>
<CENTER><H2>Messages</H2></CENTER></A><P>
<A NAME="vnotebookADD_TABSET_TAB"><HR><H4>vnotebookADD_TABSET_TAB</H4></A>
<PRE>
        &lt;<B>vnotebookADD_TABSET_TAB</B>&gt;
</PRE>

<DL><DD>
Adds the tab <SAMP>tab</SAMP> to the tabset
<SAMP>tabset</SAMP> for the notebook <SAMP>notebook</SAMP>.
This function is normally called internal to the Notebook
class and should not be used as the standard method for
adding a tab to a tabset. When a page is added to a
notebook, the tab associated with the page is automatically
added to the tabset when it sends a
<CODE><A HREF="vnotebook-x.html#vnotebookRECALC_TABSET_TABS"><CODE>vnotebookRECALC_TABSET_TABS</CODE></A></CODE>.
<CODE>vnotebookAddTabSetTabs</CODE> is implemented by
sending this message to the notebook. The tabset should not
take ownership of the tab. The page that owns the tab is
responsible for destroying it.
</DD></DL>
<P>
<A NAME="vnotebookCALC_FOLIO_RECT"><HR><H4>vnotebookCALC_FOLIO_RECT</H4></A>
<PRE>
        &lt;<B>vnotebookCALC_FOLIO_RECT</B>&gt;
</PRE>

<DL><DD>
Calculates the size and position of the folio rect
associated with the notebook <SAMP>notebook</SAMP>. It then
calls <CODE><A HREF="vrect-x.html#vrectSet"><CODE>vrectSet</CODE></A></CODE> with the proper size and
coordinates. This will store the calculated rect in
<SAMP>rect</SAMP>. <CODE><A HREF="vnotebook-x.html#vnotebookCalcFolioRect"><CODE>vnotebookCalcFolioRect</CODE></A></CODE> is
implemented by sending this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookCALC_PAGE_BUTTON_RECTS"><HR><H4>vnotebookCALC_PAGE_BUTTON_RECTS</H4></A>
<PRE>
        &lt;<B>vnotebookCALC_PAGE_BUTTON_RECTS</B>&gt;
</PRE>

<DL><DD>
Calculates the size and position of the bounding rects for
the page buttons associated with the notebook
<SAMP>notebook</SAMP>. It then calls <CODE><A HREF="vrect-x.html#vrectSet"><CODE>vrectSet</CODE></A></CODE> with
the proper size and coordinates for each page button. The
previous page button rect will be stored in
<SAMP>prevRect</SAMP> and the next page button rect will be
stored in <SAMP>nextRect</SAMP>.
<CODE><A HREF="vnotebook-x.html#vnotebookCalcPageButtonRects"><CODE>vnotebookCalcPageButtonRects</CODE></A></CODE> is implemented by
sending a this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookCALC_PAGE_CONTENT_RECT"><HR><H4>vnotebookCALC_PAGE_CONTENT_RECT</H4></A>
<PRE>
        &lt;<B>vnotebookCALC_PAGE_CONTENT_RECT</B>&gt;
</PRE>

<DL><DD>
Calculates the size and position of the content rect for
the page <SAMP>page</SAMP>. The newly calculated content
rect is returned in <SAMP>rect</SAMP>.
<CODE><A HREF="vnotebook-x.html#vnotebookCalcPageContentRect"><CODE>vnotebookCalcPageContentRect</CODE></A></CODE> is implemented by
sending this message to the page.
</DD></DL>
<P>
<A NAME="vnotebookCALC_PAGE_RECT"><HR><H4>vnotebookCALC_PAGE_RECT</H4></A>
<PRE>
        &lt;<B>vnotebookCALC_PAGE_RECT</B>&gt;
</PRE>

<DL><DD>
Calculates the size and position of the page rect for the
notebook <SAMP>notebook</SAMP>. It calls
<CODE><A HREF="vrect-x.html#vrectSet"><CODE>vrectSet</CODE></A></CODE> with the size and coordinates. This
will store the page rect in <SAMP>rect</SAMP>.
<CODE><A HREF="vnotebook-x.html#vnotebookCalcPageRect"><CODE>vnotebookCalcPageRect</CODE></A></CODE> is implemented by
sending this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookCALC_TABSET_RECT"><HR><H4>vnotebookCALC_TABSET_RECT</H4></A>
<PRE>
        &lt;<B>vnotebookCALC_TABSET_RECT</B>&gt;
</PRE>

<DL><DD>
Calculates the size and position of the tabset rect for the
tabset <SAMP>tabset</SAMP> of the notebook notebook. It
calls <CODE><A HREF="vrect-x.html#vrectSet"><CODE>vrectSet</CODE></A></CODE> with the proper size and
coordinates. This will store the tabset rect in
<SAMP>rect</SAMP>. <CODE><A HREF="vnotebook-x.html#vnotebookCalcTabSetRect"><CODE>vnotebookCalcTabSetRect</CODE></A></CODE> is
implemented by sending this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookCALC_TABSET_TAB_RECT"><HR><H4>vnotebookCALC_TABSET_TAB_RECT</H4></A>
<PRE>
        &lt;<B>vnotebookCALC_TABSET_TAB_RECT</B>&gt;
</PRE>

<DL><DD>
Calculates the size and position of the tab rect for the
tab <SAMP>tab</SAMP> inside the tabset <SAMP>tabset</SAMP>
for the notebook <SAMP>notebook</SAMP>. It calls
<CODE><A HREF="vrect-x.html#vrectSet"><CODE>vrectSet</CODE></A></CODE> with the proper size and coordinates.
This will store the tab rect in <SAMP>rect</SAMP>.
<CODE><A HREF="vnotebook-x.html#vnotebookCalcTabSetTabRect"><CODE>vnotebookCalcTabSetTabRect</CODE></A></CODE> is implemented by
sending this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookCHANGED_STYLE"><HR><H4>vnotebookCHANGED_STYLE</H4></A>
<PRE>
        &lt;<B>vnotebookCHANGED_STYLE</B>&gt;
</PRE>

<DL><DD>
Indicates that the style for the notebook
<SAMP>notebook</SAMP> has changed. It re-determines all styles
and sets the necessary flags.
<CODE>vnotebookChangeStyle</CODE> is implemented by sending
this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookCLASS_STYLE"><HR><H4>vnotebookCLASS_STYLE</H4></A>
<PRE>
        &lt;<B>vnotebookCLASS_STYLE</B>&gt;
</PRE>

<DL><DD>
Contains the style for the notebook class.
<CODE><A HREF="vnotebook-x.html#vnotebookGetClassStyle"><CODE>vnotebookGetClassStyle</CODE></A></CODE> returns this class
variable.
</DD></DL>
<P>
<A NAME="vnotebookCREATE_PAGE_BUTTON"><HR><H4>vnotebookCREATE_PAGE_BUTTON</H4></A>
<PRE>
        &lt;<B>vnotebookCREATE_PAGE_BUTTON</B>&gt;
</PRE>

<DL><DD>
Creates a button based on <SAMP>whichBtn</SAMP> for the
notebook <SAMP>notebook</SAMP>. <SAMP>whichBtn</SAMP> can
be <CODE>vnotebookNEXT_PAGE_BUTTON</CODE> or
<CODE>vnotebookPREVIOUS_PAGE_BUTTON</CODE>. The default
page button is drawn with an arrow facing in the
appropriate direction. The button's notify functions are
set so that when a button is hit, it will update the
current page.
</DD></DL>
<P>
<A NAME="vnotebookCREATE_PAGE_TAB"><HR><H4>vnotebookCREATE_PAGE_TAB</H4></A>
<PRE>
        &lt;<B>vnotebookCREATE_PAGE_TAB</B>&gt;
</PRE>

<DL><DD>
Creates a new tab for the page <SAMP>page</SAMP> and
returns a pointer to its contents. The default implemention
calls <CODE><A HREF="vnotebook-x.html#vnotebookCreateTab"><CODE>vnotebookCreateTab</CODE></A></CODE>. The Notebook class
will reclaim the storage occupied by the tab when
<CODE><A HREF="vnotebook-x.html#vnotebookDestroyTab"><CODE>vnotebookDestroyTab</CODE></A></CODE> is called.
<CODE><A HREF="vnotebook-x.html#vnotebookCreatePageTab"><CODE>vnotebookCreatePageTab</CODE></A></CODE> is implemented by
sending this message to the page.
</DD></DL>
<P>
<A NAME="vnotebookCREATE_TABSET"><HR><H4>vnotebookCREATE_TABSET</H4></A>
<PRE>
        &lt;<B>vnotebookCREATE_TABSET</B>&gt;
</PRE>

<DL><DD>
Creates a tabset based on <SAMP>whichTabs</SAMP> for the
notebook <SAMP>notebook</SAMP>. <SAMP>whichTabs</SAMP> can
be <CODE>vnotebookMAJOR_TABSET</CODE> or
<CODE>vnotebookMINOR_TABSET</CODE>.
</DD></DL>
<P>
<A NAME="vnotebookDELETE_TABSET_TAB"><HR><H4>vnotebookDELETE_TABSET_TAB</H4></A>
<PRE>
        &lt;<B>vnotebookDELETE_TABSET_TAB</B>&gt;
</PRE>

<DL><DD>
Removes the tab <SAMP>tab</SAMP> from the tabset
<SAMP>tabset</SAMP> for the notebook <SAMP>notebook</SAMP>.
<CODE><A HREF="vnotebook-x.html#vnotebookDeleteTabSetTab"><CODE>vnotebookDeleteTabSetTab</CODE></A></CODE> sends this message to
the notebook. This will not destroy the tab.
</DD></DL>
<P>
<A NAME="vnotebookDETERMINE_STYLE"><HR><H4>vnotebookDETERMINE_STYLE</H4></A>
<PRE>
        &lt;<B>vnotebookDETERMINE_STYLE</B>&gt;
</PRE>

<DL><DD>
Returns the style <SAMP>style</SAMP> for notebook
<SAMP>notebook</SAMP> only for the style based on those that are
requested in <SAMP>whichSettings</SAMP>.
<SAMP>whichSettings</SAMP> can be any or a combination of
the <CODE>vnotebookSTYLE</CODE> constants.
<CODE><A HREF="vnotebook-x.html#vnotebookDetermineStyle"><CODE>vnotebookDetermineStyle</CODE></A></CODE> is implemented by
sending this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookDRAW_BINDER"><HR><H4>vnotebookDRAW_BINDER</H4></A>
<PRE>
        &lt;<B>vnotebookDRAW_BINDER</B>&gt;
</PRE>

<DL><DD>
Draws the binder of the notebook <SAMP>notebook</SAMP> into
the current graphics state. It will draw the default binder
with the default size unless it was changed with a call to
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleBinding"><CODE>vnotebookSetStyleBinding</CODE></A></CODE> or
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleBindingSize"><CODE>vnotebookSetStyleBindingSize</CODE></A></CODE>.
<CODE><A HREF="vnotebook-x.html#vnotebookDrawBinder"><CODE>vnotebookDrawBinder</CODE></A></CODE> is implemented by sending
this message to the notebook. You should override this
function if you want to define a notebook class with a
different binding.
</DD></DL>
<P>
<A NAME="vnotebookDRAW_BINDER_WITH"><HR><H4>vnotebookDRAW_BINDER_WITH</H4></A>
<PRE>
        &lt;<B>vnotebookDRAW_BINDER_WITH</B>&gt;
</PRE>

<DL><DD>
Draws the binder of the notebook <SAMP>notebook</SAMP> into
the drawing context <SAMP>context</SAMP>. It will draw the default binder
with the default size unless it was changed with a call to
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleBinding"><CODE>vnotebookSetStyleBinding</CODE></A></CODE> or
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleBindingSize"><CODE>vnotebookSetStyleBindingSize</CODE></A></CODE>.  You should override this
function if you want to define a notebook class with a
different binding.  The function <SAMP><A HREF="vnotebook-x.html#vnotebookDrawBinderWith"><CODE>vnotebookDrawBinderWith</CODE></A></SAMP>
is implemented by sending this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookDRAW_FOLIO"><HR><H4>vnotebookDRAW_FOLIO</H4></A>
<PRE>
        &lt;<B>vnotebookDRAW_FOLIO</B>&gt;
</PRE>

<DL><DD>
Draws the folio of the notebook <SAMP>notebook</SAMP> into
the current graphics state with the dimensions defined by
<SAMP>rect</SAMP>. It will draw the default folio unless it
was hidden with a call to
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleFolio"><CODE>vnotebookSetStyleFolio</CODE></A></CODE>.
<CODE><A HREF="vnotebook-x.html#vnotebookDrawFolio"><CODE>vnotebookDrawFolio</CODE></A></CODE> is implemented by sending
this message to the notebook. You should override this
function if you want to define a notebook class with a
different folio.
</DD></DL>
<P>
<A NAME="vnotebookDRAW_FOLIO_WITH"><HR><H4>vnotebookDRAW_FOLIO_WITH</H4></A>
<PRE>
        &lt;<B>vnotebookDRAW_FOLIO_WITH</B>&gt;
</PRE>

<DL><DD>
Draws the folio of the notebook <SAMP>notebook</SAMP> into
the drawing context <SAMP>context</SAMP> with the dimensions defined by
<SAMP>rect</SAMP>. It will draw the default folio unless it
was hidden with a call to
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyleFolio"><CODE>vnotebookSetStyleFolio</CODE></A></CODE>.
<CODE><A HREF="vnotebook-x.html#vnotebookDrawFolioWith"><CODE>vnotebookDrawFolioWith</CODE></A></CODE> is implemented by sending
this message to the notebook. You should override this
function if you want to define a notebook class with a
different folio.
</DD></DL>
<P>
<A NAME="vnotebookDRAW_PAGE_AT"><HR><H4>vnotebookDRAW_PAGE_AT</H4></A>
<PRE>
        &lt;<B>vnotebookDRAW_PAGE_AT</B>&gt;
</PRE>

<DL><DD>
Draws the virtual page <SAMP>pageNum</SAMP> of the
notebook <SAMP>notebook</SAMP> into the current graphics
state with the dimensions defined by <SAMP>rect</SAMP>.
<CODE>vnotebookDrawpageAt</CODE> is implemented by sending
this message to the notebook. You should override this
function if you want to define a notebook class with a
different folio.
</DD></DL>
<P>
<A NAME="vnotebookDRAW_PAGE_AT_WITH"><HR><H4>vnotebookDRAW_PAGE_AT_WITH</H4></A>
<PRE>
        &lt;<B>vnotebookDRAW_PAGE_AT_WITH</B>&gt;
</PRE>

<DL><DD>
Draws the virtual page <SAMP>pageNum</SAMP> of the notebook
into the drawing context <SAMP>context</SAMP> with the dimensions defined
by <SAMP>rect</SAMP>.  The function
<CODE><A HREF="vnotebook-x.html#vnotebookDrawPageAtWith"><CODE>vnotebookDrawPageAtWith</CODE></A></CODE> is implemented by sending this
message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookDRAW_PAGE_BORDER"><HR><H4>vnotebookDRAW_PAGE_BORDER</H4></A>
<PRE>
        &lt;<B>vnotebookDRAW_PAGE_BORDER</B>&gt;
</PRE>

<DL><DD>
Draws the border of the page <SAMP>page</SAMP> into the
current graphics state with the dimensions defined by
<SAMP>rect</SAMP>. <CODE>vnotebookDrawpageBorder</CODE> is
implemented by sending this message to the page. You should
override this function if you want to define a page class with
a different border.
</DD></DL>
<P>
<A NAME="vnotebookDRAW_PAGE_BORDER_WITH"><HR><H4>vnotebookDRAW_PAGE_BORDER_WITH</H4></A>
<PRE>
        &lt;<B>vnotebookDRAW_PAGE_BORDER_WITH</B>&gt;
</PRE>

<DL><DD>
Draws the border of the page into the drawing context
<SAMP>context</SAMP> with the dimensions defined by <SAMP>rect</SAMP>. You
should override this message if you want to define a page
class with a different border.  The function 
<CODE><A HREF="vnotebook-x.html#vnotebookDrawPageBorderWith"><CODE>vnotebookDrawPageBorderWith</CODE></A></CODE> is implemented by
sending this message to the page.
</DD></DL>
<P>
<A NAME="vnotebookDRAW_PAGE_CONTENT"><HR><H4>vnotebookDRAW_PAGE_CONTENT</H4></A>
<PRE>
        &lt;<B>vnotebookDRAW_PAGE_CONTENT</B>&gt;
</PRE>

<DL><DD>
Draws the content of the page <SAMP>page</SAMP> into the
current graphics state with the dimensions defined by
<SAMP>rect</SAMP>. <CODE><A HREF="vnotebook-x.html#vnotebookDrawPageContent"><CODE>vnotebookDrawPageContent</CODE></A></CODE> is
implemented by sending this message to the page. You should
override this function if you want to define a page class with
different content.
</DD></DL>
<P>
<A NAME="vnotebookDRAW_PAGE_CONTENT_WITH"><HR><H4>vnotebookDRAW_PAGE_CONTENT_WITH</H4></A>
<PRE>
        &lt;<B>vnotebookDRAW_PAGE_CONTENT_WITH</B>&gt;
</PRE>

<DL><DD>
Draws the content of the page into the drawing context
<SAMP>context</SAMP> with the dimensions defined by <SAMP>rect</SAMP>. You
should override this function if you want to define a page
class with a different content.  The function 
<CODE><A HREF="vnotebook-x.html#vnotebookDrawPageContentWith"><CODE>vnotebookDrawPageContentWith</CODE></A></CODE> is implemented by
sending this message to the page.
</DD></DL>
<P>
<A NAME="vnotebookDRAW_TAB_BORDER"><HR><H4>vnotebookDRAW_TAB_BORDER</H4></A>
<PRE>
        &lt;<B>vnotebookDRAW_TAB_BORDER</B>&gt;
</PRE>

<DL><DD>
Draws the border of the tab <SAMP>tab</SAMP> into the
current graphics state. <CODE><A HREF="vnotebook-x.html#vnotebookDrawTabBorder"><CODE>vnotebookDrawTabBorder</CODE></A></CODE>
is implemented by sending this message to the tab. You
should override this function if you want to define a tab class
with a different border.
</DD></DL>
<P>
<A NAME="vnotebookDRAW_TAB_BORDER_WITH"><HR><H4>vnotebookDRAW_TAB_BORDER_WITH</H4></A>
<PRE>
        &lt;<B>vnotebookDRAW_TAB_BORDER_WITH</B>&gt;
</PRE>

<DL><DD>
Draws the border of the tab into the drawing context
<SAMP>context</SAMP>. The function 
<CODE><A HREF="vnotebook-x.html#vnotebookDrawTabBorderWith"><CODE>vnotebookDrawTabBorderWith</CODE></A></CODE> is implemented by sending this
message to the tab.  You should override this method if you want to define a tab 
with a different border.
</DD></DL>
<P>
<A NAME="vnotebookDRAW_TAB_CONTENT"><HR><H4>vnotebookDRAW_TAB_CONTENT</H4></A>
<PRE>
        &lt;<B>vnotebookDRAW_TAB_CONTENT</B>&gt;
</PRE>

<DL><DD>
Draws the contents of the tab <SAMP>tab</SAMP> into the
current graphics state with the dimensions defined by
<SAMP>rect</SAMP>. <CODE><A HREF="vnotebook-x.html#vnotebookDrawTabContent"><CODE>vnotebookDrawTabContent</CODE></A></CODE> is
implemented by sending this message to the tab. You should
override this function if you want to define a tab class with a
different content.
</DD></DL>
<P>
<A NAME="vnotebookDRAW_TAB_CONTENT_WITH"><HR><H4>vnotebookDRAW_TAB_CONTENT_WITH</H4></A>
<PRE>
        &lt;<B>vnotebookDRAW_TAB_CONTENT_WITH</B>&gt;
</PRE>

<DL><DD>
Draws the contents of the tab <SAMP>tab</SAMP> into the
drawing context <SAMP>context</SAMP> with the dimensions defined by
<SAMP>rect</SAMP>. <CODE><A HREF="vnotebook-x.html#vnotebookDrawTabContentWith"><CODE>vnotebookDrawTabContentWith</CODE></A></CODE> is
implemented by sending this message to the tab. You should
override this function if you want to define a tab class with a
different content.
</DD></DL>
<P>
<A NAME="vnotebookGET_FOLIO_SIZE"><HR><H4>vnotebookGET_FOLIO_SIZE</H4></A>
<PRE>
        &lt;<B>vnotebookGET_FOLIO_SIZE</B>&gt;
</PRE>

<DL><DD>
Returns the width <SAMP>w</SAMP>, and the height
<SAMP>h</SAMP> of the folio rect for the notebook
<SAMP>notebook</SAMP>. <CODE><A HREF="vnotebook-x.html#vnotebookGetFolioSize"><CODE>vnotebookGetFolioSize</CODE></A></CODE> is
implemented by sending this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookGET_MAX_TABSET_TAB_SIZE"><HR><H4>vnotebookGET_MAX_TABSET_TAB_SIZE</H4></A>
<PRE>
        &lt;<B>vnotebookGET_MAX_TABSET_TAB_SIZE</B>&gt;
</PRE>

<DL><DD>
Returns the maximum width <SAMP>w</SAMP>, and height
<SAMP>h</SAMP>, of tabs in the tabset <SAMP>tabset</SAMP>
for the notebook <SAMP>notebook</SAMP>.
<CODE><A HREF="vnotebook-x.html#vnotebookGetMaxTabSetTabSize"><CODE>vnotebookGetMaxTabSetTabSize</CODE></A></CODE> is implemented by
sending this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookGET_PAGE_BORDER_SIZES"><HR><H4>vnotebookGET_PAGE_BORDER_SIZES</H4></A>
<PRE>
        &lt;<B>vnotebookGET_PAGE_BORDER_SIZES</B>&gt;
</PRE>

<DL><DD>
Returns the border sizes for the page <SAMP>page</SAMP>.
<CODE><A HREF="vnotebook-x.html#vnotebookGetPageBorderSizes"><CODE>vnotebookGetPageBorderSizes</CODE></A></CODE> is implemented by
sending this message to the page. The default method will
return the line width for each of the sizes.
</DD></DL>
<P>
<A NAME="vnotebookGET_PAGE_BUTTON_SIZE"><HR><H4>vnotebookGET_PAGE_BUTTON_SIZE</H4></A>
<PRE>
        &lt;<B>vnotebookGET_PAGE_BUTTON_SIZE</B>&gt;
</PRE>

<DL><DD>
Returns the width <SAMP>w</SAMP> and the height
<SAMP>h</SAMP> of the page buttons for the notebook
<SAMP>notebook</SAMP>. <CODE><A HREF="vnotebook-x.html#vnotebookGetPageButtonSize"><CODE>vnotebookGetPageButtonSize</CODE></A></CODE> is
implemented by sending this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookGET_PAGE_CONTENT_MIN_SIZE"><HR><H4>vnotebookGET_PAGE_CONTENT_MIN_SIZE</H4></A>
<PRE>
        &lt;<B>vnotebookGET_PAGE_CONTENT_MIN_SIZE</B>&gt;
</PRE>

<DL><DD>
Returns the width <SAMP>w</SAMP> and height <SAMP>h</SAMP>
of the minimum size for the page content of the page
<SAMP>page</SAMP>. <CODE><A HREF="vnotebook-x.html#vnotebookGetPageContentMinSize"><CODE>vnotebookGetPageContentMinSize</CODE></A></CODE> is
implemented by sending this message to the page. The
default method retrieves the <CODE><A HREF="vdialog-x.html#vdialogItemList"><CODE>vdialogItemList</CODE></A></CODE>
from the container object that the page was derived from.
It then determines the minimum size by calling
<CODE><A HREF="vdialog-x.html#vdialogCalcItemListMinSize"><CODE>vdialogCalcItemListMinSize</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookGET_PAGE_CONTENT_NATURAL_SIZE"><HR><H4>vnotebookGET_PAGE_CONTENT_NATURAL_SIZE</H4></A>
<PRE>
        &lt;<B>vnotebookGET_PAGE_CONTENT_NATURAL_SIZE</B>&gt;
</PRE>

<DL><DD>
Returns the natural width <SAMP>w</SAMP>, and the natural
height <SAMP>h</SAMP>, for the page content of the page
<SAMP>page</SAMP>.
<CODE><A HREF="vnotebook-x.html#vnotebookGetPageContentNaturalSize"><CODE>vnotebookGetPageContentNaturalSize</CODE></A></CODE> is
implemented by sending this message to the page.
</DD></DL>
<P>
<A NAME="vnotebookGET_PAGE_DECORATION_SIZES"><HR><H4>vnotebookGET_PAGE_DECORATION_SIZES</H4></A>
<PRE>
        &lt;<B>vnotebookGET_PAGE_DECORATION_SIZES</B>&gt;
</PRE>

<DL><DD>
Returns the decoration sizes for the page
<SAMP>page</SAMP>. <CODE><A HREF="vnotebook-x.html#vnotebookGetPageDecorationSizes"><CODE>vnotebookGetPageDecorationSizes</CODE></A></CODE>
is implemented by sending this message to the page. The
default method returns 0 for pages and sections, but not
notebooks.
</DD></DL>
<P>
<A NAME="vnotebookGET_TABSET_CLIP_RECTS"><HR><H4>vnotebookGET_TABSET_CLIP_RECTS</H4></A>
<PRE>
        &lt;<B>vnotebookGET_TABSET_CLIP_RECTS</B>&gt;
</PRE>

<DL><DD>
Returns the count <SAMP>rectCount</SAMP> and a set of
rectangles that define the area of the notebook
<SAMP>notebook</SAMP> that is clipped out by the tabset
<SAMP>tabset</SAMP>. The rectangle set should have been
allocated by the <CODE>vrectSET</CODE> family of functions. The
rectangle set should be destroyed by the user.
<CODE><A HREF="vnotebook-x.html#vnotebookGetTabSetClipRects"><CODE>vnotebookGetTabSetClipRects</CODE></A></CODE> is implemented by
sending this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookGET_TABSET_SIZE"><HR><H4>vnotebookGET_TABSET_SIZE</H4></A>
<PRE>
        &lt;<B>vnotebookGET_TABSET_SIZE</B>&gt;
</PRE>

<DL><DD>
Returns the width <SAMP>w</SAMP>, and the height
<SAMP>h</SAMP> of the tabset <SAMP>tabset</SAMP> for the
notebook <SAMP>notebook</SAMP>.
<CODE><A HREF="vnotebook-x.html#vnotebookGetTabSetSize"><CODE>vnotebookGetTabSetSize</CODE></A></CODE> is implemented by
sending this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookGET_TABSET_TAB_AT"><HR><H4>vnotebookGET_TABSET_TAB_AT</H4></A>
<PRE>
        &lt;<B>vnotebookGET_TABSET_TAB_AT</B>&gt;
</PRE>

<DL><DD>
Returns the tab indexed at <SAMP>index</SAMP> inside the
tabset <SAMP>tabset</SAMP> for the notebook
<SAMP>notebook</SAMP>. <CODE><A HREF="vnotebook-x.html#vnotebookGetTabSetTabAt"><CODE>vnotebookGetTabSetTabAt</CODE></A></CODE> is
implemented by sending this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookGET_TABSET_TAB_COUNT"><HR><H4>vnotebookGET_TABSET_TAB_COUNT</H4></A>
<PRE>
        &lt;<B>vnotebookGET_TABSET_TAB_COUNT</B>&gt;
</PRE>

<DL><DD>
Returns the number of tabs inside the tabset
<SAMP>tabset</SAMP> for the notebook <SAMP>notebook</SAMP>.
<CODE><A HREF="vnotebook-x.html#vnotebookGetTabSetTabCount"><CODE>vnotebookGetTabSetTabCount</CODE></A></CODE> is implemented by
sending this message to the notebook. The default method
uses <CODE><A HREF="vcontainer-x.html#vcontainerGetItemCount"><CODE>vcontainerGetItemCount</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vnotebookGET_TAB_CONTENT_SIZE"><HR><H4>vnotebookGET_TAB_CONTENT_SIZE</H4></A>
<PRE>
        &lt;<B>vnotebookGET_TAB_CONTENT_SIZE</B>&gt;
</PRE>

<DL><DD>
Returns the width <SAMP>w</SAMP>, and the height
<SAMP>h</SAMP>, of the content of the tab <SAMP>tab</SAMP>.
<CODE><A HREF="vnotebook-x.html#vnotebookGetTabContentSize"><CODE>vnotebookGetTabContentSize</CODE></A></CODE> is implemented by
sending this message to the tab.
</DD></DL>
<P>
<A NAME="vnotebookPAGE_HAS_BORDER"><HR><H4>vnotebookPAGE_HAS_BORDER</H4></A>
<PRE>
        &lt;<B>vnotebookPAGE_HAS_BORDER</B>&gt;
</PRE>

<DL><DD>
Returns <SAMP>FALSE</SAMP> if the page <SAMP>page</SAMP>
should not draw its border even though
<CODE><A HREF="vdialog-x.html#vdialogItemHasBorder"><CODE>vdialogItemHasBorder</CODE></A></CODE> returns
<SAMP>TRUE</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookPAGE_IS_VALID"><HR><H4>vnotebookPAGE_IS_VALID</H4></A>
<PRE>
        &lt;<B>vnotebookPAGE_IS_VALID</B>&gt;
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the page <SAMP>page</SAMP> is
in a valid state, <SAMP>FALSE</SAMP> if not.
<CODE><A HREF="vnotebook-x.html#vnotebookPageIsValid"><CODE>vnotebookPageIsValid</CODE></A></CODE> is implemented by sending
this message to the page. The default method always returns
<SAMP>TRUE</SAMP>.
</DD></DL>
<P>
<A NAME="vnotebookRECALC"><HR><H4>vnotebookRECALC</H4></A>
<PRE>
        &lt;<B>vnotebookRECALC</B>&gt;
</PRE>

<DL><DD>
Recalculates the positions, sizes, and state of all the
various elements that comprise the notebook
<SAMP>notebook</SAMP>. This method is called when the size of the
notebook changes or the styles associated with a notebook
changes. <CODE><A HREF="vnotebook-x.html#vnotebookRecalc"><CODE>vnotebookRecalc</CODE></A></CODE> is implemented by
sending this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookRECALC_TABSET_TABS"><HR><H4>vnotebookRECALC_TABSET_TABS</H4></A>
<PRE>
        &lt;<B>vnotebookRECALC_TABSET_TABS</B>&gt;
</PRE>

<DL><DD>
Recalculates the tabs that belong in the tabset
<SAMP>tabset</SAMP> from the notebook <SAMP>notebook</SAMP>. The
Notebook class uses this method internally when a page or
section is added, deleted, or moved.
<CODE><A HREF="vnotebook-x.html#vnotebookRecalcTabSetTabs"><CODE>vnotebookRecalcTabSetTabs</CODE></A></CODE> is implemented by
sending this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookREMOVE_TABSET_TAB"><HR><H4>vnotebookREMOVE_TABSET_TAB</H4></A>
<PRE>
        &lt;<B>vnotebookREMOVE_TABSET_TAB</B>&gt;
</PRE>

<DL><DD>
Removes the tab <SAMP>tab</SAMP> from the tabset
<SAMP>tabset</SAMP> of the notebook <SAMP>notebook</SAMP>. This function is
normally called internal to the Notebook class and should
not be used as the standard method for removing a tab from a
tabset. When a page is removed from a notebook, the tab
associated with the page is automatically removed from the
tabset. The tab is not destroyed because it is owned by the
page.  <CODE><A HREF="vnotebook-x.html#vnotebookRemoveTabSetTab"><CODE>vnotebookRemoveTabSetTab</CODE></A></CODE> is implemented by sending
this message to the notebook. 
</DD></DL>
<P>
<A NAME="vnotebookSCROLL_TABSET_TAB_INTO_VIEW"><HR><H4>vnotebookSCROLL_TABSET_TAB_INTO_VIEW</H4></A>
<PRE>
        &lt;<B>vnotebookSCROLL_TABSET_TAB_INTO_VIEW</B>&gt;
</PRE>

<DL><DD>
Scrolls the tabset <SAMP>tabset</SAMP> of the
notebook <SAMP>notebook</SAMP> until the tab
<SAMP>tab</SAMP> is completely visible. If the tab is
already in view then it does nothing.
<CODE>vnotebookScrollTabsetTabIntoView</CODE> is
implemented by sending this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookSELECT_PAGE"><HR><H4>vnotebookSELECT_PAGE</H4></A>
<PRE>
        &lt;<B>vnotebookSELECT_PAGE</B>&gt;
</PRE>

<DL><DD>
Selects the page <SAMP>page</SAMP> to be the current page
in a notebook or section.
</DD></DL>
<P>
<A NAME="vnotebookSET_STYLE"><HR><H4>vnotebookSET_STYLE</H4></A>
<PRE>
        &lt;<B>vnotebookSET_STYLE</B>&gt;
</PRE>

<DL><DD>
Sets the style <SAMP>style</SAMP> to the notebook
<SAMP>notebook</SAMP>. The style can be retrieved through
<CODE><A HREF="vnotebook-x.html#vnotebookGetStyle"><CODE>vnotebookGetStyle</CODE></A></CODE>.
<CODE><A HREF="vnotebook-x.html#vnotebookSetStyle"><CODE>vnotebookSetStyle</CODE></A></CODE> is implemented by sending
this message to the notebook.
</DD></DL>
<P>
<A NAME="vnotebookSET_TABSET_TAB_SELECTED"><HR><H4>vnotebookSET_TABSET_TAB_SELECTED</H4></A>
<PRE>
        &lt;<B>vnotebookSET_TABSET_TAB_SELECTED</B>&gt;
</PRE>

<DL><DD>
Sets the selected tab of the tabset <SAMP>tabset</SAMP> for
the notebook <SAMP>notebook</SAMP> to tab. If the tab is
already the selected tab in the tabset, this function
does nothing.
</DD></DL>
<P>
<A NAME="vnotebookUNSELECT_PAGE"><HR><H4>vnotebookUNSELECT_PAGE</H4></A>
<PRE>
        &lt;<B>vnotebookUNSELECT_PAGE</B>&gt;
</PRE>

<DL><DD>
Unselects a page from being the current page in a notebook
or section.
</DD></DL>
<P>
<A NAME="section_Constant"><HR>
<CENTER><H2>Constants</H2></CENTER></A><P>
<A NAME="vnotebookBINDING_PERFECT"><HR><H4>vnotebookBINDING_PERFECT</H4></A>
<PRE>
        <B>vnotebookBINDING_PERFECT</B>
</PRE>
<A NAME="vnotebookBINDING_SPIRAL"><PRE>
        <B>vnotebookBINDING_SPIRAL</B>
</PRE>
</A>

<DL><DD>
Denotes the binding style to be drawn with the notebook.
</DD></DL>
<P>
<A NAME="vnotebookDEFAULT"><HR><H4>vnotebookDEFAULT</H4></A>
<PRE>
        <B>vnotebookDEFAULT</B>
</PRE>

<DL><DD>
Denotes that the default style is to be used.
</DD></DL>
<P>
<A NAME="vnotebookFOLIO_JUSTIFY_RIGHT"><HR><H4>vnotebookFOLIO_JUSTIFY_RIGHT</H4></A>
<PRE>
        <B>vnotebookFOLIO_JUSTIFY_RIGHT</B>
</PRE>
<A NAME="vnotebookFOLIO_JUSTIFY_CENTER"><PRE>
        <B>vnotebookFOLIO_JUSTIFY_CENTER</B>
</PRE>
</A>
<A NAME="vnotebookFOLIO_JUSTIFY_LEFT"><PRE>
        <B>vnotebookFOLIO_JUSTIFY_LEFT</B>
</PRE>
</A>

<DL><DD>
Denotes the justification of the message text inside the
folio rect.
</DD></DL>
<P>
<A NAME="vnotebookID_ATTRIBUTE_NEW_PAGE"><HR><H4>vnotebookID_ATTRIBUTE_NEW_PAGE</H4></A>
<PRE>
        <B>vnotebookID_ATTRIBUTE_NEW_PAGE</B>
</PRE>
<A NAME="vnotebookID_ATTRIBUTE_MAJOR_TAB_CHANGE"><PRE>
        <B>vnotebookID_ATTRIBUTE_MAJOR_TAB_CHANGE</B>
</PRE>
</A>
<A NAME="vnotebookID_ATTRIBUTE_MINOR_TAB_CHANGE"><PRE>
        <B>vnotebookID_ATTRIBUTE_MINOR_TAB_CHANGE</B>
</PRE>
</A>
<A NAME="vnotebookNEXT_ID_ATTRIBUTE"><PRE>
        <B>vnotebookNEXT_ID_ATTRIBUTE</B>
</PRE>
</A>

<DL><DD>
Denotes attributes ids for named notebook attributes.
</DD></DL>
<P>
<A NAME="vnotebookINCLUDED"><HR><H4>vnotebookINCLUDED</H4></A>
<PRE>
        <B>vnotebookINCLUDED</B>
</PRE>

<DL><DD>
Defined when the header file vnotebook.h is included.
</DD></DL>
<P>
<A NAME="vnotebookMAJOR_TABSET"><HR><H4>vnotebookMAJOR_TABSET</H4></A>
<PRE>
        <B>vnotebookMAJOR_TABSET</B>
</PRE>
<A NAME="vnotebookMINOR_TABSET"><PRE>
        <B>vnotebookMINOR_TABSET</B>
</PRE>
</A>

<DL><DD>
Denote types of tabs that will be in a tabset.
</DD></DL>
<P>
<A NAME="vnotebookNEXT_PAGE_BUTTON"><HR><H4>vnotebookNEXT_PAGE_BUTTON</H4></A>
<PRE>
        <B>vnotebookNEXT_PAGE_BUTTON</B>
</PRE>
<A NAME="vnotebookPREVIOUS_PAGE_BUTTON"><PRE>
        <B>vnotebookPREVIOUS_PAGE_BUTTON</B>
</PRE>
</A>

<DL><DD>
Denotes a type of page button.
</DD></DL>
<P>
<A NAME="vnotebookNEXT_SELECT"><HR><H4>vnotebookNEXT_SELECT</H4></A>
<PRE>
        <B>vnotebookNEXT_SELECT</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vnotebookSTYLE_MAJOR_TABSET_SIDE"><HR><H4>vnotebookSTYLE_MAJOR_TABSET_SIDE</H4></A>
<PRE>
        <B>vnotebookSTYLE_MAJOR_TABSET_SIDE</B>
</PRE>
<A NAME="vnotebookSTYLE_MINOR_TABSET_SIDE"><PRE>
        <B>vnotebookSTYLE_MINOR_TABSET_SIDE</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_TABS"><PRE>
        <B>vnotebookSTYLE_TABS</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_FOLIO"><PRE>
        <B>vnotebookSTYLE_FOLIO</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_FOLIO_JUSTIFY"><PRE>
        <B>vnotebookSTYLE_FOLIO_JUSTIFY</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_PAGE_BUTTONS"><PRE>
        <B>vnotebookSTYLE_PAGE_BUTTONS</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_MULTILINE_TABS"><PRE>
        <B>vnotebookSTYLE_MULTILINE_TABS</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_TAB_STYLE"><PRE>
        <B>vnotebookSTYLE_TAB_STYLE</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_VERTICAL_TABS"><PRE>
        <B>vnotebookSTYLE_VERTICAL_TABS</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_PAGES_WRAP"><PRE>
        <B>vnotebookSTYLE_PAGES_WRAP</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_PAGE_BORDERS"><PRE>
        <B>vnotebookSTYLE_PAGE_BORDERS</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_BINDING"><PRE>
        <B>vnotebookSTYLE_BINDING</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_PAGE_COUNT"><PRE>
        <B>vnotebookSTYLE_PAGE_COUNT</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_PAGE_STEP"><PRE>
        <B>vnotebookSTYLE_PAGE_STEP</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_BINDING_SIZE"><PRE>
        <B>vnotebookSTYLE_BINDING_SIZE</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_PAGE_INSET"><PRE>
        <B>vnotebookSTYLE_PAGE_INSET</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_PAGE_INSET_BORDER"><PRE>
        <B>vnotebookSTYLE_PAGE_INSET_BORDER</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_TABSET_BUTTONS_CENTERED"><PRE>
        <B>vnotebookSTYLE_TABSET_BUTTONS_CENTERED</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_TABSET_BUTTONS_PLACEMENT"><PRE>
        <B>vnotebookSTYLE_TABSET_BUTTONS_PLACEMENT</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_TABSET_PARTIAL_TABS"><PRE>
        <B>vnotebookSTYLE_TABSET_PARTIAL_TABS</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_TAB_SPACING"><PRE>
        <B>vnotebookSTYLE_TAB_SPACING</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_TAB_INSET_X"><PRE>
        <B>vnotebookSTYLE_TAB_INSET_X</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_TAB_INSET_Y"><PRE>
        <B>vnotebookSTYLE_TAB_INSET_Y</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_TAB_SELECT_RAISE"><PRE>
        <B>vnotebookSTYLE_TAB_SELECT_RAISE</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_TAB_SELECT_RESIZE"><PRE>
        <B>vnotebookSTYLE_TAB_SELECT_RESIZE</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_FOLIO_BUTTON_MARGIN"><PRE>
        <B>vnotebookSTYLE_FOLIO_BUTTON_MARGIN</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_BUTTON_MARGIN"><PRE>
        <B>vnotebookSTYLE_BUTTON_MARGIN</B>
</PRE>
</A>
<A NAME="vnotebookSTYLE_BUTTON_BORDER_MARGIN"><PRE>
        <B>vnotebookSTYLE_BUTTON_BORDER_MARGIN</B>
</PRE>
</A>
<A NAME="vnotebookNUM_STYLES"><PRE>
        <B>vnotebookNUM_STYLES</B>
</PRE>
</A>

<DL><DD>
Denotes the possible styles that the notebook will be drawn
with.
</DD></DL>
<P>
<A NAME="vnotebookTABSET_BUTTONS_SEPARATE"><HR><H4>vnotebookTABSET_BUTTONS_SEPARATE</H4></A>
<PRE>
        <B>vnotebookTABSET_BUTTONS_SEPARATE</B>
</PRE>
<A NAME="vnotebookTABSET_BUTTONS_ADJACENT"><PRE>
        <B>vnotebookTABSET_BUTTONS_ADJACENT</B>
</PRE>
</A>

<DL><DD>
Denotes whether the tabset buttons will be drawn adjacent
to each other or at separate ends of the tabset.
</DD></DL>
<P>
<A NAME="vnotebookTABSET_RIGHT"><HR><H4>vnotebookTABSET_RIGHT</H4></A>
<PRE>
        <B>vnotebookTABSET_RIGHT</B>
</PRE>
<A NAME="vnotebookTABSET_LEFT"><PRE>
        <B>vnotebookTABSET_LEFT</B>
</PRE>
</A>
<A NAME="vnotebookTABSET_BOTTOM"><PRE>
        <B>vnotebookTABSET_BOTTOM</B>
</PRE>
</A>
<A NAME="vnotebookTABSET_TOP"><PRE>
        <B>vnotebookTABSET_TOP</B>
</PRE>
</A>

<DL><DD>
Denotes where a tab should be drawn with respect to the
page for a given style.
</DD></DL>
<P>
<A NAME="vnotebookTABS_NONE"><HR><H4>vnotebookTABS_NONE</H4></A>
<PRE>
        <B>vnotebookTABS_NONE</B>
</PRE>
<A NAME="vnotebookTABS_PAGE"><PRE>
        <B>vnotebookTABS_PAGE</B>
</PRE>
</A>
<A NAME="vnotebookTABS_MAJOR"><PRE>
        <B>vnotebookTABS_MAJOR</B>
</PRE>
</A>
<A NAME="vnotebookTABS_MAJOR_AND_MINOR"><PRE>
        <B>vnotebookTABS_MAJOR_AND_MINOR</B>
</PRE>
</A>

<DL><DD>
Denotes the type of tabs that a style may have.
</DD></DL>
<P>
<A NAME="vnotebookTAB_STYLE_RECT"><HR><H4>vnotebookTAB_STYLE_RECT</H4></A>
<PRE>
        <B>vnotebookTAB_STYLE_RECT</B>
</PRE>
<A NAME="vnotebookTAB_STYLE_ROUND_RECT"><PRE>
        <B>vnotebookTAB_STYLE_ROUND_RECT</B>
</PRE>
</A>
<A NAME="vnotebookTAB_STYLE_BEVELED"><PRE>
        <B>vnotebookTAB_STYLE_BEVELED</B>
</PRE>
</A>

<DL><DD>
Denotes the drawing style for tabs.
</DD></DL>
<P>
<A NAME="vnotebookVERTICAL_TABS_NORMAL"><HR><H4>vnotebookVERTICAL_TABS_NORMAL</H4></A>
<PRE>
        <B>vnotebookVERTICAL_TABS_NORMAL</B>
</PRE>
<A NAME="vnotebookVERTICAL_TABS_ROTATED"><PRE>
        <B>vnotebookVERTICAL_TABS_ROTATED</B>
</PRE>
</A>

<DL><DD>
Denotes the drawing attitude of tabs on the vertical sides
of the notebook.
</DD></DL>
<P>
<A NAME="section_Macro"><HR>
<CENTER><H2>Macros</H2></CENTER></A><P>
<A NAME="vnotebookCLASS"><HR><H4>vnotebookCLASS</H4></A>
<PRE>
        #define <B>vnotebookCLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for notebook classes.
This macro expands to the contents of <CODE><A HREF="vnotebook-x.html#vnotebookClass"><CODE>vnotebookClass</CODE></A></CODE>.
<SAMP>SUPER</SAMP> is the type identifier of the class being declared. This
type is used by the class's subclasses to refer to it.  <SAMP>NOTEBOOK</SAMP>
is the type identifier of instances of the class being declared.
<SAMP>NOTIFY</SAMP> is the type identifier of the instance notification
function. <SAMP>TABSET</SAMP> is the type identifier of tabset associated
with the notebook. <SAMP>TAB</SAMP> is the type identifier of the tabs. For
example:
<p>
<SAMP>vnotebookCLASS(<A HREF="vnotebook-x.html#vnotebookClass"><CODE>vnotebookClass</CODE></A>, vnotebook,<A HREF="vnotebook-x.html#vnotebookNoteProc"><CODE>vnotebookNoteProc</CODE></A>,
<A HREF="vdialog-x.html#vdialogItem"><CODE>vdialogItem</CODE></A>, <A HREF="vnotebook-x.html#vnotebookTab"><CODE>vnotebookTab</CODE></A>);</SAMP>
<p>
This macro should come first in the subclass structure declaration.

</DD></DL>
<P>
<A NAME="vnotebookPageCLASS"><HR><H4>vnotebookPageCLASS</H4></A>
<PRE>
        #define <B>vnotebookPageCLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for page classes. This
macro expands to the contents of <CODE><A HREF="vnotebook-x.html#vnotebookPageClass"><CODE>vnotebookPageClass</CODE></A></CODE>.
<SAMP>SUPER</SAMP> is the type identifier of the class being declared. This
type is used by the class's subclasses to refer to it. <SAMP>PAGE</SAMP> is
the type identifier of instances of the class being declared.
<SAMP>TAB</SAMP> is the type identifier of the tabs. <SAMP>NOTIFY</SAMP> is the
type identifier of the instance notification function. For example:
<p>
<SAMP>vnotebookPageCLASS(<A HREF="vnotebook-x.html#vnotebookPageClass"><CODE>vnotebookPageClass</CODE></A>, vnotebookPage,
<A HREF="vnotebook-x.html#vnotebookTab"><CODE>vnotebookTab</CODE></A>, <A HREF="vnotebook-x.html#vnotebookPageNoteProc"><CODE>vnotebookPageNoteProc</CODE></A>);</SAMP>
<p>
This macro should come first in the subclass structure declaration.

</DD></DL>
<P>
<A NAME="vnotebookSTYLE_CLASS"><HR><H4>vnotebookSTYLE_CLASS</H4></A>
<PRE>
        #define <B>vnotebookSTYLE_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for style classes. This
macro expands to the contents of <SAMP><A HREF="vnotebook-x.html#vnotebookStyleClass"><CODE>vnotebookStyleClass</CODE></A></SAMP>.
<SAMP>SUPER</SAMP> is the type identifier of the class being declared. This
type is used by the class's subclasses to refer to it. <SAMP>STYLE</SAMP> is
the type identifier of instances of the class being declared. 
<p>
<SAMP>vnotebookSTYLE\_CLASS(<A HREF="vnotebook-x.html#vnotebookStyleClass"><CODE>vnotebookStyleClass</CODE></A>, <A HREF="vnotebook-x.html#vnotebookStyle"><CODE>vnotebookStyle</CODE></A>);</SAMP>
<p>
This macro should come first in the subclass structure declaration.

</DD></DL>
<P>
<A NAME="vnotebookSectionCLASS"><HR><H4>vnotebookSectionCLASS</H4></A>
<PRE>
        #define <B>vnotebookSectionCLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for section classes. This
macro expands to the contents of <CODE><A HREF="vnotebook-x.html#vnotebookSectionClass"><CODE>vnotebookSectionClass</CODE></A></CODE>.
<SAMP>SUPER</SAMP> is the type identifier of the class being declared. This
type is used by the class's subclasses to refer to it. <SAMP>SECTION</SAMP>
is the type identifier of instances of the class being declared.
<SAMP>TAB</SAMP> is the type identifier of the tabs. <SAMP>NOTIFY</SAMP> is the
type identifier of the instance notification function. For example:
<p>
<SAMP>vnotebookSectionCLASS(<A HREF="vnotebook-x.html#vnotebookSectionClass"><CODE>vnotebookSectionClass</CODE></A>, vnotebookSection,
<A HREF="vnotebook-x.html#vnotebookTab"><CODE>vnotebookTab</CODE></A>, <A HREF="vnotebook-x.html#vnotebookSectionNoteProc"><CODE>vnotebookSectionNoteProc</CODE></A>);</SAMP>
<p>
This macro should come first in the subclass structure declaration.

</DD></DL>
<P>
<A NAME="vnotebookTAB_CLASS"><HR><H4>vnotebookTAB_CLASS</H4></A>
<PRE>
        #define <B>vnotebookTAB_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for tab classes. This
macro expands to the contents of <CODE><A HREF="vnotebook-x.html#vnotebookTabClass"><CODE>vnotebookTabClass</CODE></A></CODE>. 
<SAMP>SUPER</SAMP> is the type identifier of the class being
declared. This type is used by the class's subclasses to refer to it. 
<SAMP>TAB</SAMP> is the type identifier of instances of the class 
being declared. <SAMP>NOTIFY</SAMP> is the type identifier of the 
instance notification function. For example:
<p>
<SAMP>vnotebookTabCLASS(<A HREF="vnotebook-x.html#vnotebookTabClass"><CODE>vnotebookTabClass</CODE></A>, <A HREF="vnotebook-x.html#vnotebookTab"><CODE>vnotebookTab</CODE></A>,
vnotebookTabNoteProc);</SAMP>
<p>
This macro should come first in the subclass structure declaration.

</DD></DL>
<P>

<P>
<!--[[/CONTENT]]-->

<HR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">
		<TD>
		<CENTER>
<!--[[NAVIGATE_ICONIC]]-->
<!--[[/NAVIGATE_ICONIC]]-->
		</CENTER>
		</TD>
		    
		<TD>
		<BR>
		<FONT SIZE=-1>
	        <A HREF="#Top">Top of This Page</A> <BR>
	        <A HREF="index.html">Table of Contents</A> <BR>
		<A HREF="../index.html">Switch to Another Document</A><BR>
		<BR>
		</FONT>
		</TD>

		<TD>
		<BR>
		<FONT SIZE=-1>
		Need help?
		<A HREF="../contact-visix.html">
		Contact Visix</A>.
		<BR> <BR>
	        <A HREF="../copyright.html">Copyright &#169; 1996-97</A>,
		<A HREF="http://www.visix.com/">Visix Software Inc.</A><BR>
		<BR>
		</FONT>
		</TD>

	</TR>

</TABLE>
		
</BODY>
</HTML>



