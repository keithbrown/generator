<HTML>
  <HEAD>
<!--[[HEADING]]-->
<title>vscrap prefix</title><!--[[/HEADING]]-->
  </HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<A NAME="Top"><IMG SRC="../graphics/trans.gif" WIDTH=2 HEIGHT=2></A><BR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">

		<TD>
		<CENTER>
		<A HREF="../index.html">
		<IMG SRC="../graphics/logo.gif" BORDER=0></A>
		</CENTER>
		</TD>

	        <TD VALIGN=TOP>
	        <BR><H1>
<!--[[TITLE]]-->
vscrap prefix<!--[[/TITLE]]-->
	        </H1><BR>
		</TD>
      
	</TR>

</TABLE>

<HR>

<BR>

<!--[[PREAMBLE]]-->
<TABLE>
<TR>
<TD><A HREF="vscrap-x.html#section_DataType">Types</A> [38]</TD>
<TD><A HREF="vscrap-x.html#section_Function">Functions</A> [156]</TD>
<TD><A HREF="vscrap-x.html#section_Message">Messages</A> [40]</TD>
<TD><A HREF="vscrap-x.html#section_Constant">Constants</A> [1]</TD>
<TD><A HREF="vscrap-x.html#section_Macro">Macros</A> [18]</TD>
</TR>
</TABLE>
<!--[[/PREAMBLE]]-->

<!--[[CONTENT]]-->

<P>
<A NAME="section_DataType"><HR>
<CENTER><H2>Types</H2></CENTER></A><P>
<A NAME="vscrap"><HR><H4>vscrap</H4></A>
<PRE>
        typedef ... <B>vscrap</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a single
scrap; objects of this type have classes derived from
<CODE><A HREF="vscrap-x.html#vscrapClass"><CODE>vscrapClass</CODE></A></CODE>. A scrap is an object that
encapsulates a piece of data (or reference to that data)
and the knowledge required to access and interpret that
data. Scraps are referenced by a pointer to this type.
Native scraps can be created dynamically using the various
<SAMP>vscrapCreate</SAMP> and <SAMP>vscrapFrom</SAMP>
functions, as well as functions in other managers that
create scraps that represent their data types. All object
types and classes that directly inherit from
<CODE><A HREF="vscrap-x.html#vscrapClass"><CODE>vscrapClass</CODE></A></CODE> must declare a <CODE>vscrap</CODE>
as their first field so that <CODE>vscrap</CODE> pointers
can be interchanged with pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapArray"><HR><H4>vscrapArray</H4></A>
<PRE>
        typedef ... <B>vscrapArray</B>;
</PRE>

<DL><DD>
Contains the information needed to represent an array
scrap; objects of this type have classes derived from
<CODE><A HREF="vscrap-x.html#vscrapArrayClass"><CODE>vscrapArrayClass</CODE></A></CODE>. An array scrap is a scrap
that includes the knowledge required to access its data as
an indexed collection of other scraps. Array scraps are
referenced by a pointer to this type. Native array scraps
can be created dynamically using the
<CODE><A HREF="vscrap-x.html#vscrapCreateArray"><CODE>vscrapCreateArray</CODE></A></CODE> function. All object types
and classes that directly inherit from
<CODE><A HREF="vscrap-x.html#vscrapArrayClass"><CODE>vscrapArrayClass</CODE></A></CODE> must declare a
<CODE>vscrapArray</CODE> as their first field so that
<CODE>vscrapArray</CODE> pointers can be interchanged with
pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapArrayClass"><HR><H4>vscrapArrayClass</H4></A>
<PRE>
        typedef ... <B>vscrapArrayClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrapArray</CODE>. Classes declared with this type
contain the same set of methods and variables as the
default array Scrap class, but the behavior of methods and
the contents of variables may vary. This class type is
derived from <CODE><A HREF="vscrap-x.html#vscrapCompoundClass"><CODE>vscrapCompoundClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapArrayIterator"><HR><H4>vscrapArrayIterator</H4></A>
<PRE>
        typedef ... <B>vscrapArrayIterator</B>;
</PRE>

<DL><DD>
Contains the information needed to represent an array scrap
iterator; objects of this type have classes derived from
<CODE><A HREF="vscrap-x.html#vscrapArrayIteratorClass"><CODE>vscrapArrayIteratorClass</CODE></A></CODE>. An array scrap
iterator is an object that is used to iterate over the
indexed elements in an array scrap. Array scrap iterators
are referenced by a pointer to this type. All object types
and classes that directly inherit from
<CODE><A HREF="vscrap-x.html#vscrapArrayIteratorClass"><CODE>vscrapArrayIteratorClass</CODE></A></CODE> must declare a
<CODE>vscrapArrayIterator</CODE> as their first field so
that <CODE>vscrapArrayIterator</CODE> pointers can be
interchanged with pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapArrayIteratorClass"><HR><H4>vscrapArrayIteratorClass</H4></A>
<PRE>
        typedef ... <B>vscrapArrayIteratorClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrapArrayIterator</CODE>. Classes declared with
this type contain the same set of methods and variables as
the default array scrap iterator class, but the behavior of
methods and the contents of variables may vary. This class
type is derived from
<CODE><A HREF="vscrap-x.html#vscrapCompoundIteratorClass"><CODE>vscrapCompoundIteratorClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapBlock"><HR><H4>vscrapBlock</H4></A>
<PRE>
        typedef ... <B>vscrapBlock</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a block
scrap; objects of this type have classes derived from
<CODE><A HREF="vscrap-x.html#vscrapBlockClass"><CODE>vscrapBlockClass</CODE></A></CODE>. A block scrap is a scrap
that includes the knowledge required to access its data as
a fixed length chunk of opaque data. Block scraps are
referenced by a pointer to this type. Native block scraps
can be created dynamically using the
<CODE><A HREF="vscrap-x.html#vscrapCreateMemory"><CODE>vscrapCreateMemory</CODE></A></CODE> function. All object types
and classes that directly inherit from
<CODE><A HREF="vscrap-x.html#vscrapBlockClass"><CODE>vscrapBlockClass</CODE></A></CODE> must declare a
<CODE>vscrapBlock</CODE> as their first field so that
<CODE>vscrapBlock</CODE> pointers can be interchanged with
pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapBlockClass"><HR><H4>vscrapBlockClass</H4></A>
<PRE>
        typedef ... <B>vscrapBlockClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrapBlock</CODE>. Classes declared with this type
contain the same set of methods and variables as the
default block Scrap class, but the behavior of methods and
the contents of variables may vary. This class type is
derived from <CODE><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapBoolean"><HR><H4>vscrapBoolean</H4></A>
<PRE>
        typedef ... <B>vscrapBoolean</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a boolean
scrap---objects of this type have classes derived from
<CODE><A HREF="vscrap-x.html#vscrapBooleanClass"><CODE>vscrapBooleanClass</CODE></A></CODE>. A boolean scrap is a scrap
that includes the knowledge required to access its data as
a boolean. Boolean scraps are referenced by a pointer to
this type. Native boolean scraps can be created dynamically
using the <CODE><A HREF="vscrap-x.html#vscrapFromBoolean"><CODE>vscrapFromBoolean</CODE></A></CODE> function. All
object types and classes that directly inherit from
<CODE><A HREF="vscrap-x.html#vscrapBooleanClass"><CODE>vscrapBooleanClass</CODE></A></CODE> must declare a
<CODE>vscrapBoolean</CODE> as their first field so that
<CODE>vscrapBoolean</CODE> pointers can be interchanged
with pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapBooleanClass"><HR><H4>vscrapBooleanClass</H4></A>
<PRE>
        typedef ... <B>vscrapBooleanClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrapBoolean</CODE>. Classes declared with this type
contain the same set of methods and variables as the
default boolean Scrap class, but the behavior of methods
and the contents of variables may vary. This class type is
derived from <CODE><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapCannotConvertException"><HR><H4>vscrapCannotConvertException</H4></A>
<PRE>
        typedef ... <B>vscrapCannotConvertException</B>;
</PRE>

<DL><DD>
Generated by the <SAMP><A HREF="vscrap-x.html#vscrapEXPORT"><CODE>vscrapEXPORT</CODE></A></SAMP> method of the
default abstract convertible Scrap class; this class must
be subclassed before it becomes useful. It is also
generated by <CODE><A HREF="vscrap-x.html#vscrapConvertStack"><CODE>vscrapConvertStack</CODE></A></CODE> if a class
cannot be found in the destination scrap that implements
the methods required to convert the source scrap.
</DD></DL>
<P>
<A NAME="vscrapCharacter"><HR><H4>vscrapCharacter</H4></A>
<PRE>
        typedef ... <B>vscrapCharacter</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a character
scrap; objects of this type have classes derived from
<CODE><A HREF="vscrap-x.html#vscrapCharacterClass"><CODE>vscrapCharacterClass</CODE></A></CODE>. A character scrap is a
scrap that includes the knowledge required to access its
data as a <SAMP><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></SAMP>.Character scraps are
referenced by a pointer to this type. Native character
scraps can be created dynamically using the
<CODE><A HREF="vscrap-x.html#vscrapFromCharacter"><CODE>vscrapFromCharacter</CODE></A></CODE> function. All object types
and classes that directly inherit from
<CODE><A HREF="vscrap-x.html#vscrapCharacterClass"><CODE>vscrapCharacterClass</CODE></A></CODE> must declare a
<CODE>vscrapCharacter</CODE> as their first field so that
<CODE>vscrapCharacter</CODE> pointers can be interchanged
with pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapCharacterClass"><HR><H4>vscrapCharacterClass</H4></A>
<PRE>
        typedef ... <B>vscrapCharacterClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrapCharacter</CODE>. Classes declared with this
type contain the same set of methods and variables as the
default character Scrap class, but the behavior of methods
and the contents of variables may vary. This class type is
derived from <CODE><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapClass"><HR><H4>vscrapClass</H4></A>
<PRE>
        typedef ... <B>vscrapClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrap</CODE>. Classes declared with this type
contain the same set of methods and variables as the
default Scrap class, but the behavior of methods and the
contents of variables may vary. This class type is derived
from <CODE><A HREF="vinstance-x.html#vinstanceClass"><CODE>vinstanceClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapCompound"><HR><H4>vscrapCompound</H4></A>
<PRE>
        typedef ... <B>vscrapCompound</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a compound
scrap---objects of this type have classes derived from
<CODE><A HREF="vscrap-x.html#vscrapCompoundClass"><CODE>vscrapCompoundClass</CODE></A></CODE>. A compound scrap is a
scrap that includes the knowledge required to access its
data as a collection of other scraps. Compound scraps are
referenced by a pointer to this type. Compound scraps can
be created dynamically using the
<CODE>vscrapCreateCompound</CODE> function. All object
types and classes that directly inherit from
<CODE><A HREF="vscrap-x.html#vscrapCompoundClass"><CODE>vscrapCompoundClass</CODE></A></CODE> must declare a
<CODE>vscrapCompound</CODE> as their first field so that
<CODE>vscrapCompound</CODE> pointers can be interchanged
with pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapCompoundClass"><HR><H4>vscrapCompoundClass</H4></A>
<PRE>
        typedef ... <B>vscrapCompoundClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrapCompound</CODE>. Classes declared with this
type contain the same set of methods and variables as the
default compound Scrap class, but the behavior of methods
and the contents of variables may vary. This class type is
derived from <CODE><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapCompoundIterator"><HR><H4>vscrapCompoundIterator</H4></A>
<PRE>
        typedef ... <B>vscrapCompoundIterator</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a compound
scrap iterator; objects of this type have classes
derived from <CODE><A HREF="vscrap-x.html#vscrapCompoundIteratorClass"><CODE>vscrapCompoundIteratorClass</CODE></A></CODE>. A
compound scrap iterator is an object that is used to
iterate over the elements in a compound scrap. Compound
scrap iterators are referenced by a pointer to this type.
All object types and classes that directly inherit from
<CODE><A HREF="vscrap-x.html#vscrapCompoundIteratorClass"><CODE>vscrapCompoundIteratorClass</CODE></A></CODE> must declare a
<CODE>vscrapCompoundIterator</CODE> as their first field so
that <CODE>vscrapCompoundIterator</CODE> pointers can be
interchanged with pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapCompoundIteratorClass"><HR><H4>vscrapCompoundIteratorClass</H4></A>
<PRE>
        typedef ... <B>vscrapCompoundIteratorClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrapCompoundIterator</CODE>. Classes declared with
this type contain the same set of methods and variables as
the default compound scrap iterator class, but the behavior
of methods and the contents of variables may vary. This
class type is derived from <CODE><A HREF="vscrap-x.html#vscrapIteratorClass"><CODE>vscrapIteratorClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapConvertible"><HR><H4>vscrapConvertible</H4></A>
<PRE>
        typedef ... <B>vscrapConvertible</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a convertible
scrap; objects of this type have classes derived from
<CODE><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A></CODE>. A convertible scrap is
a scrap that includes the knowledge required to convert the
scrap contents to and from other scraps of the same class.
Convertible scraps are referenced by a pointer to this
type. All object types and classes that directly inherit
from <CODE><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A></CODE> must declare a
<CODE>vscrapConvertible</CODE> as their first field so that
<CODE>vscrapConvertible</CODE> pointers can be interchanged
with pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapConvertibleClass"><HR><H4>vscrapConvertibleClass</H4></A>
<PRE>
        typedef ... <B>vscrapConvertibleClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrapConvertible</CODE>. Classes declared with this
type contain the same set of methods and variables as the
default convertible Scrap class, but the behavior of
methods and the contents of variables may vary. This class
type is derived from <CODE><A HREF="vdelegator-x.html#vdelegatorClass"><CODE>vdelegatorClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapDictionary"><HR><H4>vscrapDictionary</H4></A>
<PRE>
        typedef ... <B>vscrapDictionary</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a dictionary
scrap; objects of this type have classes derived from
<CODE><A HREF="vscrap-x.html#vscrapDictionaryClass"><CODE>vscrapDictionaryClass</CODE></A></CODE>. A dictionary scrap is a
scrap that includes the knowledge required to access its
data as a tagged collection of other scraps. Dictionary
scraps are referenced by a pointer to this type. Native
dictionary scraps can be created dynamically using the
<CODE><A HREF="vscrap-x.html#vscrapCreateDictionary"><CODE>vscrapCreateDictionary</CODE></A></CODE> function. All object
types and classes that directly inherit from
<CODE><A HREF="vscrap-x.html#vscrapDictionaryClass"><CODE>vscrapDictionaryClass</CODE></A></CODE> must declare a
<CODE>vscrapDictionary</CODE> as their first field so that
<CODE>vscrapDictionary</CODE> pointers can be interchanged
with pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapDictionaryClass"><HR><H4>vscrapDictionaryClass</H4></A>
<PRE>
        typedef ... <B>vscrapDictionaryClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrapDictionary</CODE>. Classes declared with this
type contain the same set of methods and variables as the
default dictionary Scrap class, but the behavior of methods
and the contents of variables may vary. This class type is
derived from <CODE><A HREF="vscrap-x.html#vscrapCompoundClass"><CODE>vscrapCompoundClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapDictionaryIterator"><HR><H4>vscrapDictionaryIterator</H4></A>
<PRE>
        typedef ... <B>vscrapDictionaryIterator</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a dictionary
scrap iterator; objects of this type have classes derived
from <CODE><A HREF="vscrap-x.html#vscrapDictionaryIteratorClass"><CODE>vscrapDictionaryIteratorClass</CODE></A></CODE>. A
dictionary scrap iterator is an object that is used to
iterate over the elements in a dictionary scrap. Dictionary
scrap iterators are referenced by a pointer to this type.
All object types and classes that directly inherit from
<CODE><A HREF="vscrap-x.html#vscrapDictionaryIteratorClass"><CODE>vscrapDictionaryIteratorClass</CODE></A></CODE> must declare a
<CODE>vscrapDictionaryIterator</CODE> as their first field
so that <CODE>vscrapDictionaryIterator</CODE> pointers can
be interchanged with pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapDictionaryIteratorClass"><HR><H4>vscrapDictionaryIteratorClass</H4></A>
<PRE>
        typedef ... <B>vscrapDictionaryIteratorClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrapDictionaryIterator</CODE>. Classes declared
with this type contain the same set of methods and
variables as the default dictionary scrap iterator class,
but the behavior of methods and the contents of variables
may vary. This class type is derived from
<CODE><A HREF="vscrap-x.html#vscrapCompoundIteratorClass"><CODE>vscrapCompoundIteratorClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapFixed"><HR><H4>vscrapFixed</H4></A>
<PRE>
        typedef ... <B>vscrapFixed</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a fixed
scrap---objects of this type have classes derived from
<CODE><A HREF="vscrap-x.html#vscrapFixedClass"><CODE>vscrapFixedClass</CODE></A></CODE>. A fixed scrap is a scrap
that includes the knowledge required to access its data as
a fixed point value. Fixed scraps are referenced by a
pointer to this type. Native fixed scraps can be created
dynamically using the <CODE><A HREF="vscrap-x.html#vscrapFromFixed"><CODE>vscrapFromFixed</CODE></A></CODE>
function. All object types and classes that directly
inherit from <CODE><A HREF="vscrap-x.html#vscrapFixedClass"><CODE>vscrapFixedClass</CODE></A></CODE> must declare a
<CODE>vscrapFixed</CODE> as their first field so that
<CODE>vscrapFixed</CODE> pointers can be interchanged with
pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapFixedClass"><HR><H4>vscrapFixedClass</H4></A>
<PRE>
        typedef ... <B>vscrapFixedClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrapFixed</CODE>. Classes declared with this type
contain the same set of methods and variables as the
default fixed Scrap class, but the behavior of methods and
the contents of variables may vary. This class type is
derived from <CODE><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapFloat"><HR><H4>vscrapFloat</H4></A>
<PRE>
        typedef ... <B>vscrapFloat</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a float
scrap; objects of this type have classes derived from
<CODE><A HREF="vscrap-x.html#vscrapFloatClass"><CODE>vscrapFloatClass</CODE></A></CODE>. A float scrap is a scrap
that includes the knowledge required to access its data as
a floating point value. Float scraps are referenced by a
pointer to this type. Native float scraps can be created
dynamically using the <CODE><A HREF="vscrap-x.html#vscrapFromFloat"><CODE>vscrapFromFloat</CODE></A></CODE>
function. All object types and classes that directly
inherit from <CODE><A HREF="vscrap-x.html#vscrapFloatClass"><CODE>vscrapFloatClass</CODE></A></CODE> must declare a
<CODE>vscrapFloat</CODE> as their first field so that
<CODE>vscrapFloat</CODE> pointers can be interchanged with
pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapFloatClass"><HR><H4>vscrapFloatClass</H4></A>
<PRE>
        typedef ... <B>vscrapFloatClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrapFloat</CODE>. Classes declared with this type
contain the same set of methods and variables as the
default float Scrap class, but the behavior of methods and
the contents of variables may vary. This class type is
derived from <CODE><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapInteger"><HR><H4>vscrapInteger</H4></A>
<PRE>
        typedef ... <B>vscrapInteger</B>;
</PRE>

<DL><DD>
Contains the information needed to represent an integer
scrap; objects of this type have classes derived from
<CODE><A HREF="vscrap-x.html#vscrapIntegerClass"><CODE>vscrapIntegerClass</CODE></A></CODE>. An integer scrap is a
scrap that includes the knowledge required to access its
data as an integer. Integer scraps are referenced by a
pointer to this type. Native integer scraps can be created
dynamically using the <CODE><A HREF="vscrap-x.html#vscrapFromInteger"><CODE>vscrapFromInteger</CODE></A></CODE>
function. All object types and classes that directly
inherit from <CODE><A HREF="vscrap-x.html#vscrapIntegerClass"><CODE>vscrapIntegerClass</CODE></A></CODE> must declare a
<CODE>vscrapInteger</CODE> as their first field so that
<CODE>vscrapInteger</CODE> pointers can be interchanged
with pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapIntegerClass"><HR><H4>vscrapIntegerClass</H4></A>
<PRE>
        typedef ... <B>vscrapIntegerClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrapInteger</CODE>. Classes declared with this type
contain the same set of methods and variables as the
default integer Scrap class, but the behavior of methods
and the contents of variables may vary. This class type is
derived from <CODE><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapIterator"><HR><H4>vscrapIterator</H4></A>
<PRE>
        typedef ... <B>vscrapIterator</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a scrap
iterator; objects of this type have classes derived from
<CODE><A HREF="vscrap-x.html#vscrapIteratorClass"><CODE>vscrapIteratorClass</CODE></A></CODE>. A scrap iterator is an
object that is used to iterate over the scrap elements of a
composite scrap. Scrap iterators are referenced by a
pointer to this type. Native scrap iterators can be created
dynamically using <CODE><A HREF="vscrap-x.html#vscrapCreateIteratorOfClass"><CODE>vscrapCreateIteratorOfClass</CODE></A></CODE>
or initialized statically using
<CODE><A HREF="vscrap-x.html#vscrapInitIteratorOfClass"><CODE>vscrapInitIteratorOfClass</CODE></A></CODE>. All object types
and classes that directly inherit from
<CODE><A HREF="vscrap-x.html#vscrapIteratorClass"><CODE>vscrapIteratorClass</CODE></A></CODE> must declare a
<CODE>vscrapIterator</CODE> as their first field so that
<CODE>vscrapIterator</CODE> pointers can be interchanged
with pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapIteratorClass"><HR><H4>vscrapIteratorClass</H4></A>
<PRE>
        typedef ... <B>vscrapIteratorClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrapIterator</CODE>. Classes declared with this
type contain the same set of methods and variables as the
default scrap iterator class, but the behavior of methods
and the contents of variables may vary. This class type is
derived from <CODE><A HREF="vclass-x.html#vclassROOT"><CODE>vclassROOT</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapString"><HR><H4>vscrapString</H4></A>
<PRE>
        typedef ... <B>vscrapString</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a string
scrap; objects of this type have classes derived from
<CODE><A HREF="vscrap-x.html#vscrapStringClass"><CODE>vscrapStringClass</CODE></A></CODE>. A string scrap is a scrap
that includes the knowledge required to access its data as
a string using String class scribes. String scraps are
referenced by a pointer to this type. Native string scraps
can be created dynamically using the
<CODE><A HREF="vscrap-x.html#vscrapFromString"><CODE>vscrapFromString</CODE></A></CODE> function. All object types
and classes that directly inherit from
<CODE><A HREF="vscrap-x.html#vscrapStringClass"><CODE>vscrapStringClass</CODE></A></CODE> must declare a
<CODE>vscrapString</CODE> as their first field so that
<CODE>vscrapString</CODE> pointers can be interchanged with
pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapStringClass"><HR><H4>vscrapStringClass</H4></A>
<PRE>
        typedef ... <B>vscrapStringClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrapString</CODE>. Classes declared with this type
contain the same set of methods and variables as the
default string Scrap class, but the behavior of methods and
the contents of variables may vary. This class type is
derived from <CODE><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapTag"><HR><H4>vscrapTag</H4></A>
<PRE>
        typedef ... <B>vscrapTag</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a tag
scrap; objects of this type have classes derived from
<CODE><A HREF="vscrap-x.html#vscrapTagClass"><CODE>vscrapTagClass</CODE></A></CODE>. A tag scrap is a scrap that
includes the knowledge required to access its data as a
<SAMP>const <A HREF="vname-x.html#vname"><CODE>vname</CODE></A> *</SAMP>. Tag scraps are referenced by a
pointer to this type. Native tag scraps can be created
dynamically using the <CODE><A HREF="vscrap-x.html#vscrapFromTag"><CODE>vscrapFromTag</CODE></A></CODE> function.
All object types and classes that directly inherit from
<CODE><A HREF="vscrap-x.html#vscrapTagClass"><CODE>vscrapTagClass</CODE></A></CODE> must declare a
<CODE>vscrapTag</CODE> as their first field so that
<CODE>vscrapTag</CODE> pointers can be interchanged with
pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapTagClass"><HR><H4>vscrapTagClass</H4></A>
<PRE>
        typedef ... <B>vscrapTagClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrapTag</CODE>. Classes declared with this type
contain the same set of methods and variables as the
default tag Scrap class, but the behavior of methods and
the contents of variables may vary. This class type is
derived from <CODE><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapTypeable"><HR><H4>vscrapTypeable</H4></A>
<PRE>
        typedef ... <B>vscrapTypeable</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a typeable
scrap; objects of this type have classes derived from
<CODE><A HREF="vscrap-x.html#vscrapTypeableClass"><CODE>vscrapTypeableClass</CODE></A></CODE>. A typeable scrap is a
scrap that includes the knowledge required to assign a type
to a previously untyped scrap. Typeable scraps are
referenced by a pointer to this type. Native typeable
scraps can be created by <CODE><A HREF="vscrap-x.html#vscrapCreateNative"><CODE>vscrapCreateNative</CODE></A></CODE>.
All object types and classes that directly inherit from
<CODE><A HREF="vscrap-x.html#vscrapTypeableClass"><CODE>vscrapTypeableClass</CODE></A></CODE> must declare a
<CODE>vscrapTypeable</CODE> as their first field so that
<CODE>vscrapTypeable</CODE> pointers can be interchanged
with pointers to the new data type.
</DD></DL>
<P>
<A NAME="vscrapTypeableClass"><HR><H4>vscrapTypeableClass</H4></A>
<PRE>
        typedef ... <B>vscrapTypeableClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<CODE>vscrapTypeable</CODE>. Classes declared with this
type contain the same set of methods and variables as the
default typeable Scrap class, but the behavior of methods
and the contents of variables may vary. This class type is
derived from <CODE><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapUnimplementedException"><HR><H4>vscrapUnimplementedException</H4></A>
<PRE>
        typedef ... <B>vscrapUnimplementedException</B>;
</PRE>

<DL><DD>
Generated by all <SAMP>GET</SAMP> and <SAMP>SET</SAMP>
methods for the default abstract Scrap classes; these
classes must be subclassed before they become useful.
</DD></DL>
<P>
<A NAME="section_Function"><HR>
<CENTER><H2>Functions</H2></CENTER></A><P>
<A NAME="vscrap"><HR><H4>vscrap</H4></A>
<PRE>
        void <B>vscrap</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vscrapAddElement"><HR><H4>vscrapAddElement</H4></A>
<PRE>
        void <B>vscrapAddElement</B>(
                vscrap * scrap,
                vscrap * element);
</PRE>

<DL><DD>
Adds the scrap <SAMP>element</SAMP> to the compound
<SAMP>scrap</SAMP> object. 
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapADD_ELEMENT"><CODE>vscrapADD_ELEMENT</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapCompoundClass"><CODE>vscrapCompoundClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapAddElementStack"><HR><H4>vscrapAddElementStack</H4></A>
<PRE>
        void <B>vscrapAddElementStack</B>(
                vdelegatorStack stack,
                vscrap * element);
</PRE>

<DL><DD>
Adds the scrap <SAMP>element</SAMP> to the compound scrap
that <SAMP>stack</SAMP> is directed to.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapADD_ELEMENT"><CODE>vscrapADD_ELEMENT</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapCompoundClass"><CODE>vscrapCompoundClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapConvert"><HR><H4>vscrapConvert</H4></A>
<PRE>
        void <B>vscrapConvert</B>(
                vscrap * from,
                vscrap * to);
</PRE>

<DL><DD>
Copies the contents of <SAMP>from</SAMP> to the scrap
<SAMP>to</SAMP>. This is accomplished by finding a delegate
of <SAMP>from</SAMP> which can export its data to
<SAMP>to</SAMP>.
  <P>
If the conversion is not possible, a
<CODE><A HREF="vscrap-x.html#vscrapCannotConvertException"><CODE>vscrapCannotConvertException</CODE></A></CODE> exception is
raised. A conversion fails if <SAMP>to</SAMP> does not
implement the methods required to access the data referred
to by <SAMP>from</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapConvertStack"><HR><H4>vscrapConvertStack</H4></A>
<PRE>
        void <B>vscrapConvertStack</B>(
                vdelegatorStack source,
                vdelegatorStack dest);
</PRE>

<DL><DD>
Copies the contents of the convertible scrap that
<SAMP>source</SAMP> is directed to. The contents are copied
to the convertible scrap that <SAMP>dest</SAMP> is directed
to. This is accomplished by finding a delegate of
<SAMP>source</SAMP> which can export its data to
<SAMP>dest</SAMP>.
  <P>
If the conversion is not possible, a
<CODE><A HREF="vscrap-x.html#vscrapCannotConvertException"><CODE>vscrapCannotConvertException</CODE></A></CODE> exception is
raised. A conversion fails if <SAMP>to</SAMP> does not
implement the methods required to access the data referred
to by <SAMP>from</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapConvertToNative"><HR><H4>vscrapConvertToNative</H4></A>
<PRE>
        vscrap * <B>vscrapConvertToNative</B>(
                vscrap * from);
</PRE>

<DL><DD>
Converts the <SAMP>from</SAMP> scrap into a scrap that uses
the native data representation. This scrap has its own
private copy of the data. <SAMP>from</SAMP> is destroyed by
this call.
</DD></DL>
<P>
<A NAME="vscrapCreateArray"><HR><H4>vscrapCreateArray</H4></A>
<PRE>
        vscrap * <B>vscrapCreateArray</B>();
</PRE>

<DL><DD>
Creates an empty native array scrap.
</DD></DL>
<P>
<A NAME="vscrapCreateCompoundElementIterator"><HR><H4>vscrapCreateCompoundElementIterator</H4></A>
<PRE>
        vscrapCompoundIterator * <B>vscrapCreateCompoundElementIterator</B>(
                vscrap * scrap);
</PRE>

<DL><DD>
Creates a compound scrap iterator that can be used to
iterate over the elements in the compound scrap
<SAMP>scrap</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapCreateCompoundElementIteratorStack"><HR><H4>vscrapCreateCompoundElementIteratorStack</H4></A>
<PRE>
        vscrapCompoundIterator * <B>vscrapCreateCompoundElementIteratorStack</B>(
                vdelegatorStack stack);
</PRE>

<DL><DD>
Creates a compound scrap iterator that can be used to
iterate over the elements in the compound scrap
<SAMP>stack</SAMP> is directed to.
</DD></DL>
<P>
<A NAME="vscrapCreateDictionary"><HR><H4>vscrapCreateDictionary</H4></A>
<PRE>
        vscrap * <B>vscrapCreateDictionary</B>();
</PRE>

<DL><DD>
Creates an empty native dictionary scrap.
</DD></DL>
<P>
<A NAME="vscrapCreateIteratorOfClass"><HR><H4>vscrapCreateIteratorOfClass</H4></A>
<PRE>
        vscrapIterator * <B>vscrapCreateIteratorOfClass</B>(
                void * clas,
                const vdelegatorStack * stack);
</PRE>

<DL><DD>
Begins an iteration of all the scrap elements of a
multi-element scrap by dynamically allocating an iterator
object of class <SAMP>clas</SAMP> and initializing it to
refer to the scrap object represented by the delegator
stack <SAMP>stack</SAMP>. The iterator initially contains
no element; <CODE><A HREF="vscrap-x.html#vscrapNextIterator"><CODE>vscrapNextIterator</CODE></A></CODE> must be called
to obtain the first element of the scrap. Note that the
order in which elements are obtained by the iterator is
arbitrary.
</DD></DL>
<P>
<A NAME="vscrapCreateMemory"><HR><H4>vscrapCreateMemory</H4></A>
<PRE>
        vscrap * <B>vscrapCreateMemory</B>();
</PRE>

<DL><DD>
Creates an empty native data block scrap.
</DD></DL>
<P>
<A NAME="vscrapCreateNative"><HR><H4>vscrapCreateNative</H4></A>
<PRE>
        vscrap * <B>vscrapCreateNative</B>();
</PRE>

<DL><DD>
Dynamically allocates an untyped native scrap. The
resulting scrap can be used as a generic target for scrap
conversion or entyping.
</DD></DL>
<P>
<A NAME="vscrapCreateReference"><HR><H4>vscrapCreateReference</H4></A>
<PRE>
        vscrap * <B>vscrapCreateReference</B>(
                vscrap * scrap);
</PRE>

<DL><DD>
Creates a scrap that references the same data as
<SAMP>scrap</SAMP>. The resulting scrap behaves identically
to the scrap it references except that destroying the new
scrap does not destroy the data associated with the old
scrap.
  <P>
Note that <SAMP>scrap</SAMP> must not be destroyed for the
reference scrap to continue to function properly.
</DD></DL>
<P>
<A NAME="vscrapDestroy"><HR><H4>vscrapDestroy</H4></A>
<PRE>
        void <B>vscrapDestroy</B>(
                vscrap * scrap);
</PRE>

<DL><DD>
Destroys the scrap <SAMP>scrap</SAMP>. If the data
referenced by the scrap is owned by the scrap, the data is
also destroyed. Use this function to reclaim the storage
occupied by a scrap. The scrap should not be referenced by
any other object when it is destroyed. This function is
implemented by sending the message
<CODE><A HREF="vinstance-x.html#vinstanceDESTROY"><CODE>vinstanceDESTROY</CODE></A></CODE> to <SAMP>scrap</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapDestroyIterator"><HR><H4>vscrapDestroyIterator</H4></A>
<PRE>
        void <B>vscrapDestroyIterator</B>(
                vscrapIterator * iter);
</PRE>

<DL><DD>
Terminates the iteration represented by <SAMP>iter</SAMP>,
even if it is not yet exhausted. This function is necessary
to reclaim storage allocated for the iterator by the
Representation Manager. This function is implemented by
sending the message <CODE><A HREF="vscrap-x.html#vscrapDESTROY_ITERATOR"><CODE>vscrapDESTROY_ITERATOR</CODE></A></CODE> to
iter.
</DD></DL>
<P>
<A NAME="vscrapDump"><HR><H4>vscrapDump</H4></A>
<PRE>
        void <B>vscrapDump</B>(
                vscrap * scrap,
                FILE * stream);
</PRE>

<DL><DD>
Prints the contents of the convertible scrap
<SAMP>scrap</SAMP> on to the file <SAMP>stream</SAMP> in
user-readable form. This function is intended for debugging
purposes and should not be used to store the contents of
the scrap in a readable form.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapDUMP"><CODE>vscrapDUMP</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapDumpStack"><HR><H4>vscrapDumpStack</H4></A>
<PRE>
        void <B>vscrapDumpStack</B>(
                vdelegatorStack stack,
                FILE * stream);
</PRE>

<DL><DD>
Prints the contents of the convertible scrap that
<SAMP>stack</SAMP> is directed to. The contents are printed
to the file <SAMP>stream</SAMP> in user-readable form. This
function is intended for debugging purposes and should not
be used to store the contents of the scrap in a readable
form.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapDUMP"><CODE>vscrapDUMP</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapEmptyElements"><HR><H4>vscrapEmptyElements</H4></A>
<PRE>
        void <B>vscrapEmptyElements</B>(
                vscrap * scrap);
</PRE>

<DL><DD>
Removes all existing scrap elements from the compound scrap
<SAMP>scrap</SAMP>.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapEMPTY_ELEMENTS"><CODE>vscrapEMPTY_ELEMENTS</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapCompoundClass"><CODE>vscrapCompoundClass</CODE></A></SAMP>
</DD></DL>
<P>
<A NAME="vscrapEmptyElementsStack"><HR><H4>vscrapEmptyElementsStack</H4></A>
<PRE>
        void <B>vscrapEmptyElementsStack</B>(
                vdelegatorStack stack);
</PRE>

<DL><DD>
Removes all existing scrap elements from the compound scrap
<SAMP>stack</SAMP> is directed to.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapEMPTY_ELEMENTS"><CODE>vscrapEMPTY_ELEMENTS</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapCompoundClass"><CODE>vscrapCompoundClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapEntype"><HR><H4>vscrapEntype</H4></A>
<PRE>
        vbool <B>vscrapEntype</B>(
                vscrap * scrap,
                void * clas);
</PRE>

<DL><DD>
Modifies the type of <SAMP>scrap</SAMP> so that it
delegates to an object which <CODE>IsKindOf</CODE>
<SAMP>clas</SAMP>. It returns <SAMP>TRUE</SAMP> if
successful, <SAMP>FALSE</SAMP> if not.
  <P>
For example, calling <CODE>vscrapEntype</CODE> on a scrap
created by the Resource Manager causes the scrap to set the
type of the resource to which it refers to a type
compatible with <SAMP>clas</SAMP>.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapENTYPE"><CODE>vscrapENTYPE</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapTypeableClass"><CODE>vscrapTypeableClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapEntypeStack"><HR><H4>vscrapEntypeStack</H4></A>
<PRE>
        vbool <B>vscrapEntypeStack</B>(
                vdelegatorStack stack,
                void * clas);
</PRE>

<DL><DD>
Modifies the type of the typeable scrap <SAMP>stack</SAMP>
is directed to so that it delegates to an object which
<CODE>IsKindOf</CODE> <SAMP>clas</SAMP>. It returns
<SAMP>TRUE</SAMP> if successful, <SAMP>FALSE</SAMP> if not.
  <P>
For example, calling <CODE>vscrapEntype</CODE> on a scrap
created by the Resource Manager causes the scrap to set the
type of the resource to which it refers to a type
compatible with <SAMP>clas</SAMP>.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapENTYPE"><CODE>vscrapENTYPE</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapTypeableClass"><CODE>vscrapTypeableClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapExport"><HR><H4>vscrapExport</H4></A>
<PRE>
        void <B>vscrapExport</B>(
                vscrap * scrap,
                vscrap * dest);
</PRE>

<DL><DD>
Exports the contents of the scrap <SAMP>scrap</SAMP> to the
scrap <SAMP>dest</SAMP>. This function is implemented by
dispatching the dynamic message <SAMP><A HREF="vscrap-x.html#vscrapEXPORT"><CODE>vscrapEXPORT</CODE></A></SAMP>
to a delegate of <SAMP>scrap</SAMP> which
<CODE>IsKindOf</CODE> <SAMP><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A></SAMP>.
<SAMP>dest</SAMP> should implement <SAMP>scrap</SAMP>'s
export class for the export to be successful. If the
conversion is not possible, a
<SAMP>Scrap/CannotConvert</SAMP> exception is raised.
  <P>
This function should not normally be called directly;
<CODE><A HREF="vscrap-x.html#vscrapConvert"><CODE>vscrapConvert</CODE></A></CODE> should be used instead.
</DD></DL>
<P>
<A NAME="vscrapExportStack"><HR><H4>vscrapExportStack</H4></A>
<PRE>
        void <B>vscrapExportStack</B>(
                vdelegatorStack stack,
                vdelegatorStack dest);
</PRE>

<DL><DD>
Exports the contents of the convertible scrap that
<SAMP>stack</SAMP> is directed to to the scrap
<SAMP>dest</SAMP> is directed to.
  <P>
This function is implemented by sending the message
<SAMP><A HREF="vscrap-x.html#vscrapEXPORT"><CODE>vscrapEXPORT</CODE></A></SAMP> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP>vscrapConvertiblelass.</SAMP>
  <P>
The scrap <SAMP>dest</SAMP> is directed to should implement
<SAMP>stack</SAMP>'s export class for the export to be
successful. If the conversion is not possible, a
<SAMP>Scrap/CannotConvert</SAMP> exception is raised.
  <P>
This function should not normally be called directly;
<CODE><A HREF="vscrap-x.html#vscrapConvertStack"><CODE>vscrapConvertStack</CODE></A></CODE> should be used instead.
</DD></DL>
<P>
<A NAME="vscrapFromBoolean"><HR><H4>vscrapFromBoolean</H4></A>
<PRE>
        vscrap * <B>vscrapFromBoolean</B>(
                int value);
</PRE>

<DL><DD>
Creates a native boolean scrap and sets the value of the
scrap to the boolean <SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapFromCharacter"><HR><H4>vscrapFromCharacter</H4></A>
<PRE>
        vscrap * <B>vscrapFromCharacter</B>(
                int value);
</PRE>

<DL><DD>
Creates a native character scrap and sets the value of the
scrap to the character <SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapFromFixed"><HR><H4>vscrapFromFixed</H4></A>
<PRE>
        vscrap * <B>vscrapFromFixed</B>(
                vfixed value);
</PRE>

<DL><DD>
Creates a native fixed-point scrap and sets the value of
the scrap to the fixed-point <SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapFromFloat"><HR><H4>vscrapFromFloat</H4></A>
<PRE>
        vscrap * <B>vscrapFromFloat</B>(
                double value);
</PRE>

<DL><DD>
Creates a native floating-point scrap and sets the value of
the scrap to the double-precision floating-point
<SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapFromInteger"><HR><H4>vscrapFromInteger</H4></A>
<PRE>
        vscrap * <B>vscrapFromInteger</B>(
                long value);
</PRE>

<DL><DD>
Creates a native integer scrap and sets the value of the
scrap to the integer <SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapFromMemory"><HR><H4>vscrapFromMemory</H4></A>
<PRE>
        vscrap * <B>vscrapFromMemory</B>(
                void * pointer,
                size_t size);
</PRE>

<DL><DD>
Creates a native opaque data block scrap and sets the size
of the block to <SAMP>size</SAMP> and the data block
contents to the contents of <SAMP>pointer</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapFromMemoryOwned"><HR><H4>vscrapFromMemoryOwned</H4></A>
<PRE>
        vscrap * <B>vscrapFromMemoryOwned</B>(
                void * pointer,
                size_t size);
</PRE>

<DL><DD>
Creates a native opaque data block scrap, sets the size of
the block to <SAMP>size</SAMP>, and takes the memory
pointed to by <SAMP>pointer</SAMP>. The passed memory must
have been allocated with either <CODE><A HREF="vmem-x.html#vmemAlloc"><CODE>vmemAlloc</CODE></A></CODE> or
<CODE><A HREF="vmem-x.html#vmemRealloc"><CODE>vmemRealloc</CODE></A></CODE>. The scrap takes ownership of the
memory and will pass it to <CODE><A HREF="vmem-x.html#vmemFree"><CODE>vmemFree</CODE></A></CODE> when it no
longer needs it.
</DD></DL>
<P>
<A NAME="vscrapFromMemoryShared"><HR><H4>vscrapFromMemoryShared</H4></A>
<PRE>
        vscrap * <B>vscrapFromMemoryShared</B>(
                void * pointer,
                size_t size);
</PRE>

<DL><DD>
Creates a native opaque data block scrap and sets the size
of the block to <SAMP>size</SAMP> and uses the memory
pointed to by <SAMP>pointer</SAMP>. The passed memory must
exist for the lifetime of the scrap.
</DD></DL>
<P>
<A NAME="vscrapFromString"><HR><H4>vscrapFromString</H4></A>
<PRE>
        vscrap * <B>vscrapFromString</B>(
                const vchar * string);
</PRE>

<DL><DD>
Creates a native string scrap and sets the value of the
scrap to <SAMP>string</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapFromStringScribed"><HR><H4>vscrapFromStringScribed</H4></A>
<PRE>
        vscrap * <B>vscrapFromStringScribed</B>(
                vscribe * scribe);
</PRE>

<DL><DD>
Creates a native string scrap and sets the value of the
scrap to the scribed string <SAMP>scribe</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapFromTag"><HR><H4>vscrapFromTag</H4></A>
<PRE>
        vscrap * <B>vscrapFromTag</B>(
                const vname * tag);
</PRE>

<DL><DD>
Creates a native tag scrap and sets the value of the scrap
to the global name <SAMP>tag</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGenerateCannotConvert"><HR><H4>vscrapGenerateCannotConvert</H4></A>
<PRE>
        void <B>vscrapGenerateCannotConvert</B>(
                const vdelegatorStack * from,
                const vdelegatorStack * to);
</PRE>

<DL><DD>
Raises a <SAMP>Scrap/CannotConvert</SAMP> exception.
</DD></DL>
<P>
<A NAME="vscrapGenerateUnimplemented"><HR><H4>vscrapGenerateUnimplemented</H4></A>
<PRE>
        void <B>vscrapGenerateUnimplemented</B>(
                const vdelegatorStack * stack);
</PRE>

<DL><DD>
Raises a <SAMP>Scrap/Unimplemented</SAMP> exception.
</DD></DL>
<P>
<A NAME="vscrapGetArrayClass"><HR><H4>vscrapGetArrayClass</H4></A>
<PRE>
        vscrapArrayClass * <B>vscrapGetArrayClass</B>(
                vscrapArray * scrap);
</PRE>

<DL><DD>
Returns the Scrap class of the array scrap
<SAMP>array</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetArrayCount"><HR><H4>vscrapGetArrayCount</H4></A>
<PRE>
        size_t <B>vscrapGetArrayCount</B>(
                vscrap * scrap);
</PRE>

<DL><DD>
Returns number of scrap elements in the array scrap
<SAMP>scrap</SAMP>.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapGET_ARRAY_COUNT"><CODE>vscrapGET_ARRAY_COUNT</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapArrayClass"><CODE>vscrapArrayClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetArrayCountStack"><HR><H4>vscrapGetArrayCountStack</H4></A>
<PRE>
        size_t <B>vscrapGetArrayCountStack</B>(
                vdelegatorStack stack);
</PRE>

<DL><DD>
Returns the number of scrap elements in the array scrap
that <SAMP>stack</SAMP> is directed to.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapGET_ARRAY_COUNT"><CODE>vscrapGET_ARRAY_COUNT</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapArrayClass"><CODE>vscrapArrayClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapGetArrayIteratorClass"><HR><H4>vscrapGetArrayIteratorClass</H4></A>
<PRE>
        vscrapArrayIteratorClass * <B>vscrapGetArrayIteratorClass</B>(
                vscrapArrayIterator * iter);
</PRE>

<DL><DD>
Returns the array scrap iterator class of the array scrap
iterator <SAMP>iter</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetArrayIteratorIndex"><HR><H4>vscrapGetArrayIteratorIndex</H4></A>
<PRE>
        size_t <B>vscrapGetArrayIteratorIndex</B>(
                vscrapArrayIterator * iter);
</PRE>

<DL><DD>
Returns the index of the scrap element referenced by the
current state of the <SAMP>iter</SAMP>. This function is
implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapGET_ITERATOR_INDEX"><CODE>vscrapGET_ITERATOR_INDEX</CODE></A></CODE> to <SAMP>iter</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetBlockClass"><HR><H4>vscrapGetBlockClass</H4></A>
<PRE>
        vscrapBlockClass * <B>vscrapGetBlockClass</B>(
                vscrapBlock * scrap);
</PRE>

<DL><DD>
Returns the Scrap class of the opaque data block scrap
<SAMP>block</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetBlockSize"><HR><H4>vscrapGetBlockSize</H4></A>
<PRE>
        size_t <B>vscrapGetBlockSize</B>(
                vscrap * scrap);
</PRE>

<DL><DD>
Returns the size in bytes of the data referenced by the
block scrap <SAMP>scrap</SAMP>. This function is implemented 
by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapGET_BLOCK_SIZE"><CODE>vscrapGET_BLOCK_SIZE</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapBlockClass"><CODE>vscrapBlockClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetBlockSizeStack"><HR><H4>vscrapGetBlockSizeStack</H4></A>
<PRE>
        size_t <B>vscrapGetBlockSizeStack</B>(
                vdelegatorStack stack);
</PRE>

<DL><DD>
Returns the size in bytes of the data block referenced by
the block scrap that <SAMP>stack</SAMP> is directed to.
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapGET_BLOCK_SIZE"><CODE>vscrapGET_BLOCK_SIZE</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapBlockClass"><CODE>vscrapBlockClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapGetBoolean"><HR><H4>vscrapGetBoolean</H4></A>
<PRE>
        vbool <B>vscrapGetBoolean</B>(
                vscrap * scrap);
</PRE>

<DL><DD>
Returns the value of the boolean scrap <SAMP>scrap</SAMP>. 
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapGET_BOOLEAN"><CODE>vscrapGET_BOOLEAN</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP>vscrapBooleanclass</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetBooleanClass"><HR><H4>vscrapGetBooleanClass</H4></A>
<PRE>
        vscrapBooleanClass * <B>vscrapGetBooleanClass</B>(
                vscrapBoolean * scrap);
</PRE>

<DL><DD>
Returns the class identifier of the boolean scrap
<SAMP>scrap</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetBooleanStack"><HR><H4>vscrapGetBooleanStack</H4></A>
<PRE>
        vbool <B>vscrapGetBooleanStack</B>(
                vdelegatorStack stack);
</PRE>

<DL><DD>
Returns the value of the the boolean scrap
<SAMP>stack</SAMP> is directed to. 
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapGET_BOOLEAN"><CODE>vscrapGET_BOOLEAN</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapBooleanClass"><CODE>vscrapBooleanClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapGetCannotConvertException"><HR><H4>vscrapGetCannotConvertException</H4></A>
<PRE>
        vscrapCannotConvertException * <B>vscrapGetCannotConvertException</B>();
</PRE>

<DL><DD>
Returns the current <SAMP>Scrap/CannotConvert</SAMP>
exception in the exception chain, or <SAMP>NULL</SAMP> if
there is no such exception.
</DD></DL>
<P>
<A NAME="vscrapGetCannotConvertExceptionFrom"><HR><H4>vscrapGetCannotConvertExceptionFrom</H4></A>
<PRE>
        vdelegatorStack * <B>vscrapGetCannotConvertExceptionFrom</B>(
                vscrapCannotConvertException * exception);
</PRE>

<DL><DD>
Returns the delegator stack for the source scrap of the
conversion that raised the <SAMP>Scrap/CannotConvert</SAMP>
exception.
</DD></DL>
<P>
<A NAME="vscrapGetCannotConvertExceptionTo"><HR><H4>vscrapGetCannotConvertExceptionTo</H4></A>
<PRE>
        vdelegatorStack * <B>vscrapGetCannotConvertExceptionTo</B>(
                vscrapCannotConvertException * exception);
</PRE>

<DL><DD>
Returns the delegator stack for the destination scrap of
the conversion that raised the
<SAMP>Scrap/CannotConvert</SAMP> exception.
</DD></DL>
<P>
<A NAME="vscrapGetCharacter"><HR><H4>vscrapGetCharacter</H4></A>
<PRE>
        vchar <B>vscrapGetCharacter</B>(
                vscrap * scrap);
</PRE>

<DL><DD>
Returns the value of the character scrap
<SAMP>scrap</SAMP>. This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapGET_CHARACTER"><CODE>vscrapGET_CHARACTER</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapCharacterClass"><CODE>vscrapCharacterClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetCharacterClass"><HR><H4>vscrapGetCharacterClass</H4></A>
<PRE>
        vscrapCharacterClass * <B>vscrapGetCharacterClass</B>(
                vscrapCharacter * scrap);
</PRE>

<DL><DD>
Returns the Scrap class of the character scrap
<SAMP>scrap</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetCharacterStack"><HR><H4>vscrapGetCharacterStack</H4></A>
<PRE>
        vchar <B>vscrapGetCharacterStack</B>(
                vdelegatorStack stack);
</PRE>

<DL><DD>
Returns the value of the character scrap that
<SAMP>stack</SAMP> is directed to. 
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapGET_CHARACTER"><CODE>vscrapGET_CHARACTER</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapCharacterClass"><CODE>vscrapCharacterClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapGetClass"><HR><H4>vscrapGetClass</H4></A>
<PRE>
        vscrapClass * <B>vscrapGetClass</B>(
                vscrap * scrap);
</PRE>

<DL><DD>
Returns the Scrap class of the scrap <SAMP>scrap</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetCompoundClass"><HR><H4>vscrapGetCompoundClass</H4></A>
<PRE>
        vscrapCompoundClass * <B>vscrapGetCompoundClass</B>(
                vscrapCompound * scrap);
</PRE>

<DL><DD>
Returns the Scrap class of the compound scrap
<SAMP>compound</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetCompoundElementIteratorClass"><HR><H4>vscrapGetCompoundElementIteratorClass</H4></A>
<PRE>
        void * <B>vscrapGetCompoundElementIteratorClass</B>(
                vscrapCompound * scrap);
</PRE>

<DL><DD>
Returns the class of a compound scrap iterator that can be
used to iterate over the elements in the compound scrap
<SAMP>compound</SAMP>. This function is implemented by
getting the value of the class variable
<CODE><A HREF="vscrap-x.html#vscrapCOMPOUND_ITERATOR_CLASS"><CODE>vscrapCOMPOUND_ITERATOR_CLASS</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapGetCompoundIteratorClass"><HR><H4>vscrapGetCompoundIteratorClass</H4></A>
<PRE>
        vscrapCompoundIteratorClass * <B>vscrapGetCompoundIteratorClass</B>(
                vscrapCompoundIterator * iter);
</PRE>

<DL><DD>
Returns the compound scrap iterator class of the compound
scrap iterator <SAMP>iter</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetCompoundIteratorElement"><HR><H4>vscrapGetCompoundIteratorElement</H4></A>
<PRE>
        vscrap * <B>vscrapGetCompoundIteratorElement</B>(
                vscrapCompoundIterator * iter);
</PRE>

<DL><DD>
Returns the scrap element referenced by the current state
of the iterator <SAMP>iter</SAMP>. This function is
implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapGET_ITERATOR_ELEMENT"><CODE>vscrapGET_ITERATOR_ELEMENT</CODE></A></CODE> to
<SAMP>iter</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetConvertibleClass"><HR><H4>vscrapGetConvertibleClass</H4></A>
<PRE>
        vscrapConvertibleClass * <B>vscrapGetConvertibleClass</B>(
                vscrapConvertible * scrap);
</PRE>

<DL><DD>
Returns the Scrap class of the convertible scrap
<SAMP>scrap</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetConvertibleExportClass"><HR><H4>vscrapGetConvertibleExportClass</H4></A>
<PRE>
        vclass * <B>vscrapGetConvertibleExportClass</B>(
                vscrapConvertible * scrap);
</PRE>

<DL><DD>
Returns the Scrap class that the convertible scrap
<SAMP>scrap</SAMP> is able to export to. This function is
implemented by getting the value of the class variable
<CODE><A HREF="vscrap-x.html#vscrapEXPORT_CLASS"><CODE>vscrapEXPORT_CLASS</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultArrayClass"><HR><H4>vscrapGetDefaultArrayClass</H4></A>
<PRE>
        vscrapArrayClass * <B>vscrapGetDefaultArrayClass</B>();
</PRE>

<DL><DD>
Returns the class used to create array scraps. This class
can be modified to alter the behavior of all array scraps
subsequently created by the Representation class. Changes
to this class are visible to any other applications in the
same process or sharing the same display server. This
function can be called to explicitly register the default
array Scrap class with the Class manager. This is an
abstract class and must be subclassed from in order to be
useful.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultArrayIteratorClass"><HR><H4>vscrapGetDefaultArrayIteratorClass</H4></A>
<PRE>
        vscrapArrayIteratorClass * <B>vscrapGetDefaultArrayIteratorClass</B>();
</PRE>

<DL><DD>
Returns the class used to create array scrap iterators.
This class can be modified to alter the behavior of all
array scrap iterators subsequently created by the
Representation class. Changes to this class are not
visible to any other applications in the same process or
sharing the same display server. This function can be
called to explicitly register the default array scrap
iterator class with the Class class. This is an abstract
class and must be subclassed from in order to be useful.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultBlockClass"><HR><H4>vscrapGetDefaultBlockClass</H4></A>
<PRE>
        vscrapBlockClass * <B>vscrapGetDefaultBlockClass</B>();
</PRE>

<DL><DD>
Returns the class used to create opaque data block scraps.
This class can be modified to alter the behavior of all
opaque data block scraps subsequently created by the
Representation class. Changes to this class are not
visible to any other applications in the same process or
sharing the same display server. This function can be
called to explicitly register the default opaque data block
Scrap class with the Class class. This is an abstract
class and must be subclassed from in order to be useful.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultBooleanClass"><HR><H4>vscrapGetDefaultBooleanClass</H4></A>
<PRE>
        vscrapBooleanClass * <B>vscrapGetDefaultBooleanClass</B>();
</PRE>

<DL><DD>
Returns the class used to create boolean scraps. This class
can be modified to alter the behavior of all boolean scraps
subsequently created by the Representation class. Changes
to this class are not visible to any other applications in
the same process or sharing the same display server. This
function can be called to explicitly register the default
boolean Scrap class with the Class class. This is an
abstract class and must be subclassed from in order to be
useful.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultCharacterClass"><HR><H4>vscrapGetDefaultCharacterClass</H4></A>
<PRE>
        vscrapCharacterClass * <B>vscrapGetDefaultCharacterClass</B>();
</PRE>

<DL><DD>
Returns the class used to create character scraps. This
class can be modified to alter the behavior of all
character scraps subsequently created by the Representation
class. Changes to this class are not visible to any other
applications in the same process or sharing the same
display server. This function can be called to explicitly
register the default character Scrap class with the Class
class. This is an abstract class and must be subclassed
from in order to be useful.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultClass"><HR><H4>vscrapGetDefaultClass</H4></A>
<PRE>
        vscrapClass * <B>vscrapGetDefaultClass</B>();
</PRE>

<DL><DD>
Returns the class used to create scraps using the
<SAMP>vscrapFrom</SAMP> and <SAMP>vscrapCreate</SAMP>
functions. This class can be modified to alter the behavior
of all scraps subsequently created by this functions.
Changes to this class are not visible to any other
applications in the same process or sharing the same
display server. This function can be called to explicitly
register the default Scrap class with the Class class.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultCompoundClass"><HR><H4>vscrapGetDefaultCompoundClass</H4></A>
<PRE>
        vscrapCompoundClass * <B>vscrapGetDefaultCompoundClass</B>();
</PRE>

<DL><DD>
Returns the class used to create compound scraps. This
class can be modified to alter the behavior of all compound
scraps subsequently created by the Representation class.
Changes to this class are not visible to any other
applications in the same process or sharing the same
display server. This function can be called to explicitly
register the default compound Scrap class with the Class
class. This is an abstract class and must be subclassed
from in order to be useful.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultCompoundIteratorClass"><HR><H4>vscrapGetDefaultCompoundIteratorClass</H4></A>
<PRE>
        vscrapCompoundIteratorClass * <B>vscrapGetDefaultCompoundIteratorClass</B>();
</PRE>

<DL><DD>
Returns the class used to create compound scrap iterators.
This class can be modified to alter the behavior of all
compound scrap iterators subsequently created by the
Representation class. Changes to this class are not
visible to any other applications in the same process or
sharing the same display server. This function can be
called to explicitly register the default compound scrap
iterator class with the Class class. This is an abstract
class and must be subclassed from in order to be useful.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultConvertibleClass"><HR><H4>vscrapGetDefaultConvertibleClass</H4></A>
<PRE>
        vscrapConvertibleClass * <B>vscrapGetDefaultConvertibleClass</B>();
</PRE>

<DL><DD>
Returns the class used to create convertible scraps. This
class can be modified to alter the behavior of all
convertible scraps subsequently created by the
Representation class. Changes to this class are not
visible to any other applications in the same process or
sharing the same display server. This function can be
called to explicitly register the default convertible scrap
class with the Class class. This is an abstract class and
must be subclassed from in order to be useful.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultDictionaryClass"><HR><H4>vscrapGetDefaultDictionaryClass</H4></A>
<PRE>
        vscrapDictionaryClass * <B>vscrapGetDefaultDictionaryClass</B>();
</PRE>

<DL><DD>
Returns the class used to create dictionary scraps. This
class can be modified to alter the behavior of all
dictionary scraps subsequently created by the
Representation class. Changes to this class are not
visible to any other applications in the same process or
sharing the same display server. This function can be
called to explicitly register the default dictionary scrap
class with the Class class. This is an abstract class and
must be subclassed from in order to be useful.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultDictionaryIteratorClass"><HR><H4>vscrapGetDefaultDictionaryIteratorClass</H4></A>
<PRE>
        vscrapDictionaryIteratorClass * <B>vscrapGetDefaultDictionaryIteratorClass</B>();
</PRE>

<DL><DD>
Returns the class used to create dictionary scrap
iterators. This class can be modified to alter the behavior
of all dictionary scrap iterators subsequently created by
the Representation class. Changes to this class are not
visible to any other applications in the same process or
sharing the same display server. This function can be
called to explicitly register the default dictionary scrap
iterator class with the Class class. This is an abstract
class and must be subclassed from in order to be useful.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultFixedClass"><HR><H4>vscrapGetDefaultFixedClass</H4></A>
<PRE>
        vscrapFixedClass * <B>vscrapGetDefaultFixedClass</B>();
</PRE>

<DL><DD>
Returns the class used to create fixed-point scraps. This
class can be modified to alter the behavior of all
fixed-point scraps subsequently created by the
Representation class. Changes to this class are not
visible to any other applications in the same process or
sharing the same display server. This function can be
called to explicitly register the default fixed-point scrap
class with the Class class. This is an abstract class and
must be subclassed from in order to be useful.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultFloatClass"><HR><H4>vscrapGetDefaultFloatClass</H4></A>
<PRE>
        vscrapFloatClass * <B>vscrapGetDefaultFloatClass</B>();
</PRE>

<DL><DD>
Returns the class used to create floating-point scraps.
This class can be modified to alter the behavior of all
floating-point scraps subsequently created by the
Representation class. Changes to this class are not
visible to any other applications in the same process or
sharing the same display server. This function can be
called to explicitly register the default floating-point
Scrap class with the Class class. This is an abstract
class and must be subclassed from in order to be useful.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultIntegerClass"><HR><H4>vscrapGetDefaultIntegerClass</H4></A>
<PRE>
        vscrapIntegerClass * <B>vscrapGetDefaultIntegerClass</B>();
</PRE>

<DL><DD>
Returns the class used to create integer scraps. This class
can be modified to alter the behavior of all integer scraps
subsequently created by the Representation class. Changes
to this class are not visible to any other applications in
the same process or sharing the same display server. This
function can be called to explicitly register the default
integer Scrap class with the Class class. This is an
abstract class and must be subclassed from in order to be
useful.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultIteratorClass"><HR><H4>vscrapGetDefaultIteratorClass</H4></A>
<PRE>
        vscrapIteratorClass * <B>vscrapGetDefaultIteratorClass</B>();
</PRE>

<DL><DD>
Returns the class used to create scraps using the
<CODE><A HREF="vscrap-x.html#vscrapCreateIteratorOfClass"><CODE>vscrapCreateIteratorOfClass</CODE></A></CODE> and
<CODE><A HREF="vscrap-x.html#vscrapInitIteratorOfClass"><CODE>vscrapInitIteratorOfClass</CODE></A></CODE> functions. The
default iterator class is an abstract class and thus must
be subclassed from to be useful. Iterators provide the
means to access each element of a multi-element scrap.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultStringClass"><HR><H4>vscrapGetDefaultStringClass</H4></A>
<PRE>
        vscrapStringClass * <B>vscrapGetDefaultStringClass</B>();
</PRE>

<DL><DD>
Returns the class used to create string scraps. This class
can be modified to alter the behavior of all string scraps
subsequently created by the Representation class. Changes
to this class are not visible to any other applications in
the same process or sharing the same display server. This
function can be called to explicitly register the default
string Scrap class with the Class class. This is an
abstract class and must be subclassed from in order to be
useful.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultTagClass"><HR><H4>vscrapGetDefaultTagClass</H4></A>
<PRE>
        vscrapTagClass * <B>vscrapGetDefaultTagClass</B>();
</PRE>

<DL><DD>
Returns the class used to create tag scraps. This class can
be modified to alter the behavior of all tag scraps
subsequently created by the Representation class. Changes
to this class not visible to any other applications in the
same process or sharing the same display server. This
function can be called to explicitly register the default
tag Scrap class with the Class class. This is an abstract
class and must be subclassed from in order to be useful.
</DD></DL>
<P>
<A NAME="vscrapGetDefaultTypeableClass"><HR><H4>vscrapGetDefaultTypeableClass</H4></A>
<PRE>
        vscrapTypeableClass * <B>vscrapGetDefaultTypeableClass</B>();
</PRE>

<DL><DD>
Returns the class used to create typeable scraps. This
class can be modified to alter the behavior of all typeable
scraps subsequently created by the Representation class.
Changes to this class are not visible to any other
applications in the same process or sharing the same
display server. This function can be called to explicitly
register the default typeable Scrap class with the Class
class. This is an abstract class and must be subclassed
from in order to be useful.
</DD></DL>
<P>
<A NAME="vscrapGetDictionaryClass"><HR><H4>vscrapGetDictionaryClass</H4></A>
<PRE>
        vscrapDictionaryClass * <B>vscrapGetDictionaryClass</B>(
                vscrapDictionary * scrap);
</PRE>

<DL><DD>
Returns the dictionary Scrap class of the dictionary scrap
<SAMP>scrap</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetDictionaryIteratorClass"><HR><H4>vscrapGetDictionaryIteratorClass</H4></A>
<PRE>
        vscrapDictionaryIteratorClass * <B>vscrapGetDictionaryIteratorClass</B>(
                vscrapDictionaryIterator * iter);
</PRE>

<DL><DD>
Returns the dictionary scrap iterator class of the
dictionary scrap iterator <SAMP>iter</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetDictionaryIteratorKey"><HR><H4>vscrapGetDictionaryIteratorKey</H4></A>
<PRE>
        const vname * <B>vscrapGetDictionaryIteratorKey</B>(
                vscrapDictionaryIterator * iter);
</PRE>

<DL><DD>
Returns the global name key used to access the scrap
element of the dictionary scrap being iterated over by
<SAMP>iter</SAMP>. This function is implemented by sending
the message <CODE><A HREF="vscrap-x.html#vscrapGET_ITERATOR_KEY"><CODE>vscrapGET_ITERATOR_KEY</CODE></A></CODE> to
<SAMP>iter</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetElementAt"><HR><H4>vscrapGetElementAt</H4></A>
<PRE>
        vscrap * <B>vscrapGetElementAt</B>(
                vscrap * scrap,
                size_t index);
</PRE>

<DL><DD>
Returns the scrap element stored at <SAMP>index</SAMP> in
the array scrap <SAMP>scrap</SAMP>. 
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapGET_ELEMENT_AT"><CODE>vscrapGET_ELEMENT_AT</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapArrayClass"><CODE>vscrapArrayClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetElementAtStack"><HR><H4>vscrapGetElementAtStack</H4></A>
<PRE>
        vscrap * <B>vscrapGetElementAtStack</B>(
                vdelegatorStack stack,
                size_t index);
</PRE>

<DL><DD>
Returns the scrap element stored at <SAMP>index</SAMP> in
the array scrap that <SAMP>stack</SAMP> is directed to. 
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapGET_ELEMENT_AT"><CODE>vscrapGET_ELEMENT_AT</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapArrayClass"><CODE>vscrapArrayClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetFixed"><HR><H4>vscrapGetFixed</H4></A>
<PRE>
        vfixed <B>vscrapGetFixed</B>(
                vscrap * scrap);
</PRE>

<DL><DD>
Returns the value of the fixed-point that scrap
<SAMP>scrap</SAMP>.This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapGET_FIXED"><CODE>vscrapGET_FIXED</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapFixedClass"><CODE>vscrapFixedClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetFixedClass"><HR><H4>vscrapGetFixedClass</H4></A>
<PRE>
        vscrapFixedClass * <B>vscrapGetFixedClass</B>(
                vscrapFixed * scrap);
</PRE>

<DL><DD>
Returns the Scrap class of the fixed-point scrap
<SAMP>scrap</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetFixedStack"><HR><H4>vscrapGetFixedStack</H4></A>
<PRE>
        vfixed <B>vscrapGetFixedStack</B>(
                vdelegatorStack stack);
</PRE>

<DL><DD>
Returns the value of the fixed-point scrap that
<SAMP>stack</SAMP> is directed to.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapGET_FIXED"><CODE>vscrapGET_FIXED</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapFixedClass"><CODE>vscrapFixedClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapGetFloat"><HR><H4>vscrapGetFloat</H4></A>
<PRE>
        double <B>vscrapGetFloat</B>(
                vscrap * scrap);
</PRE>

<DL><DD>
Returns the value of the floating-point scrap
<SAMP>scrap</SAMP>.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapGET_FLOAT"><CODE>vscrapGET_FLOAT</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapFloatClass"><CODE>vscrapFloatClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetFloatClass"><HR><H4>vscrapGetFloatClass</H4></A>
<PRE>
        vscrapFloatClass * <B>vscrapGetFloatClass</B>(
                vscrapFloat * scrap);
</PRE>

<DL><DD>
Returns the Scrap class of the floating-point scrap
<SAMP>scrap</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetFloatStack"><HR><H4>vscrapGetFloatStack</H4></A>
<PRE>
        double <B>vscrapGetFloatStack</B>(
                vdelegatorStack stack);
</PRE>

<DL><DD>
Returns the value of the floating-point scrap that
<SAMP>stack</SAMP> is directed to.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapGET_FLOAT"><CODE>vscrapGET_FLOAT</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapFloatClass"><CODE>vscrapFloatClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapGetInteger"><HR><H4>vscrapGetInteger</H4></A>
<PRE>
        long <B>vscrapGetInteger</B>(
                vscrap * scrap);
</PRE>

<DL><DD>
Returns the value of the integer scrap <SAMP>scrap</SAMP>.
  <P>
This function is implemented by dispatching the dynamic
message <CODE>vscrapGetInteger</CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapIntegerClass"><CODE>vscrapIntegerClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetIntegerClass"><HR><H4>vscrapGetIntegerClass</H4></A>
<PRE>
        vscrapIntegerClass * <B>vscrapGetIntegerClass</B>(
                vscrapInteger * scrap);
</PRE>

<DL><DD>
Returns the Scrap class of the integer scrap
<SAMP>scrap</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetIntegerStack"><HR><H4>vscrapGetIntegerStack</H4></A>
<PRE>
        long <B>vscrapGetIntegerStack</B>(
                vdelegatorStack stack);
</PRE>

<DL><DD>
Returns the value of the integer scrap that
<SAMP>stack</SAMP> is directed to.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapGET_INTEGER"><CODE>vscrapGET_INTEGER</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapIntegerClass"><CODE>vscrapIntegerClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapGetIteratorClass"><HR><H4>vscrapGetIteratorClass</H4></A>
<PRE>
        vscrapIteratorClass * <B>vscrapGetIteratorClass</B>(
                vscrapIterator * iter);
</PRE>

<DL><DD>
Returns the class of the iterator <SAMP>iter</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetIteratorStack"><HR><H4>vscrapGetIteratorStack</H4></A>
<PRE>
        const vdelegatorStack * <B>vscrapGetIteratorStack</B>(
                vscrapIterator * iter);
</PRE>

<DL><DD>
Returns a delegator stack that represents the scrap element
currently referenced by <SAMP>iter</SAMP>. This function
should be called only after <CODE><A HREF="vscrap-x.html#vscrapNextIterator"><CODE>vscrapNextIterator</CODE></A></CODE>
has returned <SAMP>TRUE</SAMP>. Note that the order in
which scrap elements are iterated is arbitrary.
</DD></DL>
<P>
<A NAME="vscrapGetStringClass"><HR><H4>vscrapGetStringClass</H4></A>
<PRE>
        vscrapStringClass * <B>vscrapGetStringClass</B>(
                vscrapString * scrap);
</PRE>

<DL><DD>
Returns the Scrap class of the string scrap
<SAMP>scrap</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetTag"><HR><H4>vscrapGetTag</H4></A>
<PRE>
        const vname * <B>vscrapGetTag</B>(
                vscrap * scrap);
</PRE>

<DL><DD>
Returns the value of the tag scrap <SAMP>scrap</SAMP> as a
name in the global name table.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapGET_TAG"><CODE>vscrapGET_TAG</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapTagClass"><CODE>vscrapTagClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetTagClass"><HR><H4>vscrapGetTagClass</H4></A>
<PRE>
        vscrapTagClass * <B>vscrapGetTagClass</B>(
                vscrapTag * scrap);
</PRE>

<DL><DD>
Returns the Scrap class of the tag scrap
<SAMP>scrap</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetTagStack"><HR><H4>vscrapGetTagStack</H4></A>
<PRE>
        const vname * <B>vscrapGetTagStack</B>(
                vdelegatorStack stack);
</PRE>

<DL><DD>
Returns the value of the tag scrap that <SAMP>stack</SAMP>
is directed to as a name in the global name table.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapGET_TAG"><CODE>vscrapGET_TAG</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapTagClass"><CODE>vscrapTagClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapGetTypeableClass"><HR><H4>vscrapGetTypeableClass</H4></A>
<PRE>
        vscrapTypeableClass * <B>vscrapGetTypeableClass</B>(
                vscrapTypeable * scrap);
</PRE>

<DL><DD>
Returns the Scrap class of the typeable scrap
<SAMP>scrap</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGetUnimplementedException"><HR><H4>vscrapGetUnimplementedException</H4></A>
<PRE>
        vscrapUnimplementedException * <B>vscrapGetUnimplementedException</B>();
</PRE>

<DL><DD>
Returns the current <SAMP>Scrap/Unimplemented</SAMP>
exception in the exception chain, or <SAMP>NULL</SAMP> if
there is no such exception.
</DD></DL>
<P>
<A NAME="vscrapGetUnimplementedExceptionStack"><HR><H4>vscrapGetUnimplementedExceptionStack</H4></A>
<PRE>
        vdelegatorStack * <B>vscrapGetUnimplementedExceptionStack</B>(
                vscrapUnimplementedException * exception);
</PRE>

<DL><DD>
Returns the delegator stack that existed at the time the
<SAMP>Scrap/Unimplemented</SAMP> exception was raised.
</DD></DL>
<P>
<A NAME="vscrapImport"><HR><H4>vscrapImport</H4></A>
<PRE>
        void <B>vscrapImport</B>(
                vscrap * scrap,
                vscrap * source);
</PRE>

<DL><DD>
Imports the contents of the convertible scrap
<SAMP>source</SAMP> to the scrap <SAMP>scrap</SAMP>.
  <P>
This function is implemented by dispatching the dynamic
message <SAMP><A HREF="vscrap-x.html#vscrapIMPORT"><CODE>vscrapIMPORT</CODE></A></SAMP> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A></SAMP>.
  <P>
If the conversion is not possible, a
<CODE><A HREF="vscrap-x.html#vscrapCannotConvertException"><CODE>vscrapCannotConvertException</CODE></A></CODE> is raised. A
conversion fails if <SAMP>scrap</SAMP> does not implement
the methods required to access the data referred to by
<SAMP>source</SAMP>.
  <P>
This function should not normally be called directly;
<CODE><A HREF="vscrap-x.html#vscrapConvert"><CODE>vscrapConvert</CODE></A></CODE> should be used instead.
</DD></DL>
<P>
<A NAME="vscrapImportStack"><HR><H4>vscrapImportStack</H4></A>
<PRE>
        void <B>vscrapImportStack</B>(
                vdelegatorStack stack,
                vdelegatorStack source);
</PRE>

<DL><DD>
Imports the contents of the convertible scrap that
<SAMP>source</SAMP> is directed to to the scrap that
<SAMP>stack</SAMP> is directed to.
  <P>
This function is implemented by sending the message
<SAMP><A HREF="vscrap-x.html#vscrapIMPORT"><CODE>vscrapIMPORT</CODE></A></SAMP> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A>.</SAMP>
  <P>
If the conversion is not possible, a
<CODE><A HREF="vscrap-x.html#vscrapCannotConvertException"><CODE>vscrapCannotConvertException</CODE></A></CODE> is raised. A
conversion fails if <SAMP>scrap</SAMP> does not implement
the methods required to access the data referred to by
<SAMP>source</SAMP>.
  <P>
This function should not normally be called directly;
<CODE><A HREF="vscrap-x.html#vscrapConvert"><CODE>vscrapConvert</CODE></A></CODE> should be used instead.
</DD></DL>
<P>
<A NAME="vscrapInitIteratorOfClass"><HR><H4>vscrapInitIteratorOfClass</H4></A>
<PRE>
        void <B>vscrapInitIteratorOfClass</B>(
                vscrapIterator * iter,
                void * clas,
                const vdelegatorStack * stack);
</PRE>

<DL><DD>
Begins an iteration of all the scrap elements of a
multi-element scrap by initializing the iterator object
<SAMP>iter</SAMP> to be of class <SAMP>clas</SAMP> and to
reference the scrap object represented by the delegator
stack <SAMP>stack</SAMP>. The iterator initially contains
no element; <CODE><A HREF="vscrap-x.html#vscrapNextIterator"><CODE>vscrapNextIterator</CODE></A></CODE> must be called
to obtain the first element of the scrap. Note that the
order in which elements are obtained by the iterator is
arbitrary.
</DD></DL>
<P>
<A NAME="vscrapIsKindOf"><HR><H4>vscrapIsKindOf</H4></A>
<PRE>
        vbool <B>vscrapIsKindOf</B>(
                vscrap * scrap,
                void * clas);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the object
<SAMP>scrap</SAMP><B><I> </I></B><I>or one of its
delegates</I> <CODE>IsKindOf</CODE> <SAMP>clas</SAMP>, or
<SAMP>FALSE</SAMP> if none are. This function is used to
test if a scrap implements the methods needed to
successfully convert it to a new scrap of the specified
class.
</DD></DL>
<P>
<A NAME="vscrapLoadElement"><HR><H4>vscrapLoadElement</H4></A>
<PRE>
        vscrap * <B>vscrapLoadElement</B>(
                vscrap * scrap,
                const vname * key);
</PRE>

<DL><DD>
Returns the scrap element stored using the global name
<SAMP>key</SAMP> in the dictionary scrap
<SAMP>scrap</SAMP>.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapLOAD_ELEMENT"><CODE>vscrapLOAD_ELEMENT</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapDictionaryClass"><CODE>vscrapDictionaryClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapLoadElementStack"><HR><H4>vscrapLoadElementStack</H4></A>
<PRE>
        vscrap * <B>vscrapLoadElementStack</B>(
                vdelegatorStack stack,
                const vname * key);
</PRE>

<DL><DD>
Returns the scrap element stored using the global name
<SAMP>key</SAMP> in the dictionary scrap <SAMP>stack</SAMP>
is directed to.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapLOAD_ELEMENT"><CODE>vscrapLOAD_ELEMENT</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapDictionaryClass"><CODE>vscrapDictionaryClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapNextIterator"><HR><H4>vscrapNextIterator</H4></A>
<PRE>
        vbool <B>vscrapNextIterator</B>(
                vscrapIterator * iter);
</PRE>

<DL><DD>
Performs the next step of the iteration represented by the
<SAMP>iter </SAMP>and returns <SAMP>TRUE</SAMP> if a scrap
element is available, <SAMP>FALSE</SAMP> if not. A
delegator stack that represents the scrap element currently
referenced by the iterator can be retrieved using the
<CODE><A HREF="vscrap-x.html#vscrapGetIteratorStack"><CODE>vscrapGetIteratorStack</CODE></A></CODE> function. This function
is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapNEXT_ITERATOR"><CODE>vscrapNEXT_ITERATOR</CODE></A></CODE> to <SAMP>iter</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapReadBlock"><HR><H4>vscrapReadBlock</H4></A>
<PRE>
        void <B>vscrapReadBlock</B>(
                vscrap * scrap,
                size_t offset,
                size_t count,
                void * buffer);
</PRE>

<DL><DD>
Copies <SAMP>count</SAMP> bytes starting at
<SAMP>offset</SAMP> bytes from the start of the data block
scrap <SAMP>scrap</SAMP> to <SAMP>buffer</SAMP>.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapREAD_BLOCK"><CODE>vscrapREAD_BLOCK</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapBlockClass"><CODE>vscrapBlockClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapReadBlockStack"><HR><H4>vscrapReadBlockStack</H4></A>
<PRE>
        void <B>vscrapReadBlockStack</B>(
                vdelegatorStack stack,
                size_t offset,
                size_t count,
                void * buffer);
</PRE>

<DL><DD>
Copies <SAMP>count</SAMP> bytes starting at
<SAMP>offset</SAMP> bytes from the start of the data block
scrap that <SAMP>stack</SAMP> is directed to to
<SAMP>buffer</SAMP>.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapREAD_BLOCK"><CODE>vscrapREAD_BLOCK</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapBlockClass"><CODE>vscrapBlockClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapRegisterNativeClass"><HR><H4>vscrapRegisterNativeClass</H4></A>
<PRE>
        void <B>vscrapRegisterNativeClass</B>(
                void * clas,
                void * implementation);
</PRE>

<DL><DD>
Registers the new application-defined abstract Scrap class
<SAMP>clas</SAMP> and its native implementation
<SAMP>implementation</SAMP> with the Representation
Manager. This allows generic Representation class
functions such as <CODE><A HREF="vscrap-x.html#vscrapConvertToNative"><CODE>vscrapConvertToNative</CODE></A></CODE> to
work on application-defined Scrap classes.
</DD></DL>
<P>
<A NAME="vscrapRemoveElement"><HR><H4>vscrapRemoveElement</H4></A>
<PRE>
        void <B>vscrapRemoveElement</B>(
                vscrap * scrap,
                const vname * key);
</PRE>

<DL><DD>
Removes the scrap element stored using the global name
<SAMP>key</SAMP> from the dictionary scrap
<SAMP>scrap</SAMP>.
  <P>
This function is implemented by dispatching the dynamic
message <CODE>vscrapRemoveElement</CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapDictionaryClass"><CODE>vscrapDictionaryClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapRemoveElementStack"><HR><H4>vscrapRemoveElementStack</H4></A>
<PRE>
        void <B>vscrapRemoveElementStack</B>(
                vdelegatorStack stack,
                const vname * key);
</PRE>

<DL><DD>
Removes the scrap element stored using the global name
<SAMP>key</SAMP> from the dictionary scrap that
<SAMP>stack</SAMP> is directed to.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapREMOVE_ELEMENT"><CODE>vscrapREMOVE_ELEMENT</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapDictionaryClass"><CODE>vscrapDictionaryClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapScribeString"><HR><H4>vscrapScribeString</H4></A>
<PRE>
        vscribe * <B>vscrapScribeString</B>(
                vscrap * scrap);
</PRE>

<DL><DD>
Returns the value of the string scrap <SAMP>scrap</SAMP> as
a scribe.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapSCRIBE_STRING"><CODE>vscrapSCRIBE_STRING</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapStringClass"><CODE>vscrapStringClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapScribeStringStack"><HR><H4>vscrapScribeStringStack</H4></A>
<PRE>
        vscribe * <B>vscrapScribeStringStack</B>(
                vdelegatorStack stack);
</PRE>

<DL><DD>
Returns the value of the string scrap that
<SAMP>stack</SAMP> is directed to as a scribe.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapSCRIBE_STRING"><CODE>vscrapSCRIBE_STRING</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapStringClass"><CODE>vscrapStringClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapSendArray"><HR><H4>vscrapSendArray</H4></A>
<PRE>
        void <B>vscrapSendArray</B>(
                vdelegatorStack * stack,
                ... arg2);
</PRE>

<DL><DD>
Invokes the behavior associated with the message identifier
passed as the second parameter. The message is sent to the
array scrap described by <SAMP>stack</SAMP>. Message
arguments are passed inside parentheses as the third
argument. The arguments and return type depend on the type
of message sent. The second parameter must be a message
identifier declared by the array Scrap class. This function
is implemented as a macro. This function assumes that
<SAMP>stack</SAMP> has already been directed to a scrap
object that implements the array Scrap class.
</DD></DL>
<P>
<A NAME="vscrapSendBlock"><HR><H4>vscrapSendBlock</H4></A>
<PRE>
        void <B>vscrapSendBlock</B>(
                vdelegatorStack * stack,
                ... arg2);
</PRE>

<DL><DD>
Invokes the behavior associated with the message identifier
passed as the second parameter. The message is sent to the
block scrap described by <SAMP>stack</SAMP>. Message
arguments are passed inside parentheses as the third
argument. The arguments and return type depend on the type
of message sent. The second parameter must be a message
identifier declared by the block Scrap class. This function
is implemented as a macro. This function assumes that
<SAMP>stack</SAMP> has already been directed to a scrap
object that implements the block Scrap class.
</DD></DL>
<P>
<A NAME="vscrapSendBoolean"><HR><H4>vscrapSendBoolean</H4></A>
<PRE>
        void <B>vscrapSendBoolean</B>(
                vdelegatorStack * stack,
                ... arg2);
</PRE>

<DL><DD>
Invokes the behavior associated with the message identifier
passed as the second parameter. The message is sent to the
boolean scrap described by <SAMP>stack</SAMP>. Message
arguments are passed inside parentheses as the third
argument. The arguments and return type depend on the type
of message sent. The second parameter must be a message
identifier declared by the boolean Scrap class. This
function is implemented as a macro. This function assumes
that <SAMP>stack</SAMP> has already been directed to a
scrap object that implements the boolean Scrap class.
</DD></DL>
<P>
<A NAME="vscrapSendCharacter"><HR><H4>vscrapSendCharacter</H4></A>
<PRE>
        void <B>vscrapSendCharacter</B>(
                vdelegatorStack * stack,
                ... arg2);
</PRE>

<DL><DD>
Invokes the behavior associated with the message identifier
passed as the second parameter. The message is sent to the
character scrap described by <SAMP>stack</SAMP>. Message
arguments are passed inside parentheses as the third
argument. The arguments and return type depend on the type
of message sent. The second parameter must be a message
identifier declared by the character Scrap class. This
function is implemented as a macro. This function assumes
that <SAMP>stack</SAMP> has already been directed to a
scrap object that implements the character Scrap class.
</DD></DL>
<P>
<A NAME="vscrapSendCompound"><HR><H4>vscrapSendCompound</H4></A>
<PRE>
        void <B>vscrapSendCompound</B>(
                vdelegatorStack * stack,
                ... arg2);
</PRE>

<DL><DD>
Invokes the behavior associated with the message identifier
passed as the second parameter. The message is sent to the
compound scrap described by <SAMP>stack</SAMP>. Message
arguments are passed inside parentheses as the third
argument. The arguments and return type depend on the type
of message sent. The second parameter must be a message
identifier declared by the compound Scrap class. This
function is implemented as a macro. This function assumes
that <SAMP>stack</SAMP> has already been directed to a
scrap object that implements the compound Scrap class.
</DD></DL>
<P>
<A NAME="vscrapSendConvertible"><HR><H4>vscrapSendConvertible</H4></A>
<PRE>
        void <B>vscrapSendConvertible</B>(
                vdelegatorStack * stack,
                ... arg2);
</PRE>

<DL><DD>
Invokes the behavior associated with the message identifier
passed as the second parameter. The message is sent to the
convertible scrap described by <SAMP>stack</SAMP>. Message
arguments are passed inside parentheses as the third
argument. The arguments and return type depend on the type
of message sent. The second parameter must be a message
identifier declared by the convertible Scrap class. This
function is implemented as a macro. This function assumes
that <SAMP>stack</SAMP> has already been directed to a
scrap object that implements the convertible Scrap class.
</DD></DL>
<P>
<A NAME="vscrapSendDictionary"><HR><H4>vscrapSendDictionary</H4></A>
<PRE>
        void <B>vscrapSendDictionary</B>(
                vdelegatorStack * stack,
                ... arg2);
</PRE>

<DL><DD>
Invokes the behavior associated with the message identifier
passed as the second parameter. The message is sent to the
dictionary scrap described by <SAMP>stack</SAMP>. Message
arguments are passed inside parentheses as the third
argument. The arguments and return type depend on the type
of message sent. The second parameter must be a message
identifier declared by the dictionary Scrap class. This
function is implemented as a macro. This function assumes
that <SAMP>stack</SAMP> has already been directed to a
scrap object that implements the dictionary Scrap class.
</DD></DL>
<P>
<A NAME="vscrapSendFixed"><HR><H4>vscrapSendFixed</H4></A>
<PRE>
        void <B>vscrapSendFixed</B>(
                vdelegatorStack * stack,
                ... arg2);
</PRE>

<DL><DD>
Invokes the behavior associated with the message identifier
passed as the second parameter. The message is sent to the
fixed-point scrap described by <SAMP>stack</SAMP>. Message
arguments are passed inside parentheses as the third
argument. The arguments and return type depend on the type
of message sent. The second parameter must be a message
identifier declared by the fixed-point Scrap class. This
function is implemented as a macro. This function assumes
that <SAMP>stack</SAMP> has already been directed to a
scrap object that implements the fixed-point Scrap class.
</DD></DL>
<P>
<A NAME="vscrapSendFloat"><HR><H4>vscrapSendFloat</H4></A>
<PRE>
        void <B>vscrapSendFloat</B>(
                vdelegatorStack * stack,
                ... arg2);
</PRE>

<DL><DD>
Invokes the behavior associated with the message identifier
passed as the second parameter. The message is sent to the
floating-point scrap described by <SAMP>stack</SAMP>.
Message arguments are passed inside parentheses as the
third argument. The arguments and return type depend on the
type of message sent. The second parameter must be a
message identifier declared by the floating-point scrap
class. This function is implemented as a macro. This
function assumes that <SAMP>stack</SAMP> has already been
directed to a scrap object that implements the
floating-point Scrap class.
</DD></DL>
<P>
<A NAME="vscrapSendInteger"><HR><H4>vscrapSendInteger</H4></A>
<PRE>
        void <B>vscrapSendInteger</B>(
                vdelegatorStack * stack,
                ... arg2);
</PRE>

<DL><DD>
Invokes the behavior associated with the message identifier
passed as the second parameter. The message is sent to the
integer scrap described by <SAMP>stack</SAMP>. Message
arguments are passed inside parentheses as the third
argument. The arguments and return type depend on the type
of message sent. The second parameter must be a message
identifier declared by the integer Scrap class. This
function is implemented as a macro. This function assumes
that <SAMP>stack</SAMP> has already been directed to a
scrap object that implements the integer Scrap class.
</DD></DL>
<P>
<A NAME="vscrapSendString"><HR><H4>vscrapSendString</H4></A>
<PRE>
        void <B>vscrapSendString</B>(
                vdelegatorStack * stack,
                ... arg2);
</PRE>

<DL><DD>
Invokes the behavior associated with the message identifier
passed as the second parameter. The message is sent to the
string scrap described by <SAMP>stack</SAMP>. Message
arguments are passed inside parentheses as the third
argument. The arguments and return type depend on the type
of message sent. The second parameter must be a message
identifier declared by the string Scrap class. This
function is implemented as a macro. This function assumes
that <SAMP>stack</SAMP> has already been directed to a
scrap object that implements the string Scrap class.
</DD></DL>
<P>
<A NAME="vscrapSendTag"><HR><H4>vscrapSendTag</H4></A>
<PRE>
        void <B>vscrapSendTag</B>(
                vdelegatorStack * stack,
                ... arg2);
</PRE>

<DL><DD>
Invokes the behavior associated with the message identifier
passed as the second parameter. The message is sent to the
tag scrap described by <SAMP>stack</SAMP>. Message
arguments are passed inside parentheses as the third
argument. The arguments and return type depend on the type
of message sent. The second parameter must be a message
identifier declared by the tag Scrap class. This function
is implemented as a macro. This function assumes that
<SAMP>stack</SAMP> has already been directed to a scrap
object that implements the tag Scrap class.
</DD></DL>
<P>
<A NAME="vscrapSendTypeable"><HR><H4>vscrapSendTypeable</H4></A>
<PRE>
        void <B>vscrapSendTypeable</B>(
                vdelegatorStack * stack,
                ... arg2);
</PRE>

<DL><DD>
Invokes the behavior associated with the message identifier
passed as the second parameter. The message is sent to the
typeable scrap described by <SAMP>stack</SAMP>. Message
arguments are passed inside parentheses as the third
argument. The arguments and return type depend on the type
of message sent. The second parameter must be a message
identifier declared by the typeable Scrap class. This
function is implemented as a macro. This function assumes
that <SAMP>stack</SAMP> has already been directed to a
scrap object that implements the typeable Scrap class.
</DD></DL>
<P>
<A NAME="vscrapSetArrayCount"><HR><H4>vscrapSetArrayCount</H4></A>
<PRE>
        void <B>vscrapSetArrayCount</B>(
                vscrap * scrap,
                size_t count);
</PRE>

<DL><DD>
Sets the number of scrap elements in the array scrap
<SAMP>scrap</SAMP> to <SAMP>count</SAMP>.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapSET_ARRAY_COUNT"><CODE>vscrapSET_ARRAY_COUNT</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapArrayClass"><CODE>vscrapArrayClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSetArrayCountStack"><HR><H4>vscrapSetArrayCountStack</H4></A>
<PRE>
        void <B>vscrapSetArrayCountStack</B>(
                vdelegatorStack stack,
                size_t count);
</PRE>

<DL><DD>
Sets the number of scrap elements in the array scrap that
<SAMP>stack</SAMP> is directed to to <SAMP>count</SAMP>.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapSET_ARRAY_COUNT"><CODE>vscrapSET_ARRAY_COUNT</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapArrayClass"><CODE>vscrapArrayClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapSetBlockSize"><HR><H4>vscrapSetBlockSize</H4></A>
<PRE>
        void <B>vscrapSetBlockSize</B>(
                vscrap * scrap,
                size_t size);
</PRE>

<DL><DD>
Sets the size in bytes of the data block scrap
<SAMP>scrap</SAMP>.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapSET_BLOCK_SIZE"><CODE>vscrapSET_BLOCK_SIZE</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapBlockClass"><CODE>vscrapBlockClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSetBlockSizeStack"><HR><H4>vscrapSetBlockSizeStack</H4></A>
<PRE>
        void <B>vscrapSetBlockSizeStack</B>(
                vdelegatorStack stack,
                size_t size);
</PRE>

<DL><DD>
Sets the size in bytes of the data block scrap that
<SAMP>stack</SAMP> is directed to.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapSET_BLOCK_SIZE"><CODE>vscrapSET_BLOCK_SIZE</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapBlockClass"><CODE>vscrapBlockClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapSetBoolean"><HR><H4>vscrapSetBoolean</H4></A>
<PRE>
        void <B>vscrapSetBoolean</B>(
                vscrap * scrap,
                int value);
</PRE>

<DL><DD>
Sets the value of the boolean scrap <SAMP>scrap</SAMP> to
<SAMP>value</SAMP>.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapSET_BOOLEAN"><CODE>vscrapSET_BOOLEAN</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapBooleanClass"><CODE>vscrapBooleanClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSetBooleanStack"><HR><H4>vscrapSetBooleanStack</H4></A>
<PRE>
        void <B>vscrapSetBooleanStack</B>(
                vdelegatorStack stack,
                int value);
</PRE>

<DL><DD>
Sets the value of the boolean scrap that <SAMP>stack</SAMP>
is directed to to <SAMP>value</SAMP>.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapSET_BOOLEAN"><CODE>vscrapSET_BOOLEAN</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapBooleanClass"><CODE>vscrapBooleanClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapSetCharacter"><HR><H4>vscrapSetCharacter</H4></A>
<PRE>
        void <B>vscrapSetCharacter</B>(
                vscrap * scrap,
                int value);
</PRE>

<DL><DD>
Sets the value of the character scrap <SAMP>scrap</SAMP> to
the character <SAMP>value</SAMP>.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapSET_CHARACTER"><CODE>vscrapSET_CHARACTER</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapCharacterClass"><CODE>vscrapCharacterClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSetCharacterStack"><HR><H4>vscrapSetCharacterStack</H4></A>
<PRE>
        void <B>vscrapSetCharacterStack</B>(
                vdelegatorStack stack,
                int value);
</PRE>

<DL><DD>
Sets the value of the character scrap that
<SAMP>stack</SAMP> is directed to to the character
<SAMP>value</SAMP>.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapSET_CHARACTER"><CODE>vscrapSET_CHARACTER</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapCharacterClass"><CODE>vscrapCharacterClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapSetElementAt"><HR><H4>vscrapSetElementAt</H4></A>
<PRE>
        void <B>vscrapSetElementAt</B>(
                vscrap * scrap,
                size_t index,
                vscrap * element);
</PRE>

<DL><DD>
Sets the element stored at <SAMP>index</SAMP> in the array
scrap <SAMP>scrap</SAMP> to <SAMP>element</SAMP>. Ownership
of <SAMP>element</SAMP> is passed.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapSET_ELEMENT_AT"><CODE>vscrapSET_ELEMENT_AT</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapArrayClass"><CODE>vscrapArrayClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSetElementAtStack"><HR><H4>vscrapSetElementAtStack</H4></A>
<PRE>
        void <B>vscrapSetElementAtStack</B>(
                vdelegatorStack stack,
                size_t index,
                vscrap * element);
</PRE>

<DL><DD>
Sets the element stored at <SAMP>index</SAMP> in the array
scrap that <SAMP>stack</SAMP> is directed to to
<SAMP>element</SAMP>. Ownership of <SAMP>element</SAMP> is
passed.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapSET_ELEMENT_AT"><CODE>vscrapSET_ELEMENT_AT</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapArrayClass"><CODE>vscrapArrayClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapSetFixed"><HR><H4>vscrapSetFixed</H4></A>
<PRE>
        void <B>vscrapSetFixed</B>(
                vscrap * scrap,
                vfixed value);
</PRE>

<DL><DD>
Sets the value of the fixed-point scrap <SAMP>scrap</SAMP>
to <SAMP>value</SAMP>.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapSET_FIXED"><CODE>vscrapSET_FIXED</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapFixedClass"><CODE>vscrapFixedClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSetFixedStack"><HR><H4>vscrapSetFixedStack</H4></A>
<PRE>
        void <B>vscrapSetFixedStack</B>(
                vdelegatorStack stack,
                vfixed value);
</PRE>

<DL><DD>
Sets the value of the fixed-point scrap that
<SAMP>stack</SAMP> is directed to to <SAMP>value</SAMP>.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapSET_FIXED"><CODE>vscrapSET_FIXED</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapFixedClass"><CODE>vscrapFixedClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapSetFloat"><HR><H4>vscrapSetFloat</H4></A>
<PRE>
        void <B>vscrapSetFloat</B>(
                vscrap * scrap,
                double value);
</PRE>

<DL><DD>
Sets the value of the floating-point scrap
<SAMP>scrap</SAMP> to <SAMP>value</SAMP>.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapSET_FLOAT"><CODE>vscrapSET_FLOAT</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapFloatClass"><CODE>vscrapFloatClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSetFloatStack"><HR><H4>vscrapSetFloatStack</H4></A>
<PRE>
        void <B>vscrapSetFloatStack</B>(
                vdelegatorStack stack,
                double value);
</PRE>

<DL><DD>
Sets the value of the floating-point scrap that
<SAMP>stack</SAMP> is directed to to <SAMP>value</SAMP>.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapSET_FLOAT"><CODE>vscrapSET_FLOAT</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapFloatClass"><CODE>vscrapFloatClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapSetInteger"><HR><H4>vscrapSetInteger</H4></A>
<PRE>
        void <B>vscrapSetInteger</B>(
                vscrap * scrap,
                long value);
</PRE>

<DL><DD>
Sets the value of the integer scrap <SAMP>scrap</SAMP> to
<SAMP>value</SAMP>.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapSET_INTEGER"><CODE>vscrapSET_INTEGER</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapIntegerClass"><CODE>vscrapIntegerClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSetIntegerStack"><HR><H4>vscrapSetIntegerStack</H4></A>
<PRE>
        void <B>vscrapSetIntegerStack</B>(
                vdelegatorStack stack,
                long value);
</PRE>

<DL><DD>
Sets the value of the integer scrap that <SAMP>stack</SAMP>
is directed to to <SAMP>value</SAMP>.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapSET_INTEGER"><CODE>vscrapSET_INTEGER</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapIntegerClass"><CODE>vscrapIntegerClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapSetStringScribed"><HR><H4>vscrapSetStringScribed</H4></A>
<PRE>
        void <B>vscrapSetStringScribed</B>(
                vscrap * scrap,
                vscribe * scribe);
</PRE>

<DL><DD>
Sets the value of the string scrap <SAMP>scrap</SAMP> to
the result of scribing <SAMP>scribe</SAMP>.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapSET_STRING_SCRIBED"><CODE>vscrapSET_STRING_SCRIBED</CODE></A></CODE> to a delegate
of <SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapStringClass"><CODE>vscrapStringClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSetStringScribedStack"><HR><H4>vscrapSetStringScribedStack</H4></A>
<PRE>
        void <B>vscrapSetStringScribedStack</B>(
                vdelegatorStack stack,
                vscribe * scribe);
</PRE>

<DL><DD>
Sets the value of the string scrap that <SAMP>stack</SAMP>
is directed to to the result of scribing
<SAMP>scribe</SAMP>.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapSET_STRING_SCRIBED"><CODE>vscrapSET_STRING_SCRIBED</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapStringClass"><CODE>vscrapStringClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapSetTag"><HR><H4>vscrapSetTag</H4></A>
<PRE>
        void <B>vscrapSetTag</B>(
                vscrap * scrap,
                const vname * tag);
</PRE>

<DL><DD>
Sets the value of the tag scrap <SAMP>scrap</SAMP> to the
name <SAMP>tag</SAMP> from the global name table.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapSET_TAG"><CODE>vscrapSET_TAG</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapTagClass"><CODE>vscrapTagClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSetTagStack"><HR><H4>vscrapSetTagStack</H4></A>
<PRE>
        void <B>vscrapSetTagStack</B>(
                vdelegatorStack stack,
                const vname * tag);
</PRE>

<DL><DD>
Sets the value of the tag scrap that <SAMP>stack</SAMP> is
directed to to the name <SAMP>tag</SAMP> from the global
name table.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapSET_TAG"><CODE>vscrapSET_TAG</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapTagClass"><CODE>vscrapTagClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapStartup"><HR><H4>vscrapStartup</H4></A>
<PRE>
        void <B>vscrapStartup</B>();
</PRE>

<DL><DD>
Initializes the Representation class. Has no effect if
the Representation class is already initialized.
</DD></DL>
<P>
<A NAME="vscrapStoreElement"><HR><H4>vscrapStoreElement</H4></A>
<PRE>
        void <B>vscrapStoreElement</B>(
                vscrap * scrap,
                const vname * key,
                vscrap * element);
</PRE>

<DL><DD>
Stores the scrap <SAMP>element</SAMP> in the dictionary
scrap <SAMP>scrap</SAMP> using the global name
<SAMP>tag</SAMP>. Ownership of <SAMP>element</SAMP> is
passed.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapSTORE_ELEMENT"><CODE>vscrapSTORE_ELEMENT</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapDictionaryClass"><CODE>vscrapDictionaryClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapStoreElementStack"><HR><H4>vscrapStoreElementStack</H4></A>
<PRE>
        void <B>vscrapStoreElementStack</B>(
                vdelegatorStack stack,
                const vname * key,
                vscrap * element);
</PRE>

<DL><DD>
Stores the scrap <SAMP>element</SAMP> in the dictionary
scrap that <SAMP>stack</SAMP> is directed to using the
global name <SAMP>name</SAMP>. Ownership of
<SAMP>element</SAMP> is passed.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapSTORE_ELEMENT"><CODE>vscrapSTORE_ELEMENT</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapDictionaryClass"><CODE>vscrapDictionaryClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapSyncBlock"><HR><H4>vscrapSyncBlock</H4></A>
<PRE>
        void <B>vscrapSyncBlock</B>(
                vscrap * scrap);
</PRE>

<DL><DD>
Syncs data in a data block scrap. The actual meaning of this depends on the 
type of block scrap, but typically it means saving or flushing the data.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapSYNC_BLOCK"><CODE>vscrapSYNC_BLOCK</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapBlockClass"><CODE>vscrapBlockClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSyncBlockStack"><HR><H4>vscrapSyncBlockStack</H4></A>
<PRE>
        void <B>vscrapSyncBlockStack</B>(
                vdelegatorStack stack);
</PRE>

<DL><DD>
Syncs the data of the data block scrap the stack is directed to. The actual 
meaning of this depends on the type of block scrap, but typically it means 
saving or flushing the data.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapSYNC_BLOCK"><CODE>vscrapSYNC_BLOCK</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapBlockClass"><CODE>vscrapBlockClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="vscrapWriteBlock"><HR><H4>vscrapWriteBlock</H4></A>
<PRE>
        void <B>vscrapWriteBlock</B>(
                vscrap * scrap,
                size_t offset,
                size_t count,
                const void * buffer);
</PRE>

<DL><DD>
Copies <SAMP>count</SAMP> bytes from <SAMP>buffer</SAMP> to
the data block scrap <SAMP>scrap</SAMP> starting at
<SAMP>offset</SAMP> bytes from the start of scrap.
  <P>
This function is implemented by dispatching the dynamic
message <CODE><A HREF="vscrap-x.html#vscrapWRITE_BLOCK"><CODE>vscrapWRITE_BLOCK</CODE></A></CODE> to a delegate of
<SAMP>scrap</SAMP> which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapBlockClass"><CODE>vscrapBlockClass</CODE></A></SAMP>.
</DD></DL>
<P>
<A NAME="vscrapWriteBlockStack"><HR><H4>vscrapWriteBlockStack</H4></A>
<PRE>
        void <B>vscrapWriteBlockStack</B>(
                vdelegatorStack stack,
                size_t offset,
                size_t count,
                const void * buffer);
</PRE>

<DL><DD>
Copies <SAMP>count</SAMP> bytes from <SAMP>buffer</SAMP> to
the data block scrap that <SAMP>stack</SAMP> is directed
to, starting at <SAMP>offset</SAMP> bytes from the start of
scrap.
  <P>
This function is implemented by sending the message
<CODE><A HREF="vscrap-x.html#vscrapWRITE_BLOCK"><CODE>vscrapWRITE_BLOCK</CODE></A></CODE> to the top object on
<SAMP>stack</SAMP>, after <SAMP>stack</SAMP> has been
directed to an object which <CODE>IsKindOf</CODE>
<SAMP><A HREF="vscrap-x.html#vscrapBlockClass"><CODE>vscrapBlockClass</CODE></A>.</SAMP>
</DD></DL>
<P>
<A NAME="section_Message"><HR>
<CENTER><H2>Messages</H2></CENTER></A><P>
<A NAME="vscrapADD_ELEMENT"><HR><H4>vscrapADD_ELEMENT</H4></A>
<PRE>
        &lt;<B>vscrapADD_ELEMENT</B>&gt;
</PRE>

<DL><DD>
Adds the scrap <SAMP>element</SAMP> to the scrap object
described by <SAMP>stack</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapDESTROY_ITERATOR"><HR><H4>vscrapDESTROY_ITERATOR</H4></A>
<PRE>
        &lt;<B>vscrapDESTROY_ITERATOR</B>&gt;
</PRE>

<DL><DD>
Terminates the iteration represented by <SAMP>iter</SAMP>,
even if it is not yet exhausted. This message also reclaims
storage allocated by the Representation Manager during
iteration.
</DD></DL>
<P>
<A NAME="vscrapDUMP"><HR><H4>vscrapDUMP</H4></A>
<PRE>
        &lt;<B>vscrapDUMP</B>&gt;
</PRE>

<DL><DD>
Prints the contents of the convertible that
<SAMP>stack</SAMP> is directed to. The contents are printed
to the file <SAMP>stream</SAMP> in a user-readable form.
This message is intended for debugging and should not be
used to store the contents of the scrap in recoverable
form. This message has effect only if debugging is enabled.
</DD></DL>
<P>
<A NAME="vscrapELEMENT_ITERATOR_CLASS"><HR><H4>vscrapELEMENT_ITERATOR_CLASS</H4></A>
<PRE>
        &lt;<B>vscrapELEMENT_ITERATOR_CLASS</B>&gt;
</PRE>

<DL><DD>
Contains the type class of the compound iterator object
that can be used to iterate over the elements in the
compound Scrap class.
</DD></DL>
<P>
<A NAME="vscrapEMPTY_ELEMENTS"><HR><H4>vscrapEMPTY_ELEMENTS</H4></A>
<PRE>
        &lt;<B>vscrapEMPTY_ELEMENTS</B>&gt;
</PRE>

<DL><DD>
Removes all scrap elements from the scrap object described
by <SAMP>stack</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapENTYPE"><HR><H4>vscrapENTYPE</H4></A>
<PRE>
        &lt;<B>vscrapENTYPE</B>&gt;
</PRE>

<DL><DD>
Attempts to assign the type class <SAMP>clas</SAMP> to the
scrap object described by <SAMP>stack</SAMP>, returning
<SAMP>TRUE</SAMP> if successful or <SAMP>FALSE</SAMP> if
the requested class is not implemented. This message is
typically sent to a typeable scrap when an attempt to
import the contents of the source scrap object fails.
</DD></DL>
<P>
<A NAME="vscrapEXPORT"><HR><H4>vscrapEXPORT</H4></A>
<PRE>
        &lt;<B>vscrapEXPORT</B>&gt;
</PRE>

<DL><DD>
Converts the contents of the scrap object described by
<SAMP>stack</SAMP> to the scrap object described by
<SAMP>dest</SAMP>. Typically, conversion is accomplished by
sending messages to get the value of the object described
by <SAMP>dest</SAMP> and set the value of the object
described by <SAMP>stack</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapEXPORT_CLASS"><HR><H4>vscrapEXPORT_CLASS</H4></A>
<PRE>
        &lt;<B>vscrapEXPORT_CLASS</B>&gt;
</PRE>

<DL><DD>
Contains the type class identifier of the Scrap class that
the convertible Scrap class can export to. This class
variable is used by the default <SAMP><A HREF="vscrap-x.html#vscrapIMPORT"><CODE>vscrapIMPORT</CODE></A></SAMP>
and <SAMP>vscrapEXPORT</SAMP> methods for convertible
scraps.
</DD></DL>
<P>
<A NAME="vscrapGET_ARRAY_COUNT"><HR><H4>vscrapGET_ARRAY_COUNT</H4></A>
<PRE>
        &lt;<B>vscrapGET_ARRAY_COUNT</B>&gt;
</PRE>

<DL><DD>
Returns the number of scrap elements in the scrap object
described by <SAMP>stack</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGET_BLOCK_SIZE"><HR><H4>vscrapGET_BLOCK_SIZE</H4></A>
<PRE>
        &lt;<B>vscrapGET_BLOCK_SIZE</B>&gt;
</PRE>

<DL><DD>
Returns the size of the data block referenced by the scrap
object described by <SAMP>stack</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGET_BOOLEAN"><HR><H4>vscrapGET_BOOLEAN</H4></A>
<PRE>
        &lt;<B>vscrapGET_BOOLEAN</B>&gt;
</PRE>

<DL><DD>
Returns the value of the scrap object described by
<SAMP>stack</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGET_CHARACTER"><HR><H4>vscrapGET_CHARACTER</H4></A>
<PRE>
        &lt;<B>vscrapGET_CHARACTER</B>&gt;
</PRE>

<DL><DD>
Returns the value of the scrap object described by
<SAMP>stack</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGET_ELEMENT_AT"><HR><H4>vscrapGET_ELEMENT_AT</H4></A>
<PRE>
        &lt;<B>vscrapGET_ELEMENT_AT</B>&gt;
</PRE>

<DL><DD>
Returns the scrap element stored at <SAMP>index</SAMP> in
the array scrap object described by <SAMP>stack</SAMP>.
This method is invoked by the default array Scrap class
<SAMP><A HREF="vscrap-x.html#vscrapEXPORT"><CODE>vscrapEXPORT</CODE></A></SAMP> method.
</DD></DL>
<P>
<A NAME="vscrapGET_FIXED"><HR><H4>vscrapGET_FIXED</H4></A>
<PRE>
        &lt;<B>vscrapGET_FIXED</B>&gt;
</PRE>

<DL><DD>
Returns the value of the scrap object described by
<SAMP>stack</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGET_FLOAT"><HR><H4>vscrapGET_FLOAT</H4></A>
<PRE>
        &lt;<B>vscrapGET_FLOAT</B>&gt;
</PRE>

<DL><DD>
Returns the value of the floating-point scrap object
described by <SAMP>stack</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGET_INTEGER"><HR><H4>vscrapGET_INTEGER</H4></A>
<PRE>
        &lt;<B>vscrapGET_INTEGER</B>&gt;
</PRE>

<DL><DD>
Returns the value of the scrap object described by
<SAMP>stack</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGET_ITERATOR_ELEMENT"><HR><H4>vscrapGET_ITERATOR_ELEMENT</H4></A>
<PRE>
        &lt;<B>vscrapGET_ITERATOR_ELEMENT</B>&gt;
</PRE>

<DL><DD>
Returns the scrap element referenced by the current state
of iteration represented by <SAMP>iter</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGET_ITERATOR_INDEX"><HR><H4>vscrapGET_ITERATOR_INDEX</H4></A>
<PRE>
        &lt;<B>vscrapGET_ITERATOR_INDEX</B>&gt;
</PRE>

<DL><DD>
Returns the index of the scrap element referenced by the
current state of iteration described by <SAMP>iter</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapGET_ITERATOR_KEY"><HR><H4>vscrapGET_ITERATOR_KEY</H4></A>
<PRE>
        &lt;<B>vscrapGET_ITERATOR_KEY</B>&gt;
</PRE>

<DL><DD>
Returns the global name key that corresponds to the scrap
element referenced by the current state of the iteration
described by <SAMP>iter</SAMP>. This method is invoked by
the default <SAMP><A HREF="vscrap-x.html#vscrapEXPORT"><CODE>vscrapEXPORT</CODE></A></SAMP> method for dictionary
Scrap classes.
</DD></DL>
<P>
<A NAME="vscrapGET_TAG"><HR><H4>vscrapGET_TAG</H4></A>
<PRE>
        &lt;<B>vscrapGET_TAG</B>&gt;
</PRE>

<DL><DD>
Returns the value of the scrap object described by
<SAMP>stack</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapIMPORT"><HR><H4>vscrapIMPORT</H4></A>
<PRE>
        &lt;<B>vscrapIMPORT</B>&gt;
</PRE>

<DL><DD>
Converts the contents of the scrap object described by
<SAMP>source</SAMP> to the scrap object described by
<SAMP>stack</SAMP>. Typically, conversion is accomplished
by directing <SAMP>stack</SAMP> to a delegate object of the
class of the object described by <SAMP>source</SAMP> and
then sending the message <SAMP><A HREF="vscrap-x.html#vscrapEXPORT"><CODE>vscrapEXPORT</CODE></A></SAMP> to the
object described by <SAMP>source</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapINIT_ITERATOR"><HR><H4>vscrapINIT_ITERATOR</H4></A>
<PRE>
        &lt;<B>vscrapINIT_ITERATOR</B>&gt;
</PRE>

<DL><DD>
Begins an iteration of all scrap elements in a scrap with
multiple elements by initializing <SAMP>iter</SAMP> to
iterate over the scrap object described by
<SAMP>stack</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapLOAD_ELEMENT"><HR><H4>vscrapLOAD_ELEMENT</H4></A>
<PRE>
        &lt;<B>vscrapLOAD_ELEMENT</B>&gt;
</PRE>

<DL><DD>
Returns the scrap element stored in the scrap object
described by <SAMP>stack</SAMP> using the global name
<SAMP>key</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapNEXT_ITERATOR"><HR><H4>vscrapNEXT_ITERATOR</H4></A>
<PRE>
        &lt;<B>vscrapNEXT_ITERATOR</B>&gt;
</PRE>

<DL><DD>
Performs the next step of the iteration represented by
<SAMP>iter</SAMP> and returns <CODE>TRUE</CODE> if a scrap
element is available, <CODE>FALSE</CODE> if there are no
more scrap elements available in the scrap.
</DD></DL>
<P>
<A NAME="vscrapREAD_BLOCK"><HR><H4>vscrapREAD_BLOCK</H4></A>
<PRE>
        &lt;<B>vscrapREAD_BLOCK</B>&gt;
</PRE>

<DL><DD>
Reads <SAMP>count</SAMP> bytes from the scrap object
described by <SAMP>stack</SAMP> starting at
<SAMP>offset</SAMP> bytes from the beginning of the block
and places them in <SAMP>buffer</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapREMOVE_ELEMENT"><HR><H4>vscrapREMOVE_ELEMENT</H4></A>
<PRE>
        &lt;<B>vscrapREMOVE_ELEMENT</B>&gt;
</PRE>

<DL><DD>
Removes the scrap element stored using the global name
<SAMP>key</SAMP> in the scrap object described by
<SAMP>stack</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSCRIBE_STRING"><HR><H4>vscrapSCRIBE_STRING</H4></A>
<PRE>
        &lt;<B>vscrapSCRIBE_STRING</B>&gt;
</PRE>

<DL><DD>
Returns the value of the scrap object described by
<SAMP>stack</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSET_ARRAY_COUNT"><HR><H4>vscrapSET_ARRAY_COUNT</H4></A>
<PRE>
        &lt;<B>vscrapSET_ARRAY_COUNT</B>&gt;
</PRE>

<DL><DD>
Sets the number of scrap elements in the array scrap
described by <SAMP>stack</SAMP> to <SAMP>count</SAMP>. This
method is used by the default <SAMP><A HREF="vscrap-x.html#vscrapEXPORT"><CODE>vscrapEXPORT</CODE></A></SAMP>
method for array Scrap classes.
</DD></DL>
<P>
<A NAME="vscrapSET_BLOCK_SIZE"><HR><H4>vscrapSET_BLOCK_SIZE</H4></A>
<PRE>
        &lt;<B>vscrapSET_BLOCK_SIZE</B>&gt;
</PRE>

<DL><DD>
Sets the size of the data block referenced by the scrap
object described by <SAMP>stack</SAMP> to
<SAMP>size</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSET_BOOLEAN"><HR><H4>vscrapSET_BOOLEAN</H4></A>
<PRE>
        &lt;<B>vscrapSET_BOOLEAN</B>&gt;
</PRE>

<DL><DD>
Sets the value of the scrap object described by
<SAMP>stack</SAMP> to <SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSET_CHARACTER"><HR><H4>vscrapSET_CHARACTER</H4></A>
<PRE>
        &lt;<B>vscrapSET_CHARACTER</B>&gt;
</PRE>

<DL><DD>
Sets the value of the scrap object described by
<SAMP>stack</SAMP> to <SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSET_ELEMENT_AT"><HR><H4>vscrapSET_ELEMENT_AT</H4></A>
<PRE>
        &lt;<B>vscrapSET_ELEMENT_AT</B>&gt;
</PRE>

<DL><DD>
Stores the scrap element <SAMP>scrap</SAMP> in the array
scrap object described by <SAMP>stack</SAMP> at the
location given by <SAMP>index</SAMP>. Ownership of
<SAMP>element</SAMP> is passed. This method is used by the
default <SAMP><A HREF="vscrap-x.html#vscrapEXPORT"><CODE>vscrapEXPORT</CODE></A></SAMP> method for array scrap
classes.
</DD></DL>
<P>
<A NAME="vscrapSET_FIXED"><HR><H4>vscrapSET_FIXED</H4></A>
<PRE>
        &lt;<B>vscrapSET_FIXED</B>&gt;
</PRE>

<DL><DD>
Sets the value of the fixed-point scrap <SAMP>stack</SAMP>
is directed to to <SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSET_FLOAT"><HR><H4>vscrapSET_FLOAT</H4></A>
<PRE>
        &lt;<B>vscrapSET_FLOAT</B>&gt;
</PRE>

<DL><DD>
Sets the value of the scrap object described by
<SAMP>stack</SAMP> to <SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSET_INTEGER"><HR><H4>vscrapSET_INTEGER</H4></A>
<PRE>
        &lt;<B>vscrapSET_INTEGER</B>&gt;
</PRE>

<DL><DD>
Sets the value of the scrap object described by
<SAMP>stack</SAMP> to <SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSET_STRING_SCRIBED"><HR><H4>vscrapSET_STRING_SCRIBED</H4></A>
<PRE>
        &lt;<B>vscrapSET_STRING_SCRIBED</B>&gt;
</PRE>

<DL><DD>
Sets the value of the scrap object described by
<SAMP>stack</SAMP> to <SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSET_TAG"><HR><H4>vscrapSET_TAG</H4></A>
<PRE>
        &lt;<B>vscrapSET_TAG</B>&gt;
</PRE>

<DL><DD>
Sets the value of the scrap object described by
<SAMP>stack</SAMP> to <SAMP>value</SAMP>.
</DD></DL>
<P>
<A NAME="vscrapSTORE_ELEMENT"><HR><H4>vscrapSTORE_ELEMENT</H4></A>
<PRE>
        &lt;<B>vscrapSTORE_ELEMENT</B>&gt;
</PRE>

<DL><DD>
Stores the scrap element <SAMP>scrap</SAMP> in the
dictionary scrap described by <SAMP>stack</SAMP> using the
global name <SAMP>key</SAMP>. This method is used by the
default <SAMP><A HREF="vscrap-x.html#vscrapEXPORT"><CODE>vscrapEXPORT</CODE></A></SAMP> method for dictionary
Scrap classes.
</DD></DL>
<P>
<A NAME="vscrapSYNC_BLOCK"><HR><H4>vscrapSYNC_BLOCK</H4></A>
<PRE>
        &lt;<B>vscrapSYNC_BLOCK</B>&gt;
</PRE>

<DL><DD>
Syncs data in a data block scrap. The actual meaning of this
depends on the type of block scrap, but typically it means saving
or flushing the data.
</DD></DL>
<P>
<A NAME="vscrapWRITE_BLOCK"><HR><H4>vscrapWRITE_BLOCK</H4></A>
<PRE>
        &lt;<B>vscrapWRITE_BLOCK</B>&gt;
</PRE>

<DL><DD>
Writes <SAMP>count</SAMP> bytes from <SAMP>buffer</SAMP>
into the scrap object described by <SAMP>stack</SAMP>
starting at <SAMP>offset</SAMP> bytes from the beginning of
the block.
</DD></DL>
<P>
<A NAME="section_Constant"><HR>
<CENTER><H2>Constants</H2></CENTER></A><P>
<A NAME="vscrapINCLUDED"><HR><H4>vscrapINCLUDED</H4></A>
<PRE>
        <B>vscrapINCLUDED</B>
</PRE>

<DL><DD>
This symbol is defined if the Representation class header
file has already been included, and is used to prevent
multiple inclusion of the header file. This symbol can also
be used by an application program to prevent the C
preprocessor from even accessing the header file, in some
cases greatly speeding the compilation process. For
example, the following code could be placed at the
beginning of the application source file:
  <P>
<BLOCKQUOTE>
<PRE>

	...
	#ifndef vscrapINCLUDED
	#include <vscrap.h>
	#endif
	...

</PRE>
</BLOCKQUOTE>

  <P>
Doing this prevents the preprocessor from even opening the
header file if it has already been included; since opening
and parsing multiple header files is relatively expensive,
bracketing each included Galaxy header file as shown above
can in some cases greatly improve compilation speed.
</DD></DL>
<P>
<A NAME="section_Macro"><HR>
<CENTER><H2>Macros</H2></CENTER></A><P>
<A NAME="vscrapARRAY_CLASS"><HR><H4>vscrapARRAY_CLASS</H4></A>
<PRE>
        #define <B>vscrapARRAY_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for array scrap
classes-this macro expands to the contents of
<CODE><A HREF="vscrap-x.html#vscrapArrayClass"><CODE>vscrapArrayClass</CODE></A></CODE>. <CODE>CLASS</CODE> is the type
identifier of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapArrayClass"><CODE>vscrapArrayClass</CODE></A></CODE>). This type is used by the class's
subclasses to refer to it. <CODE>OBJECT</CODE> is the type identifier
of instances of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapArray"><CODE>vscrapArray</CODE></A></CODE>). This macro should be used by the scrap
subclasses to declare the contents of the Scrap class. This macro
should come first in the subclass structure declaration.
</DD></DL>
<P>
<A NAME="vscrapARRAY_ITERATOR_CLASS"><HR><H4>vscrapARRAY_ITERATOR_CLASS</H4></A>
<PRE>
        #define <B>vscrapARRAY_ITERATOR_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for array scrap iterator
classes-this macro expands to the contents of
<CODE><A HREF="vscrap-x.html#vscrapArrayIteratorClass"><CODE>vscrapArrayIteratorClass</CODE></A></CODE>. <CODE>CLASS</CODE> is the type
identifier of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapArrayIteratorClass"><CODE>vscrapArrayIteratorClass</CODE></A></CODE>). This type is used by the
class's subclasses to refer to it. <CODE>OBJECT</CODE> is the type
identifier of instances of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapArrayIterator"><CODE>vscrapArrayIterator</CODE></A></CODE>). This macro should be used by the
scrap subclasses to declare the contents of the Scrap class. This
macro should come first in the subclass structure declaration.
</DD></DL>
<P>
<A NAME="vscrapBLOCK_CLASS"><HR><H4>vscrapBLOCK_CLASS</H4></A>
<PRE>
        #define <B>vscrapBLOCK_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for block scrap
classes-this macro expands to the contents of
<CODE><A HREF="vscrap-x.html#vscrapBlockClass"><CODE>vscrapBlockClass</CODE></A></CODE>. <CODE>CLASS</CODE> is the type
identifier of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapBlockClass"><CODE>vscrapBlockClass</CODE></A></CODE>). This type is used by the class's
subclasses to refer to it. <CODE>OBJECT</CODE> is the type identifier
of instances of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapBlock"><CODE>vscrapBlock</CODE></A></CODE>). This macro should be used by the scrap
subclasses to declare the contents of the Scrap class. This macro
should come first in the subclass structure declaration.
</DD></DL>
<P>
<A NAME="vscrapBOOLEAN_CLASS"><HR><H4>vscrapBOOLEAN_CLASS</H4></A>
<PRE>
        #define <B>vscrapBOOLEAN_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for boolean scrap
classes; this macro expands to the contents of
<CODE><A HREF="vscrap-x.html#vscrapBooleanClass"><CODE>vscrapBooleanClass</CODE></A></CODE>. <CODE>CLASS</CODE> is the type
identifier of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapBooleanClass"><CODE>vscrapBooleanClass</CODE></A></CODE>). This type is used by the class's
subclasses to refer to it. <CODE>OBJECT</CODE> is the type identifier
of instances of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapBoolean"><CODE>vscrapBoolean</CODE></A></CODE>). This macro should be used by the scrap
subclasses to declare the contents of the Scrap class. This macro
should come first in the subclass structure declaration.
</DD></DL>
<P>
<A NAME="vscrapCHARACTER_CLASS"><HR><H4>vscrapCHARACTER_CLASS</H4></A>
<PRE>
        #define <B>vscrapCHARACTER_CLASS</B>(...) ...
</PRE>

<DL><DD>

Contains the method and variable declarations for character Scrap
classes-this macro expands to the contents of
<CODE><A HREF="vscrap-x.html#vscrapCharacterClass"><CODE>vscrapCharacterClass</CODE></A></CODE>. <CODE>CLASS</CODE> is the type
identifier of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapCharacterClass"><CODE>vscrapCharacterClass</CODE></A></CODE>). This type is used by the class's
subclasses to refer to it. <CODE>OBJECT</CODE> is the type identifier
of instances of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapCharacter"><CODE>vscrapCharacter</CODE></A></CODE>). This macro should be used by the scrap
subclasses to declare the contents of the Scrap class. This macro
should come first in the subclass structure declaration.
</DD></DL>
<P>
<A NAME="vscrapCLASS"><HR><H4>vscrapCLASS</H4></A>
<PRE>
        #define <B>vscrapCLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for Scrap classes-this
macro expands to the contents of <CODE><A HREF="vscrap-x.html#vscrapClass"><CODE>vscrapClass</CODE></A></CODE>.
<CODE>SUPER</CODE> is the type identifier of the class being declared
(for example, <CODE><A HREF="vscrap-x.html#vscrapClass"><CODE>vscrapClass</CODE></A></CODE>).</CODE> This type is used by
the class's subclasses to refer to it. <CODE>INSTANCE</CODE> is the
type identifier of instances of the class being declared (for example,
<CODE>vscrap</CODE>). This macro should be used by the scrap
subclasses to declare the contents of the Scrap class. This macro
should come first in the subclass structure declaration.
</DD></DL>
<P>
<A NAME="vscrapCOMPOUND_CLASS"><HR><H4>vscrapCOMPOUND_CLASS</H4></A>
<PRE>
        #define <B>vscrapCOMPOUND_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for compound scrap
classes-this macro expands to the contents of
<CODE><A HREF="vscrap-x.html#vscrapCompoundClass"><CODE>vscrapCompoundClass</CODE></A></CODE>. <CODE>CLASS</CODE> is the type
identifier of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapCompoundClass"><CODE>vscrapCompoundClass</CODE></A></CODE>). This type is used by the class's
subclasses to refer to it. <CODE>OBJECT</CODE> is the type identifier
of instances of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapCompound"><CODE>vscrapCompound</CODE></A></CODE>). This macro should be used by the scrap
subclasses to declare the contents of the Scrap class. This macro
should come first in the subclass structure declaration.
</DD></DL>
<P>
<A NAME="vscrapCOMPOUND_ITERATOR_CLASS"><HR><H4>vscrapCOMPOUND_ITERATOR_CLASS</H4></A>
<PRE>
        #define <B>vscrapCOMPOUND_ITERATOR_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for compound scrap
iterator classes-this macro expands to the contents of
<CODE><A HREF="vscrap-x.html#vscrapCompoundIteratorClass"><CODE>vscrapCompoundIteratorClass</CODE></A></CODE>. <CODE>CLASS</CODE> is the
type identifier of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapCompoundIteratorClass"><CODE>vscrapCompoundIteratorClass</CODE></A></CODE>). This type is used by the
class's subclasses to refer to it. <CODE>OBJECT</CODE> is the type
identifier of instances of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapCompoundIterator"><CODE>vscrapCompoundIterator</CODE></A></CODE>). This macro should be used by the
scrap subclasses to declare the contents of the Scrap class. This
macro should come first in the subclass structure declaration.
</DD></DL>
<P>
<A NAME="vscrapCONVERTIBLE_CLASS"><HR><H4>vscrapCONVERTIBLE_CLASS</H4></A>
<PRE>
        #define <B>vscrapCONVERTIBLE_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for convertible scrap
classes-this macro expands to the contents of
<CODE><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A></CODE>. <CODE>CLASS</CODE> is the type
identifier of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapConvertibleClass"><CODE>vscrapConvertibleClass</CODE></A></CODE>). This type is used by the class's
subclasses to refer to it. <CODE>OBJECT</CODE> is the type identifier
of instances of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapConvertible"><CODE>vscrapConvertible</CODE></A></CODE>). This macro should be used by the
scrap subclasses to declare the contents of the Scrap class. This
macro should come first in the subclass structure declaration.
</DD></DL>
<P>
<A NAME="vscrapDICTIONARY_CLASS"><HR><H4>vscrapDICTIONARY_CLASS</H4></A>
<PRE>
        #define <B>vscrapDICTIONARY_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for dictionary scrap
classes-this macro expands to the contents of
<CODE><A HREF="vscrap-x.html#vscrapDictionaryClass"><CODE>vscrapDictionaryClass</CODE></A></CODE>. <CODE>CLASS</CODE> is the type
identifier of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapDictionaryClass"><CODE>vscrapDictionaryClass</CODE></A></CODE>). This type is used by the class's
subclasses to refer to it. <CODE>OBJECT</CODE> is the type identifier
of instances of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapDictionary"><CODE>vscrapDictionary</CODE></A></CODE>). This macro should be used by the Scrap
subclasses to declare the contents of the Scrap class. This macro
should come first in the subclass structure declaration.
</DD></DL>
<P>
<A NAME="vscrapDICTIONARY_ITERATOR_CLASS"><HR><H4>vscrapDICTIONARY_ITERATOR_CLASS</H4></A>
<PRE>
        #define <B>vscrapDICTIONARY_ITERATOR_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for dictionary scrap
iterator classes-this macro expands to the contents of
<CODE><A HREF="vscrap-x.html#vscrapDictionaryIteratorClass"><CODE>vscrapDictionaryIteratorClass</CODE></A></CODE>. <CODE>CLASS</CODE> is the
type identifier of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapDictionaryIteratorClass"><CODE>vscrapDictionaryIteratorClass</CODE></A></CODE>). This type is used by the
class's subclasses to refer to it. <CODE>OBJECT</CODE> is the type
identifier of instances of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapDictionaryIterator"><CODE>vscrapDictionaryIterator</CODE></A></CODE>). This macro should be used by
the scrap subclasses to declare the contents of the Scrap class. This
macro should come first in the subclass structure declaration.
</DD></DL>
<P>
<A NAME="vscrapFIXED_CLASS"><HR><H4>vscrapFIXED_CLASS</H4></A>
<PRE>
        #define <B>vscrapFIXED_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for fixed scrap
classes-this macro expands to the contents of
<CODE><A HREF="vscrap-x.html#vscrapFixedClass"><CODE>vscrapFixedClass</CODE></A></CODE>. <CODE>CLASS</CODE> is the type
identifier of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapFixedClass"><CODE>vscrapFixedClass</CODE></A></CODE>). This type is used by the class's
subclasses to refer to it. <CODE>OBJECT</CODE> is the type identifier
of instances of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapFixed"><CODE>vscrapFixed</CODE></A></CODE>). This macro should be used by the scrap
subclasses to declare the contents of the Scrap class. This macro
should come first in the subclass structure declaration.
</DD></DL>
<P>
<A NAME="vscrapFLOAT_CLASS"><HR><H4>vscrapFLOAT_CLASS</H4></A>
<PRE>
        #define <B>vscrapFLOAT_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for float scrap
classes-this macro expands to the contents of
<CODE><A HREF="vscrap-x.html#vscrapFloatClass"><CODE>vscrapFloatClass</CODE></A></CODE>. <CODE>CLASS</CODE> is the type
identifier of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapFloatClass"><CODE>vscrapFloatClass</CODE></A></CODE>). This type is used by the class's
subclasses to refer to it. <CODE>OBJECT</CODE> is the type identifier
of instances of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapFloat"><CODE>vscrapFloat</CODE></A></CODE>). This macro should be used by the scrap
subclasses to declare the contents of the Scrap class. This macro
should come first in the subclass structure declaration.
</DD></DL>
<P>
<A NAME="vscrapINTEGER_CLASS"><HR><H4>vscrapINTEGER_CLASS</H4></A>
<PRE>
        #define <B>vscrapINTEGER_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for integer scrap
classes; this macro expands to the contents of
<CODE><A HREF="vscrap-x.html#vscrapIntegerClass"><CODE>vscrapIntegerClass</CODE></A></CODE>. <CODE>CLASS</CODE> is the type
identifier of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapIntegerClass"><CODE>vscrapIntegerClass</CODE></A></CODE>). This type is used by the class's
subclasses to refer to it. <CODE>OBJECT</CODE> is the type identifier
of instances of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapInteger"><CODE>vscrapInteger</CODE></A></CODE>). This macro should be used by the scrap
subclasses to declare the contents of the Scrap class. This macro
should come first in the subclass structure declaration.
</DD></DL>
<P>
<A NAME="vscrapITERATOR_CLASS"><HR><H4>vscrapITERATOR_CLASS</H4></A>
<PRE>
        #define <B>vscrapITERATOR_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for scrap iterator
classes-this macro expands to the contents of
<CODE><A HREF="vscrap-x.html#vscrapIteratorClass"><CODE>vscrapIteratorClass</CODE></A></CODE>. <CODE>CLASS</CODE> is the type
identifier of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapIteratorClass"><CODE>vscrapIteratorClass</CODE></A></CODE>). This type is used by the class's
subclasses to refer to it. <CODE>OBJECT</CODE> is the type identifier
of instances of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapIterator"><CODE>vscrapIterator</CODE></A></CODE>). This macro should be used by the scrap
subclasses to declare the contents of the Scrap class. This macro
should come first in the subclass structure declaration.
</DD></DL>
<P>
<A NAME="vscrapSTRING_CLASS"><HR><H4>vscrapSTRING_CLASS</H4></A>
<PRE>
        #define <B>vscrapSTRING_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for string Scrap classes
- this macro expands to the contents of
<CODE><A HREF="vscrap-x.html#vscrapStringClass"><CODE>vscrapStringClass</CODE></A></CODE>. <CODE>CLASS</CODE> is the type
identifier of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapStringClass"><CODE>vscrapStringClass</CODE></A></CODE>). This type is used by the class's
subclasses to refer to it. <CODE>OBJECT</CODE> is the type identifier
of instances of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapString"><CODE>vscrapString</CODE></A></CODE>). This macro should be used by the scrap
subclasses to declare the contents of the Scrap class. This macro
should come first in the subclass structure declaration.
</DD></DL>
<P>
<A NAME="vscrapTAG_CLASS"><HR><H4>vscrapTAG_CLASS</H4></A>
<PRE>
        #define <B>vscrapTAG_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for tag scrap
classes-this macro expands to the contents of
<CODE><A HREF="vscrap-x.html#vscrapTagClass"><CODE>vscrapTagClass</CODE></A></CODE>. <CODE>CLASS</CODE> is the type identifier
of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapTagClass"><CODE>vscrapTagClass</CODE></A></CODE>). This type is used by the class's
subclasses to refer to it. <CODE>OBJECT</CODE> is the type identifier
of instances of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapTag"><CODE>vscrapTag</CODE></A></CODE>). This macro should be used by the scrap
subclasses to declare the contents of the Scrap class. This macro
should come first in the subclass structure declaration.
</DD></DL>
<P>
<A NAME="vscrapTYPEABLE_CLASS"><HR><H4>vscrapTYPEABLE_CLASS</H4></A>
<PRE>
        #define <B>vscrapTYPEABLE_CLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for typeable scrap
classes-this macro expands to the contents of
<CODE><A HREF="vscrap-x.html#vscrapTypeableClass"><CODE>vscrapTypeableClass</CODE></A></CODE>. <CODE>CLASS</CODE> is the type
identifier of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapTypeableClass"><CODE>vscrapTypeableClass</CODE></A></CODE>). This type is used by the class's
subclasses to refer to it. <CODE>OBJECT</CODE> is the type identifier
of instances of the class being declared (for example,
<CODE><A HREF="vscrap-x.html#vscrapTypeable"><CODE>vscrapTypeable</CODE></A></CODE>). This macro should be used by the scrap
subclasses to declare the contents of the Scrap class. This macro
should come first in the subclass structure declaration.
</DD></DL>
<P>

<P>
<!--[[/CONTENT]]-->

<HR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">
		<TD>
		<CENTER>
<!--[[NAVIGATE_ICONIC]]-->
<!--[[/NAVIGATE_ICONIC]]-->
		</CENTER>
		</TD>
		    
		<TD>
		<BR>
		<FONT SIZE=-1>
	        <A HREF="#Top">Top of This Page</A> <BR>
	        <A HREF="index.html">Table of Contents</A> <BR>
		<A HREF="../index.html">Switch to Another Document</A><BR>
		<BR>
		</FONT>
		</TD>

		<TD>
		<BR>
		<FONT SIZE=-1>
		Need help?
		<A HREF="../contact-visix.html">
		Contact Visix</A>.
		<BR> <BR>
	        <A HREF="../copyright.html">Copyright &#169; 1996-97</A>,
		<A HREF="http://www.visix.com/">Visix Software Inc.</A><BR>
		<BR>
		</FONT>
		</TD>

	</TR>

</TABLE>
		
</BODY>
</HTML>



