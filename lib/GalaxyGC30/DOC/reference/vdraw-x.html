<HTML>
  <HEAD>
<!--[[HEADING]]-->
<title>vdraw prefix</title><!--[[/HEADING]]-->
  </HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<A NAME="Top"><IMG SRC="../graphics/trans.gif" WIDTH=2 HEIGHT=2></A><BR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">

		<TD>
		<CENTER>
		<A HREF="../index.html">
		<IMG SRC="../graphics/logo.gif" BORDER=0></A>
		</CENTER>
		</TD>

	        <TD VALIGN=TOP>
	        <BR><H1>
<!--[[TITLE]]-->
vdraw prefix<!--[[/TITLE]]-->
	        </H1><BR>
		</TD>
      
	</TR>

</TABLE>

<HR>

<BR>

<!--[[PREAMBLE]]-->
<TABLE>
<TR>
<TD><A HREF="vdraw-x.html#section_DataType">Types</A> [8]</TD>
<TD><A HREF="vdraw-x.html#section_Function">Functions</A> [275]</TD>
<TD></TD>
<TD><A HREF="vdraw-x.html#section_Constant">Constants</A> [20]</TD>
<TD></TD>
</TR>
</TABLE>
<!--[[/PREAMBLE]]-->

<!--[[CONTENT]]-->

<P>
<A NAME="section_DataType"><HR>
<CENTER><H2>Types</H2></CENTER></A><P>
<A NAME="vdrawDriver"><HR><H4>vdrawDriver</H4></A>
<PRE>
        typedef ... <B>vdrawDriver</B>;
</PRE>

<DL><DD>
Contains the addresses of the functions used by Galaxy to
implement a graphics device driver. The contents of this
structure are still under development and will be
documented in a later release.
</DD></DL>
<P>
<A NAME="vdrawDynamicFuncs"><HR><H4>vdrawDynamicFuncs</H4></A>
<PRE>
        typedef ... <B>vdrawDynamicFuncs</B>;
</PRE>

<DL><DD>
Contains the addresses of the <B><I>dynamic drawing
functions</I></B>. The Drawing class uses these function
pointers to direct drawing operations for a given gstate.
By changing the dynamic functions, the Drawing class can
be customized for a particular environment or application.
These functions also provide a means to redirect output to
a device which accepts PostScript source code. The Drawing
Manager itself changes the current set of dynamic functions
based on the current transformation matrix and the contents
of the current path. This allows simple transformations to
be hard-coded without any branch overhead. The contents of
this structure will probably be expanded in a later Galaxy
release.
  <P>
To change the dynamic functions, you should create a
structure of this type and fill it in with your custom
drawing functions. <SAMP>flags</SAMP> should be set to
zero. The structure field member name is the name of the
Drawing class entry point being replaced without the
<SAMP>vdraw</SAMP> prefix. For example, the field
<CODE>ImageMask</CODE> replaces the entry point
<CODE><A HREF="vdraw-x.html#vdrawImageMask"><CODE>vdrawImageMask</CODE></A></CODE>. If you do not want to write a
given function yourself use
<CODE><A HREF="vdraw-x.html#vdrawStdDynamicFuncs"><CODE>vdrawStdDynamicFuncs</CODE></A></CODE> to obtain the standard
function. Use <CODE><A HREF="vdraw-x.html#vdrawSetDevice"><CODE>vdrawSetDevice</CODE></A></CODE> to set the
dynamic functions of the current gstate.
</DD></DL>
<P>
<A NAME="vdrawGState"><HR><H4>vdrawGState</H4></A>
<PRE>
        typedef ... <B>vdrawGState</B>;
</PRE>

<DL><DD>
Contains a set of attributesused by drawing operations. Use
this type to declare references to your own private
gstates. The attributes specified in the current gstate are
used as implicit arguments for most Drawing class 
function calls. Table lists the gstate attributes and
indicates which rendering operations use them. The effects
of individual attributes are documented under the function
entry points that alter them. For example, refer to
<CODE><A HREF="vdraw-x.html#vdrawSetLineWidth"><CODE>vdrawSetLineWidth</CODE></A></CODE> for the
<CODE>LineWidth</CODE> attribute. Note that the current
gstate itself has no exported representation.
  <P>
Means are provided to create and manipulate gstates
independently of the current gstate. Use
<CODE><A HREF="vdraw-x.html#vdrawCreateGState"><CODE>vdrawCreateGState</CODE></A></CODE> to create a private copy of
the current gstate and <CODE><A HREF="vdraw-x.html#vdrawGSave"><CODE>vdrawGSave</CODE></A></CODE> to push a
copy of the current gstate on the gstate stack.
  <P>
<BLOCKQUOTE>
Table: Gstate attributes used by drawing operations
<TABLE BORDER>
<TR>
<TD> Attribute</TD> <TD> Fill</TD> <TD> Stroke</TD> <TD>
Show</TD> <TD> Image</TD> 
</TR>
<TR>
<TD><SAMP>Clip</SAMP></TD> <TD>all forms</TD> <TD>all
forms</TD> <TD>all forms</TD> <TD>all forms</TD> 
</TR>
<TR>
<TD><SAMP>Color</SAMP></TD> <TD>all forms</TD> <TD>all
forms</TD> <TD>all forms</TD> <TD>some forms</TD> 
</TR>
<TR>
<TD><SAMP>Complexity</SAMP></TD> <TD>all forms</TD> <TD>no
forms</TD> <TD>no forms</TD> <TD>no forms</TD> 
</TR>
<TR>
<TD><SAMP>Dash</SAMP></TD> <TD>no forms</TD> <TD>all
forms</TD> <TD>no forms</TD> <TD>no forms</TD> 
</TR>
<TR>
<TD><SAMP>Device</SAMP></TD> <TD>all forms</TD> <TD>all
forms</TD> <TD>all forms</TD> <TD>all forms</TD> 
</TR>
<TR>
<TD><SAMP>Flatness</SAMP></TD> <TD>some forms</TD> <TD>some
forms</TD> <TD>no forms</TD> <TD>no forms</TD> 
</TR>
<TR>
<TD><SAMP>Font</SAMP></TD> <TD>no forms</TD> <TD>no
forms</TD> <TD>all forms</TD> <TD>no forms</TD> 
</TR>
<TR>
<TD><SAMP>Function</SAMP></TD> <TD>all forms</TD> <TD>all
forms</TD> <TD>all forms</TD> <TD>all forms</TD> 
</TR>
<TR>
<TD><SAMP>LineCap</SAMP></TD> <TD>no forms</TD> <TD>all
forms</TD> <TD>no forms</TD> <TD>no forms</TD> 
</TR>
<TR>
<TD><SAMP>LineJoin</SAMP></TD> <TD>no forms</TD> <TD>all
forms</TD> <TD>no forms</TD> <TD>no forms</TD> 
</TR>
<TR>
<TD><SAMP>LineWidth</SAMP></TD> <TD>no forms</TD> <TD>all
forms</TD> <TD>no forms</TD> <TD>no forms</TD> 
</TR>
<TR>
<TD><SAMP>Matrix</SAMP></TD> <TD>no forms</TD> <TD>all
forms</TD> <TD>no forms</TD> <TD>no forms</TD> 
</TR>
<TR>
<TD><SAMP>MiterLimit</SAMP></TD> <TD>no forms</TD> <TD>all
forms</TD> <TD>no forms</TD> <TD>no forms</TD> 
</TR>
<TR>
<TD><SAMP>Path</SAMP></TD> <TD>some forms</TD> <TD>some
forms</TD> <TD>no forms</TD> <TD>no forms</TD> 
</TR>
<TR>
<TD><SAMP>Position</SAMP></TD> <TD>no forms</TD> <TD>no
forms</TD> <TD>all forms</TD> <TD>some forms</TD> 
</TR>
<TR>
<TD><SAMP>Rule</SAMP>\dag</TD> <TD>all forms</TD> <TD>no
forms</TD> <TD>no forms</TD> <TD>no forms</TD> 
</TR>
<TR>
<TD><SAMP>StrokeAdjust</SAMP></TD> <TD>no forms</TD>
<TD>all forms</TD> <TD>no forms</TD> <TD>no forms</TD> 
</TR>
</TABLE>

  <P>
\dag <SAMP>Rule</SAMP> is an explicit argument of fill
operations retained by the gstate for device drivers. 
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawKeyStrokeShowProc"><HR><H4>vdrawKeyStrokeShowProc</H4></A>
<PRE>
        typedef ... <B>vdrawKeyStrokeShowProc</B>;
</PRE>

<DL><DD>
Denotes a function that draws a keystroke into the current
graphics state.
</DD></DL>
<P>
<A NAME="vdrawNoCurrentPointException"><HR><H4>vdrawNoCurrentPointException</H4></A>
<PRE>
        typedef ... <B>vdrawNoCurrentPointException</B>;
</PRE>

<DL><DD>
Generated by the following functions if there is no current
point: 

<P>
<UL>
<LI><CODE><A HREF="vdraw-x.html#vdrawCurveTo"><CODE>vdrawCurveTo</CODE></A></CODE>
<LI>CODE><A HREF="vdraw-x.html#vdrawLineTo"><CODE>vdrawLineTo</CODE></A></CODE>
<LI><CODE><A HREF="vdraw-x.html#vdrawShow"><CODE>vdrawShow</CODE></A></CODE>
<LI><CODE><A HREF="vdraw-x.html#vdrawImageIdent"><CODE>vdrawImageIdent</CODE></A></CODE>
<LI><CODE><A HREF="vdraw-x.html#vdrawCharPath"><CODE>vdrawCharPath</CODE></A></CODE>
<LI><CODE><A HREF="vdraw-x.html#vdrawMaskPathIdent"><CODE>vdrawMaskPathIdent</CODE></A></CODE>
<LI><CODE><A HREF="vdraw-x.html#vdrawGetPoint"><CODE>vdrawGetPoint</CODE></A></CODE>, and variations. 
</ul>

<P>
You can specify a current point with <CODE><A HREF="vdraw-x.html#vdrawMoveTo"><CODE>vdrawMoveTo</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdrawPathIterator"><HR><H4>vdrawPathIterator</H4></A>
<PRE>
        typedef ... <B>vdrawPathIterator</B>;
</PRE>

<DL><DD>
Denotes an abstract index variable type used to iterate
through the elements of a path. This type is used by the
functions <CODE>vdrawPathIterator</CODE>.
  <P>
The remainder of this section is devoted to type
definitions. These are provided for Galaxy users who want
to customize the behavior of the Drawing class or write
their own device drivers.
</DD></DL>
<P>
<A NAME="vdrawStaticFuncs"><HR><H4>vdrawStaticFuncs</H4></A>
<PRE>
        typedef ... <B>vdrawStaticFuncs</B>;
</PRE>

<DL><DD>
Contains the addresses of the <B><I>static drawing
functions</I></B>. The Drawing class uses these function
pointers to direct drawing operations for a given gstate.
By changing the static functions the Drawing class can be
customized for a particular environment or application.
These functions also provide a means to redirect output to
a device which accepts PostScript source code. The contents
of this structure are likely to be expanded in a later
Galaxy release.
  <P>
To change the static functions you should create a
structure of this type and fill it in with your custom
drawing functions. <SAMP>flags</SAMP> should be set to
zero. The structure field member name is the name of the
Drawing class entry point being replaced without the
<SAMP>vdraw</SAMP> prefix. For example, the field
<CODE>GSave</CODE> replaces the entry point
<CODE><A HREF="vdraw-x.html#vdrawGSave"><CODE>vdrawGSave</CODE></A></CODE>. If you do not want to write a
given function yourself use
<CODE><A HREF="vdraw-x.html#vdrawStdStaticFuncs"><CODE>vdrawStdStaticFuncs</CODE></A></CODE> to obtain the standard
function. Use <CODE><A HREF="vdraw-x.html#vdrawSetDevice"><CODE>vdrawSetDevice</CODE></A></CODE> to set the static
functions of the current gstate.
</DD></DL>
<P>
<A NAME="vdrawUPath"><HR><H4>vdrawUPath</H4></A>
<PRE>
        typedef ... <B>vdrawUPath</B>;
</PRE>

<DL><DD>
Contains a path description which can be drawn with a
single function call. Rendering the same path repeatedly is
more efficient if it is constructed only once and then
drawn with a user path function. Some implementations will
also cache a bit mask for frequently used user paths,
allowing the path to be drawn with mask operations.
</DD></DL>
<P>
<A NAME="section_Function"><HR>
<CENTER><H2>Functions</H2></CENTER></A><P>
<A NAME="vdrawAShow"><HR><H4>vdrawAShow</H4></A>
<PRE>
        void <B>vdrawAShow</B>(
                int ax,
                int ay,
                const vchar * s);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> or the scribe
<SAMP>scribe</SAMP> in the current font and current color,
with the origin of the first character at the current
point. <SAMP>ax</SAMP> and <SAMP>ay</SAMP> indicate the
amount of user space width to add to the width of each
character in the string. (See figure). 
<P>
Note that character
width has a y coordinate as well as an x coordinate. The
current point is moved by the width of the string, plus any
extra width. If <SAMP>count</SAMP> is provided, exactly
<SAMP>count</SAMP> characters are drawn from the string,
regardless of null characters. Scribed entry points allow
you to draw strings in other character sets or
representations. <CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
<P>
Refer to the ``String Manager'' chapter
of the <I>Galaxy Application Environment Programmer's
Guide</I> for more information about scribes.
</DD></DL>
<P>
<A NAME="vdrawAWidthShow"><HR><H4>vdrawAWidthShow</H4></A>
<PRE>
        void <B>vdrawAWidthShow</B>(
                int cx,
                int cy,
                int c,
                int ax,
                int ay,
                const vchar * s);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> or the scribe
<SAMP>scribe</SAMP> in the current font and current color,
with the origin of the first character at the current
point. <SAMP>ax</SAMP> and <SAMP>ay</SAMP> indicate the
amount of user space width to add to the width of each
character in the string. (See figure). <SAMP>cx</SAMP> and
<SAMP>cy</SAMP> indicate the amount of width to add to the
width of the character <SAMP>c</SAMP> where it appears
in the string. 
<P>
Note that character width has a y coordinate
as well as an x coordinate. The current point is moved by
the width of the string plus any extra width. If
<SAMP>count</SAMP> is provided, exactly <SAMP>count</SAMP>
characters are drawn from the string, regardless of null
characters. Scribed entry points allow you to draw strings
in other character sets or representations.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is
generated if there is no current point.
<P>
Refer to the ``String Manager'' chapter of the <I>Galaxy Application
Environment Programmer's Guide</I> for more information
about scribes.
</DD></DL>
<P>
<A NAME="vdrawArc"><HR><H4>vdrawArc</H4></A>
<PRE>
        void <B>vdrawArc</B>(
                int x,
                int y,
                int r,
                int angle1,
                int angle2);
</PRE>

<DL><DD>
Appends an arc to the current path, with center at
<SAMP>x,y</SAMP> and radius of <SAMP>r</SAMP>. (See figure).
Only the counter-clockwise segment of the arc, from
<SAMP>angle1</SAMP> to <SAMP>angle2</SAMP> degrees, is
actually constructed. <SAMP>vdrawArc(x,y,r,0,360)</SAMP>
draws an entire circle. If a current point is defined, a
line segment joins that point to the first endpoint on the
arc. The current point is then set at the second endpoint.
The arc is represented internally by one or more Bezier
curve segments, though a window system arc function may be
used under favorable circumstances.
<CODE><A HREF="vex-x.html#vexArgRangeException"><CODE>vexArgRangeException</CODE></A></CODE> is generated if
<SAMP>r</SAMP> is less than zero.
<P>
<BLOCKQUOTE>
Figure: vdrawArc
  <P>
<IMG SRC="Drawing.Drawing_arcs.gif">
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawArcN"><HR><H4>vdrawArcN</H4></A>
<PRE>
        void <B>vdrawArcN</B>(
                int x,
                int y,
                int r,
                int angle1,
                int angle2);
</PRE>

<DL><DD>
Appends an arc to the current path, with center at
<SAMP>x,y</SAMP> and radius of <SAMP>r</SAMP>. Only the
clockwise segment of the arc, from <SAMP>angle1</SAMP> to
<SAMP>angle2</SAMP> degrees, is actually constructed.
<SAMP>vdrawArcN(x,y,r,0,360)</SAMP> draws an entire circle.
If a current point is defined, a line segment joins that
point to the first endpoint on the arc. The current point
is then set at the second endpoint. The arc is represented
internally by one or more Bezier curve segments, though a
window system arc function may be used under favorable
circumstances. <CODE><A HREF="vex-x.html#vexArgRangeException"><CODE>vexArgRangeException</CODE></A></CODE> is
generated if <SAMP>r</SAMP> is less than zero.
</DD></DL>
<P>
<A NAME="vdrawArcT"><HR><H4>vdrawArcT</H4></A>
<PRE>
        void <B>vdrawArcT</B>(
                int x1,
                int y1,
                int x2,
                int y2,
                int r);
</PRE>

<DL><DD>
Appends an arc segment to the current path. (See figure).
The arc has radius <SAMP>r</SAMP> and is positioned tangent
to two line segments. These segments are drawn from the
current point <SAMP>x0,y0</SAMP> to point
<SAMP>x1,y1</SAMP>, and from <SAMP>x1,y1</SAMP> to
<SAMP>x2,y2</SAMP>. If necessary, a line segment is
appended from the current point <SAMP>x0,y0</SAMP> to the
first tangent point (<SAMP>rxt1,ryt1</SAMP> in the figure).
The current point is set at <SAMP>rxt2,ryt2</SAMP>. The arc
is represented internally by a Bezier curve segment.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
<CODE><A HREF="vex-x.html#vexArgRangeException"><CODE>vexArgRangeException</CODE></A></CODE> is generated if
<SAMP>r</SAMP> is less than zero.
<P>
<BLOCKQUOTE>
Figure: vdrawArcTo
  <P>
<IMG SRC="Drawing.Operation_of_ArcTo_Fun.gif">
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawArrowHiliteFillX"><HR><H4>vdrawArrowHiliteFillX</H4></A>
<PRE>
        void <B>vdrawArrowHiliteFillX</B>(
                int x,
                int y,
                int length,
                int half,
                vcolor * interior,
                vcolor * straight,
                vcolor * bent);
</PRE>

<DL><DD>
Draws an arrow with a three-dimensional appearance into the
current graphics state, pointing in a horizontal direction.
<SAMP>x</SAMP>, <SAMP>y</SAMP> is the location at which to
draw the arrow and <SAMP>interior</SAMP>,
<SAMP>straight</SAMP>, and <SAMP>bent</SAMP> are the shadow
colors to use. <SAMP>length</SAMP> is the length of the
arrow to draw and <SAMP>half</SAMP> is half the width of
the arrow.
</DD></DL>
<P>
<A NAME="vdrawArrowHiliteFillY"><HR><H4>vdrawArrowHiliteFillY</H4></A>
<PRE>
        void <B>vdrawArrowHiliteFillY</B>(
                int x,
                int y,
                int length,
                int half,
                vcolor * interior,
                vcolor * straight,
                vcolor * bent);
</PRE>

<DL><DD>
Draws an arrow with a three-dimensional appearance into the
current graphics state, pointing in a vertical direction.
<SAMP>x</SAMP>, <SAMP>y</SAMP> is the location at which to
draw the arrow and <SAMP>interior</SAMP>,
<SAMP>straight</SAMP>, and <SAMP>bent</SAMP> are the shadow
colors to use. <SAMP>length</SAMP> is the length of the
arrow to draw and <SAMP>half</SAMP> is half the width of
the arrow.
</DD></DL>
<P>
<A NAME="vdrawBoxHiliteFill"><HR><H4>vdrawBoxHiliteFill</H4></A>
<PRE>
        void <B>vdrawBoxHiliteFill</B>(
                const vrect * rect,
                vcolor * interior,
                vcolor * top,
                vcolor * bottom);
</PRE>

<DL><DD>
Draws a highlighted box inside the rectangle
<SAMP>rect</SAMP> into the current graphics state, with
interior color <SAMP>interior</SAMP>, and shadow colors
<SAMP>top</SAMP> and <SAMP>bottom</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawCharPath"><HR><H4>vdrawCharPath</H4></A>
<PRE>
        void <B>vdrawCharPath</B>(
                const vchar * s);
</PRE>

<DL><DD>
Appends the outline of the character string <SAMP>s</SAMP>
to the current path. Characters are positioned at the
current point as if <CODE><A HREF="vdraw-x.html#vdrawShow"><CODE>vdrawShow</CODE></A></CODE> or one of its
variants was called. The characters are rendered
efficiently if outline fonts are available or if the path
is subsequently used in a clip or fill operation. Otherwise
the operation is relatively expensive.
</DD></DL>
<P>
<A NAME="vdrawClip"><HR><H4>vdrawClip</H4></A>
<PRE>
        void <B>vdrawClip</B>();
</PRE>

<DL><DD>
Computes the intersection of the current path and the
current clipping path and stores it as the new clipping
path. It does not reset the current path. This function is
expensive to implement on window systems that lack a
PostScript interpreter, and clients are advised to avoid it
whenever possible. (Use <CODE><A HREF="vdraw-x.html#vdrawRectsClip"><CODE>vdrawRectsClip</CODE></A></CODE> if the
clipping path is a rectangle.) It tests for ``inside''
using the nonzero winding rule.
</DD></DL>
<P>
<A NAME="vdrawClipBounds"><HR><H4>vdrawClipBounds</H4></A>
<PRE>
        void <B>vdrawClipBounds</B>(
                const vrect ** rects,
                int * count);
</PRE>

<DL><DD>
Computes a set of bounding boxes that enclose the current
clipping path. This function then returns the box
coordinates in <SAMP>rects</SAMP> and the number of boxes
in <SAMP>count</SAMP>. Depending on the window system, this
function either returns a bounding box for each individual
subpath or returns a single bounding box for the entire
path. The bounding box of a subpath is the smallest
rectangle that encloses all points along the subpath. (See
figure). This function does not take line width into
account. If the subpath contains curves, the bounding box
is computed to enclose all control points of the curves.
<P>
This function computes the bounding box of the path in
device space and returns the user space bounding box of the
device space bounding box. The box may be larger than
expected if the user space coordinate axes are not aligned
with the device space coordinate axes. The pointer returned
by this call can be used until the next call to the Drawing
class. Use <CODE><A HREF="vrect-x.html#vrectCloneSet"><CODE>vrectCloneSet</CODE></A></CODE> (a Plane Geometry
class function) to copy the rectangles, if persistence is
desired.
</DD></DL>
<P>
<A NAME="vdrawClipPath"><HR><H4>vdrawClipPath</H4></A>
<PRE>
        void <B>vdrawClipPath</B>();
</PRE>

<DL><DD>
Replaces the current path with the current clipping path.
</DD></DL>
<P>
<A NAME="vdrawClosePath"><HR><H4>vdrawClosePath</H4></A>
<PRE>
        void <B>vdrawClosePath</B>();
</PRE>

<DL><DD>
Closes the current subpath by adding a line segment between
the current point and the start of the subpath. (See
figure). It has no effect if there is no current path.
<P>
<BLOCKQUOTE>
Figure: vdrawClosePath
  <P>
<IMG SRC="Drawing.Operation_of_vdrawClos.gif">
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawConcat"><HR><H4>vdrawConcat</H4></A>
<PRE>
        void <B>vdrawConcat</B>(
                const vmatrix * mtx);
</PRE>

<DL><DD>
Concatenates <SAMP>mtx</SAMP> with the current
transformation matrix and stores the result as the new
current transformation matrix. This applies the
transformation represented by <SAMP>mtx</SAMP> to the
current transformation. For example, if <SAMP>mtx</SAMP>
represents a rotation of 30 degrees, concatenating it with
the current matrix produces a new current transformation
rotated by 30 degrees with respect to the former
transformation. <CODE>vdrawConcat</CODE> is cumulative;
applying the rotation described above twice in
succession results in a total rotation of 60 degrees.
</DD></DL>
<P>
<A NAME="vdrawCopyGState"><HR><H4>vdrawCopyGState</H4></A>
<PRE>
        void <B>vdrawCopyGState</B>(
                vdrawGState * gstate1,
                vdrawGState * gstate2);
</PRE>

<DL><DD>
Copies the contents of <SAMP>gstate1</SAMP> into
<SAMP>gstate2</SAMP>. <SAMP>gstate2</SAMP> must already be
initialized; you can create a new gstate with
<CODE><A HREF="vdraw-x.html#vdrawCreateGState"><CODE>vdrawCreateGState</CODE></A></CODE>. All attributes of the
gstate are copied, including its device and clip path. 
<P>
Note that the view clip is not copied, since it is not stored in
a gstate.
</DD></DL>
<P>
<A NAME="vdrawCreateCachedUPath"><HR><H4>vdrawCreateCachedUPath</H4></A>
<PRE>
        vdrawUPath * <B>vdrawCreateCachedUPath</B>();
</PRE>

<DL><DD>
Creates a ``user path'' from the current path and returns a
pointer to the user path. The user path can be subsequently
rendered with a single function call. The pixels touched by
the path may be remembered so that the path itself does not
have to be rendered each time it is drawn. Cache creation is
subject to available resources.
</DD></DL>
<P>
<A NAME="vdrawCreateGState"><HR><H4>vdrawCreateGState</H4></A>
<PRE>
        vdrawGState * <B>vdrawCreateGState</B>();
</PRE>

<DL><DD>
Creates a new gstate and returns a pointer to it. The
contents of the new gstate are identical to the current
gstate. All attributes of the current gstate are copied,
including its device and clip path.
<P>
Note that the current view clip is not copied, because
it is not stored in a gstate.
</DD></DL>
<P>
<A NAME="vdrawCreateImageDrawcontext"><HR><H4>vdrawCreateImageDrawcontext</H4></A>
<PRE>
        vdrawcontext * <B>vdrawCreateImageDrawcontext</B>(
                vimage * image);
</PRE>

<DL><DD>
Creates a drawing context with the image as the drawing device.
Establishes the image <SAMP>image</SAMP> as the target of drawing operations for the drawing context. Drawing operations then leave marks on this image. This function sets the current transformation matrix to reflect the resolution and orientation of the screen and sets the current clipping path to the image bounds. 
</DD></DL>
<P>
<A NAME="vdrawCreateMaskDrawcontext"><HR><H4>vdrawCreateMaskDrawcontext</H4></A>
<PRE>
        vdrawcontext * <B>vdrawCreateMaskDrawcontext</B>(
                vimage * mask);
</PRE>

<DL><DD>
Creates a drawing context with a mask as the drawing device.
Establishes the mask <SAMP>image</SAMP> as the target of drawing. Drawing 
operations then leave marks on the mask. This function sets the current 
transformation matrix to reflect the resolution and orientation of the 
screen, and sets the current clipping path to the mask bounds. Mask 
devices ignore the color attribute of the drawing context and use solely 
the function attribute to determine pixel values. Use 
<CODE>vdrawFUNC_SET</CODE> and <CODE>vdrawFUNC_CLEAR</CODE> to specify 1 
and 0 pixels, respectively. Mask images must be one bit deep. Masks 
suitable for off-screen rendering can be obtained from the Image Manager 
with the function <CODE><A HREF="vimage-x.html#vimageCreateSpecific"><CODE>vimageCreateSpecific</CODE></A></CODE>.
    <P>
<BLOCKQUOTE>

<PRE>

<A HREF="vimage-x.html#vimage"><CODE>vimage</CODE></A>       *image;
<A HREF="vdrawcontext-x.html#vdrawcontext"><CODE>vdrawcontext</CODE></A> *dc;
<A HREF="vrect-x.html#vrect"><CODE>vrect</CODE></A>         rect;

image = <A HREF="vimage-x.html#vimageCreateSpecific"><CODE>vimageCreateSpecific</CODE></A>(100, 100, 2);
<A HREF="vimage-x.html#vimageSetSize"><CODE>vimageSetSize</CODE></A>(image, 100, 100);
<A HREF="vimage-x.html#vimageSetNumColors"><CODE>vimageSetNumColors</CODE></A>(image, 2);

dc = vdrawCreateMaskDrawcontext(image);
<A HREF="vdrawpen-x.html#vdrawpen"><CODE>vdrawpen</CODE></A> *pen = <A HREF="vdrawcontext-x.html#vdrawcontextGetPen"><CODE>vdrawcontextGetPen</CODE></A>(dc);
vdrawpenSetFunction(pen, vdrawFUNC_CLEAR);

<A HREF="vrect-x.html#vrectSet"><CODE>vrectSet</CODE></A>(&rect, 0,0, 100, 100);
<A HREF="vdrawcontext-x.html#vdrawcontextFillRectangles"><CODE>vdrawcontextFillRectangles</CODE></A>(dc, &rect, 1);

vdrawpenSetFunction(pen, vdrawFUNC_SET);
vdrawcontextLineTo(100, 100);

vdrawdelete dc;
<A HREF="vimage-x.html#vimageDestroy"><CODE>vimageDestroy</CODE></A>(image);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawCreateUPath"><HR><H4>vdrawCreateUPath</H4></A>
<PRE>
        vdrawUPath * <B>vdrawCreateUPath</B>();
</PRE>

<DL><DD>
Creates a ``user path'' from the current path and returns a
pointer to the user path. The user path can be subsequently
rendered with a single function call.
</DD></DL>
<P>
<A NAME="vdrawCurveTo"><HR><H4>vdrawCurveTo</H4></A>
<PRE>
        void <B>vdrawCurveTo</B>(
                int x1,
                int y1,
                int x2,
                int y2,
                int x3,
                int y3);
</PRE>

<DL><DD>
Appends a Bezier curve segment to the current path. (See
figure). The curve begins at the current point 
(<SAMP>x0,y0</SAMP> in the figure) and ends at
<SAMP>x3,y3</SAMP>.~<SAMP>x1,y1</SAMP> and
<SAMP>x2,y2</SAMP> are the Bezier cubic control points of
the curve. 
<P>
Sets the current point to <SAMP>x3,y3</SAMP>.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
<P>
<BLOCKQUOTE>
Figure: vdrawCurveTo
<P>
<IMG SRC="Drawing.Operation_of_vdrawCur.gif">
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawDTransform"><HR><H4>vdrawDTransform</H4></A>
<PRE>
        void <B>vdrawDTransform</B>(
                int dx,
                int dy,
                int * rdx,
                int * rdy);
</PRE>

<DL><DD>
Computes the transformation of <SAMP>dx</SAMP> and
<SAMP>dy</SAMP> without the translation component and
stores the result in <SAMP>rdx</SAMP> and <SAMP>rdy</SAMP>
(See figure). This function computes a device space vector for
a given user space vector. The delta transformation is
useful for determining an object's size after
transformation. This function rounds the result of
<CODE><A HREF="vdraw-x.html#vdrawFDTransform"><CODE>vdrawFDTransform</CODE></A></CODE>.
<P>
<BLOCKQUOTE>
Figure: <A HREF="vdraw-x.html#vdrawTransform"><CODE>vdrawTransform</CODE></A> and vdrawDTransform
<P>
<IMG SRC="Drawing.Operation_of_vdrawTran.gif">
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawDeactivateDevice"><HR><H4>vdrawDeactivateDevice</H4></A>
<PRE>
        void <B>vdrawDeactivateDevice</B>();
</PRE>

<DL><DD>
Deactivates the current drawing device.
Set the drawing device to the null device.
</DD></DL>
<P>
<A NAME="vdrawDefaultMatrix"><HR><H4>vdrawDefaultMatrix</H4></A>
<PRE>
        const vmatrix * <B>vdrawDefaultMatrix</B>();
</PRE>

<DL><DD>
Returns the default transformation matrix for the current
device. The matrix returned by this function is not
rounded. Therefore,
<CODE><A HREF="vdraw-x.html#vdrawSetMatrix"><CODE>vdrawSetMatrix</CODE></A></CODE> and <CODE>vdrawDefaultMatrix</CODE>
may not produce the same effect as
<CODE><A HREF="vdraw-x.html#vdrawInitMatrix"><CODE>vdrawInitMatrix</CODE></A></CODE><SAMP>()</SAMP>.
<P>
This pointer remains valid until the next call to the Drawing
class; copy the contents of the pointer if
you need the matrix for any length of time.
</DD></DL>
<P>
<A NAME="vdrawDestroyGState"><HR><H4>vdrawDestroyGState</H4></A>
<PRE>
        void <B>vdrawDestroyGState</B>(
                vdrawGState * gstate);
</PRE>

<DL><DD>
Destroys the gstate <SAMP>gstate</SAMP>, which must have
been created by <CODE><A HREF="vdraw-x.html#vdrawCreateGState"><CODE>vdrawCreateGState</CODE></A></CODE>. Use this
function to reclaim the storage occupied by a gstate. The
gstate should not be referenced by any other object when it
is destroyed.
</DD></DL>
<P>
<A NAME="vdrawDestroyPathIterator"><HR><H4>vdrawDestroyPathIterator</H4></A>
<PRE>
        void <B>vdrawDestroyPathIterator</B>(
                vdrawPathIterator * iterator);
</PRE>

<DL><DD>
Terminates the path iteration represented by the path
iterator <SAMP>iterator</SAMP>, even if the iteration is
not yet exhausted. This function is necessary to reclaim
internal iteration objects allocated by the Drawing
class.
</DD></DL>
<P>
<A NAME="vdrawDestroyUPath"><HR><H4>vdrawDestroyUPath</H4></A>
<PRE>
        void <B>vdrawDestroyUPath</B>(
                vdrawUPath * upath);
</PRE>

<DL><DD>
Destroys the user path represented by <SAMP>upath</SAMP>,
which must have been created by <CODE><A HREF="vdraw-x.html#vdrawCreateUPath"><CODE>vdrawCreateUPath</CODE></A></CODE> or
<CODE><A HREF="vdraw-x.html#vdrawCreateCachedUPath"><CODE>vdrawCreateCachedUPath</CODE></A></CODE>. Use this function to
reclaim the storage occupied by a user path.
<P>
The user path should not be referenced by any other object when it is
destroyed.
</DD></DL>
<P>
<A NAME="vdrawDiamondHiliteFill"><HR><H4>vdrawDiamondHiliteFill</H4></A>
<PRE>
        void <B>vdrawDiamondHiliteFill</B>(
                const vrect * rect,
                vcolor * interior,
                vcolor * top,
                vcolor * bottom);
</PRE>

<DL><DD>
Draws a highlighted diamond inside the rectangle
<SAMP>rect</SAMP> into the current graphics state, with
interior color <SAMP>interior</SAMP>, and shadow colors
<SAMP>top</SAMP> and <SAMP>bottom</SAMP>. This function can
be used to draw Motif-style radio buttons.
</DD></DL>
<P>
<A NAME="vdrawEOClip"><HR><H4>vdrawEOClip</H4></A>
<PRE>
        void <B>vdrawEOClip</B>();
</PRE>

<DL><DD>
Computes the intersection of the current path and the
current clipping path and stores it as the new clipping
path. Does not reset the current path. This function is
expensive to implement on window systems that lack a
PostScript interpreter, and clients are advised to avoid it
whenever possible: Use <CODE><A HREF="vdraw-x.html#vdrawRectsClip"><CODE>vdrawRectsClip</CODE></A></CODE> if the
clipping path is a rectangle. This function uses the
even-odd rule. (See figure).
</DD></DL>
<P>
<A NAME="vdrawEOFill"><HR><H4>vdrawEOFill</H4></A>
<PRE>
        void <B>vdrawEOFill</B>();
</PRE>

<DL><DD>
Fills the current path with the current color and begins a
new current path. It uses the even-odd winding rule. (See
figure).
</DD></DL>
<P>
<A NAME="vdrawEOViewClip"><HR><H4>vdrawEOViewClip</H4></A>
<PRE>
        void <B>vdrawEOViewClip</B>();
</PRE>

<DL><DD>
Sets the view clip to the region inside the current path
and resets the current path. These functions are expensive
to implement on window systems that lack a PostScript
interpreter, and clients are advised to avoid them whenever
possible: Use <CODE><A HREF="vdraw-x.html#vdrawRectsViewClip"><CODE>vdrawRectsViewClip</CODE></A></CODE> instead. It
uses the even-odd winding rule. (See figure). 
<P>
The view clip is used by the Window class for update region
maintenance; the view clip should not be changed otherwise.
The view clip is ignored by some devices.
</DD></DL>
<P>
<A NAME="vdrawFAShow"><HR><H4>vdrawFAShow</H4></A>
<PRE>
        void <B>vdrawFAShow</B>(
                double ax,
                double ay,
                const vchar * s);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font and
current color, with the origin of the first character at
the current point. <SAMP>ax</SAMP> and <SAMP>ay</SAMP>
indicate the amount of user space width to add to the width
of each character in the string. (See figure).
<P>
Note that character width has a y coordinate as well as an x
coordinate. The current point is moved by the width of the
string plus any extra width.
<P>
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFAWidthShow"><HR><H4>vdrawFAWidthShow</H4></A>
<PRE>
        void <B>vdrawFAWidthShow</B>(
                double cx,
                double cy,
                int c,
                double ax,
                double ay,
                const vchar * s);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font and
current color, with the origin of the first character at
the current point. <SAMP>ax</SAMP> and <SAMP>ay</SAMP>
indicate the amount of user space width to add to the width
of each character in the string. (See figure).
<SAMP>cx</SAMP> and <SAMP>cy</SAMP> indicate the amount of
width to add to the width of the character <SAMP>c</SAMP>
wherever it appears in the string. 
<P>
Note that character width has a y coordinate as well as an x coordinate. 
The current point is moved by the width of the string plus any
extra width.
<P>
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is
generated if there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFArc"><HR><H4>vdrawFArc</H4></A>
<PRE>
        void <B>vdrawFArc</B>(
                double x,
                double y,
                double r,
                double angle1,
                double angle2);
</PRE>

<DL><DD>
Appends an arc to the current path, with center at
<SAMP>x,y</SAMP> and radius of <SAMP>r</SAMP>. (See figure).
Only the counter-clockwise segment of the arc, from
<SAMP>angle1</SAMP> to <SAMP>angle2</SAMP> degrees, is
actually constructed. <SAMP>vdrawFArc(x,y,r,0,360)</SAMP>
draws an entire circle. 
<P>
If a current point is defined, a
line segment joins that point to the first endpoint on the
arc. The current point is then set at the second endpoint.
The arc is represented internally by one or more Bezier
curve segments, though a window system arc function may be
used under favorable circumstances.
<CODE><A HREF="vex-x.html#vexArgRangeException"><CODE>vexArgRangeException</CODE></A></CODE> is generated if
<SAMP>r</SAMP> is less than zero.
</DD></DL>
<P>
<A NAME="vdrawFArcN"><HR><H4>vdrawFArcN</H4></A>
<PRE>
        void <B>vdrawFArcN</B>(
                double x,
                double y,
                double r,
                double angle1,
                double angle2);
</PRE>

<DL><DD>
Appends an arc to the current path, with center at
<SAMP>x,y</SAMP> and radius of <SAMP>r</SAMP>. Only the
clockwise segment of the arc, from <SAMP>angle1</SAMP> to
<SAMP>angle2</SAMP> degrees, is actually constructed.
<SAMP>vdrawFArcN(x,y,r,0,360)</SAMP> draws an entire
circle. If a current point is defined, a line segment joins
that point to the first endpoint on the arc. 
<P>
The current point is then set at the second endpoint. The arc is
represented internally by one or more Bezier curve
segments, though a window system arc function may be used
under favorable circumstances.
<CODE><A HREF="vex-x.html#vexArgRangeException"><CODE>vexArgRangeException</CODE></A></CODE> is generated if
<SAMP>r</SAMP> is less than zero.
</DD></DL>
<P>
<A NAME="vdrawFArcT"><HR><H4>vdrawFArcT</H4></A>
<PRE>
        void <B>vdrawFArcT</B>(
                double x1,
                double y1,
                double x2,
                double y2,
                double r);
</PRE>

<DL><DD>
Appends an arc segment to the current path. (See figure).
The arc has radius <SAMP>r</SAMP> and is positioned tangent
to two line segments. These segments are drawn from the
current point <SAMP>x0,y0</SAMP> to point
<SAMP>x1,y1</SAMP>, and from <SAMP>x1,y1</SAMP> to
<SAMP>x2,y2</SAMP>. 
<P>
If necessary, a line segment is
appended from the current point <SAMP>x0,y0</SAMP> to the
first tangent point. (<SAMP>rxt1,ryt1</SAMP> in the figure). The
current point is set at <SAMP>rxt2,ryt2</SAMP>. The arc is
represented internally by a Bezier curve segment.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
<CODE><A HREF="vex-x.html#vexArgRangeException"><CODE>vexArgRangeException</CODE></A></CODE> is generated if
<SAMP>r</SAMP> is less than zero.
</DD></DL>
<P>
<A NAME="vdrawFArcTo"><HR><H4>vdrawFArcTo</H4></A>
<PRE>
        void <B>vdrawFArcTo</B>(
                double x1,
                double y1,
                double x2,
                double y2,
                double r,
                double * rxt1,
                double * ryt1,
                double * rxt2,
                double * ryt2);
</PRE>

<DL><DD>
Appends an arc segment to the current path. (See the figure).
The arc has radius <SAMP>r</SAMP> and is positioned tangent
to two line segments. These segments are drawn from the
current point <SAMP>x0,y0</SAMP> to point
<SAMP>x1,y1</SAMP>, and from <SAMP>x1,y1</SAMP> to
<SAMP>x2,y2</SAMP>. 
<P>
If necessary, a line segment is
appended from the current point <SAMP>x0,y0</SAMP> to the
first tangent point (<SAMP>rxt1,ryt1</SAMP> in the figure). The
current point is set at <SAMP>rxt2,ryt2</SAMP>. The arc is
represented internally by a Bezier curve segment. Returns
the tangent points in <SAMP>rxt1, ryt1, rxt2,</SAMP> and
<SAMP>ryt2</SAMP>. There is no integer version of this
function. <CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is
generated if there is no current point.
<CODE><A HREF="vex-x.html#vexArgRangeException"><CODE>vexArgRangeException</CODE></A></CODE> is generated if
<SAMP>r</SAMP> is less than zero.
</DD></DL>
<P>
<A NAME="vdrawFClipBounds"><HR><H4>vdrawFClipBounds</H4></A>
<PRE>
        void <B>vdrawFClipBounds</B>(
                const vrectFloat ** rects,
                int * count);
</PRE>

<DL><DD>
Computes a set of bounding boxes that enclose the current
clipping path. This function then returns the box
coordinates in <SAMP>rects</SAMP> and the number of boxes
in <SAMP>count</SAMP>. Depending on the window system, this
function either returns a bounding box for each individual
subpath or returns a single bounding box for the entire
path. 
<P>
The bounding box of a subpath is the smallest
rectangle that encloses all points along the subpath. (See
figure). This function does not take line width into
account. If the subpath contains curves, the bounding box
is computed to enclose all control points of the curves.
This function computes the bounding box of the path in
device space and returns the user space bounding box of the
device space bounding box. The box may be larger than
expected if the user space coordinate axes are not aligned
with the device space coordinate axes. The pointer returned
by this call can be used until the next call to the Drawing
class. Use <CODE><A HREF="vrect-x.html#vrectCloneSet"><CODE>vrectCloneSet</CODE></A></CODE> (a Plane Geometry
class function) to copy the rectangles, if persistence is
desired.
</DD></DL>
<P>
<A NAME="vdrawFCurveTo"><HR><H4>vdrawFCurveTo</H4></A>
<PRE>
        void <B>vdrawFCurveTo</B>(
                double x1,
                double y1,
                double x2,
                double y2,
                double x3,
                double y3);
</PRE>

<DL><DD>
Appends a Bezier curvesegment to the current path. (See
figure). The curve begins at the current point
(<SAMP>x0,y0</SAMP> in the figure) and ends at
<SAMP>x3,y3</SAMP>. <SAMP>x1,y1</SAMP> and
<SAMP>x2,y2</SAMP> are the Bezier cubic control points of
the curve. It sets the current point to <SAMP>x3,y3</SAMP>.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFDTransform"><HR><H4>vdrawFDTransform</H4></A>
<PRE>
        void <B>vdrawFDTransform</B>(
                double dx,
                double dy,
                double * rdx,
                double * rdy);
</PRE>

<DL><DD>
Computes the transformation of <SAMP>x</SAMP> and
<SAMP>y</SAMP> without the translation component and stores
the result in <SAMP>rx</SAMP> and <SAMP>ry</SAMP>. (See figure).
<P>
This function computes a device space vector for a given
user space vector. The delta transformation is useful for
determining an object's size after transformation.
</DD></DL>
<P>
<A NAME="vdrawFGetDash"><HR><H4>vdrawFGetDash</H4></A>
<PRE>
        void <B>vdrawFGetDash</B>(
                int * size,
                const float ** pat,
                double * offset);
</PRE>

<DL><DD>
Returns the currentdash pattern in <SAMP>pat</SAMP>, the
number of dashes in <SAMP>size</SAMP>, and the dash phase
offset in <SAMP>offset</SAMP>. It generates a
<CODE><A HREF="vex-x.html#vexArgNullException"><CODE>vexArgNullException</CODE></A></CODE> if any pointer is
<SAMP>NULL</SAMP>. The pointer returned in <SAMP>pat</SAMP>
is valid until the next call to the Drawing class.
<SAMP>pat</SAMP> can be <SAMP>NULL</SAMP> if
<SAMP>size</SAMP> is zero. There is no integer argument
version of this function.
</DD></DL>
<P>
<A NAME="vdrawFGetFlat"><HR><H4>vdrawFGetFlat</H4></A>
<PRE>
        double <B>vdrawFGetFlat</B>();
</PRE>

<DL><DD>
Returns the current flatness.
</DD></DL>
<P>
<A NAME="vdrawFGetGray"><HR><H4>vdrawFGetGray</H4></A>
<PRE>
        double <B>vdrawFGetGray</B>();
</PRE>

<DL><DD>
Returns the gray value of the current drawing color.
</DD></DL>
<P>
<A NAME="vdrawFGetHLSColor"><HR><H4>vdrawFGetHLSColor</H4></A>
<PRE>
        void <B>vdrawFGetHLSColor</B>(
                double * hue,
                double * lightness,
                double * saturation);
</PRE>

<DL><DD>
Returns the HLS value of the current drawing color.
</DD></DL>
<P>
<A NAME="vdrawFGetLineWidth"><HR><H4>vdrawFGetLineWidth</H4></A>
<PRE>
        double <B>vdrawFGetLineWidth</B>();
</PRE>

<DL><DD>
Returns the current line width in user-space units.
</DD></DL>
<P>
<A NAME="vdrawFGetMiterLimit"><HR><H4>vdrawFGetMiterLimit</H4></A>
<PRE>
        double <B>vdrawFGetMiterLimit</B>();
</PRE>

<DL><DD>
Returns the current miter limit. (See figure).
</DD></DL>
<P>
<A NAME="vdrawFGetPathIteratorX"><HR><H4>vdrawFGetPathIteratorX</H4></A>
<PRE>
        double <B>vdrawFGetPathIteratorX</B>(
                vdrawPathIterator * iterator);
</PRE>

<DL><DD>
Returns the x coordinate of a move or line segment in user
space units.
</DD></DL>
<P>
<A NAME="vdrawFGetPathIteratorX1"><HR><H4>vdrawFGetPathIteratorX1</H4></A>
<PRE>
        double <B>vdrawFGetPathIteratorX1</B>(
                vdrawPathIterator * iterator);
</PRE>

<DL><DD>
Returns the first x coordinate of a curve element being
iterated.
</DD></DL>
<P>
<A NAME="vdrawFGetPathIteratorX2"><HR><H4>vdrawFGetPathIteratorX2</H4></A>
<PRE>
        double <B>vdrawFGetPathIteratorX2</B>(
                vdrawPathIterator * iterator);
</PRE>

<DL><DD>
Returns the second x coordinate of a curve element being
iterated.
</DD></DL>
<P>
<A NAME="vdrawFGetPathIteratorX3"><HR><H4>vdrawFGetPathIteratorX3</H4></A>
<PRE>
        double <B>vdrawFGetPathIteratorX3</B>(
                vdrawPathIterator * iterator);
</PRE>

<DL><DD>
Returns the third x coordinate of a curve element being
iterated.
</DD></DL>
<P>
<A NAME="vdrawFGetPathIteratorY"><HR><H4>vdrawFGetPathIteratorY</H4></A>
<PRE>
        double <B>vdrawFGetPathIteratorY</B>(
                vdrawPathIterator * iterator);
</PRE>

<DL><DD>
Returns the y coordinate of a move or line segment in 
user-space units.
</DD></DL>
<P>
<A NAME="vdrawFGetPathIteratorY1"><HR><H4>vdrawFGetPathIteratorY1</H4></A>
<PRE>
        double <B>vdrawFGetPathIteratorY1</B>(
                vdrawPathIterator * iterator);
</PRE>

<DL><DD>
Returns the first y coordinate of a curve element being
iterated.
</DD></DL>
<P>
<A NAME="vdrawFGetPathIteratorY2"><HR><H4>vdrawFGetPathIteratorY2</H4></A>
<PRE>
        double <B>vdrawFGetPathIteratorY2</B>(
                vdrawPathIterator * iterator);
</PRE>

<DL><DD>
Returns the second y coordinate of a curve element being
iterated.
</DD></DL>
<P>
<A NAME="vdrawFGetPathIteratorY3"><HR><H4>vdrawFGetPathIteratorY3</H4></A>
<PRE>
        double <B>vdrawFGetPathIteratorY3</B>(
                vdrawPathIterator * iterator);
</PRE>

<DL><DD>
Returns the third y3 coordinate of a curve element being
iterated.
</DD></DL>
<P>
<A NAME="vdrawFGetPoint"><HR><H4>vdrawFGetPoint</H4></A>
<PRE>
        void <B>vdrawFGetPoint</B>(
                double * rx,
                double * ry);
</PRE>

<DL><DD>
Returns the current point in user space coordinates in
<SAMP>rx</SAMP> and <SAMP>ry</SAMP>. The current point is
the last endpoint of the current path.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
the current path is empty and <CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE>
is generated if the current transformation matrix cannot be
inverted. The current point is set by the path construction
functions, such as <CODE><A HREF="vdraw-x.html#vdrawMoveTo"><CODE>vdrawMoveTo</CODE></A></CODE> and
<CODE><A HREF="vdraw-x.html#vdrawLineTo"><CODE>vdrawLineTo</CODE></A></CODE>).
</DD></DL>
<P>
<A NAME="vdrawFGetRGBColor"><HR><H4>vdrawFGetRGBColor</H4></A>
<PRE>
        void <B>vdrawFGetRGBColor</B>(
                double * red,
                double * green,
                double * blue);
</PRE>

<DL><DD>
Returns the RGB value of the current drawing color.
</DD></DL>
<P>
<A NAME="vdrawFIDTransform"><HR><H4>vdrawFIDTransform</H4></A>
<PRE>
        void <B>vdrawFIDTransform</B>(
                double dx,
                double dy,
                double * rdx,
                double * rdy);
</PRE>

<DL><DD>
Computes the inverse transformation of <SAMP>dx</SAMP> and
<SAMP>dy</SAMP> without the current translation component
and stores the result in <SAMP>rdx</SAMP> and
<SAMP>rdy</SAMP>. The inverse delta transformation computes
a user-space vector for a given device space vector. This
function is useful for determining the <I>size</I> of an
object after transformation as opposed to its
<I>location</I> in the coordinate system. It generates a
<CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE> if the current transformation
matrix cannot be inverted.
</DD></DL>
<P>
<A NAME="vdrawFITransform"><HR><H4>vdrawFITransform</H4></A>
<PRE>
        void <B>vdrawFITransform</B>(
                double x,
                double y,
                double * rx,
                double * ry);
</PRE>

<DL><DD>
Computes the inverse transformation of <SAMP>x</SAMP> and
<SAMP>y</SAMP> and stores the result in <SAMP>rx</SAMP> and
<SAMP>ry</SAMP>. The inverse transformation computes a user
space coordinate for a given device space coordinate. It
generates <CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE> if the current
transformation matrix cannot be inverted. The integer
version of this function rounds the result of the
floating-point version.
</DD></DL>
<P>
<A NAME="vdrawFLineTo"><HR><H4>vdrawFLineTo</H4></A>
<PRE>
        void <B>vdrawFLineTo</B>(
                double x,
                double y);
</PRE>

<DL><DD>
Appends a line segment to the current path. The resulting
line has as its endpoints the initial current point and
<SAMP>x,y</SAMP>. (See figure). The current point is moved
to <SAMP>x,y</SAMP>.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFMoveTo"><HR><H4>vdrawFMoveTo</H4></A>
<PRE>
        void <B>vdrawFMoveTo</B>(
                double x,
                double y);
</PRE>

<DL><DD>
Begins a new subpath of the current path and sets the
current point to the position <SAMP>x,y</SAMP>. (See
figure).
</DD></DL>
<P>
<A NAME="vdrawFPathBounds"><HR><H4>vdrawFPathBounds</H4></A>
<PRE>
        void <B>vdrawFPathBounds</B>(
                const vrectFloat ** rects,
                int * count);
</PRE>

<DL><DD>
Computes a set of bounding boxes that enclose the current
path. This function then returns the box coordinates in
<SAMP>rects</SAMP> and the number of boxes in
<SAMP>count</SAMP>. Depending on the window system, the
function either returns a bounding box for each individual
subpath or returns a single bounding box for the entire
current path. The bounding box of a subpath is the smallest
rectangle that encloses all points along the subpath. (See
figure). This function does not take line width into
account. If the subpath contains curves, the bounding box
is computed to enclose all control points of the curves;
this can lead to an overly large bounding box.
<P>
To generate a true bounding box, call <CODE><A HREF="vdraw-x.html#vdrawFlattenPath"><CODE>vdrawFlattenPath</CODE></A></CODE>
first to produce a line approximation of any curve segments
in the path. The bounding box subsequently returned by
<CODE>vdrawFPathBounds</CODE> is a true bounding box. This
function takes the bounding box of the path in device space
and returns the user space bounding box of the device space
bounding box. The box returned may be larger than expected
if the user space coordinate axes are not aligned with the
device space coordinate axes. The pointer returned by this
call can be used until the next call to the Drawing
class. 
<P>
Use <CODE><A HREF="vrect-x.html#vrectCloneSet"><CODE>vrectCloneSet</CODE></A></CODE> (a Plane Geometry
class function) to copy the rectangles, if persistence is
desired.
</DD></DL>
<P>
<A NAME="vdrawFRCurveTo"><HR><H4>vdrawFRCurveTo</H4></A>
<PRE>
        void <B>vdrawFRCurveTo</B>(
                double dx1,
                double dy1,
                double dx2,
                double dy2,
                double dx3,
                double dy3);
</PRE>

<DL><DD>
Appends a Bezier curve segment to the current path. The
curve begins at the current point (<SAMP>x0, y0</SAMP> in
figure) and ends at <SAMP>(x3, y3)</SAMP>. All arguments
are measured relative to the current point. The point
<SAMP>(x1, y1)</SAMP> is offset from <SAMP>(x0, y0)</SAMP>
by <SAMP>(dx1, dy1)</SAMP>; the point <SAMP>(x2, y2)
</SAMP> is offset from <SAMP>(x1, y1)</SAMP> by <SAMP>(dx2,
dy2)</SAMP>; and the point <SAMP>(x3, y3)</SAMP> is offset
from <SAMP>(x2, y2)</SAMP> by <SAMP>(dx3, dy3)</SAMP>.
<P>
This method moves the current point by the sum of <SAMP>(dx1,
dy1)</SAMP>, plus <SAMP>(dx2, dy2)</SAMP>, plus <SAMP>(dx3,
dy3)</SAMP>. <CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is
generated if there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFRLineTo"><HR><H4>vdrawFRLineTo</H4></A>
<PRE>
        void <B>vdrawFRLineTo</B>(
                double dx,
                double dy);
</PRE>

<DL><DD>
Appends a line segment to the current path. Both arguments
are relative to the current point. The resulting line has
as its endpoints the initial current point
<SAMP>x0,y0</SAMP> and the point <SAMP>(x0 + dx, y0 +
dy)</SAMP>. (See figure). The trailing endpoint then becomes
the current point. <CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> 
is generated if there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFRMoveTo"><HR><H4>vdrawFRMoveTo</H4></A>
<PRE>
        void <B>vdrawFRMoveTo</B>(
                double dx,
                double dy);
</PRE>

<DL><DD>
Begins a new subpath of the current path and moves the
current point by <SAMP>dx,dy</SAMP>. (See figure).
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFRRCurveTo"><HR><H4>vdrawFRRCurveTo</H4></A>
<PRE>
        void <B>vdrawFRRCurveTo</B>(
                double dx1,
                double dy1,
                double dx2,
                double dy2,
                double dx3,
                double dy3);
</PRE>

<DL><DD>
Appends a Bezier curve segment to the current path. This
function creates the curve by relative increments, using
arguments that are each an offset from the preceding
argument. (See figure). <SAMP>dx1</SAMP> and
<SAMP>dy1</SAMP> are distances measured from the initial
current point <SAMP>x0,y0</SAMP> and define the location of
the curve control point <SAMP>x1,y1</SAMP>. Arguments
<SAMP>dx2</SAMP> and <SAMP>dy2</SAMP> are distances from
<SAMP>x1,y1</SAMP> and give the curve control point,
<SAMP>x2,y2</SAMP>. Arguments <SAMP>dx3</SAMP> and
<SAMP>dy3</SAMP> are distances measured from
<SAMP>x2,y2</SAMP>, and give the trailing endpoint of the
curve, <SAMP>x3,y3</SAMP>. The new current point is
<SAMP>x3,y3</SAMP>, which is distant from the initial
current point by the sum of (<SAMP>dx1,dy1</SAMP> ) plus
(<SAMP>dx2,dy2</SAMP>) plus (<SAMP>dx3,dy3</SAMP>).
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFRects"><HR><H4>vdrawFRects</H4></A>
<PRE>
        void <B>vdrawFRects</B>(
                const vrectFloat * rects,
                int count);
</PRE>

<DL><DD>
Constructs a path of line segments that encloses the
rectangles in <SAMP>rects</SAMP>. There are
<SAMP>count</SAMP> rectangles. Each rectangle is
constructed in its own closed subpath. If the rectangles
are to be immediately rendered, calling a rectangle
rendering operation (such as <CODE><A HREF="vdraw-x.html#vdrawRectsFill"><CODE>vdrawRectsFill</CODE></A></CODE>)
is likely to be much more efficient than calling this
function and rendering the resulting path.
</DD></DL>
<P>
<A NAME="vdrawFRectsClip"><HR><H4>vdrawFRectsClip</H4></A>
<PRE>
        void <B>vdrawFRectsClip</B>(
                const vrectFloat * rects,
                int count);
</PRE>

<DL><DD>
Intersects the current clipping path with the union of the
rectangles in <SAMP>rects</SAMP>, stores it as the new
clipping path, and begins a new current path. There are
<SAMP>count</SAMP> rectangles in <SAMP>rects</SAMP>. This
function is usually much more efficient than constructing
rectangular paths and clipping to them.
</DD></DL>
<P>
<A NAME="vdrawFRectsFill"><HR><H4>vdrawFRectsFill</H4></A>
<PRE>
        void <B>vdrawFRectsFill</B>(
                const vrectFloat * rects,
                int count);
</PRE>

<DL><DD>
Fills each rectangle in the array <SAMP>rects</SAMP> with
the current color. There are <SAMP>count</SAMP> rectangles.
Does not affect the current path. This function is usually
more efficient than constructing rectangular paths and
filling them.
</DD></DL>
<P>
<A NAME="vdrawFRectsStroke"><HR><H4>vdrawFRectsStroke</H4></A>
<PRE>
        void <B>vdrawFRectsStroke</B>(
                const vrectFloat * rects,
                int count);
</PRE>

<DL><DD>
Outlines each rectangle in the array <SAMP>rects</SAMP>
with the current line style. There are <SAMP>count</SAMP>
rectangles. Does not affect the current path. This function
is usually more efficient than constructing rectangular
paths and stroking them.
</DD></DL>
<P>
<A NAME="vdrawFRectsViewClip"><HR><H4>vdrawFRectsViewClip</H4></A>
<PRE>
        void <B>vdrawFRectsViewClip</B>(
                const vrectFloat * rects,
                int count);
</PRE>

<DL><DD>
Replaces the view clip with the union of the rectangles in
array <SAMP>rects</SAMP>. There are <SAMP>count</SAMP>
rectangles. The current gstate is not affected. The view
clip is used by the Window class for update region
maintenance and should not be changed otherwise. The view
clip is ignored by some devices.
</DD></DL>
<P>
<A NAME="vdrawFRotate"><HR><H4>vdrawFRotate</H4></A>
<PRE>
        void <B>vdrawFRotate</B>(
                double angle);
</PRE>

<DL><DD>
Rotates the current coordinate system by <SAMP>angle</SAMP>
degrees counterclockwise by modifying the current
transformation matrix.~<SAMP>angle</SAMP> can be negative
for clockwise rotation. Rotation can be visualized as the
turning of the coordinate axes about the origin. (See
figure). <CODE><A HREF="vdraw-x.html#vdrawRotate"><CODE>vdrawRotate</CODE></A></CODE> is cumulative; that is,
repeating a rotation of 15 degrees results in a total
rotation of 30 degrees.
</DD></DL>
<P>
<A NAME="vdrawFScale"><HR><H4>vdrawFScale</H4></A>
<PRE>
        void <B>vdrawFScale</B>(
                double x,
                double y);
</PRE>

<DL><DD>
Scales the current coordinate system by <SAMP>x</SAMP> and
<SAMP>y</SAMP> by modifying the current transformation
matrixtransformation matrix. Either parameter can be
negative. It is generally not useful if either parameter is
zero, and subsequent drawing operations may result in a
<CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE> being generated. Scaling by a
number greater than one effectively increases the size of
each user space unit, while scaling by a number between
zero and one decreases the size of each unit. Scaling by
negative values is useful for changing the direction of the
coordinate system, from increasing upwards to increasing
downwards, for example. 
<P>
<CODE><A HREF="vdraw-x.html#vdrawScale"><CODE>vdrawScale</CODE></A></CODE><SAMP>
(72,72)</SAMP> changes the default user space unit system
from points to inches. (See figure). <CODE><A HREF="vdraw-x.html#vdrawScale"><CODE>vdrawScale</CODE></A></CODE>
is cumulative; that is, scaling by 1.5 and then by 1.5
again results in a total scaling increase of 225 percent (1
x 1.5 x 1.5 = 2.25).
</DD></DL>
<P>
<A NAME="vdrawFScribedAShow"><HR><H4>vdrawFScribedAShow</H4></A>
<PRE>
        void <B>vdrawFScribedAShow</B>(
                double ax,
                double ay,
                vscribe * scribe);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> in the current font
and current color, with the origin of the first character
at the current point. <SAMP>ax</SAMP> and <SAMP>ay</SAMP>
indicate the amount of user space width to add to the width
of each character in the string. (See figure). 
<P>
Note that character width has a y coordinate as well as an x
coordinate. The current point is moved by the width of the
string plus any extra width. Scribed entry points allow you
to draw strings in other character sets or
representations. <CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
<P>
Refer to the ``String Manager'' chapter
of the <I>Galaxy Application Environment Programmer's
Guide</I> for more information about scribes.
</DD></DL>
<P>
<A NAME="vdrawFScribedAWidthShow"><HR><H4>vdrawFScribedAWidthShow</H4></A>
<PRE>
        void <B>vdrawFScribedAWidthShow</B>(
                double cx,
                double cy,
                int c,
                double ax,
                double ay,
                vscribe * scribe);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> in the current font
and current color, with the origin of the first character
at the current point. <SAMP>ax</SAMP> and <SAMP>ay</SAMP>
indicate the amount of user space width to add to the width
of each character in the string. (See figure).
<SAMP>cx</SAMP> and <SAMP>cy</SAMP> indicate the amount of
width to add to the width of the character <SAMP>c</SAMP>
where it appears in the string. 
<P>
Note that character width has a y coordinate as well as 
an x coordinate. The current point is moved by the width 
of the string, plus any extra width.
Scribed entry points allow you to draw strings
in other character sets or representations.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is
generated if there is no current point.
<P>
Refer to the ``String Manager'' chapter of the <I>Galaxy Application
Environment Programmer's Guide</I> for more information
about scribes.
</DD></DL>
<P>
<A NAME="vdrawFScribedWidthShow"><HR><H4>vdrawFScribedWidthShow</H4></A>
<PRE>
        void <B>vdrawFScribedWidthShow</B>(
                double cx,
                double cy,
                int c,
                vscribe * scribe);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> in the current font
and current color, with the origin of the first character
at the current point. <SAMP>cx</SAMP> and <SAMP>cy</SAMP>
indicate the amount of width to add to the width of the
character <SAMP>c</SAMP> where it appears in the string
(See Figure). 
<P>
Note that character width has a y coordinate
as well as an x coordinate. The current point is moved by
the width of the string plus any extra width. Scribed entry
points allow you to draw strings in other character sets or
representations. <CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
<P>
Refer to the ``String Manager'' chapter
of the <I>Galaxy Application Environment Programmer's
Guide</I> for more information about scribes.
</DD></DL>
<P>
<A NAME="vdrawFScribedXShow"><HR><H4>vdrawFScribedXShow</H4></A>
<PRE>
        void <B>vdrawFScribedXShow</B>(
                vscribe * scribe,
                const float * widths);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> at the current point
in the current font, but uses the array <SAMP>widths</SAMP>
to specify the x character width of each character in the
string. Each element of <SAMP>widths</SAMP> defines the x
width of the character listed in the corresponding position
of <SAMP>scribe</SAMP>. The y width of each character is
assumed to be zero. (See figure). The current point is moved
by the width of the string. Scribed entry points allow you
to draw strings in other character sets or
representations. <CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
<P>
Refer to the ``String Manager'' chapter
of the <I>Galaxy Application Environment Programmer's
Guide</I> for more information about scribes.
</DD></DL>
<P>
<A NAME="vdrawFScribedXYShow"><HR><H4>vdrawFScribedXYShow</H4></A>
<PRE>
        void <B>vdrawFScribedXYShow</B>(
                vscribe * scribe,
                const float * widths);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> at the current point
in the current font, but uses the array <SAMP>widths</SAMP>
to specify the x and y character width of each character in
the string. Each element of <SAMP>widths</SAMP> defines the
x and y width of the character listed in the position
<I>index</I>/2 of <SAMP>scribe</SAMP>, where <I>index</I>
is the index of the width. Each width pair is assumed to be
an x value followed by a y value. (See figure). The current
point is moved by the width of the string. Scribed entry
points allow you to draw strings in other character sets or
representations. <CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
<P>
Refer to the ``String Manager'' chapter
of the <I>Galaxy Application Environment Programmer's
Guide</I> for more information about scribes.
</DD></DL>
<P>
<A NAME="vdrawFScribedYShow"><HR><H4>vdrawFScribedYShow</H4></A>
<PRE>
        void <B>vdrawFScribedYShow</B>(
                vscribe * scribe,
                const float * widths);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> at the current point
in the current font, but uses the array <SAMP>widths</SAMP>
to specify the y character width of each character in the
string. Each element of <SAMP>widths</SAMP> defines the y
width of the character listed in the corresponding position
of <SAMP>scribe</SAMP>. The x width of each character is
assumed to be zero. (See figure). The current point is moved
by the width of the string. Scribed entry points allow you
to draw strings in other character sets or representations.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
<P>
Refer to the ``String Manager'' chapter
of the <I>Galaxy Application Environment Programmer's
Guide</I> for more information about scribes.
</DD></DL>
<P>
<A NAME="vdrawFSetDash"><HR><H4>vdrawFSetDash</H4></A>
<PRE>
        void <B>vdrawFSetDash</B>(
                int size,
                const float * pat,
                double offset);
</PRE>

<DL><DD>
Specifies the dash pattern for stroking operations.
<SAMP>size</SAMP> is the number of elements in array
<SAMP>pat</SAMP>. <SAMP>pat</SAMP> describes the dash
pattern, and <SAMP>offset</SAMP> is the phase offset. (See
figure). The elements of array <SAMP>pat</SAMP> describe
the segments in the dash pattern. 
<P>
Segment lengths are expressed in user space units. The elements of
<SAMP>pat</SAMP> alternate between on and off segments; the
first element of <SAMP>pat</SAMP> is an on segment. When
<SAMP>pat</SAMP> contains an odd number of elements, the
dash pattern is the concatenation of <SAMP>pat</SAMP> with
itself. For example, if <SAMP>pat</SAMP> equals {3.0, 1.0,
3.0}, the dash pattern is {3.0, 1.0, 3.0, 3.0, 1.0, 3.0}.
<SAMP>pat</SAMP> may be <SAMP>NULL</SAMP> if
<SAMP>size</SAMP> is zero (this sets a solid line). A copy
of <SAMP>pat</SAMP> is made in the current gstate.
<SAMP>offset</SAMP> is the number of user space units
truncated from the leading point of the dashed line. If the
offset is 3 and <SAMP>pat</SAMP> is {2.0, 2.0, 3.0, 3.0},
then the first instance of the dash pattern is 1 off, 3 on,
3 off. The rest of the path is then drawn with the entire
{2.0, 2.0, 3.0, 3.0} pattern.
<P>
The ends of each dash have the current line's cap style. Each
subpath is treated independently; for example, the pattern
is restarted from the beginning, and the offset is applied
the same for each subpath.
<P>
This function generates <CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE> if
<SAMP>size</SAMP> is less than zero, any element of
<SAMP>pat</SAMP> is less than zero, or <SAMP>size</SAMP> is
non-zero and all elements of <SAMP>pat</SAMP> are zero.
There is no integer-argument version of this function.
<P>
<BLOCKQUOTE>
Figure: Operation of FSetDash
<P>
<IMG SRC="Drawing.Operation_of_vdrawFSe_Cxx.gif">
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawFSetFlat"><HR><H4>vdrawFSetFlat</H4></A>
<PRE>
        void <B>vdrawFSetFlat</B>(
                double flatness);
</PRE>

<DL><DD>
Sets the current flatness to <SAMP>flatness</SAMP>. Curves
are rendered as a series of straight lines that form a
curve approximation. Flatness controls the amount of
deviation allowed between the approximation and the ``true
curve." (See figure). The allowed deviation is
expressed in terms of device pixels. This represents a
trade-off between curve fidelity and drawing efficiency. A
small deviation increases the smoothness of the
representation but also increases the number of line
segments required to render the approximation. 
<P>
The default flatness is a suitable value for the current device.
Flatness values less than 0.2 is set to 0.2. Flatness
values greater than 100 is set to 100. It generates
<CODE><A HREF="vex-x.html#vexArgRangeException"><CODE>vexArgRangeException</CODE></A></CODE> if <SAMP>flatness</SAMP>
is less than zero.
</DD></DL>
<P>
<A NAME="vdrawFSetGray"><HR><H4>vdrawFSetGray</H4></A>
<PRE>
        void <B>vdrawFSetGray</B>(
                double gray);
</PRE>

<DL><DD>
Sets the current color to the gray value <SAMP>gray</SAMP>.
This gray value will be used for all subsequent rendering.
Gray values range from zero one.
</DD></DL>
<P>
<A NAME="vdrawFSetHLSColor"><HR><H4>vdrawFSetHLSColor</H4></A>
<PRE>
        void <B>vdrawFSetHLSColor</B>(
                double hue,
                double lightness,
                double saturation);
</PRE>

<DL><DD>
Sets the current color to the HLS color value
<SAMP>hue</SAMP>,<SAMP>lightness</SAMP> and <SAMP>saturation</SAMP>. 
This color value will be used for
all subsequent rendering. HLS values range from zero one.
</DD></DL>
<P>
<A NAME="vdrawFSetLineWidth"><HR><H4>vdrawFSetLineWidth</H4></A>
<PRE>
        void <B>vdrawFSetLineWidth</B>(
                double width);
</PRE>

<DL><DD>
Sets the current line width (thickness) to
<SAMP>width</SAMP> user space units. (See figure). For any
given device, a line of zero width is defined as the
thinnest possible width for that device. Zero width lines
give better performance on some window systems, but at the
expense of visual fidelity. Zero width lines should be
avoided if the target device could be a printer since they
are likely to be invisible to the eye. It generates
<CODE><A HREF="vex-x.html#vexArgRangeException"><CODE>vexArgRangeException</CODE></A></CODE> if <SAMP>width</SAMP> is
less than zero.
</DD></DL>
<P>
<A NAME="vdrawFSetMiterLimit"><HR><H4>vdrawFSetMiterLimit</H4></A>
<PRE>
        void <B>vdrawFSetMiterLimit</B>(
                double limit);
</PRE>

<DL><DD>
Sets the current miter limit to <SAMP>limit</SAMP>. When
mitered ends have been specified as the style for
connecting line segments, the miter limit controls the
length of the mitered joins. This eliminates objectionably
long miter joins that might result when segments connect at
acute angles. (See figure). This function generates
<CODE><A HREF="vex-x.html#vexArgRangeException"><CODE>vexArgRangeException</CODE></A></CODE> if <SAMP>limit</SAMP> is
less than one.
</DD></DL>
<P>
<A NAME="vdrawFSetRGBColor"><HR><H4>vdrawFSetRGBColor</H4></A>
<PRE>
        void <B>vdrawFSetRGBColor</B>(
                double red,
                double green,
                double blue);
</PRE>

<DL><DD>
Sets the current color to the RGB color value
<SAMP>red</SAMP>, <SAMP>green</SAMP>, <SAMP>blue</SAMP>.
This color value will be used for all subsequent rendering.
RGB values range from zero to one.
</DD></DL>
<P>
<A NAME="vdrawFSizedAShow"><HR><H4>vdrawFSizedAShow</H4></A>
<PRE>
        void <B>vdrawFSizedAShow</B>(
                double ax,
                double ay,
                const vchar * s,
                size_t count);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font and
current color, with the origin of the first character at
the current point. <SAMP>ax</SAMP> and <SAMP>ay</SAMP>
indicate the amount of user space width to add to the width
of each character in the string. (See figure). 
<P>
Note that character width has a y coordinate as well as an x
coordinate. The current point is moved by the width of the
string plus any extra width. Exactly <SAMP>count</SAMP>
characters will be drawn from the string, regardless of
null characters. <CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE>
is generated if there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFSizedAWidthShow"><HR><H4>vdrawFSizedAWidthShow</H4></A>
<PRE>
        void <B>vdrawFSizedAWidthShow</B>(
                double cx,
                double cy,
                int c,
                double ax,
                double ay,
                const vchar * s,
                size_t count);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font and
current color, with the origin of the first character at
the current point. <SAMP>ax</SAMP> and <SAMP>ay</SAMP>
indicate the amount of user space width to add to the width
of each character in the string. (See figure).
<SAMP>cx</SAMP> and <SAMP>cy</SAMP> indicate the amount of
width to add to the width of the character <SAMP>c</SAMP>
where it appears in the string. 
<P>
Note that character width has a y coordinate as well as an x 
coordinate. The current point is moved by the width 
of the string plus any extra width. 
Exactly <SAMP>count</SAMP> characters are
drawn from the string, regardless of null characters.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFSizedWidthShow"><HR><H4>vdrawFSizedWidthShow</H4></A>
<PRE>
        void <B>vdrawFSizedWidthShow</B>(
                double cx,
                double cy,
                int c,
                const vchar * s,
                size_t count);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font and
current color, with the origin of the first character at
the current point. <SAMP>cx</SAMP> and <SAMP>cy</SAMP>
indicate the amount of width to add to the width of the
character <SAMP>c</SAMP> where it appears in the string
(See figure). 
<P>
Note that character width has a y coordinate
as well as an x coordinate. The current point is moved by
the width of the string plus any extra width. Exactly
<SAMP>count</SAMP> characters are drawn from the string,
regardless of null characters.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFSizedXShow"><HR><H4>vdrawFSizedXShow</H4></A>
<PRE>
        void <B>vdrawFSizedXShow</B>(
                const vchar * s,
                size_t count,
                const float * widths);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> at the current point in the
current font, but uses the array <SAMP>widths</SAMP> to
specify the x character width of each character in the
string. Each element of <SAMP>widths</SAMP> defines the x
width of the character listed in the corresponding position
of the string <SAMP>s</SAMP>. The y width of each character
is assumed to be zero. (See figure). The current point is
moved by the width of the string. Exactly
<SAMP>count</SAMP> characters are drawn from string
<SAMP>s</SAMP>, regardless of null characters.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFSizedXYShow"><HR><H4>vdrawFSizedXYShow</H4></A>
<PRE>
        void <B>vdrawFSizedXYShow</B>(
                const vchar * s,
                size_t count,
                const float * widths);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> at the current point in the
current font, but uses the array <SAMP>widths</SAMP> to
specify the x and y character width of each character in
the string. Each element of <SAMP>widths</SAMP> defines the
x and y width of the character listed in the position
<I>index</I>/2 of the string <SAMP>s</SAMP>, where
<I>index</I> is the index of the width. Each width pair is
assumed to be an x value followed by a y value. (See
figure). The current point is moved by the width of the
string. Exactly <SAMP>count</SAMP> characters are drawn
from string <SAMP>s</SAMP>, regardless of null characters.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFSizedYShow"><HR><H4>vdrawFSizedYShow</H4></A>
<PRE>
        void <B>vdrawFSizedYShow</B>(
                const vchar * s,
                size_t count,
                const float * widths);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> at the current point in the
current font, but uses the array <SAMP>widths</SAMP> to
specify the y character width of each character in the
string. Each element of <SAMP>widths</SAMP> defines the y
width of the character listed in the corresponding position
of the string <SAMP>s</SAMP>. The x width of each character
is assumed to be zero. (See figure). The current point is
moved by the width of the string. Exactly
<SAMP>count</SAMP> characters are drawn from string
<SAMP>s</SAMP>, regardless of null characters.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFTransform"><HR><H4>vdrawFTransform</H4></A>
<PRE>
        void <B>vdrawFTransform</B>(
                double x,
                double y,
                double * rx,
                double * ry);
</PRE>

<DL><DD>
Computes the transformation of <SAMP>x</SAMP> and
<SAMP>y</SAMP> and stores the result in <SAMP>rx</SAMP> and
<SAMP>ry</SAMP>. The standard transformation computes a
device space coordinate for a given user space coordinate.
(See figure).
</DD></DL>
<P>
<A NAME="vdrawFTranslate"><HR><H4>vdrawFTranslate</H4></A>
<PRE>
        void <B>vdrawFTranslate</B>(
                double x,
                double y);
</PRE>

<DL><DD>
Translates the current coordinate system by <SAMP>x</SAMP>
and <SAMP>y</SAMP> by modifying the current transformation
matrix. Either parameter can be negative or zero.
Translationeffectively moves the origin to the specified
coordinates in the <I>current</I> coordinate system. (See
figure). Translation, like other coordinate system
modifications, is cumulative:
<CODE>vdrawFTranslate</CODE><SAMP>(10,10)</SAMP> has the
same effect as calling
<CODE>vdrawFTranslate</CODE><SAMP>(5,5)</SAMP> twice in
succession.
</DD></DL>
<P>
<A NAME="vdrawFViewClipBounds"><HR><H4>vdrawFViewClipBounds</H4></A>
<PRE>
        void <B>vdrawFViewClipBounds</B>(
                const vrectFloat ** rects,
                int * count);
</PRE>

<DL><DD>
Computes a set of bounding boxes that enclose the current
view clipping path. This function then returns the box
coordinates in <SAMP>rects</SAMP> and the number of boxes
in <SAMP>count</SAMP>. Depending on the window system, this
function either returns a bounding box for each individual
subpath or returns a single bounding box for the entire
path. The bounding box of a subpath is the smallest
rectangle that encloses all points along the subpath. (See
figure). 
<P>
This function does not take line width into account. 
If the subpath contains curves, the bounding box
is computed to enclose all control points of the curves.
This function computes the bounding box of the path in
device space and returns the user space bounding box of the
device space bounding box. The box may be larger than
expected if the user space coordinate axes are not aligned
with the device space coordinate axes. The pointer returned
by this call can be used until the next call to the Drawing
class. Use <CODE><A HREF="vrect-x.html#vrectCloneSet"><CODE>vrectCloneSet</CODE></A></CODE> (a Plane Geometry
class function) to copy the rectangles, if persistence is
desired.
</DD></DL>
<P>
<A NAME="vdrawFWidthShow"><HR><H4>vdrawFWidthShow</H4></A>
<PRE>
        void <B>vdrawFWidthShow</B>(
                double cx,
                double cy,
                int c,
                const vchar * s);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font and
current color, with the origin of the first character at
the current point. <SAMP>cx</SAMP> and <SAMP>cy</SAMP>
indicate the amount of width to add to the width of the
character <SAMP>c</SAMP> wherever it appears in the string.
(See figure).
<P>
Note that character width has a y coordinate
as well as an x coordinate. The current point is moved by
the width of the string plus any extra width.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFXShow"><HR><H4>vdrawFXShow</H4></A>
<PRE>
        void <B>vdrawFXShow</B>(
                const vchar * s,
                const float * widths);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> at the current point in the
current font, but uses the array <SAMP>widths</SAMP> to
specify the x character width of each character in the
string. Each element of <SAMP>widths</SAMP> defines the x
width of the character listed in the corresponding position
of the string <SAMP>s</SAMP>. The y width of each character
is assumed to be zero. (See figure). The current point is
moved by the width of the string.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFXYShow"><HR><H4>vdrawFXYShow</H4></A>
<PRE>
        void <B>vdrawFXYShow</B>(
                const vchar * s,
                const float * widths);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> at the current point in the
current font, but uses the array <SAMP>widths</SAMP> to
specify the x and y character width of each character in
the string. Each element of <SAMP>widths</SAMP> defines the
x and y width of the character listed in the position
<I>index</I>/2 of the string <SAMP>s</SAMP>, where
<I>index</I> is the index of the width. Each width pair is
assumed to be an x value followed by a y value. (See
figure). The current point is moved by the width of the
string. <CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is
generated if there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFYShow"><HR><H4>vdrawFYShow</H4></A>
<PRE>
        void <B>vdrawFYShow</B>(
                const vchar * s,
                const float * widths);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> at the current point in the
current font, but uses the array <SAMP>widths</SAMP> to
specify the y character width of each character in the
string. Each element of <SAMP>widths</SAMP> defines the y
width of the character listed in the corresponding position
of the string <SAMP>s</SAMP>. The x width of each character
is assumed to be zero. (See figure). The current point is
moved by the width of the string.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawFill"><HR><H4>vdrawFill</H4></A>
<PRE>
        void <B>vdrawFill</B>();
</PRE>

<DL><DD>
Fills the current path with the current color and begins a
new current path. It tests for ``inside'' using the nonzero
winding rule. (See figure).
<P>
<BLOCKQUOTE>
Figure: Rules for path filling
<P>
<IMG SRC="Drawing.Rules_for_path_filling.gif">
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawFlattenPath"><HR><H4>vdrawFlattenPath</H4></A>
<PRE>
        void <B>vdrawFlattenPath</B>();
</PRE>

<DL><DD>
Replaces all curve segments in the current path with line
segment approximations. The approximation reflects the
accuracy level specified by the current flatness attribute
set using <CODE><A HREF="vdraw-x.html#vdrawSetFlat"><CODE>vdrawSetFlat</CODE></A></CODE>. If the current
flatness is small, this function may produce a very large
path. It has no effect if the current path contains no
curve segments.
</DD></DL>
<P>
<A NAME="vdrawGRestore"><HR><H4>vdrawGRestore</H4></A>
<PRE>
        void <B>vdrawGRestore</B>();
</PRE>

<DL><DD>
Removes the topmost gstate from the gstate stackstackand
copies its contents into the current gstate. This function
effectively undoes any modifications made to the current
gstate since the last call to <CODE><A HREF="vdraw-x.html#vdrawGSave"><CODE>vdrawGSave</CODE></A></CODE>. If
the gstate stack is empty, this function has no effect. You
can use <CODE><A HREF="vdraw-x.html#vdrawGSave"><CODE>vdrawGSave</CODE></A></CODE> and
<CODE>vdrawGRestore</CODE> to preserve the contents of the
current gstate across many drawing calls. For example:
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vdraw-x.html#vdrawGSave"><CODE>vdrawGSave</CODE></A>();
<A HREF="vdraw-x.html#vdrawSetColor"><CODE>vdrawSetColor</CODE></A>(<A HREF="vcolor-x.html#vcolorGetWhite"><CODE>vcolorGetWhite</CODE></A>());
<A HREF="vdraw-x.html#vdrawSetFont"><CODE>vdrawSetFont</CODE></A>(<A HREF="vfont-x.html#vfontFindScribed"><CODE>vfontFindScribed</CODE></A>(<A HREF="vchar-x.html#vcharScribeLiteral"><CODE>vcharScribeLiteral</CODE></A>("times-10")));
<A HREF="vdraw-x.html#vdrawMoveTo"><CODE>vdrawMoveTo</CODE></A>(100, 100);
vdrawShowScribed(<A HREF="vchar-x.html#vcharScribeLiteral"><CODE>vcharScribeLiteral</CODE></A>("Spam"));
vdrawGRestore();

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawGRestoreAll"><HR><H4>vdrawGRestoreAll</H4></A>
<PRE>
        void <B>vdrawGRestoreAll</B>();
</PRE>

<DL><DD>
Removes all gstate objects from the gstate stack and
initializes the attributes of the current gstate to their
default values, as if <CODE><A HREF="vdraw-x.html#vdrawInitGraphics"><CODE>vdrawInitGraphics</CODE></A></CODE> were
called. This simulates the correct behavior of the
PostScript operator <CODE>grestoreall</CODE> in the absence
of a save/restore facility. You should <I>not</I> use this
function to balance the gstate stack when you are done
drawing, since other drawing code may have pushed gstates
on the stack before you were called.
</DD></DL>
<P>
<A NAME="vdrawGSave"><HR><H4>vdrawGSave</H4></A>
<PRE>
        void <B>vdrawGSave</B>();
</PRE>

<DL><DD>
Saves the current gstate on top of the gstate stack.
You can use <CODE>vdrawGSave</CODE> and
<CODE><A HREF="vdraw-x.html#vdrawGRestore"><CODE>vdrawGRestore</CODE></A></CODE> to preserve the contents of the
current gstate across many drawing calls.
</DD></DL>
<P>
<A NAME="vdrawGetColor"><HR><H4>vdrawGetColor</H4></A>
<PRE>
        vcolor * <B>vdrawGetColor</B>();
</PRE>

<DL><DD>
Returns the current drawing color.
</DD></DL>
<P>
<A NAME="vdrawGetComplement"><HR><H4>vdrawGetComplement</H4></A>
<PRE>
        vcolor * <B>vdrawGetComplement</B>();
</PRE>

<DL><DD>
Returns the current complement color.
</DD></DL>
<P>
<A NAME="vdrawGetComplexity"><HR><H4>vdrawGetComplexity</H4></A>
<PRE>
        int <B>vdrawGetComplexity</B>();
</PRE>

<DL><DD>
Returns the current path complexity.
</DD></DL>
<P>
<A NAME="vdrawGetDevice"><HR><H4>vdrawGetDevice</H4></A>
<PRE>
        void * <B>vdrawGetDevice</B>();
</PRE>

<DL><DD>
Returns the current device instance pointer (installed by
<CODE><A HREF="vdraw-x.html#vdrawSetDevice"><CODE>vdrawSetDevice</CODE></A></CODE>) for the current gstate. This
function should only be called from within a driver
function to obtain the current device instance.
</DD></DL>
<P>
<A NAME="vdrawGetFlat"><HR><H4>vdrawGetFlat</H4></A>
<PRE>
        int <B>vdrawGetFlat</B>();
</PRE>

<DL><DD>
Returns the current flatness.
</DD></DL>
<P>
<A NAME="vdrawGetFont"><HR><H4>vdrawGetFont</H4></A>
<PRE>
        vfont * <B>vdrawGetFont</B>();
</PRE>

<DL><DD>
Returns the current font.
</DD></DL>
<P>
<A NAME="vdrawGetFunction"><HR><H4>vdrawGetFunction</H4></A>
<PRE>
        int <B>vdrawGetFunction</B>();
</PRE>

<DL><DD>
Returns the current drawing function.
</DD></DL>
<P>
<A NAME="vdrawGetGState"><HR><H4>vdrawGetGState</H4></A>
<PRE>
        void <B>vdrawGetGState</B>(
                vdrawGState * gstate);
</PRE>

<DL><DD>
Copies the contents of the current gstate into
<SAMP>gstate</SAMP>.~<SAMP>gstate</SAMP> must already be
initialized; create a new gstate with
<CODE><A HREF="vdraw-x.html#vdrawCreateGState"><CODE>vdrawCreateGState</CODE></A></CODE>. All attributes of the
current gstate are copied, including its device and clip
path.
<P>
Note that the view clip is not copied, since it is
not stored in a gstate.
</DD></DL>
<P>
<A NAME="vdrawGetGray"><HR><H4>vdrawGetGray</H4></A>
<PRE>
        unsigned int <B>vdrawGetGray</B>();
</PRE>

<DL><DD>
Returns the gray value of the current drawing color.
</DD></DL>
<P>
<A NAME="vdrawGetHLSColor"><HR><H4>vdrawGetHLSColor</H4></A>
<PRE>
        void <B>vdrawGetHLSColor</B>(
                unsigned int * hue,
                unsigned int * lightness,
                unsigned int * saturation);
</PRE>

<DL><DD>
Returns the HLS value of the current drawing color.
</DD></DL>
<P>
<A NAME="vdrawGetLineCap"><HR><H4>vdrawGetLineCap</H4></A>
<PRE>
        int <B>vdrawGetLineCap</B>();
</PRE>

<DL><DD>
Returns the current line cap style. (See figure).
</DD></DL>
<P>
<A NAME="vdrawGetLineJoin"><HR><H4>vdrawGetLineJoin</H4></A>
<PRE>
        int <B>vdrawGetLineJoin</B>();
</PRE>

<DL><DD>
Returns the current line join style. (See figure).
</DD></DL>
<P>
<A NAME="vdrawGetLineWidth"><HR><H4>vdrawGetLineWidth</H4></A>
<PRE>
        int <B>vdrawGetLineWidth</B>();
</PRE>

<DL><DD>
Returns the current line width in user space units. The
value is rounded when the line width is fractional.
</DD></DL>
<P>
<A NAME="vdrawGetMatrix"><HR><H4>vdrawGetMatrix</H4></A>
<PRE>
        const vmatrix * <B>vdrawGetMatrix</B>();
</PRE>

<DL><DD>
Returns the address of the current transformation matrix.
This pointer is valid until the next Drawing class call.
</DD></DL>
<P>
<A NAME="vdrawGetMiterLimit"><HR><H4>vdrawGetMiterLimit</H4></A>
<PRE>
        int <B>vdrawGetMiterLimit</B>();
</PRE>

<DL><DD>
Returns the current miter limit. (See figure).
</DD></DL>
<P>
<A NAME="vdrawGetNoCurrentPointException"><HR><H4>vdrawGetNoCurrentPointException</H4></A>
<PRE>
        vdrawNoCurrentPointException * <B>vdrawGetNoCurrentPointException</B>();
</PRE>

<DL><DD>
Returns a pointer to the current ``No Current Point''
exception, or <SAMP>NULL</SAMP> if the current exception is
not of this type. Refer to the ``Types'' section at the
beginning of this chapter for a description of this
exception.
</DD></DL>
<P>
<A NAME="vdrawGetNoCurrentPointExceptionClass"><HR><H4>vdrawGetNoCurrentPointExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vdrawGetNoCurrentPointExceptionClass</B>();
</PRE>

<DL><DD>
Returns a pointer to the ``No Current Point'' exception
class. This class can be used to generate exceptions or
define new exception classes. Refer to the ``Types''
section at the beginning of this chapter for a description
of this exception.
</DD></DL>
<P>
<A NAME="vdrawGetPathIteratorType"><HR><H4>vdrawGetPathIteratorType</H4></A>
<PRE>
        int <B>vdrawGetPathIteratorType</B>(
                vdrawPathIterator * iterator);
</PRE>

<DL><DD>
Returns the type of path element indexed by the iterator
<SAMP>iterator</SAMP>. The type will be one of the
following constants:
  <P>
<BLOCKQUOTE>

<DL>
<DT><CODE>vdrawELEM_MOVE</CODE>
<DD>move element

<DT><CODE>vdrawELEM_LINE</CODE>
<DD>line element

<DT><CODE>vdrawELEM_CURVE</CODE>
<DD>curve element

<DT><CODE>vdrawELEM_CLOSE</CODE>
<DD>close element
</DL>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawGetPhase"><HR><H4>vdrawGetPhase</H4></A>
<PRE>
        void <B>vdrawGetPhase</B>(
                int * rx,
                int * ry);
</PRE>

<DL><DD>
Returns the current pixel phase.
</DD></DL>
<P>
<A NAME="vdrawGetPoint"><HR><H4>vdrawGetPoint</H4></A>
<PRE>
        void <B>vdrawGetPoint</B>(
                int * rx,
                int * ry);
</PRE>

<DL><DD>
Returns the current pointin user space coordinates in
<SAMP>rx</SAMP> and <SAMP>ry</SAMP>. The current point is
the last endpoint of the current path.
<P>
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
the current path is empty and <CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE>
is generated if the current transformation matrix cannot be
inverted. The current point is rounded. The current point
is set by the path construction functions, such as
<CODE><A HREF="vdraw-x.html#vdrawMoveTo"><CODE>vdrawMoveTo</CODE></A></CODE> and <CODE><A HREF="vdraw-x.html#vdrawLineTo"><CODE>vdrawLineTo</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdrawGetRGBColor"><HR><H4>vdrawGetRGBColor</H4></A>
<PRE>
        void <B>vdrawGetRGBColor</B>(
                unsigned int * red,
                unsigned int * green,
                unsigned int * blue);
</PRE>

<DL><DD>
Returns the RGB value of the current drawing color.
</DD></DL>
<P>
<A NAME="vdrawGetRule"><HR><H4>vdrawGetRule</H4></A>
<PRE>
        int <B>vdrawGetRule</B>();
</PRE>

<DL><DD>
Returns the drawing rule set by fill operations such as
<CODE><A HREF="vdraw-x.html#vdrawFill"><CODE>vdrawFill</CODE></A></CODE> or <CODE><A HREF="vdraw-x.html#vdrawEOFill"><CODE>vdrawEOFill</CODE></A></CODE>. This
value is useful to device drivers performing polygon fill
operations. (See figure). The function returns one of the
following values:
<P>

<DL>
<DT><CODE>vdrawRULE_EVEN_ODD</CODE>
<DD>Polygons are filled using the even-odd rule.

<DT><CODE>vdrawRULE_WINDING</CODE>
<DD>Polygons are filled using the non-zero winding rule.
</DL>

</DD></DL>
<P>
<A NAME="vdrawGetStrokeAdjust"><HR><H4>vdrawGetStrokeAdjust</H4></A>
<PRE>
        int <B>vdrawGetStrokeAdjust</B>();
</PRE>

<DL><DD>
Returns the current stroke-adjustment flag. If stroke
adjustment is on, lines with a small number of device
pixels are adjusted for uniform width.
</DD></DL>
<P>
<A NAME="vdrawGetTransform"><HR><H4>vdrawGetTransform</H4></A>
<PRE>
        const vtransform * <B>vdrawGetTransform</B>();
</PRE>

<DL><DD>
Returns a pointer to a transformation object that
corresponds to the transformation matrix in the current
graphics state.
</DD></DL>
<P>
<A NAME="vdrawIDTransform"><HR><H4>vdrawIDTransform</H4></A>
<PRE>
        void <B>vdrawIDTransform</B>(
                int dx,
                int dy,
                int * rdx,
                int * rdy);
</PRE>

<DL><DD>
Computes the inverse transformationof <SAMP>dx</SAMP> and
<SAMP>dy</SAMP> without the current translation component
and stores the result in <SAMP>rdx</SAMP> and
<SAMP>rdy</SAMP>. The inverse delta transformation computes
a user space vector for a given device space vector. This
function is useful for determining the <I>size</I> of an
object after transformation as opposed to its
<I>location</I> in the coordinate system. It generates a
<CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE> if the current transformation
matrix cannot be inverted. This function rounds the result
of <CODE><A HREF="vdraw-x.html#vdrawFIDTransform"><CODE>vdrawFIDTransform</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdrawITransform"><HR><H4>vdrawITransform</H4></A>
<PRE>
        void <B>vdrawITransform</B>(
                int x,
                int y,
                int * rx,
                int * ry);
</PRE>

<DL><DD>
Computes the inverse transformationof <SAMP>x</SAMP> and
<SAMP>y</SAMP> and stores the result in <SAMP>rx</SAMP> and
<SAMP>ry</SAMP>. The inverse transformation computes a user
space coordinate for a given device space coordinate. This
function generates a <CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE> if the
current transformation matrix cannot be inverted. The
integer version of this function rounds the result of
<CODE><A HREF="vdraw-x.html#vdrawFITransform"><CODE>vdrawFITransform</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdrawImage"><HR><H4>vdrawImage</H4></A>
<PRE>
        void <B>vdrawImage</B>(
                vimage * image,
                const vmatrix * mtx);
</PRE>

<DL><DD>
Renders the image <SAMP>image</SAMP> on the current device.
The transformation matrix <SAMP>mtx</SAMP> maps coordinates
in user space to coordinates in the source image space and
defines the region of user-space that receives the image.
</DD></DL>
<P>
<A NAME="vdrawImageComposite"><HR><H4>vdrawImageComposite</H4></A>
<PRE>
        void <B>vdrawImageComposite</B>(
                vimage * image,
                const vmatrix * mtx);
</PRE>

<DL><DD>
Renders the image <SAMP>image</SAMP> on the current device
using a compositing operation. The transformation matrix
<SAMP>mtx</SAMP> maps coordinates in user space to
coordinates in the source image space and defines the
region of user-space that receives the image. The
<CODE>Transparency</CODE> attribute of the image, if any,
determines where the image is transparent and where it is
opaque. Transparency pixels set to one indicate an opaque
image pixel, while transparency pixels set to zero indicate
transparent image pixel. The transparency image must have
depth one. This function may ignore the
<CODE>Transparency</CODE> attribute for some devices, most
notably PostScript printers.
</DD></DL>
<P>
<A NAME="vdrawImageCompositeIdent"><HR><H4>vdrawImageCompositeIdent</H4></A>
<PRE>
        void <B>vdrawImageCompositeIdent</B>(
                vimage * image);
</PRE>

<DL><DD>
Renders the image <SAMP>image</SAMP> on the current device
using a compositing operation such that the origin of the
image is located at the current point and each pixel of the
image is drawn at the scale of one user-space unit. The
<CODE>Transparency</CODE> attribute of the image, if any,
determines where the image is transparent and where it is
opaque. Transparency pixels set to one indicate an opaque
image pixel, while transparency pixels set to zero indicate
transparent image pixel. The transparency image must have
depth of one. 
<P>
This function may ignore the
<CODE>Transparency</CODE> attribute for some devices, most
notably PostScript printers.
</DD></DL>
<P>
<A NAME="vdrawImageDevice"><HR><H4>vdrawImageDevice</H4></A>
<PRE>
        void <B>vdrawImageDevice</B>(
                vimage * image);
</PRE>

<DL><DD>
Establishes the image <SAMP>image</SAMP> as the target of
drawing operations from the current gstate. Drawing
operations then leave marks on the image instead of on the
device previously in the gstate. This function sets the
current transformation matrix to reflect the resolution and
orientation of the screen and sets the current clipping
path to the image bounds. Images suitable for off-screen
rendering can be obtained from the Window class with the
function <CODE><A HREF="vwindow-x.html#vwindowCreateBufferImage"><CODE>vwindowCreateBufferImage</CODE></A></CODE>. The
following code, for example, renders a black circle inside
a white background on an image, the paints the image on the
current device at the location (100, 100):
<P>
<BLOCKQUOTE>

<PRE>
<A HREF="vimage-x.html#vimage"><CODE>vimage</CODE></A> *image;
image = <A HREF="vwindow-x.html#vwindowCreateBufferImage"><CODE>vwindowCreateBufferImage</CODE></A>(100, 100);
<A HREF="vdraw-x.html#vdrawGSave"><CODE>vdrawGSave</CODE></A>();
vdrawImageDevice(image);
<A HREF="vdraw-x.html#vdrawSetColor"><CODE>vdrawSetColor</CODE></A>(<A HREF="vcolor-x.html#vcolorGetWhite"><CODE>vcolorGetWhite</CODE></A>());
<A HREF="vdraw-x.html#vdrawRectFill"><CODE>vdrawRectFill</CODE></A>(0, 0, 100, 100);
<A HREF="vdraw-x.html#vdrawSetColor"><CODE>vdrawSetColor</CODE></A>(<A HREF="vcolor-x.html#vcolorGetBlack"><CODE>vcolorGetBlack</CODE></A>());
<A HREF="vdraw-x.html#vdrawArc"><CODE>vdrawArc</CODE></A>(50, 50, 40, 0, 360);
<A HREF="vdraw-x.html#vdrawFill"><CODE>vdrawFill</CODE></A>();
<A HREF="vdraw-x.html#vdrawGRestore"><CODE>vdrawGRestore</CODE></A>();
<A HREF="vdraw-x.html#vdrawMoveTo"><CODE>vdrawMoveTo</CODE></A>(100, 100);
<A HREF="vdraw-x.html#vdrawImageIdent"><CODE>vdrawImageIdent</CODE></A>(image);
<A HREF="vimage-x.html#vimageDestroy"><CODE>vimageDestroy</CODE></A>(image);
</PRE>

</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawImageIdent"><HR><H4>vdrawImageIdent</H4></A>
<PRE>
        void <B>vdrawImageIdent</B>(
                vimage * image);
</PRE>

<DL><DD>
Renders the image <SAMP>image</SAMP> such that the origin
of the image is located at the current point and each pixel
of the image is drawn at the scale of one user space unit.
If the relationship between user-space units and device
space units is one to one, the image is copied directly to
the device. Otherwise, a transformation matrix is
constructed and normal image sampling is performed.
</DD></DL>
<P>
<A NAME="vdrawImageMask"><HR><H4>vdrawImageMask</H4></A>
<PRE>
        void <B>vdrawImageMask</B>(
                vimage * mask,
                const vmatrix * mtx);
</PRE>

<DL><DD>
Uses the image <SAMP>mask</SAMP> as a filter for drawing a
rectangle filled with the current color. The rectangle is
drawn on the current device. A zero pixel value in
<SAMP>mask</SAMP> specifies that color should not appear
inside the bounds of the pixel, while a one value indicates
that color should appear. The transformation matrix
<SAMP>mtx</SAMP> maps coordinates in user-space to
coordinates of <SAMP>mask</SAMP> and defines the region of
user space that receives the rectangle. The mask must have
a depth of one.
</DD></DL>
<P>
<A NAME="vdrawImageMaskIdent"><HR><H4>vdrawImageMaskIdent</H4></A>
<PRE>
        void <B>vdrawImageMaskIdent</B>(
                vimage * mask);
</PRE>

<DL><DD>
Uses the image <SAMP>mask</SAMP> as a filter for drawing a
rectangle filled with the current color. The origin of the
rectangle is located at the current point and each pixel of
the mask is drawn at the scale of one user-space unit. A
zero pixel value in <SAMP>mask</SAMP> specifies that color
should not appear inside the bounds of the pixel, while a
one value indicates that color should appear. The mask must
have a depth of one.
</DD></DL>
<P>
<A NAME="vdrawInitClip"><HR><H4>vdrawInitClip</H4></A>
<PRE>
        void <B>vdrawInitClip</B>();
</PRE>

<DL><DD>
Initializes the clipping path in the current gstate to a
path enclosing the entire imageable area of the current
device. Do <I>not</I> use this function to restore the clip
path to its previous state after you are finished clipping,
since some clipping may already be in effect when your
drawing code is called. You should, instead, save the
current gstate before clipping, the restore it after you
are finished drawing.
<P>
The following code fragment illustrates how to do this
correctly:
<P>
<BLOCKQUOTE>

<PRE>
<A HREF="vrect-x.html#vrect"><CODE>vrect</CODE></A> clipRect;  /* contains the rectangle to clip to */

<A HREF="vdraw-x.html#vdrawGSave"><CODE>vdrawGSave</CODE></A>();
<A HREF="vdraw-x.html#vdrawRectsClip"><CODE>vdrawRectsClip</CODE></A>(&clipRect, 1);
<A HREF="vdraw-x.html#vdrawArc"><CODE>vdrawArc</CODE></A>(100, 100, 50, 0, 360);  /* clip this */
<A HREF="vdraw-x.html#vdrawFill"><CODE>vdrawFill</CODE></A>();
<A HREF="vdraw-x.html#vdrawGRestore"><CODE>vdrawGRestore</CODE></A>();

<A HREF="vdraw-x.html#vdrawArc"><CODE>vdrawArc</CODE></A>(200, 200, 50, 0, 360);  /* don't clip this */
</PRE>

</BLOCKQUOTE>
<P>
You should not need to call this function under normal
circumstances. This function is likely to have undesirable
side-effects on drawing code that is called after your
drawing code. Additionally, if your code is included as
part of a composite drawing, you will not get correct
results if your code calls this function.
</DD></DL>
<P>
<A NAME="vdrawInitGraphics"><HR><H4>vdrawInitGraphics</H4></A>
<PRE>
        void <B>vdrawInitGraphics</B>();
</PRE>

<DL><DD>
Resets certain attributes of the current gstate to their
default values:
<P>
<BLOCKQUOTE>

<DL>
<DT><B>Attribute</B>

<DD><B>Default Value</B>
<DT>Clip

<DD>entire device area
<DT>Color

<DD>black
<DT>Dash

<DD>solid line
<DT>LineCap

<DD><CODE>vdrawCAP_BUTT</CODE>
<DT>LineJoin

<DD><CODE>vdrawJOIN_MITER</CODE>
<DT>LineWidth

<DD>1.0
<DT>Matrix

<DD>device default matrix
<DT>MiterLimit

<DD>10.0
<DT>Path

<DD>no path
<DT>CurrentPoint

<DD>no current point
</DL>

</BLOCKQUOTE>
<P>
The other components of the current gstate are unchanged by
this function. You should not call this function from your
drawing code, since it is likely to produce undesirable
side-effects on other drawing code. You should, instead,
assume that all attributes are set to their default values
when your code is called: you can assume that any
deviations form the defaults are intentional.
</DD></DL>
<P>
<A NAME="vdrawInitMatrix"><HR><H4>vdrawInitMatrix</H4></A>
<PRE>
        void <B>vdrawInitMatrix</B>();
</PRE>

<DL><DD>
Sets the current transformation matrix to the default 
matrix for the current device. The
origin of the coordinate system is moved to the lower left
corner of the device and user-space units are set to points
increasing up and to the right. User space units are
rounded to device pixels if indicated by the device.
<P>
You should not call this function from casual drawing code,
since any modifications to the current transformation made
by other functions are lost. Assume that the current 
transformation is the default transformation and
that any deviations from it are intentional. If it is
important that your user-space units be exactly 72 pixels
per inch, you can use <CODE><A HREF="vdraw-x.html#vdrawUnround"><CODE>vdrawUnround</CODE></A></CODE> to undo any
rounding that was applied to the current transformation.
<P>
You should not need to call this function under normal
circumstances. This function is likely to have undesirable
side-effects on drawing code that is called after your
drawing code. Additionally, if your code is included as
part of a composite drawing, you will not get correct
results if your code calls this function.
</DD></DL>
<P>
<A NAME="vdrawInitPathIterator"><HR><H4>vdrawInitPathIterator</H4></A>
<PRE>
        void <B>vdrawInitPathIterator</B>(
                vdrawPathIterator * iterator);
</PRE>

<DL><DD>
Begins an iteration of all the elements of the current
path. The iterator will initially contain no path
element; <CODE><A HREF="vdraw-x.html#vdrawNextPathIterator"><CODE>vdrawNextPathIterator</CODE></A></CODE> must be
called to obtain the first path element. Note that you can
modify the current path during the iteration; this
function effectively takes a ``snapshot'' of the current
path before beginning the iteration.
</DD></DL>
<P>
<A NAME="vdrawInitViewClip"><HR><H4>vdrawInitViewClip</H4></A>
<PRE>
        void <B>vdrawInitViewClip</B>();
</PRE>

<DL><DD>
Initializes the view clipping pathto the default clipping
pathof the current device. The current gstate is not
affected. The view clip is used by the Window class for
update region maintenance; it should not be changed by
clients. The view clip is ignored by some devices. Your
drawing code should assume that the current view clip has
already been set correctly for you. If you attempt to
change it yourself, you will most likely get incorrect
results.
<P>
You should not need to call this function under normal
circumstances. This function is likely to have undesirable
side-effects on drawing code that is called after your
drawing code. Additionally, if your code is included as
part of a composite drawing, you will not get correct
results if you call this function.
</DD></DL>
<P>
<A NAME="vdrawIntersectsClip"><HR><H4>vdrawIntersectsClip</H4></A>
<PRE>
        int <B>vdrawIntersectsClip</B>(
                const vrect * rect);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the rectangle
<SAMP>rect</SAMP> intersects the current clipping path,
<SAMP>FALSE</SAMP> if it does not.
</DD></DL>
<P>
<A NAME="vdrawIntersectsViewClip"><HR><H4>vdrawIntersectsViewClip</H4></A>
<PRE>
        int <B>vdrawIntersectsViewClip</B>(
                const vrect * rect);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the rectangle
<SAMP>rect</SAMP> intersects the current view clipping
path, <SAMP>FALSE</SAMP> if it does not. This function can
be called during an update event to determine which objects
need to be drawn.
</DD></DL>
<P>
<A NAME="vdrawKeyStrokeShow"><HR><H4>vdrawKeyStrokeShow</H4></A>
<PRE>
        void <B>vdrawKeyStrokeShow</B>(
                vkeyStroke key);
</PRE>

<DL><DD>
Draws a user-readable representation of the keystroke
<SAMP>key</SAMP> with its origin at the current point and
offsets the current point by the width of the keystroke
glyph(s). Keystrokes are drawn using symbols appropriate to
the current look and feel.
</DD></DL>
<P>
<A NAME="vdrawLineTo"><HR><H4>vdrawLineTo</H4></A>
<PRE>
        void <B>vdrawLineTo</B>(
                int x,
                int y);
</PRE>

<DL><DD>
Appends a line segment to the current path. The resulting
line has as its endpoints the initial current point and
<SAMP>x,y</SAMP>. (See figure). The current point is moved
to <SAMP>x,y</SAMP>.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
<P>
<BLOCKQUOTE>
Figure: Operation of LineTo functions
<P>
<IMG SRC="Drawing.Operation_of_LineTo.gif">
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawMaskDevice"><HR><H4>vdrawMaskDevice</H4></A>
<PRE>
        void <B>vdrawMaskDevice</B>(
                vimage * image);
</PRE>

<DL><DD>
Establishes themask <SAMP>image</SAMP> as the target of
drawing operations from the current gstate. Drawing
operations then leave marks on the mask instead of on the
device previously in the gstate. This function sets the
current transformation matrix to reflect the resolution and
orientation of the screen, and sets the current clipping
path to the mask bounds. Mask devices ignore the current
color attribute of the gstate and use solely the function
attribute to determine pixel values. Use
<CODE>vdrawFUNC_SET</CODE> and <CODE>vdrawFUNC_CLEAR</CODE>
to specify 1 and 0 pixels, respectively. 
<P>
Mask images must be one bit deep. Masks suitable for off-screen rendering
can be obtained from the Image class with the function
<CODE><A HREF="vimage-x.html#vimageCreateSpecific"><CODE>vimageCreateSpecific</CODE></A></CODE>.The following code, for
example, renders a on a mask, then pours the current color
through the mask on the current device at the location
(100, 100):
<P>
<BLOCKQUOTE>

<PRE>
<A HREF="vimage-x.html#vimage"><CODE>vimage</CODE></A> *image;
image = <A HREF="vimage-x.html#vimageCreateSpecific"><CODE>vimageCreateSpecific</CODE></A>(100, 100, 2);
<A HREF="vdraw-x.html#vdrawGSave"><CODE>vdrawGSave</CODE></A>();
vdrawMaskDevice(image);
<A HREF="vdraw-x.html#vdrawSetFunction"><CODE>vdrawSetFunction</CODE></A>(vdrawFUNC_CLEAR);
<A HREF="vdraw-x.html#vdrawRectFill"><CODE>vdrawRectFill</CODE></A>(0, 0, 100, 100);
<A HREF="vdraw-x.html#vdrawSetFunction"><CODE>vdrawSetFunction</CODE></A>(vdrawFUNC_SET);
<A HREF="vdraw-x.html#vdrawArc"><CODE>vdrawArc</CODE></A>(50, 50, 40, 0, 360);
<A HREF="vdraw-x.html#vdrawFill"><CODE>vdrawFill</CODE></A>();
<A HREF="vdraw-x.html#vdrawGRestore"><CODE>vdrawGRestore</CODE></A>();
<A HREF="vdraw-x.html#vdrawMoveTo"><CODE>vdrawMoveTo</CODE></A>(100, 100);
<A HREF="vdraw-x.html#vdrawImageMaskIdent"><CODE>vdrawImageMaskIdent</CODE></A>(image);
<A HREF="vimage-x.html#vimageDestroy"><CODE>vimageDestroy</CODE></A>(image);
</PRE>

</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawMaskPath"><HR><H4>vdrawMaskPath</H4></A>
<PRE>
        void <B>vdrawMaskPath</B>(
                vimage * mask,
                const vmatrix * mtx);
</PRE>

<DL><DD>
Appends the mask <SAMP>mask</SAMP> to the current path,
using the matrix <SAMP>mtx</SAMP> to specify the coordinate
system of the mask. A one pixel value in <SAMP>mask</SAMP>
specifies that the path should enclose the bounds of the
pixel, while a zero value indicates that the resulting path
should not enclose it. The mask is rendered efficiently if
the path is subsequently used in a clip or fill operation,
but may be expensive for other kinds of operations.
</DD></DL>
<P>
<A NAME="vdrawMaskPathIdent"><HR><H4>vdrawMaskPathIdent</H4></A>
<PRE>
        void <B>vdrawMaskPathIdent</B>(
                vimage * mask);
</PRE>

<DL><DD>
Appends the mask <SAMP>mask</SAMP> to the current path. The
origin of the mask is located at the current point and each
pixel of the mask is sampled at the scale of one user space
unit. A one pixel value in <SAMP>mask</SAMP> specifies that
the path should enclose the bounds of the pixel, while a
zero value indicates that the resulting path should not
enclose it. The mask is rendered efficiently if the path is
subsequently used in a clip or fill operation, but may be
expensive for other kinds of operations.
</DD></DL>
<P>
<A NAME="vdrawMoveTo"><HR><H4>vdrawMoveTo</H4></A>
<PRE>
        void <B>vdrawMoveTo</B>(
                int x,
                int y);
</PRE>

<DL><DD>
Begins a new subpath of the current path and sets the
current point to the position <SAMP>x,y</SAMP>. (See
figure).
<P>
<BLOCKQUOTE>
Figure: Operation of vdrawMoveTo
<P>
<IMG SRC="Drawing.Operation_of_vdrawMoveTo.gif">
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawNewPath"><HR><H4>vdrawNewPath</H4></A>
<PRE>
        void <B>vdrawNewPath</B>();
</PRE>

<DL><DD>
Clears the current path and undefines the current point.
</DD></DL>
<P>
<A NAME="vdrawNextPathIterator"><HR><H4>vdrawNextPathIterator</H4></A>
<PRE>
        int <B>vdrawNextPathIterator</B>(
                vdrawPathIterator * iterator);
</PRE>

<DL><DD>
Performs the next step of the iteration represented by
<SAMP>iterator</SAMP> and returns <SAMP>TRUE</SAMP> if a
path element is available, <SAMP>FALSE</SAMP> if not. The
path element type can be retrieved from the iterator with
<CODE><A HREF="vdraw-x.html#vdrawGetPathIteratorType"><CODE>vdrawGetPathIteratorType</CODE></A></CODE>. The coordinates of
the element can be retrieved with the various
<CODE><A HREF="vdraw-x.html#vdrawFGetPathIteratorX"><CODE>vdrawFGetPathIteratorX</CODE></A>/Y</CODE> functions. For
example, the following code fragment averages the
coordinates of all the elements of the current path:
  <P>
<BLOCKQUOTE>


<PRE>

<A HREF="vdraw-x.html#vdrawPathIterator"><CODE>vdrawPathIterator</CODE></A> iterator;
double      x, y;
int        count;
<A HREF="vdraw-x.html#vdrawInitPathIterator"><CODE>vdrawInitPathIterator</CODE></A>(&iterator);
x = y = 0.0;
count = 0;
while (vdrawNextPathIterator(&iterator))
  switch (<A HREF="vdraw-x.html#vdrawGetPathIteratorType"><CODE>vdrawGetPathIteratorType</CODE></A>(&iterator))
  {
  case vdrawPATH_MOVE:
  case vdrawPATH_LINE:
    x += <A HREF="vdraw-x.html#vdrawFGetPathIteratorX"><CODE>vdrawFGetPathIteratorX</CODE></A>(&iterator);
    y += <A HREF="vdraw-x.html#vdrawFGetPathIteratorY"><CODE>vdrawFGetPathIteratorY</CODE></A>(&iterator);
    count++;
    break;
  case vdrawPATH_CURVE:
    x += <A HREF="vdraw-x.html#vdrawFGetPathIteratorX1"><CODE>vdrawFGetPathIteratorX1</CODE></A>(&iterator);
    y += <A HREF="vdraw-x.html#vdrawFGetPathIteratorY1"><CODE>vdrawFGetPathIteratorY1</CODE></A>(&iterator);
    x += <A HREF="vdraw-x.html#vdrawFGetPathIteratorX2"><CODE>vdrawFGetPathIteratorX2</CODE></A>(&iterator);
    y += <A HREF="vdraw-x.html#vdrawFGetPathIteratorY2"><CODE>vdrawFGetPathIteratorY2</CODE></A>(&iterator);
    x += <A HREF="vdraw-x.html#vdrawFGetPathIteratorX3"><CODE>vdrawFGetPathIteratorX3</CODE></A>(&iterator);
    y += <A HREF="vdraw-x.html#vdrawFGetPathIteratorY3"><CODE>vdrawFGetPathIteratorY3</CODE></A>(&iterator);
    count += 3;
    break;
  default:
    break;
  }
<A HREF="vdraw-x.html#vdrawDestroyPathIterator"><CODE>vdrawDestroyPathIterator</CODE></A>(&iterator);
x /= count;
y /= count;

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawNullDevice"><HR><H4>vdrawNullDevice</H4></A>
<PRE>
        void <B>vdrawNullDevice</B>();
</PRE>

<DL><DD>
Establishes a null singularity as the device for drawing
operations from the current gstate. Drawing operations
directed to the null device do not make any marks but
produce normal side effects. This function sets the current
transformation matrix to the identity matrix and the
current clipping path to a point at the origin, which
effectively clips out the entire coordinate system.
</DD></DL>
<P>
<A NAME="vdrawNullDriver"><HR><H4>vdrawNullDriver</H4></A>
<PRE>
        const vdrawDriver * <B>vdrawNullDriver</B>();
</PRE>

<DL><DD>
Returns the null device driver, which should be used by
devices that require custom high-level behavior, but not
custom, low-level behavior. See the section
<CODE><A HREF="vdraw-x.html#vdrawSetDevice"><CODE>vdrawSetDevice</CODE></A></CODE> for further information.
</DD></DL>
<P>
<A NAME="vdrawPathBounds"><HR><H4>vdrawPathBounds</H4></A>
<PRE>
        void <B>vdrawPathBounds</B>(
                const vrect ** rects,
                int * count);
</PRE>

<DL><DD>
Computes a set of bounding boxes that enclose the current
path. This function then returns the box coordinates in
<SAMP>rects</SAMP> and the number of boxes in
<SAMP>count</SAMP>. Depending on the window system, the
function either returns a bounding box for each individual
subpath, or returns a single bounding box for the entire
current path. The bounding box of a subpath is the smallest
rectangle that encloses all points along the subpath (see
figure). This function does not take line width into
account. If the subpath contains curves, the bounding box
is computed to enclose all control points of the curves;
this can lead to an overly large bounding box. 
<P>
To generate a true bounding box, call <CODE><A HREF="vdraw-x.html#vdrawFlattenPath"><CODE>vdrawFlattenPath</CODE></A></CODE>
first to produce a line approximation of any curve segments
in the path. The bounding box subsequently returned by
<CODE><A HREF="vdraw-x.html#vdrawFPathBounds"><CODE>vdrawFPathBounds</CODE></A></CODE> is a true bounding box. This
function takes the bounding box of the path in device space
and returns the user space bounding box of the device space
bounding box. The box returned may be larger than expected
if the user space coordinate axes are not aligned with the
device space coordinate axes. The pointer returned by this
call can be used until the next call to the Drawing
class. Use <CODE><A HREF="vrect-x.html#vrectCloneSet"><CODE>vrectCloneSet</CODE></A></CODE> (a Plane Geometry
class function) to copy the rectangles if persistence is
desired.
<P>
<BLOCKQUOTE>
Figure: Operation of <A HREF="vdraw-x.html#vdrawFPathBounds"><CODE>vdrawFPathBounds</CODE></A>
<P>
<IMG SRC="Drawing.Operation_of_vdrawFPa.gif">
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawRCurveTo"><HR><H4>vdrawRCurveTo</H4></A>
<PRE>
        void <B>vdrawRCurveTo</B>(
                int dx1,
                int dy1,
                int dx2,
                int dy2,
                int dx3,
                int dy3);
</PRE>

<DL><DD>
Appends a Bezier curve segmentto the current path. The
curve begins at the current point (<SAMP>x0,y0</SAMP> in
the figure) and ends at <SAMP>(x3,y3)</SAMP>. All arguments are
measured relative to the current point. The point
<SAMP>(x1,y1)</SAMP> is offset from <SAMP>(x0,y0)</SAMP> by
<SAMP>(dx1,dy1)</SAMP>; the point <SAMP>(x2,y2)</SAMP> is
offset from <SAMP>(x1,y1)</SAMP> by <SAMP>(dx2,dy2)</SAMP>;
and the point <SAMP>(x3,y3)</SAMP> is offset from
<SAMP>(x2y2)</SAMP> by <SAMP>(dx3,dy3)</SAMP>. Moves the
current point by the sum of <SAMP>(dx1,dy1)</SAMP> plus
<SAMP>(dx2,dy2)</SAMP> plus <SAMP>(dx3,dy3)</SAMP>.
<P>
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawRLineTo"><HR><H4>vdrawRLineTo</H4></A>
<PRE>
        void <B>vdrawRLineTo</B>(
                int dx,
                int dy);
</PRE>

<DL><DD>
Appends a line segment to the current path. Both arguments
are relative to the current point. The resulting line has
as its endpoints the initial current point
<SAMP>x0,y0</SAMP> and the point <SAMP>(x0 + dx, y0 +
dy)</SAMP>. (See figure). The trailing endpoint then becomes
the current point.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
<P>
<BLOCKQUOTE>
Figure: Operation of the RLineTo functions
<P>
<IMG SRC="Drawing.Operation_of_RLineTo.gif">
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawRMoveTo"><HR><H4>vdrawRMoveTo</H4></A>
<PRE>
        void <B>vdrawRMoveTo</B>(
                int dx,
                int dy);
</PRE>

<DL><DD>
Begins a new subpath of the current path and moves the
current point by <SAMP>dx,dy</SAMP>. (See figure).
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
<P>
<BLOCKQUOTE>
Figure: Operation of the RMoveTo functions
<P>
<IMG SRC="Drawing.Operation_of_RMoveTo.gif">
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawRRCurveTo"><HR><H4>vdrawRRCurveTo</H4></A>
<PRE>
        void <B>vdrawRRCurveTo</B>(
                int dx1,
                int dy1,
                int dx2,
                int dy2,
                int dx3,
                int dy3);
</PRE>

<DL><DD>
Appends a Bezier curve segmentto the current path. This
function creates the curve by relative increments, using
arguments that are each an offset from the preceding
argument. (See figure). 
<P>
<SAMP>dx1</SAMP> and <SAMP>dy1</SAMP> are distances 
measured from the initial current point <SAMP>x0, y0</SAMP> 
and define the location of the curve control point <SAMP>x1, y1</SAMP>. 
Arguments <SAMP>dx2</SAMP> and <SAMP>dy2</SAMP> are distances from
<SAMP>x1, y1</SAMP> and give the curve control point,
<SAMP>x2, y2</SAMP>. Arguments <SAMP>dx3</SAMP> and
<SAMP>dy3</SAMP> are distances measured from <SAMP>x2,
y2</SAMP>, and give the trailing endpoint of the curve,
<SAMP>x3, y3</SAMP>. The new current point is <SAMP>x3,
y3</SAMP>, which is distant from the initial current point
by the sum of (<SAMP>dx1, dy1</SAMP> ) plus (<SAMP>dx2,
dy2</SAMP>) plus (<SAMP>dx3, dy3</SAMP>).
<P>
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
<P>
<BLOCKQUOTE>
Figure: Drawing curves with vdrawRRCurveTo
<P>
<IMG SRC="Drawing.Drawing_curves_vdraw.gif">
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawRectArcFill"><HR><H4>vdrawRectArcFill</H4></A>
<PRE>
        void <B>vdrawRectArcFill</B>(
                int x,
                int y,
                int w,
                int h,
                int angle1,
                int angle2);
</PRE>

<DL><DD>
Fills a chord of a single arc that is tangent to the
rectangle <SAMP>x,y,w,h</SAMP> with the current color. The
arc is constructed from <SAMP>angle1</SAMP> to
<SAMP>angle2</SAMP> degrees.
</DD></DL>
<P>
<A NAME="vdrawRectArcFillSector"><HR><H4>vdrawRectArcFillSector</H4></A>
<PRE>
        void <B>vdrawRectArcFillSector</B>(
                int x,
                int y,
                int w,
                int h,
                int angle1,
                int angle2);
</PRE>

<DL><DD>
Fills a sector of single arc that is tangent to the
rectangle <SAMP>x,y,w,h</SAMP> with the current color. The
arc is constructed from <SAMP>angle1</SAMP> to
<SAMP>angle2</SAMP> degrees.
</DD></DL>
<P>
<A NAME="vdrawRectArcStroke"><HR><H4>vdrawRectArcStroke</H4></A>
<PRE>
        void <B>vdrawRectArcStroke</B>(
                int x,
                int y,
                int w,
                int h,
                int angle1,
                int angle2);
</PRE>

<DL><DD>
Outlines a single arc tangent to the rectangle
<SAMP>x,y,w,h</SAMP> with the current color. The arc is
constructed from <SAMP>angle1</SAMP> to <SAMP>angle2</SAMP>
degrees.
</DD></DL>
<P>
<A NAME="vdrawRectArcStrokeInside"><HR><H4>vdrawRectArcStrokeInside</H4></A>
<PRE>
        void <B>vdrawRectArcStrokeInside</B>(
                int x,
                int y,
                int w,
                int h,
                int angle1,
                int angle2);
</PRE>

<DL><DD>
Outlines a single arc tangent to the rectangle
<SAMP>x,y,w,h</SAMP> with the current color while ensuring
that the arc's outline lies within the rectangle. The arc
is constructed from <SAMP>angle1</SAMP> to
<SAMP>angle2</SAMP> degree.
</DD></DL>
<P>
<A NAME="vdrawRectArcs"><HR><H4>vdrawRectArcs</H4></A>
<PRE>
        void <B>vdrawRectArcs</B>(
                const vrect * rects,
                int count,
                int angle1,
                int angle2);
</PRE>

<DL><DD>
Appends <SAMP>count</SAMP> chords of arcs to the current
path such that each arc is tangent to the sides of the
corresponding rectangle in the array <SAMP>rects</SAMP>.
Each arc is constructed from <SAMP>angle1</SAMP> to
<SAMP>angle2</SAMP> counterclockwise degrees.
</DD></DL>
<P>
<A NAME="vdrawRectArcsFill"><HR><H4>vdrawRectArcsFill</H4></A>
<PRE>
        void <B>vdrawRectArcsFill</B>(
                const vrect * rects,
                int count,
                int angle1,
                int angle2);
</PRE>

<DL><DD>
Fills <SAMP>count</SAMP> chords of arcs such that each arc
is tangent to the sides of the corresponding rectangle in
the array <SAMP>rects</SAMP>. Each arc is constructed from
<SAMP>angle1</SAMP> to <SAMP>angle2</SAMP> counterclockwise
degrees.
</DD></DL>
<P>
<A NAME="vdrawRectArcsFillSector"><HR><H4>vdrawRectArcsFillSector</H4></A>
<PRE>
        void <B>vdrawRectArcsFillSector</B>(
                const vrect * rects,
                int count,
                int angle1,
                int angle2);
</PRE>

<DL><DD>
Fills <SAMP>count</SAMP> sectors of arcs such that each arc
is tangent to the sides of the corresponding rectangle in
the array <SAMP>rects</SAMP>. Each arc is constructed from
<SAMP>angle1</SAMP> to <SAMP>angle2</SAMP> counterclockwise
degrees.
</DD></DL>
<P>
<A NAME="vdrawRectArcsSector"><HR><H4>vdrawRectArcsSector</H4></A>
<PRE>
        void <B>vdrawRectArcsSector</B>(
                const vrect * rects,
                int count,
                int angle1,
                int angle2);
</PRE>

<DL><DD>
Appends <SAMP>count</SAMP> sectors of arcs to the current
path such that each arc is tangent to the sides of the
corresponding rectangle in the array <SAMP>rects</SAMP>.
Each arc is constructed from <SAMP>angle1</SAMP> to
<SAMP>angle2</SAMP> counterclockwise degrees.
</DD></DL>
<P>
<A NAME="vdrawRectArcsStroke"><HR><H4>vdrawRectArcsStroke</H4></A>
<PRE>
        void <B>vdrawRectArcsStroke</B>(
                const vrect * rects,
                int count,
                int angle1,
                int angle2);
</PRE>

<DL><DD>
Strokes <SAMP>count</SAMP> arcs such that each arc is
tangent to the sides of the corresponding rectangle in the
array <SAMP>rects</SAMP>. Each arc is constructed from
<SAMP>angle1</SAMP> to <SAMP>angle2</SAMP> counterclockwise
degrees.
</DD></DL>
<P>
<A NAME="vdrawRectArcsStrokeInside"><HR><H4>vdrawRectArcsStrokeInside</H4></A>
<PRE>
        void <B>vdrawRectArcsStrokeInside</B>(
                const vrect * rects,
                int count,
                int angle1,
                int angle2);
</PRE>

<DL><DD>
Strokes <SAMP>count</SAMP> arcs such that outline of each
arc (as determined by the current line width) is tangent to
the sides of the corresponding rectangle in the array
<SAMP>rects</SAMP>. Each arc is constructed from
<SAMP>angle1</SAMP> to <SAMP>angle2</SAMP> counterclockwise
degrees.
</DD></DL>
<P>
<A NAME="vdrawRectClip"><HR><H4>vdrawRectClip</H4></A>
<PRE>
        void <B>vdrawRectClip</B>(
                int x,
                int y,
                int w,
                int h);
</PRE>

<DL><DD>
Intersects the current clipping path with the rectangle
<SAMP>x,y,w,h</SAMP> and stores the intersection as the new
clipping path.
</DD></DL>
<P>
<A NAME="vdrawRectEllipseFill"><HR><H4>vdrawRectEllipseFill</H4></A>
<PRE>
        void <B>vdrawRectEllipseFill</B>(
                int x,
                int y,
                int w,
                int h);
</PRE>

<DL><DD>
Fills a single ellipse tangent to the rectangle
<SAMP>x,y,w,h</SAMP> with the current color.
</DD></DL>
<P>
<A NAME="vdrawRectEllipseStroke"><HR><H4>vdrawRectEllipseStroke</H4></A>
<PRE>
        void <B>vdrawRectEllipseStroke</B>(
                int x,
                int y,
                int w,
                int h);
</PRE>

<DL><DD>
Outlines a single ellipse tangent to the rectangle
<SAMP>x,y,w,h</SAMP> with the current color.
</DD></DL>
<P>
<A NAME="vdrawRectEllipseStrokeInside"><HR><H4>vdrawRectEllipseStrokeInside</H4></A>
<PRE>
        void <B>vdrawRectEllipseStrokeInside</B>(
                int x,
                int y,
                int w,
                int h);
</PRE>

<DL><DD>
Outlines a single ellipse tangent to the rectangle
<SAMP>x,y,w,h</SAMP> with the current color while ensuring
that the outline lies within the rectangle.
</DD></DL>
<P>
<A NAME="vdrawRectEllipses"><HR><H4>vdrawRectEllipses</H4></A>
<PRE>
        void <B>vdrawRectEllipses</B>(
                const vrect * rects,
                int count);
</PRE>

<DL><DD>
Appends <SAMP>count</SAMP> arcs to the current path such
that each arc is an ellipse tangent to the sides of the
corresponding rectangle in the array <SAMP>rects</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawRectEllipsesFill"><HR><H4>vdrawRectEllipsesFill</H4></A>
<PRE>
        void <B>vdrawRectEllipsesFill</B>(
                const vrect * rects,
                int count);
</PRE>

<DL><DD>
Fills <SAMP>count</SAMP> arcs such that each arc is an
ellipse tangent to the sides of the corresponding rectangle
in the array <SAMP>rects</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawRectEllipsesStroke"><HR><H4>vdrawRectEllipsesStroke</H4></A>
<PRE>
        void <B>vdrawRectEllipsesStroke</B>(
                const vrect * rects,
                int count);
</PRE>

<DL><DD>
Outlines <SAMP>count</SAMP> arcs such that each arc is an
ellipse tangent to the sides of the corresponding rectangle
in the array <SAMP>rects</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawRectEllipsesStrokeInside"><HR><H4>vdrawRectEllipsesStrokeInside</H4></A>
<PRE>
        void <B>vdrawRectEllipsesStrokeInside</B>(
                const vrect * rects,
                int count);
</PRE>

<DL><DD>
Outlines <SAMP>count</SAMP> arcs such that the outline of
each arc (as determined by the current line width) is an
ellipse tangent to the sides of the corresponding rectangle
in the array <SAMP>rects</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawRectFill"><HR><H4>vdrawRectFill</H4></A>
<PRE>
        void <B>vdrawRectFill</B>(
                int x,
                int y,
                int w,
                int h);
</PRE>

<DL><DD>
Fills the rectangle <SAMP>x,y,w,h</SAMP> with the current
color.
</DD></DL>
<P>
<A NAME="vdrawRectHiliteFill"><HR><H4>vdrawRectHiliteFill</H4></A>
<PRE>
        void <B>vdrawRectHiliteFill</B>(
                int x,
                int y,
                int w,
                int h,
                vcolor * interior,
                vcolor * top,
                vcolor * bottom);
</PRE>

<DL><DD>
Draws the ``slab'' rectangle designated by
<SAMP>x,y,w,h</SAMP> using <SAMP>interior</SAMP> as an
interior color and <SAMP>top</SAMP> and <SAMP>bottom</SAMP>
as shadow colors. If any color is <SAMP>NULL</SAMP>, that
portion of the rectangle is not drawn. 
<P>
Refer to the section
<CODE><A HREF="vdraw-x.html#vdrawRectsHiliteFill"><CODE>vdrawRectsHiliteFill</CODE></A></CODE> for more detailed
information.
</DD></DL>
<P>
<A NAME="vdrawRectHiliteFillInside"><HR><H4>vdrawRectHiliteFillInside</H4></A>
<PRE>
        void <B>vdrawRectHiliteFillInside</B>(
                int x,
                int y,
                int w,
                int h,
                vcolor * interior,
                vcolor * top,
                vcolor * bottom);
</PRE>

<DL><DD>
Draws the inside of the ``slab'' rectangle designated by
<SAMP>x,y,w,h</SAMP> using <SAMP>interior</SAMP> for the
interior color and <SAMP>top</SAMP> and <SAMP>bottom</SAMP>
for the shadow colors. If any color is <SAMP>NULL</SAMP>,
that portion of the rectangle is not drawn. 
<P>
Refer to the section <CODE><A HREF="vdraw-x.html#vdrawRectsHiliteFill"><CODE>vdrawRectsHiliteFill</CODE></A></CODE> for more detailed
information.
</DD></DL>
<P>
<A NAME="vdrawRectHiliteStroke"><HR><H4>vdrawRectHiliteStroke</H4></A>
<PRE>
        void <B>vdrawRectHiliteStroke</B>(
                int x,
                int y,
                int w,
                int h,
                vcolor * top,
                vcolor * bottom);
</PRE>

<DL><DD>
Outlines the ``etched'' rectangle designated by
<SAMP>x,y,w,h</SAMP> using <SAMP>top</SAMP> and
<SAMP>bottom</SAMP> for the shadow colors. If either color
is <SAMP>NULL</SAMP>, that portion of the rectangle is not
drawn. 
<P>
Refer to the section <CODE><A HREF="vdraw-x.html#vdrawRectsHiliteStroke"><CODE>vdrawRectsHiliteStroke</CODE></A></CODE> for
more detailed information.
</DD></DL>
<P>
<A NAME="vdrawRectHiliteStrokeInside"><HR><H4>vdrawRectHiliteStrokeInside</H4></A>
<PRE>
        void <B>vdrawRectHiliteStrokeInside</B>(
                int x,
                int y,
                int w,
                int h,
                vcolor * top,
                vcolor * bottom);
</PRE>

<DL><DD>
Outlines the inside of the ``etched'' rectangle designated
by <SAMP>x,y,w,h</SAMP> with <SAMP>top</SAMP> and
<SAMP>bottom</SAMP> as shadow colors. If either color is
<SAMP>NULL</SAMP>, that portion of the rectangle is not
drawn.
<P>
Refer to the section <CODE><A HREF="vdraw-x.html#vdrawRectsHiliteStroke"><CODE>vdrawRectsHiliteStroke</CODE></A></CODE> for
more detailed information.
</DD></DL>
<P>
<A NAME="vdrawRectImage"><HR><H4>vdrawRectImage</H4></A>
<PRE>
        void <B>vdrawRectImage</B>(
                vimage * image,
                const vrect * source,
                const vrect * dest);
</PRE>

<DL><DD>
Renders a portion of the image <SAMP>image</SAMP> specified
by the rectangle <SAMP>source</SAMP> into the rectangle
<SAMP>dest</SAMP> in the user space coordinate system.
<SAMP>source</SAMP> is a rectangle in image coordinates
that specifies which pixels of the image should be
rendered. <SAMP>source</SAMP> can exceed the bounds of the
image itself. In this case, the image is tiled as much as
necessary to enclose the desired area.
</DD></DL>
<P>
<A NAME="vdrawRectImageComposite"><HR><H4>vdrawRectImageComposite</H4></A>
<PRE>
        void <B>vdrawRectImageComposite</B>(
                vimage * image,
                const vrect * source,
                const vrect * dest);
</PRE>

<DL><DD>
Renders a portion of the image <SAMP>image</SAMP> specified
by the rectangle <SAMP>source</SAMP> into the rectangle
<SAMP>dest</SAMP> in the user space coordinate system using
a compositing operation. <SAMP>source</SAMP> is a rectangle
in image coordinates that specifies which pixels of the
image should be rendered. <SAMP>source</SAMP> can exceed
the bounds of the image itself. In this case, the image is
tiled as much as necessary to enclose the desired area.
<P>
The <CODE>Transparency</CODE> attribute of the image, if any,
determines where the image is transparent and where it is
opaque. Transparency pixels set to one indicate an opaque
image pixel, while transparency pixels set to zero indicate
transparent image pixel. The transparency image must have
depth of one. 
<P>
This function may ignore the
<CODE>Transparency</CODE> attribute for some devices, most
notably PostScript printers.
</DD></DL>
<P>
<A NAME="vdrawRectImageCompositeIdent"><HR><H4>vdrawRectImageCompositeIdent</H4></A>
<PRE>
        void <B>vdrawRectImageCompositeIdent</B>(
                vimage * image,
                const vrect * source);
</PRE>

<DL><DD>
Renders a portion of the image <SAMP>image</SAMP> specified
by the rectangle <SAMP>source</SAMP> using a compositing
operation, such that the rectangle is located at the
current point and each pixel of the image is drawn at the
scale of one user space unit. <SAMP>source</SAMP> is a
rectangle in image coordinates that specifies which pixels
of the image should be rendered. <SAMP>source</SAMP> can
exceed the bounds of the image itself. In this case, the
image is tiled as much as necessary to enclose the desired
area. 
<P>
The <CODE>Transparency</CODE> attribute of the image,
if any, determines where the image is transparent and where
it is opaque. Transparency pixels set to one indicate an
opaque image pixel, while transparency pixels set to zero
indicate transparent image pixel. The transparency image
must have depth of one. 
<P>
This function may ignore the <CODE>Transparency</CODE> 
attribute for some devices, most notably PostScript printers.
</DD></DL>
<P>
<A NAME="vdrawRectImageIdent"><HR><H4>vdrawRectImageIdent</H4></A>
<PRE>
        void <B>vdrawRectImageIdent</B>(
                vimage * image,
                const vrect * source);
</PRE>

<DL><DD>
Renders a portion of the image <SAMP>image</SAMP> specified
by the rectangle <SAMP>source</SAMP> such that the
rectangle is located at the current point and each pixel of
the image is drawn at the scale of one user space unit.
<SAMP>source</SAMP> is a rectangle in image coordinates
that specifies which pixels of the image should be
rendered. <SAMP>source</SAMP> can exceed the bounds of the
image itself. In this case, the image is tiled as much as
necessary to enclose the desired area.
</DD></DL>
<P>
<A NAME="vdrawRectImageMask"><HR><H4>vdrawRectImageMask</H4></A>
<PRE>
        void <B>vdrawRectImageMask</B>(
                vimage * mask,
                const vrect * source,
                const vrect * dest);
</PRE>

<DL><DD>
Renders a portion of the mask <SAMP>mask</SAMP> specified
by the rectangle <SAMP>source</SAMP> into the rectangle
<SAMP>dest</SAMP> in the user space coordinate system.
<P>
<SAMP>source</SAMP> is a rectangle in image coordinates
that specifies which pixels of the mask should be rendered.
<SAMP>source</SAMP> can exceed the bounds of the mask
itself. In this case, the mask is tiled as much as
necessary to enclose the desired area. The mask is used as
a filter for the current color. A zero pixel value in
<SAMP>mask</SAMP> specifies that color should not appear
inside the bounds of the pixel, while a one value indicates
that color should appear. The mask must have a depth of
one.
</DD></DL>
<P>
<A NAME="vdrawRectImageMaskIdent"><HR><H4>vdrawRectImageMaskIdent</H4></A>
<PRE>
        void <B>vdrawRectImageMaskIdent</B>(
                vimage * mask,
                const vrect * source);
</PRE>

<DL><DD>
Renders a portion of the mask <SAMP>mask</SAMP> specified
by the rectangle <SAMP>source</SAMP> such that the
rectangle is located at the current point and each pixel of
the mask is drawn at the scale of one user space unit.
<P>
<SAMP>source</SAMP> is a rectangle in image coordinates
that specifies which pixels of the mask should be rendered.
<SAMP>source</SAMP> can exceed the bounds of the mask
itself. In this case, the image is tiled as much as
necessary to enclose the desired area. The mask is used as
a filter for the current color. A zero pixel value in
<SAMP>mask</SAMP> specifies that color should not appear
inside the bounds of the pixel, while a one value indicates
that color should appear. The mask must have a depth of
one.
</DD></DL>
<P>
<A NAME="vdrawRectShow"><HR><H4>vdrawRectShow</H4></A>
<PRE>
        void <B>vdrawRectShow</B>(
                const vchar * s,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font inside
the rectangle <SAMP>rect</SAMP>. The characters of the
string are clipped to the edges of <SAMP>rect</SAMP>. The
string is drawn with its left edge on the left edge of
<SAMP>rect</SAMP> and with its baseline <I>descent</I>
units above the bottom edge of <SAMP>rect</SAMP>, where
<I>descent</I> is the descent of the current font.
</DD></DL>
<P>
<A NAME="vdrawRectShowCenter"><HR><H4>vdrawRectShowCenter</H4></A>
<PRE>
        void <B>vdrawRectShowCenter</B>(
                const vchar * s,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font inside
the rectangle <SAMP>rect</SAMP>. The characters of the
string are clipped to the edges of <SAMP>rect</SAMP>. This
function centers the string inside <SAMP>rect</SAMP> along
both axes.
</DD></DL>
<P>
<A NAME="vdrawRectShowCenterX"><HR><H4>vdrawRectShowCenterX</H4></A>
<PRE>
        void <B>vdrawRectShowCenterX</B>(
                const vchar * s,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font inside
the rectangle <SAMP>rect</SAMP>. The characters of the
string are clipped to the edges of <SAMP>rect</SAMP>. The
string is drawn with its baseline <I>descent</I> units
above the bottom edge of <SAMP>rect</SAMP>, where
<I>descent</I> is the descent of the current font. The
string is drawn centered inside <SAMP>rect</SAMP> along its
x axis.
</DD></DL>
<P>
<A NAME="vdrawRectShowCenterY"><HR><H4>vdrawRectShowCenterY</H4></A>
<PRE>
        void <B>vdrawRectShowCenterY</B>(
                const vchar * s,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font inside
the rectangle <SAMP>rect</SAMP>. The characters of the
string are clipped to the edges of <SAMP>rect</SAMP>. The
string is drawn with its left edge on the left edge of
<SAMP>rect</SAMP>. The string is drawn centered inside
<SAMP>rect</SAMP> along its y axis.
</DD></DL>
<P>
<A NAME="vdrawRectShowMnemonic"><HR><H4>vdrawRectShowMnemonic</H4></A>
<PRE>
        void <B>vdrawRectShowMnemonic</B>(
                const vchar * title,
                int mnemonic,
                const vrect * rect,
                unsigned int flags);
</PRE>

<DL><DD>
Draws the string <SAMP>title</SAMP> inside the rectangle
<SAMP>rect</SAMP> with the character <SAMP>mnemonic</SAMP>
underlined. <SAMP>flags</SAMP> indicates how the string
should be centered. Use the constant
<SAMP>vdrawShow_X</SAMP> to center the string horizontally,
<SAMP>vdrawShow_Y</SAMP> to center the string vertically,
and <SAMP>vdrawShow_X | vdrawShow_Y</SAMP> to center the
string both horizontally and vertically.
</DD></DL>
<P>
<A NAME="vdrawRectStroke"><HR><H4>vdrawRectStroke</H4></A>
<PRE>
        void <B>vdrawRectStroke</B>(
                int x,
                int y,
                int w,
                int h);
</PRE>

<DL><DD>
Outlines the rectangle <SAMP>x,y,w,h</SAMP> with the
current line style.
</DD></DL>
<P>
<A NAME="vdrawRectStrokeInside"><HR><H4>vdrawRectStrokeInside</H4></A>
<PRE>
        void <B>vdrawRectStrokeInside</B>(
                int x,
                int y,
                int w,
                int h);
</PRE>

<DL><DD>
Outlines the inside of the rectangle <SAMP>x,y,w,h</SAMP>
with the current line style.
</DD></DL>
<P>
<A NAME="vdrawRects"><HR><H4>vdrawRects</H4></A>
<PRE>
        void <B>vdrawRects</B>(
                const vrect * rects,
                int count);
</PRE>

<DL><DD>
Constructs a path of line segments that encloses the
rectangles in <SAMP>rects</SAMP>. There are
<SAMP>count</SAMP> rectangles. Each rectangle is
constructed in its own closed subpath. If the rectangles
are to be immediately rendered, calling a rectangle
rendering operation, such as <CODE><A HREF="vdraw-x.html#vdrawRectsFill"><CODE>vdrawRectsFill</CODE></A></CODE>,
is likely to be much more efficient than calling this
function and rendering the resulting path.
</DD></DL>
<P>
<A NAME="vdrawRectsClip"><HR><H4>vdrawRectsClip</H4></A>
<PRE>
        void <B>vdrawRectsClip</B>(
                const vrect * rects,
                int count);
</PRE>

<DL><DD>
Intersects the current clipping path with the union of the
rectangles in <SAMP>rects</SAMP>, stores it as the new
clipping path, and begins a new current path. There are
<SAMP>count</SAMP> rectangles in <SAMP>rects</SAMP>. This
function is usually much more efficient than constructing
rectangular paths and clipping to them.
</DD></DL>
<P>
<A NAME="vdrawRectsFill"><HR><H4>vdrawRectsFill</H4></A>
<PRE>
        void <B>vdrawRectsFill</B>(
                const vrect * rects,
                int count);
</PRE>

<DL><DD>
Fills each rectangle in the array <SAMP>rects</SAMP> with
the current color. There are <SAMP>count</SAMP> rectangles.
This does not affect the current path. This function is
usually more efficient than constructing rectangular paths
and filling them.
</DD></DL>
<P>
<A NAME="vdrawRectsHiliteFill"><HR><H4>vdrawRectsHiliteFill</H4></A>
<PRE>
        void <B>vdrawRectsHiliteFill</B>(
                const vrect * rects,
                int count,
                vcolor * interior,
                vcolor * top,
                vcolor * bottom);
</PRE>

<DL><DD>
Draws ``slab'' rectangles specified by <SAMP>rects</SAMP>
using <SAMP>interior</SAMP> for the interior color and
<SAMP>top</SAMP> and <SAMP>bottom</SAMP> for the shadow
colors. There are <SAMP>count</SAMP> rectangles in
<SAMP>rects</SAMP>. The shadow of each rectangle is drawn
with the current line width centered on the rectangle's
edges. (See figure). 
<P>
You can obtain colors suitable for 3D highlighting with a given object's
<CODE>DetermineColor</CODE> function. The following list presents 
the necessary calls and their functions.
<P>

<DL>

<DT><SAMP>window</SAMP>,<SAMP><A HREF="vwindow-x.html#vwindowDetermineColor"><CODE>vwindowDetermineColor</CODE></A>(window,
vdrawCOLOR_SHADOW_TOP)</SAMP>
<DD>Determine the top shadow color of the window.

<DT>Use <CODE>vdrawCOLOR_SHADOW_TOP</CODE> for <SAMP>top</SAMP>
and <CODE>vdrawCOLOR_SHADOW_BOTTOM</CODE> for <SAMP>bottom</SAMP> 
<DD>Create an embossed (raised) effect. 
Reverse the two colors for a debossed (inset) effect. 

<DT>Use <CODE>vdrawCOLOR_BACKGROUND_EMBOSS</CODE> or
<CODE>vdrawCOLOR_BACKGROUND_DEBOSS</CODE> for <SAMP>interior</SAMP> 
<DD>Accentuate the background of the rectangles. 

</DL>

<P>
If any color argument is <SAMP>NULL</SAMP>,
that portion of the highlighted rectangles is not drawn.
The following code fragment illustrates how to draw
embossed and debossed ``slab'' rectangles inside a window:
<P>
<BLOCKQUOTE>

<PRE>

<A HREF="vwindow-x.html#vwindow"><CODE>vwindow</CODE></A>  *window;  /* contains the window to draw in */
<A HREF="vcolor-x.html#vcolor"><CODE>vcolor</CODE></A>  *colors[4];
<A HREF="vrect-x.html#vrect"><CODE>vrect</CODE></A>   emboss, deboss;
static int colorIDs[4] = {
  vdrawCOLOR_BACKGROUND_EMBOSS,
  vdrawCOLOR_BACKGROUND_DEBOSS,
  vdrawCOLOR_SHADOW_TOP,
  vdrawCOLOR_SHADOW_BOTTOM
};
emboss.x = 100;
emboss.y = 100;
emboss.w = emboss.h = 100;
deboss.x = 300;
deboss.y = 100;
deboss.w = deboss.h = 100;
<A HREF="vwindow-x.html#vwindowDetermineColors"><CODE>vwindowDetermineColors</CODE></A>(window, colorIDs, 4, colors);
<A HREF="vdraw-x.html#vdrawGSave"><CODE>vdrawGSave</CODE></A>();
<A HREF="vwindow-x.html#vwindowDrawDevice"><CODE>vwindowDrawDevice</CODE></A>(window);
vdrawRectsHiliteFill(&emboss, 1, colors[0], colors[2], colors[3]);
vdrawRectsHiliteFill(&deboss, 1, colors[1], colors[3], colors[2]);
<A HREF="vdraw-x.html#vdrawGRestore"><CODE>vdrawGRestore</CODE></A>();

</PRE>
</BLOCKQUOTE>

<P>
<BLOCKQUOTE>
Figure: 3D Highlighting Functions
<P>
<IMG SRC="Drawing.Highlighting_Funct.gif">
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawRectsHiliteFillInside"><HR><H4>vdrawRectsHiliteFillInside</H4></A>
<PRE>
        void <B>vdrawRectsHiliteFillInside</B>(
                const vrect * rects,
                int count,
                vcolor * interior,
                vcolor * top,
                vcolor * bottom);
</PRE>

<DL><DD>
Outlines the rectangles addressed by <SAMP>rects</SAMP> in
a manner similar to <CODE>vdrawRectsHiliteFill</CODE>,
except that the shadow outlines are constrained to the
insides of the rectangles, instead of being centered on
them. There are <SAMP>count</SAMP> rectangles.
</DD></DL>
<P>
<A NAME="vdrawRectsHiliteStroke"><HR><H4>vdrawRectsHiliteStroke</H4></A>
<PRE>
        void <B>vdrawRectsHiliteStroke</B>(
                const vrect * rects,
                int count,
                vcolor * top,
                vcolor * bottom);
</PRE>

<DL><DD>
Draws ``etched'' rectangles specified by <SAMP>rects</SAMP>
using <SAMP>top</SAMP> and <SAMP>bottom</SAMP> for the
shadow colors. There are <SAMP>count</SAMP> rectangles in
<SAMP>rects</SAMP>. The shadow of each rectangle is drawn
with the current line width centered on the rectangle's
edges. You can obtain colors suitable for 3D highlighting
with an given object's <CODE>DetermineColor</CODE>
function. The following list presents 
the necessary calls and their functions.
<P>
<DL>

<DT><SAMP>window</SAMP>,<SAMP><A HREF="vwindow-x.html#vwindowDetermineColor"><CODE>vwindowDetermineColor</CODE></A>(window,
vdrawCOLOR_SHADOW_TOP)</SAMP>
<DD>Determine the top shadow color of the window.

<DT>Use <CODE>vdrawCOLOR_SHADOW_TOP</CODE> for <SAMP>top</SAMP>
and <CODE>vdrawCOLOR_SHADOW_BOTTOM</CODE> for <SAMP>bottom</SAMP> 
<DD>Create an embossed (raised) effect. 
Reverse the two colors for a debossed (inset) effect. 

<DT>Use <CODE>vdrawCOLOR_BACKGROUND_EMBOSS</CODE> or
<CODE>vdrawCOLOR_BACKGROUND_DEBOSS</CODE> for <SAMP>interior</SAMP> 
<DD>Accentuate the background of the rectangles. 

</DL>
<P>
If any color argument is <SAMP>NULL</SAMP>, that portion of
the highlighted rectangles is not drawn. The following code
fragment illustrates how to draw embossed and debossed
``etched'' rectangles inside a window.
<P>
<BLOCKQUOTE>
<PRE>

<A HREF="vwindow-x.html#vwindow"><CODE>vwindow</CODE></A>  *window;  /* contains the window to draw in */
<A HREF="vcolor-x.html#vcolor"><CODE>vcolor</CODE></A>  *colors[2];
<A HREF="vrect-x.html#vrect"><CODE>vrect</CODE></A>   emboss, deboss;
static int colorIDs[2] = {
  vdrawCOLOR_SHADOW_TOP,
  vdrawCOLOR_SHADOW_BOTTOM
};
emboss.x = 100;
emboss.y = 100;
emboss.w = emboss.h = 100;
deboss.x = 300;
deboss.y = 100;
deboss.w = deboss.h = 100;
<A HREF="vwindow-x.html#vwindowDetermineColors"><CODE>vwindowDetermineColors</CODE></A>(window, colorIDs, 2, colors);
<A HREF="vdraw-x.html#vdrawGSave"><CODE>vdrawGSave</CODE></A>();
<A HREF="vwindow-x.html#vwindowDrawDevice"><CODE>vwindowDrawDevice</CODE></A>(window);
vdrawRectsHiliteStroke(&emboss, 1, colors[2], colors[3]);
vdrawRectsHiliteStroke(&deboss, 1, colors[3], colors[2]);
<A HREF="vdraw-x.html#vdrawGRestore"><CODE>vdrawGRestore</CODE></A>();

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawRectsHiliteStrokeInside"><HR><H4>vdrawRectsHiliteStrokeInside</H4></A>
<PRE>
        void <B>vdrawRectsHiliteStrokeInside</B>(
                const vrect * rects,
                int count,
                vcolor * top,
                vcolor * bottom);
</PRE>

<DL><DD>
Outlines the rectangles addressed by <SAMP>rects</SAMP> in
a manner similar to <CODE>vdrawRectsHiliteStroke</CODE>,
except that the outlines are constrained to the insides of
the rectangles, instead of being centered on them. (See
Figure). There are <SAMP>count</SAMP> rectangles.
<P>

<BLOCKQUOTE>
Figure: Stroke and stroke-inside functions for highlighting
<P>
<IMG SRC="Drawing.Stroke_and_s-i_for.gif">
</BLOCKQUOTE>

</DD></DL>
<P>
<A NAME="vdrawRectsStroke"><HR><H4>vdrawRectsStroke</H4></A>
<PRE>
        void <B>vdrawRectsStroke</B>(
                const vrect * rects,
                int count);
</PRE>

<DL><DD>
Outlines each rectangle in the array <SAMP>rects</SAMP>
with the current line style. There are <SAMP>count</SAMP>
rectangles. This does not affect the current path. This
function is usually more efficient than constructing
rectangular paths and stroking them.
</DD></DL>
<P>
<A NAME="vdrawRectsStrokeInside"><HR><H4>vdrawRectsStrokeInside</H4></A>
<PRE>
        void <B>vdrawRectsStrokeInside</B>(
                const vrect * rects,
                int count);
</PRE>

<DL><DD>
Outlines the rectangles addressed by <SAMP>rects</SAMP> in
a manner similar to <CODE>vdrawRectsStroke</CODE>, except
that the outlines are constrained to the insides of the
rectangles instead of being centered on them. (See figure).
There are <SAMP>count</SAMP> rectangles.
<P>

<BLOCKQUOTE>
Figure: Stroke and stroke-inside functions for rectangles
<P>
<IMG SRC="Drawing.Stroke_and_s-i_for_r.gif">
</BLOCKQUOTE>

</DD></DL>
<P>
<A NAME="vdrawRectsViewClip"><HR><H4>vdrawRectsViewClip</H4></A>
<PRE>
        void <B>vdrawRectsViewClip</B>(
                const vrect * rects,
                int count);
</PRE>

<DL><DD>
Replaces the view clip with the union of the rectangles in
array <SAMP>rects</SAMP>. There are <SAMP>count</SAMP>
rectangles. The current gstate is not affected. The view
clip is used by the Window class for update region
maintenance and should not be changed otherwise. The view
clip is ignored by some devices.
</DD></DL>
<P>
<A NAME="vdrawRegisterImageDriver"><HR><H4>vdrawRegisterImageDriver</H4></A>
<PRE>
        void <B>vdrawRegisterImageDriver</B>(
                const vdrawDriver * driver,
                unsigned int flags);
</PRE>

<DL><DD>
Registers the device driver for image devices with the
Drawing Manager. The Window class calls this function
during startup to ensure that the Drawing class has
access to window system resources. The image driver is used
to implement complex clipping operations as well as
<CODE><A HREF="vdraw-x.html#vdrawImageDevice"><CODE>vdrawImageDevice</CODE></A></CODE>. This function is not useful
to application programs.
</DD></DL>
<P>
<A NAME="vdrawRegisterKeyStrokeShow"><HR><H4>vdrawRegisterKeyStrokeShow</H4></A>
<PRE>
        void <B>vdrawRegisterKeyStrokeShow</B>(
                vdrawKeyStrokeShowProc proc);
</PRE>

<DL><DD>
Registers a keystroke drawing function with the Drawing
class. This function is used to implement
<CODE><A HREF="vdraw-x.html#vdrawKeyStrokeShow"><CODE>vdrawKeyStrokeShow</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdrawRotate"><HR><H4>vdrawRotate</H4></A>
<PRE>
        void <B>vdrawRotate</B>(
                int angle);
</PRE>

<DL><DD>
Rotates the current coordinate system by <SAMP>angle</SAMP>
degrees counterclockwise by modifying the current
transformation matrix. <SAMP>angle</SAMP> can be negative
for clockwise rotation. Rotation can be visualized as the
turning of the coordinate axes about the origin. (See
Figure). <CODE>vdrawRotate</CODE> is cumulative; that is,
repeating a rotation of 15 degrees results in a total
rotation of 30 degrees.
  <P>
<BLOCKQUOTE>
Figure: Image rotation
  <P>
<IMG SRC="Drawing.Image_rotation.gif"></BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawRoundRectFill"><HR><H4>vdrawRoundRectFill</H4></A>
<PRE>
        void <B>vdrawRoundRectFill</B>(
                int x,
                int y,
                int w,
                int h,
                int r);
</PRE>

<DL><DD>
Fills the round corner rectangle bounded by
<SAMP>x,y,w,h</SAMP> with the current color. The
round-corner rectangle has corners of radius
<SAMP>r</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawRoundRectStroke"><HR><H4>vdrawRoundRectStroke</H4></A>
<PRE>
        void <B>vdrawRoundRectStroke</B>(
                int x,
                int y,
                int w,
                int h,
                int r);
</PRE>

<DL><DD>
Outlines the round corner rectangle bounded by
<SAMP>x,y,w,h</SAMP> with the current color and line style.
The round-corner rectangle has corners of radius
<SAMP>r</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawRoundRectStrokeInside"><HR><H4>vdrawRoundRectStrokeInside</H4></A>
<PRE>
        void <B>vdrawRoundRectStrokeInside</B>(
                int x,
                int y,
                int w,
                int h,
                int r);
</PRE>

<DL><DD>
Outlines the inside of the round corner rectangle bounded
by <SAMP>x,y,w,h</SAMP> with the current color and line
style. The round-corner rectangle has corners of radius
<SAMP>r</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawRoundRects"><HR><H4>vdrawRoundRects</H4></A>
<PRE>
        void <B>vdrawRoundRects</B>(
                const vrect * rects,
                int count,
                int r);
</PRE>

<DL><DD>
Constructs a set of round-corner rectangle subpaths whose
sides lie along the sides of the rectangles in
<SAMP>rects</SAMP>. (See figure). The round-corner
rectangles have corners of radius <SAMP>r</SAMP>.
<SAMP>rects</SAMP> points to <SAMP>count</SAMP> rectangles.
  <P>
<BLOCKQUOTE>
Figure: Operation of vdrawRoundRects
  <P>
<IMG SRC="Drawing.Operation_of_vdrawRou.gif">
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawRoundRectsFill"><HR><H4>vdrawRoundRectsFill</H4></A>
<PRE>
        void <B>vdrawRoundRectsFill</B>(
                const vrect * rects,
                int count,
                int r);
</PRE>

<DL><DD>
Fills the inside of a set of round-corner rectangles whose
sides lie along the sides of the rectangles in
<SAMP>rects</SAMP>. The round-corner rectangles have
corners of radius <SAMP>r</SAMP>. <SAMP>rects</SAMP> points
to <SAMP>count</SAMP> rectangles.
</DD></DL>
<P>
<A NAME="vdrawRoundRectsStroke"><HR><H4>vdrawRoundRectsStroke</H4></A>
<PRE>
        void <B>vdrawRoundRectsStroke</B>(
                const vrect * rects,
                int count,
                int r);
</PRE>

<DL><DD>
Outlines the set of round-corner rectangles whose sides lie
along the sides of the rectangles in <SAMP>rects</SAMP>.
The round-corner rectangles have corners of radius
<SAMP>r</SAMP>. <SAMP>rects</SAMP> points to
<SAMP>count</SAMP> rectangles.
</DD></DL>
<P>
<A NAME="vdrawRoundRectsStrokeInside"><HR><H4>vdrawRoundRectsStrokeInside</H4></A>
<PRE>
        void <B>vdrawRoundRectsStrokeInside</B>(
                const vrect * rects,
                int count,
                int r);
</PRE>

<DL><DD>
Outlines the rectangles addressed by <SAMP>rects</SAMP> in
a manner similar to <CODE>vdrawRoundRectsStroke</CODE>,
except that the outlines are constrained to the insides of
the rectangles, instead of being centered on them. There
are <SAMP>count</SAMP> rectangles.
</DD></DL>
<P>
<A NAME="vdrawScale"><HR><H4>vdrawScale</H4></A>
<PRE>
        void <B>vdrawScale</B>(
                int x,
                int y);
</PRE>

<DL><DD>
Scales the current coordinate system by <SAMP>x</SAMP> and
<SAMP>y</SAMP> by modifying thecurrent transformation
matrix. Either parameter can be negative. It generally not
useful if either parameter is zero, and subsequent drawing
operations may result <CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE> being
generated. Scaling by a number greater than one effectively
increases the size of each user space unit, while scaling
by a number between zero and one decreases the size of each
unit. Scaling by negative values is useful for changing the
direction of the coordinate system (from increasing upwards
to increasing downwards, for example).
<CODE>vdrawScale</CODE><SAMP> (72,72)</SAMP> changes the
default user space unit system from points to inches. (See
figure). <CODE>vdrawScale</CODE> is cumulative; that is,
scaling by 1.5 and then by 1.5 again results in a total
scaling increase of 225 percent (1 x 1.5 x 1.5 = 2.25).
  <P>
<BLOCKQUOTE>
Figure: Image scaling
  <P>
<IMG SRC="Drawing.Image_scaling_C.gif">
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawScribedAShow"><HR><H4>vdrawScribedAShow</H4></A>
<PRE>
        void <B>vdrawScribedAShow</B>(
                int ax,
                int ay,
                vscribe * scribe);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> in the current font
and current color, with the origin of the first character
at the current point. <SAMP>ax</SAMP> and <SAMP>ay</SAMP>
indicate the amount of user space width to add to the width
of each character in the string. (See figure). Note that
character width has a y coordinate as well as an x
coordinate. The current point is moved by the width of the
string plus any extra width. Scribed entry points allow you
to draw strings in other character sets or
representations. Refer to the ``String Manager'' chapter
of the <I>Galaxy Application Environment Programmer's
Guide</I> for more information about scribes.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawScribedAWidthShow"><HR><H4>vdrawScribedAWidthShow</H4></A>
<PRE>
        void <B>vdrawScribedAWidthShow</B>(
                int cx,
                int cy,
                int c,
                int ax,
                int ay,
                vscribe * scribe);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> in the current font
and current color, with the origin of the first character
at the current point. <SAMP>ax</SAMP> and <SAMP>ay</SAMP>
indicate the amount of user space width to add to the width
of each character in the string. (See Figure).
<SAMP>cx</SAMP> and <SAMP>cy</SAMP> indicate the amount of
width to add to the width of the character <SAMP>c</SAMP>
wherever it appears in the string. Note that character
width has a y coordinate as well as an x coordinate. The
current point is moved by the width of the string plus any
extra width. Scribed entry points allow you to draw strings
in other character sets or representations. Refer to the
``String Manager'' chapter of the <I>Galaxy Application
Environment Programmer's Guide</I> for more information
about scribes. <CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is
generated if there is no current point.
</DD></DL>
<P>
<A NAME="vdrawScribedCharPath"><HR><H4>vdrawScribedCharPath</H4></A>
<PRE>
        void <B>vdrawScribedCharPath</B>(
                vscribe * scribe);
</PRE>

<DL><DD>
Appends the outline of the scribe <SAMP>scribe</SAMP> to
the current path. Characters are positioned at the current
point as if <CODE><A HREF="vdraw-x.html#vdrawShow"><CODE>vdrawShow</CODE></A></CODE> or one of its variants
was called. The characters are rendered efficiently if
outline fonts are available or if the path is subsequently
used in a clip or fill operation. Otherwise the operation
is relatively expensive. Scribed entry points allow you to
draw strings in other character sets or
representations. Refer to the ``String Manager'' chapter
of the <I>Galaxy Application Environment Programmer's
Guide</I> for more information about scribes.
</DD></DL>
<P>
<A NAME="vdrawScribedRectShow"><HR><H4>vdrawScribedRectShow</H4></A>
<PRE>
        void <B>vdrawScribedRectShow</B>(
                vscribe * scribe,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> in the current font
inside the rectangle <SAMP>rect</SAMP>. The characters of
the string are clipped to the edges of <SAMP>rect</SAMP>.
The string is drawn with its left edge on the left edge of
<SAMP>rect</SAMP> and with its baseline <I>descent</I>
units above the bottom edge of <SAMP>rect</SAMP>, where
<I>descent</I> is the descent of the current font. Scribed
entry points allow you to draw strings in other character
sets or representations. Refer to the ``String Manager''
chapter of the <I>Galaxy Application Environment
Programmer's Guide</I> for more information about scribes.
</DD></DL>
<P>
<A NAME="vdrawScribedRectShowCenter"><HR><H4>vdrawScribedRectShowCenter</H4></A>
<PRE>
        void <B>vdrawScribedRectShowCenter</B>(
                vscribe * scribe,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> in the current font
inside the rectangle <SAMP>rect</SAMP>. The characters of
the string are clipped to the edges of <SAMP>rect</SAMP>.
The string is drawn centered inside <SAMP>rect</SAMP> along
both axes. Scribed entry points allow you to draw strings
in other character sets or representations. Refer to the
``String Manager'' chapter of the <I>Galaxy Application
Environment Programmer's Guide</I> for more information
about scribes.
</DD></DL>
<P>
<A NAME="vdrawScribedRectShowCenterX"><HR><H4>vdrawScribedRectShowCenterX</H4></A>
<PRE>
        void <B>vdrawScribedRectShowCenterX</B>(
                vscribe * scribe,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> in the current font
inside the rectangle <SAMP>rect</SAMP>. The characters of
the string are clipped to the edges of <SAMP>rect</SAMP>.
The string is drawn with its baseline <I>descent</I> units
above the bottom edge of <SAMP>rect</SAMP>, where
<I>descent</I> is the descent of the current font. The
string is drawn centered inside <SAMP>rect</SAMP> along its
x axis. Scribed entry points allow you to draw strings in
other character sets or representations. Refer to the
``String Manager'' chapter of the <I>Galaxy Application
Environment Programmer's Guide</I> for more information
about scribes.
</DD></DL>
<P>
<A NAME="vdrawScribedRectShowCenterY"><HR><H4>vdrawScribedRectShowCenterY</H4></A>
<PRE>
        void <B>vdrawScribedRectShowCenterY</B>(
                vscribe * scribe,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> in the current font
inside the rectangle <SAMP>rect</SAMP>. The characters of
the string are clipped to the edges of <SAMP>rect</SAMP>.
The string is drawn with its left edge on the left edge of
<SAMP>rect</SAMP>. The string is drawn centered inside
<SAMP>rect</SAMP> along its y axis. Scribed entry points
allow you to draw strings in other character sets or
representations. Refer to the ``String Manager'' chapter
of the <I>Galaxy Application Environment Programmer's
Guide</I> for more information about scribes.
</DD></DL>
<P>
<A NAME="vdrawScribedShow"><HR><H4>vdrawScribedShow</H4></A>
<PRE>
        void <B>vdrawScribedShow</B>(
                vscribe * scribe);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> in the current font
and current color, with the origin of the first character
at the current point. The current point is moved by the
width of the string. Scribed entry points allow you to draw
strings in other character sets or representations. Refer
to the ``String Manager'' chapter of the <I>Galaxy
Application Environment Programmer's Guide</I> for more
information about scribes.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawScribedUnderline"><HR><H4>vdrawScribedUnderline</H4></A>
<PRE>
        void <B>vdrawScribedUnderline</B>(
                vscribe * scribe);
</PRE>

<DL><DD>
Underlines the scribe <SAMP>scribe</SAMP> with a line of
the current line width, using the current point as the
origin of the string. This function offsets the current
point by the sum of the widths of the underlined
characters.
</DD></DL>
<P>
<A NAME="vdrawScribedUnderlineShow"><HR><H4>vdrawScribedUnderlineShow</H4></A>
<PRE>
        void <B>vdrawScribedUnderlineShow</B>(
                vscribe * scribe);
</PRE>

<DL><DD>
Underlines the scribe <SAMP>scribe</SAMP> with a line of
the current line width, using the current point as the
origin of the string. Draws the string itself (written by
the scribe). This function offsets the current point by the
sum of the widths of the underlined characters.
</DD></DL>
<P>
<A NAME="vdrawScribedWidthShow"><HR><H4>vdrawScribedWidthShow</H4></A>
<PRE>
        void <B>vdrawScribedWidthShow</B>(
                int cx,
                int cy,
                int c,
                vscribe * scribe);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> in the current font
and current color, with the origin of the first character
at the current point. <SAMP>cx</SAMP> and <SAMP>cy</SAMP>
indicate the amount of width to add to the width of the
character <SAMP>c</SAMP> wherever it appears in the string.
(See figure). Note that character width has a y coordinate
as well as an x coordinate. The current point is moved by
the width of the string plus any extra width. Scribed entry
points allow you to draw strings in other character sets or
representations. Refer to the ``String Manager'' chapter
of the <I>Galaxy Application Environment Programmer's
Guide</I> for more information about scribes.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawSetColor"><HR><H4>vdrawSetColor</H4></A>
<PRE>
        void <B>vdrawSetColor</B>(
                vcolor * color);
</PRE>

<DL><DD>
Sets the current color to the color <SAMP>color</SAMP>.
This color will be used for all subsequent rendering.
Colors can be obtained in a variety of color spaces from
the Color class. Note that the Drawing class does not
include functions to set foreground/background colors;
however, color objects for these colors can be obtained
from the user interface objects themselves.
<CODE><A HREF="vwindow-x.html#vwindowDetermineForeground"><CODE>vwindowDetermineForeground</CODE></A></CODE>, for example,
determines the foreground color of a given window. This
function generates <CODE><A HREF="vex-x.html#vexArgNullException"><CODE>vexArgNullException</CODE></A></CODE> if
<SAMP>color</SAMP> is <SAMP>NULL</SAMP>. Note that this
function simply stores a reference to the color object in
the current gstate: you cannot destroy the color with
<CODE><A HREF="vcolor-x.html#vcolorRelease"><CODE>vcolorRelease</CODE></A></CODE> while the color reference is
stored in any gstate.
</DD></DL>
<P>
<A NAME="vdrawSetComplement"><HR><H4>vdrawSetComplement</H4></A>
<PRE>
        void <B>vdrawSetComplement</B>(
                vcolor * complement);
</PRE>

<DL><DD>
Sets the current complement color to the color
<SAMP>complement</SAMP>. This color is used for
``complementing'' the current color in conjunction with
certain drawing functions. This function generates a
<CODE><A HREF="vex-x.html#vexArgNullException"><CODE>vexArgNullException</CODE></A></CODE> if <SAMP>color</SAMP> is
<SAMP>NULL</SAMP>. Note that this function simply stores a
reference to the color object in the current gstate: you
cannot destroy the color with <CODE><A HREF="vcolor-x.html#vcolorRelease"><CODE>vcolorRelease</CODE></A></CODE>
while the color reference is stored in any gstate.
</DD></DL>
<P>
<A NAME="vdrawSetComplexity"><HR><H4>vdrawSetComplexity</H4></A>
<PRE>
        void <B>vdrawSetComplexity</B>(
                int complexity);
</PRE>

<DL><DD>
Sets the currentpath complexity to <SAMP>complexity</SAMP>.
<B><I>Path complexity</I></B> is a hint used by the Drawing
class to optimize fill algorithms for certainwindow
systems. The default value is one that accommodates all
path descriptions. More restrictive path complexities can
be selected to achieve faster drawing for paths that
conform to the complexity criteria, but these restrictive
complexities result in undefined behavior for paths that do
not conform. <B><I>Convex complexity</I></B>indicates that
fill operations will be performed on strictly convex
subpaths. <B><I>Nonconvex complexity</I></B> indicates that
fill operations will be performed on paths that do not
self-intersect. This function generates a
<CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE> if <SAMP>complexity</SAMP> is
not one of the following:

<ul>
<li><CODE>vdrawPATH_CONVEX</CODE>
<li><CODE>vdrawPATH_NONCONVEX</CODE>
<li><CODE>vdrawPATH_COMPLEX</CODE>
</ul>
</DD></DL>
<P>
<A NAME="vdrawSetDevice"><HR><H4>vdrawSetDevice</H4></A>
<PRE>
        void <B>vdrawSetDevice</B>(
                unsigned int flags,
                void * device,
                const vdrawDynamicFuncs * dynamicFuncs,
                const vdrawStaticFuncs * staticFuncs,
                const vdrawDriver * driver);
</PRE>

<DL><DD>
Changes the device attribute of the current gstate. This
function is used by device driver packages to implement
higher-level device specification operations (such as
<CODE><A HREF="vwindow-x.html#vwindowDrawDevice"><CODE>vwindowDrawDevice</CODE></A></CODE> or
<CODE><A HREF="vdraw-x.html#vdrawImageDevice"><CODE>vdrawImageDevice</CODE></A></CODE>). If you are implementing a
new type of drawing device, you should create a device
specification function of your own and call this function
from within it. This function should not be called directly
from application program code, and you should not require
users of your new device type to call it directly.
  <P>
<SAMP>device</SAMP> specifies the drawing device
``instance'' attribute in the current gstate. This is a
window pointer for a window device or an image pointer for
an image device, for example. <SAMP>driver</SAMP> specifies
the graphics driver which determines the low-level behavior
of the device named in <SAMP>device</SAMP>. You can pass
the result of <CODE><A HREF="vdraw-x.html#vdrawNullDriver"><CODE>vdrawNullDriver</CODE></A></CODE><SAMP>()</SAMP>
if you do not want to implement low-level behavior
yourself. <SAMP>dynamicFuncs</SAMP> and
<SAMP>staticFuncs</SAMP> specify the high-level drawing
functions to use for the device. You can pass the results
of <CODE><A HREF="vdraw-x.html#vdrawStdDynamicFuncs"><CODE>vdrawStdDynamicFuncs</CODE></A></CODE> and
<CODE><A HREF="vdraw-x.html#vdrawStdStaticFuncs"><CODE>vdrawStdStaticFuncs</CODE></A></CODE> if you do not want to
implement high-level behavior yourself. Indirected entry
points will use these functions to implement their
functionality until the device attribute is changed again.
<P>
Refer to the ``Types'' section for a listing of which vdraw
entry-points are indirected. The device flags specified in
<SAMP>flags</SAMP> modify device behavior. The meaning of
the flags depend on the device driver used. If the flag
<SAMP>vdrawDEVICE_VIEW_CLIP</SAMP> is set, view clipping is
enabled for the new device, otherwise it is disabled.
</DD></DL>
<P>
<A NAME="vdrawSetFlat"><HR><H4>vdrawSetFlat</H4></A>
<PRE>
        void <B>vdrawSetFlat</B>(
                int flatness);
</PRE>

<DL><DD>
Sets the current flatness to <SAMP>flatness</SAMP>. Curves
are rendered as a series of straight lines that form a
curve approximation. Flatness controls the amount of
deviation allowed between the approximation and the ``true
curve". (See figure). The allowed deviation is
expressed in terms of device pixels. This represents a
trade-off between curve fidelity and drawing efficiency. A
small deviation increases the smoothness of the
representation but also increases the number of line
segments required to render the approximation. The default
flatness is a suitable value for the current device.
Flatness values less than 0.2 is set to 0.2. Flatness
values greater than 100 are set to 100. This function
generates a <CODE><A HREF="vex-x.html#vexArgRangeException"><CODE>vexArgRangeException</CODE></A></CODE> if
<SAMP>flatness</SAMP> is less than zero.
  <P>
<BLOCKQUOTE>
Figure: Operation of vdrawSetFlat
  <P>
<IMG SRC="Drawing.Operation_of_vdrawSet.gif"></BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawSetFont"><HR><H4>vdrawSetFont</H4></A>
<PRE>
        void <B>vdrawSetFont</B>(
                vfont * font);
</PRE>

<DL><DD>
Sets the current font to <SAMP>font</SAMP>. The current
font is used by text drawing functions such as
<CODE><A HREF="vdraw-x.html#vdrawShow"><CODE>vdrawShow</CODE></A></CODE>. Fonts are obtained from the Font
class or from a user-interface object. For example,
<CODE><A HREF="vwindow-x.html#vwindowDetermineFont"><CODE>vwindowDetermineFont</CODE></A></CODE> returns the correct font
to use for a given window. This function generates a
<CODE><A HREF="vex-x.html#vexArgNullException"><CODE>vexArgNullException</CODE></A></CODE> if <SAMP>font</SAMP> is
<SAMP>NULL</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawSetFunction"><HR><H4>vdrawSetFunction</H4></A>
<PRE>
        void <B>vdrawSetFunction</B>(
                int func);
</PRE>

<DL><DD>
Sets the current drawing function to <SAMP>func</SAMP>. The
drawing function determines how the pixels of the source
and destination objects interact. Not all window systems
support all drawing functions. PostScript printer devices
support only <CODE>vdrawFUNC_COPY</CODE>. You should avoid
using drawing functions other than
<CODE>vdrawFUNC_COPY</CODE> if at all possible. This
function generates a <CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE> exception
if <SAMP>func</SAMP> is not one of the following:
  <P>
<BLOCKQUOTE>

<DL>
<DT><CODE>vdrawFUNC_CLEAR</CODE>
<DD>0

<DT><CODE>vdrawFUNC_AND</CODE>
<DD>src AND dst

<DT><CODE>vdrawFUNC_AND_REV</CODE>
<DD>src AND NOT dst

<DT><CODE>vdrawFUNC_COPY</CODE>
<DD>src

<DT><CODE>vdrawFUNC_AND_INV</CODE>
<DD>(NOT src) AND dst

<DT><CODE>vdrawFUNC_NOP</CODE>
<DD>dst

<DT><CODE>vdrawFUNC_XOR</CODE>
<DD>src XOR dst

<DT><CODE>vdrawFUNC_OR</CODE>
<DD>src OR dst

<DT><CODE>vdrawFUNC_NOR</CODE>
<DD>(NOT src) AND (NOT dst)

<DT><CODE>vdrawFUNC_EQUIV</CODE>
<DD>(NOT src) XOR dst

<DT><CODE>vdrawFUNC_INVERT</CODE>
<DD>NOT dst

<DT><CODE>vdrawFUNC_OR_REV</CODE>
<DD>src OR (NOT dst)

<DT><CODE>vdrawFUNC_COPY_INV</CODE>
<DD>NOT src

<DT><CODE>vdrawFUNC_OR_INV</CODE>
<DD>(NOT src) OR dst

<DT><CODE>vdrawFUNC_NAND</CODE>
<DD>(NOT src) OR (NOT dst)

<DT><CODE>vdrawFUNC_SET</CODE>
<DD>1

<DT><CODE>vdrawFUNC_HILITE</CODE>
<DD>(src XOR hilight) Approx XOR dst

<DT><CODE>vdrawFUNC_COMPLEMENT</CODE>
<DD>(src XOR complement) Approx XOR dst
</DL>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawSetGState"><HR><H4>vdrawSetGState</H4></A>
<PRE>
        void <B>vdrawSetGState</B>(
                vdrawGState * gstate);
</PRE>

<DL><DD>
Copies the contents of the gstate object
<SAMP>gstate</SAMP> into the current gstate. All attributes
of the gstate are copied, including its device and clip
path. Note that the view clip is not copied, since it is
not stored in a gstate. This function does <I>not</I>
change the current gstate to <SAMP>gstate</SAMP>; any
changes made to the current gstate after this function is
called will <I>not</I> be reflected in <SAMP>gstate</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawSetGray"><HR><H4>vdrawSetGray</H4></A>
<PRE>
        void <B>vdrawSetGray</B>(
                unsigned int gray);
</PRE>

<DL><DD>
Sets the current color to the gray value <SAMP>gray</SAMP>.
This gray value is used for all subsequent rendering. Gray
values range from zero to <CODE>vcolorCOMPONENT_MAX</CODE>.
</DD></DL>
<P>
<A NAME="vdrawSetHLSColor"><HR><H4>vdrawSetHLSColor</H4></A>
<PRE>
        void <B>vdrawSetHLSColor</B>(
                unsigned int hue,
                unsigned int lightness,
                unsigned int saturation);
</PRE>

<DL><DD>
Sets the current color to the HLS color value
<SAMP>hue</SAMP>, <SAMP>saturation</SAMP>,
<SAMP>lightness</SAMP>. This color value is used for all
subsequent rendering. HLS values range from zero to
<CODE>vcolorCOMPONENT_MAX</CODE>.
</DD></DL>
<P>
<A NAME="vdrawSetLineCap"><HR><H4>vdrawSetLineCap</H4></A>
<PRE>
        void <B>vdrawSetLineCap</B>(
                int cap);
</PRE>

<DL><DD>
Sets the current line capstyle. The line cap is used by
stroking functions to draw the unconnected ends of line
segments. (See figure). This function generates a
<CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE> if <SAMP>cap</SAMP> is not one
of the following:
  <P>
<BLOCKQUOTE>

<DL>
<DT><CODE>vdrawCAP_BUTT</CODE> 
<DT><CODE>vdrawCAP_ROUND</CODE> 
<DT><CODE>vdrawCAP_PROJECTING</CODE> 
</DL>
</BLOCKQUOTE>

  <P>
<BLOCKQUOTE>
Figure: Line cap style
  <P>
<IMG SRC="Drawing.Line_cap_style.gif"></BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawSetLineJoin"><HR><H4>vdrawSetLineJoin</H4></A>
<PRE>
        void <B>vdrawSetLineJoin</B>(
                int join);
</PRE>

<DL><DD>
Sets the current line joinstyle. The line join function
determines the way stroking functions join the butts of
line segments together: mitered, rounded, or beveled. (See
figure). This function generates a
<CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE> if <SAMP>join</SAMP> is not
one of the following:
  <P>
<BLOCKQUOTE>

<DL>
<DT><CODE>vdrawJOIN_MITER</CODE> 
<DT><CODE>vdrawJOIN_ROUND</CODE> 
<DT><CODE>vdrawJOIN_BEVEL</CODE> 
</DL>
</BLOCKQUOTE>

  <P>
<BLOCKQUOTE>
Figure: Line join style
  <P>
<IMG SRC="Drawing.Line_join_style.gif"></BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawSetLineWidth"><HR><H4>vdrawSetLineWidth</H4></A>
<PRE>
        void <B>vdrawSetLineWidth</B>(
                int width);
</PRE>

<DL><DD>
Sets the current line width (thickness) to
<SAMP>width</SAMP> user space units. (See figure). For any
given device, a line of zero width is defined as the
thinnest possible width for that device. Zero width lines
give better performance on some window systems, but at the
expense of visual fidelity. Zero width lines should be
avoided if the target device could be a printer, since they
are likely to be invisible to the eye. This function
generates a <CODE><A HREF="vex-x.html#vexArgRangeException"><CODE>vexArgRangeException</CODE></A></CODE> if
<SAMP>width</SAMP> is less than zero.
</DD></DL>
<P>
<A NAME="vdrawSetMatrix"><HR><H4>vdrawSetMatrix</H4></A>
<PRE>
        void <B>vdrawSetMatrix</B>(
                const vmatrix * mtx);
</PRE>

<DL><DD>
Sets the current transformation matrix to <SAMP>mtx</SAMP>.
Generally, you should avoid setting the transformation
matrix directly and instead modify the current
transformation by changing the coordinate system. For more 
information refer to sections:

<ul>
<li><CODE><A HREF="vdraw-x.html#vdrawRotate"><CODE>vdrawRotate</CODE></A></CODE>
<li><CODE><A HREF="vdraw-x.html#vdrawScale"><CODE>vdrawScale</CODE></A></CODE>
<li><CODE><A HREF="vdraw-x.html#vdrawTranslate"><CODE>vdrawTranslate</CODE></A></CODE>. 
</ul>

Since <CODE>vdrawSetMatrix</CODE> requires knowledge of the
device's resolution and orientation, any code using this
function is device-dependent. Subsequent drawing operations
may generate <CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE> if
<SAMP>mtx</SAMP> is not invertible.
</DD></DL>
<P>
<A NAME="vdrawSetMiterLimit"><HR><H4>vdrawSetMiterLimit</H4></A>
<PRE>
        void <B>vdrawSetMiterLimit</B>(
                int limit);
</PRE>

<DL><DD>
Sets the current miter limit to <SAMP>limit</SAMP>. When
mitered ends have been specified as the style for
connecting line segments, the miter limit controls the
length of the mitered joins. This eliminates objectionably
long miter joins that might result when segments connect at
acute angles. (See Figure). This function generates a
<CODE><A HREF="vex-x.html#vexArgRangeException"><CODE>vexArgRangeException</CODE></A></CODE> if <SAMP>limit</SAMP> is
less than one.
  <P>
<BLOCKQUOTE>
Figure: Miter length
  <P>
<IMG SRC="Drawing.Miter_length.gif"></BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawSetPhase"><HR><H4>vdrawSetPhase</H4></A>
<PRE>
        void <B>vdrawSetPhase</B>(
                int x,
                int y);
</PRE>

<DL><DD>
Changes the current color phase to <SAMP>x</SAMP>,
<SAMP>y</SAMP> in the default coordinate system of the
current device. The color phase is used to compensate for
scrolling and other visual effects that operate directly on
device pixels.
</DD></DL>
<P>
<A NAME="vdrawSetRGBColor"><HR><H4>vdrawSetRGBColor</H4></A>
<PRE>
        void <B>vdrawSetRGBColor</B>(
                unsigned int red,
                unsigned int green,
                unsigned int blue);
</PRE>

<DL><DD>
Sets the current color to the RGB color value
<SAMP>red</SAMP>, <SAMP>green</SAMP>, <SAMP>blue</SAMP>.
This color value is used for all subsequent rendering. RGB
values range from zero to <CODE>vcolorCOMPONENT_MAX</CODE>.
</DD></DL>
<P>
<A NAME="vdrawSetSizedRectShow"><HR><H4>vdrawSetSizedRectShow</H4></A>
<PRE>
        void <B>vdrawSetSizedRectShow</B>(
                const vchar * s,
                size_t count,
                const vrect * rect,
                unsigned int flags);
</PRE>

<DL><DD>
Sets graphics state attributes for a
<CODE><A HREF="vdraw-x.html#vdrawRectShow"><CODE>vdrawRectShow</CODE></A></CODE> function.
</DD></DL>
<P>
<A NAME="vdrawSetStrokeAdjust"><HR><H4>vdrawSetStrokeAdjust</H4></A>
<PRE>
        void <B>vdrawSetStrokeAdjust</B>(
                int adjust);
</PRE>

<DL><DD>
Sets the currentstroke adjustment parameter to
<SAMP>adjust</SAMP>. If stroke adjustment is on, lines with
a small number of device pixels are adjusted for uniform
width. Otherwise, lines are always drawn according to the
mathematically correct outline. It generates
<CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE> if adjust is not either
<SAMP>vdrawSTROKE_ADJUST</SAMP> or
<SAMP>vdrawNO_ADJUST</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawShow"><HR><H4>vdrawShow</H4></A>
<PRE>
        void <B>vdrawShow</B>(
                const vchar * s);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font and
current color, with the origin of the first character at
the current point. The current point is moved by the width
of the string. <CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is
generated if there is no current point.
</DD></DL>
<P>
<A NAME="vdrawSizedAShow"><HR><H4>vdrawSizedAShow</H4></A>
<PRE>
        void <B>vdrawSizedAShow</B>(
                int ax,
                int ay,
                const vchar * s,
                size_t count);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font and
current color, with the origin of the first character at
the current point. <SAMP>ax</SAMP> and <SAMP>ay</SAMP>
indicate the amount of user space width to add to the width
of each character in the string. (See figure). Note that
character width has a y coordinate as well as an x
coordinate. The current point is moved by the width of the
string plus any extra width. Exactly <SAMP>count</SAMP>
characters will be drawn from the string, regardless of
null characters. <CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE>
is generated if there is no current point.
</DD></DL>
<P>
<A NAME="vdrawSizedAWidthShow"><HR><H4>vdrawSizedAWidthShow</H4></A>
<PRE>
        void <B>vdrawSizedAWidthShow</B>(
                int cx,
                int cy,
                int c,
                int ax,
                int ay,
                const vchar * s,
                size_t count);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font and
current color, with the origin of the first character at
the current point. <SAMP>ax</SAMP> and <SAMP>ay</SAMP>
indicate the amount of user space width to add to the width
of each character in the string. (See figure).
<SAMP>cx</SAMP> and <SAMP>cy</SAMP> indicate the amount of
width to add to the width of the character <SAMP>c</SAMP>
wherever it appears in the string. Note that character
width has a y coordinate as well as an x coordinate. The
current point is moved by the width of the string plus any
extra width. Exactly <SAMP>count</SAMP> characters are
drawn from the string, regardless of null characters.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawSizedCharPath"><HR><H4>vdrawSizedCharPath</H4></A>
<PRE>
        void <B>vdrawSizedCharPath</B>(
                const vchar * s,
                size_t count);
</PRE>

<DL><DD>
Appends the outline of the character string <SAMP>s</SAMP>
to the current path. Characters are positioned at the
current point as if <CODE><A HREF="vdraw-x.html#vdrawShow"><CODE>vdrawShow</CODE></A></CODE> or one of its
variants was called. Appends exactly <SAMP>count</SAMP>
characters, regardless of null characters. The characters
are rendered efficiently if outline fonts are available or
if the path is subsequently used in a clip or fill
operation. Otherwise the operation is relatively expensive.
</DD></DL>
<P>
<A NAME="vdrawSizedRectShow"><HR><H4>vdrawSizedRectShow</H4></A>
<PRE>
        void <B>vdrawSizedRectShow</B>(
                const vchar * s,
                size_t count,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font inside
the rectangle <SAMP>rect</SAMP>. The characters of the
string are clipped to the edges of <SAMP>rect</SAMP>.
Exactly <SAMP>count</SAMP> characters of <SAMP>s</SAMP> are
drawn, regardless of null characters. The string is drawn
with its left edge on the left edge of <SAMP>rect</SAMP>
and with its baseline <I>descent</I> units above the bottom
edge of <SAMP>rect</SAMP>, where <I>descent</I> is the
descent of the current font.
</DD></DL>
<P>
<A NAME="vdrawSizedRectShowCenter"><HR><H4>vdrawSizedRectShowCenter</H4></A>
<PRE>
        void <B>vdrawSizedRectShowCenter</B>(
                const vchar * s,
                size_t count,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font inside
the rectangle <SAMP>rect</SAMP>. The characters of the
string are clipped to the edges of <SAMP>rect</SAMP>.
Exactly <SAMP>count</SAMP> characters of <SAMP>s</SAMP> are
drawn, regardless of null characters. The string is drawn
centered inside <SAMP>rect</SAMP> along both axes.
</DD></DL>
<P>
<A NAME="vdrawSizedRectShowCenterX"><HR><H4>vdrawSizedRectShowCenterX</H4></A>
<PRE>
        void <B>vdrawSizedRectShowCenterX</B>(
                const vchar * s,
                size_t count,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font inside
the rectangle <SAMP>rect</SAMP>. The characters of the
string are clipped to the edges of <SAMP>rect</SAMP>.
Exactly <SAMP>count</SAMP> characters of <SAMP>s</SAMP> are
drawn, regardless of null characters. The string is drawn
with its baseline <I>descent</I> units above the bottom
edge of <SAMP>rect</SAMP>, where <I>descent</I> is the
descent of the current font. The string is drawn centered
inside <SAMP>rect</SAMP> along its x axis.
</DD></DL>
<P>
<A NAME="vdrawSizedRectShowCenterY"><HR><H4>vdrawSizedRectShowCenterY</H4></A>
<PRE>
        void <B>vdrawSizedRectShowCenterY</B>(
                const vchar * s,
                size_t count,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font inside
the rectangle <SAMP>rect</SAMP>. The characters of the
string are clipped to the edges of <SAMP>rect</SAMP>.
Exactly <SAMP>count</SAMP> characters of <SAMP>s</SAMP> are
drawn, regardless of null characters. The string is drawn
with its left edge on the left edge of <SAMP>rect</SAMP>.
The string is drawn centered inside <SAMP>rect</SAMP> along
its y axis.
</DD></DL>
<P>
<A NAME="vdrawSizedShow"><HR><H4>vdrawSizedShow</H4></A>
<PRE>
        void <B>vdrawSizedShow</B>(
                const vchar * s,
                size_t count);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font and
current color, with the origin of the first character at
the current point. The current point is moved by the width
of the string. Exactly <SAMP>count</SAMP> characters are
drawn from the string, regardless of null characters.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawSizedUnderline"><HR><H4>vdrawSizedUnderline</H4></A>
<PRE>
        void <B>vdrawSizedUnderline</B>(
                const vchar * s,
                size_t count);
</PRE>

<DL><DD>
Underlines the string <SAMP>s</SAMP> with a line of the
current line width, using the current point as the origin
of the string. Exactly <SAMP>count</SAMP> characters are
underlined. This function offsets the current point by the
sum of the widths of the underlined characters.
</DD></DL>
<P>
<A NAME="vdrawSizedUnderlineShow"><HR><H4>vdrawSizedUnderlineShow</H4></A>
<PRE>
        void <B>vdrawSizedUnderlineShow</B>(
                const vchar * s,
                size_t count);
</PRE>

<DL><DD>
Underlines the string <SAMP>s</SAMP> with a line of the
current line width, using the current point as the origin
of the string. Exactly <SAMP>count</SAMP> characters are
underlined. Draws the string itself. This function offsets
the current point by the sum of the widths of the
underlined characters.
</DD></DL>
<P>
<A NAME="vdrawSizedWidthShow"><HR><H4>vdrawSizedWidthShow</H4></A>
<PRE>
        void <B>vdrawSizedWidthShow</B>(
                int cx,
                int cy,
                int c,
                const vchar * s,
                size_t count);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font and
current color, with the origin of the first character at
the current point. <SAMP>cx</SAMP> and <SAMP>cy</SAMP>
indicate the amount of width to add to the width of the
character <SAMP>c</SAMP> wherever it appears in the string
(see Figure). Note that character width has a y coordinate
as well as an x coordinate. The current point is moved by
the width of the string plus any extra width. Exactly
<SAMP>count</SAMP> characters are drawn from the string,
regardless of null characters.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
</DD></DL>
<P>
<A NAME="vdrawStartup"><HR><H4>vdrawStartup</H4></A>
<PRE>
        void <B>vdrawStartup</B>();
</PRE>

<DL><DD>
Initializes the Drawing class.
Has no effect if the class is already initialized. 
</DD></DL>
<P>
<A NAME="vdrawStdDynamicFuncs"><HR><H4>vdrawStdDynamicFuncs</H4></A>
<PRE>
        const vdrawDynamicFuncs * <B>vdrawStdDynamicFuncs</B>();
</PRE>

<DL><DD>
Returns the standard dynamic function set, which should be
used by rendering devices that require custom low-level
behavior, but not custom high-level behavior. Refer to the section 
<CODE><A HREF="vdraw-x.html#vdrawSetDevice"><CODE>vdrawSetDevice</CODE></A></CODE> for more information.
</DD></DL>
<P>
<A NAME="vdrawStdStaticFuncs"><HR><H4>vdrawStdStaticFuncs</H4></A>
<PRE>
        const vdrawStaticFuncs * <B>vdrawStdStaticFuncs</B>();
</PRE>

<DL><DD>
Returns the standard static function set, which should be
used by rendering devices that require custom low-level
behavior, but not custom high-level behavior. Refer to the section 
<CODE><A HREF="vdraw-x.html#vdrawSetDevice"><CODE>vdrawSetDevice</CODE></A></CODE> for more information.
</DD></DL>
<P>
<A NAME="vdrawStroke"><HR><H4>vdrawStroke</H4></A>
<PRE>
        void <B>vdrawStroke</B>();
</PRE>

<DL><DD>
Outlines the current path with the current line style and
current color and begins a new path.
</DD></DL>
<P>
<A NAME="vdrawTransform"><HR><H4>vdrawTransform</H4></A>
<PRE>
        void <B>vdrawTransform</B>(
                int x,
                int y,
                int * rx,
                int * ry);
</PRE>

<DL><DD>
Computes the transformation of <SAMP>x</SAMP> and
<SAMP>y</SAMP> and stores the result in <SAMP>rx</SAMP> and
<SAMP>ry</SAMP>. The standard transformation computes a
device space coordinate for a given user space coordinate.
(See figure). This function rounds the result of
<CODE><A HREF="vdraw-x.html#vdrawFTransform"><CODE>vdrawFTransform</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdrawTranslate"><HR><H4>vdrawTranslate</H4></A>
<PRE>
        void <B>vdrawTranslate</B>(
                int x,
                int y);
</PRE>

<DL><DD>
Translates the current coordinate system by <SAMP>x</SAMP>
and <SAMP>y</SAMP> by modifying the current transformation
matrix. Either parameter can be negative or zero.
Translationeffectively moves the origin to the specified
coordinates in the <I>current</I> coordinate system (see
Figure). Translation, like other coordinate system
modifications, is cumulative meaning that
<CODE>vdrawTranslate</CODE><SAMP>(10,10)</SAMP> has the
same effect as calling
<CODE>vdrawTranslate</CODE><SAMP>(5,5)</SAMP> twice in
succession.
  <P>
<BLOCKQUOTE>
Figure: Image translation
  <P>
<IMG SRC="Drawing.Image_translation_C.gif"></BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawUAppend"><HR><H4>vdrawUAppend</H4></A>
<PRE>
        void <B>vdrawUAppend</B>(
                vdrawUPath * upath);
</PRE>

<DL><DD>
Appends the user path <SAMP>upath</SAMP> to the current
path. If the current path is empty, the path that the user
path was created with is restored.
</DD></DL>
<P>
<A NAME="vdrawUEOFill"><HR><H4>vdrawUEOFill</H4></A>
<PRE>
        void <B>vdrawUEOFill</B>(
                vdrawUPath * upath);
</PRE>

<DL><DD>
Fills the inside of the user path <SAMP>upath</SAMP> with
the current color. When an identical path is to be rendered
several times, this function is likely to be more efficient
than constructing a path and filling it. It uses the
even-odd winding rule. (See figure).
</DD></DL>
<P>
<A NAME="vdrawUFill"><HR><H4>vdrawUFill</H4></A>
<PRE>
        void <B>vdrawUFill</B>(
                vdrawUPath * upath);
</PRE>

<DL><DD>
Fills the inside of the user path <SAMP>upath</SAMP> with
the current color. When an identical path is to be rendered
several times, this function is likely to be more efficient
than constructing a path and filling it. It tests for
``inside'' using the nonzero winding rule. (See figure).
</DD></DL>
<P>
<A NAME="vdrawUStroke"><HR><H4>vdrawUStroke</H4></A>
<PRE>
        void <B>vdrawUStroke</B>(
                vdrawUPath * upath);
</PRE>

<DL><DD>
Outlines the user path <SAMP>upath</SAMP> with the current
color and current line style (line cap, line join, line
width, and miter limit). This function is likely to be more
efficient than constructing a path and stroking it if the
identical path is to be rendered several times.
</DD></DL>
<P>
<A NAME="vdrawUnderline"><HR><H4>vdrawUnderline</H4></A>
<PRE>
        void <B>vdrawUnderline</B>(
                const vchar * s);
</PRE>

<DL><DD>
Underlines the string <SAMP>s</SAMP> with a line of the
current line width, using the current point as the origin
of the string. This function offsets the current point by
the sum of the widths of the underlined characters.
</DD></DL>
<P>
<A NAME="vdrawUnderlineMnemonic"><HR><H4>vdrawUnderlineMnemonic</H4></A>
<PRE>
        void <B>vdrawUnderlineMnemonic</B>(
                const vchar * title,
                int mnemonic);
</PRE>

<DL><DD>
Draws underlining into the current graphics state under the
first <SAMP>mnemonic</SAMP> character in the string
<SAMP>title</SAMP>. The current point should be set to the
origin of the title. This function does not draw anything
if <SAMP>mnemonic</SAMP> is not a character in
<SAMP>title</SAMP>. <SAMP>mnemonic</SAMP> should be a
character in the <CODE><A HREF="vchar-x.html#vchar"><CODE>vchar</CODE></A></CODE> character set.
</DD></DL>
<P>
<A NAME="vdrawUnderlineShow"><HR><H4>vdrawUnderlineShow</H4></A>
<PRE>
        void <B>vdrawUnderlineShow</B>(
                const vchar * s);
</PRE>

<DL><DD>
Underlines the string <SAMP>s</SAMP> with a line of the
current line width, using the current point as the origin
of the string (while also drawing the string itself). This
function offsets the current point by the sum of the widths
of the underlined characters.
</DD></DL>
<P>
<A NAME="vdrawUnround"><HR><H4>vdrawUnround</H4></A>
<PRE>
        void <B>vdrawUnround</B>();
</PRE>

<DL><DD>
Undoes any user space unit rounding established by the last
matrix initialization. You should call this function if
drawing in exact units is necessary. This function may
noticeably impact drawing performance and should be used
sparingly.
</DD></DL>
<P>
<A NAME="vdrawViewClip"><HR><H4>vdrawViewClip</H4></A>
<PRE>
        void <B>vdrawViewClip</B>();
</PRE>

<DL><DD>
Sets the view clip to the region inside the current path
and resets the current path. These functions are expensive
to implement on window systems that lack a PostScript
interpreter, and clients are advised to avoid them whenever
possible (use <CODE><A HREF="vdraw-x.html#vdrawRectsViewClip"><CODE>vdrawRectsViewClip</CODE></A></CODE> instead). It
tests for ``inside'' pixels using the nonzero winding rule.
The view clip is used by the Window class for update
region maintenance; the view clip should not be changed
otherwise. The view clip is ignored by some devices.
</DD></DL>
<P>
<A NAME="vdrawViewClipBounds"><HR><H4>vdrawViewClipBounds</H4></A>
<PRE>
        void <B>vdrawViewClipBounds</B>(
                const vrect ** rects,
                int * count);
</PRE>

<DL><DD>
Computes a set of bounding boxes that enclose the current
view clipping path. This function then returns the box
coordinates in <SAMP>rects</SAMP> and the number of boxes
in <SAMP>count</SAMP>. Depending on the window system, this
function either returns a bounding box for each individual
subpath or returns a single bounding box for the entire
path. The bounding box of a subpath is the smallest
rectangle that encloses all points along the subpath. (See
figure). This function does not take line width into
account. If the subpath contains curves, the bounding box
is computed to enclose all control points of the curves.
This function computes the bounding box of the path in
device space and returns the user space bounding box of the
device space bounding box. The box may be larger than
expected if the user space coordinate axes are not aligned
with the device space coordinate axes. The pointer returned
by this call can be used until the next call to the Drawing
class. Use <CODE><A HREF="vrect-x.html#vrectCloneSet"><CODE>vrectCloneSet</CODE></A></CODE> (a Plane Geometry
class function) to copy the rectangles if persistence is
desired.
</DD></DL>
<P>
<A NAME="vdrawViewClipPath"><HR><H4>vdrawViewClipPath</H4></A>
<PRE>
        void <B>vdrawViewClipPath</B>();
</PRE>

<DL><DD>
Replaces the current path with the current view clipping
path.
</DD></DL>
<P>
<A NAME="vdrawWidthShow"><HR><H4>vdrawWidthShow</H4></A>
<PRE>
        void <B>vdrawWidthShow</B>(
                int cx,
                int cy,
                int c,
                const vchar * s);
</PRE>

<DL><DD>
Draws the string <SAMP>s</SAMP> in the current font and
current color, with the origin of the first character at
the current point. <SAMP>cx</SAMP> and <SAMP>cy</SAMP>
indicate the amount of width to add to the width of the
character <SAMP>c</SAMP> wherever it appears in the string
(see Figure). Note that character width has a y coordinate
as well as an x coordinate. The current point is moved by
the width of the string plus any extra width.
<CODE><A HREF="vdraw-x.html#vdrawNoCurrentPointException"><CODE>vdrawNoCurrentPointException</CODE></A></CODE> is generated if
there is no current point.
  <P>
<BLOCKQUOTE>
Figure: Character width
  <P>
<IMG SRC="Drawing.Character_width.gif"></BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="section_Constant"><HR>
<CENTER><H2>Constants</H2></CENTER></A><P>
<A NAME="vdrawCAP_BUTT"><HR><H4>vdrawCAP_BUTT</H4></A>
<PRE>
        <B>vdrawCAP_BUTT</B>
</PRE>
<A NAME="vdrawCAP_PROJECTING"><PRE>
        <B>vdrawCAP_PROJECTING</B>
</PRE>
</A>
<A NAME="vdrawCAP_ROUND"><PRE>
        <B>vdrawCAP_ROUND</B>
</PRE>
</A>

<DL><DD>
Integral constants that determine the appearance of the
segment ends of unclosed path outlines. These constants are
passed as arguments to the function
<CODE><A HREF="vdraw-x.html#vdrawSetLineCap"><CODE>vdrawSetLineCap</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdrawCOLOR_BACKGROUND"><HR><H4>vdrawCOLOR_BACKGROUND</H4></A>
<PRE>
        <B>vdrawCOLOR_BACKGROUND</B>
</PRE>
<A NAME="vdrawCOLOR_FOREGROUND"><PRE>
        <B>vdrawCOLOR_FOREGROUND</B>
</PRE>
</A>
<A NAME="vdrawCOLOR_SHADOW_TOP"><PRE>
        <B>vdrawCOLOR_SHADOW_TOP</B>
</PRE>
</A>
<A NAME="vdrawCOLOR_SHADOW_BOTTOM"><PRE>
        <B>vdrawCOLOR_SHADOW_BOTTOM</B>
</PRE>
</A>
<A NAME="vdrawCOLOR_FOREGROUND_HILITE"><PRE>
        <B>vdrawCOLOR_FOREGROUND_HILITE</B>
</PRE>
</A>
<A NAME="vdrawCOLOR_BACKGROUND_HILITE"><PRE>
        <B>vdrawCOLOR_BACKGROUND_HILITE</B>
</PRE>
</A>
<A NAME="vdrawCOLOR_BACKGROUND_EMBOSS"><PRE>
        <B>vdrawCOLOR_BACKGROUND_EMBOSS</B>
</PRE>
</A>
<A NAME="vdrawCOLOR_BACKGROUND_DEBOSS"><PRE>
        <B>vdrawCOLOR_BACKGROUND_DEBOSS</B>
</PRE>
</A>
<A NAME="vdrawCOLOR_BORDER"><PRE>
        <B>vdrawCOLOR_BORDER</B>
</PRE>
</A>
<A NAME="vdrawCOLOR_FOCUS"><PRE>
        <B>vdrawCOLOR_FOCUS</B>
</PRE>
</A>
<A NAME="vdrawCOLOR_HILITE"><PRE>
        <B>vdrawCOLOR_HILITE</B>
</PRE>
</A>
<A NAME="vdrawCOLOR_SHADOW_TOP_DARK"><PRE>
        <B>vdrawCOLOR_SHADOW_TOP_DARK</B>
</PRE>
</A>
<A NAME="vdrawCOLOR_SHADOW_BOTTOM_DARK"><PRE>
        <B>vdrawCOLOR_SHADOW_BOTTOM_DARK</B>
</PRE>
</A>

<DL><DD>
Integral constants that specify <B><I>color
identifiers</I></B>. These identifiers are used by object
color determination functions (such as
<CODE><A HREF="vwindow-x.html#vwindowDetermineColor"><CODE>vwindowDetermineColor</CODE></A></CODE>) to symbolically
identify the colors that the object should be drawn with.
For example, the following statement determines the
foreground color of the window <SAMP>window</SAMP>:
  <P>
<BLOCKQUOTE>
<PRE>

foreground = <A HREF="vwindow-x.html#vwindowDetermineColor"><CODE>vwindowDetermineColor</CODE></A>(window, vdrawCOLOR_FOREGROUND);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdrawCOLOR_DISABLE"><HR><H4>vdrawCOLOR_DISABLE</H4></A>
<PRE>
        <B>vdrawCOLOR_DISABLE</B>
</PRE>

<DL><DD>
An integral constant that is a <B><I>color identifier
modifier</I></B>. This modifier can be combined with a
color identifier using the inclusive-or operator
(<SAMP>|</SAMP>) to identify the disabled version of a
given color (that is, the version of the color for objects
that are inactive or inaccessible).
</DD></DL>
<P>
<A NAME="vdrawCOLOR_MAX"><HR><H4>vdrawCOLOR_MAX</H4></A>
<PRE>
        <B>vdrawCOLOR_MAX</B>
</PRE>

<DL><DD>
Provides the number of distinct color identifiers,
including modifiers. This constant can be used to declare
an array of all the possible color identifiers.
</DD></DL>
<P>
<A NAME="vdrawDEVICE_DUMMY_VIEW_CLIP"><HR><H4>vdrawDEVICE_DUMMY_VIEW_CLIP</H4></A>
<PRE>
        <B>vdrawDEVICE_DUMMY_VIEW_CLIP</B>
</PRE>
<A NAME="vdrawDEVICE_VIEW_CLIP"><PRE>
        <B>vdrawDEVICE_VIEW_CLIP</B>
</PRE>
</A>
<A NAME="vdrawDEVICE_MASK"><PRE>
        <B>vdrawDEVICE_MASK</B>
</PRE>
</A>
<A NAME="vdrawDRIVER_STROKE_ADJUST"><PRE>
        <B>vdrawDRIVER_STROKE_ADJUST</B>
</PRE>
</A>
<A NAME="vdrawDRIVER_ROUND"><PRE>
        <B>vdrawDRIVER_ROUND</B>
</PRE>
</A>

<DL><DD>
These constants are used by the Drawing class low-level
driver interface, which is not documented or exported at
this time.
</DD></DL>
<P>
<A NAME="vdrawDIRTY_ADJUST"><HR><H4>vdrawDIRTY_ADJUST</H4></A>
<PRE>
        <B>vdrawDIRTY_ADJUST</B>
</PRE>
<A NAME="vdrawDIRTY_COLOR"><PRE>
        <B>vdrawDIRTY_COLOR</B>
</PRE>
</A>
<A NAME="vdrawDIRTY_COMPLEMENT"><PRE>
        <B>vdrawDIRTY_COMPLEMENT</B>
</PRE>
</A>
<A NAME="vdrawDIRTY_COMPLEXITY"><PRE>
        <B>vdrawDIRTY_COMPLEXITY</B>
</PRE>
</A>
<A NAME="vdrawDIRTY_DASH"><PRE>
        <B>vdrawDIRTY_DASH</B>
</PRE>
</A>
<A NAME="vdrawDIRTY_FONT"><PRE>
        <B>vdrawDIRTY_FONT</B>
</PRE>
</A>
<A NAME="vdrawDIRTY_FUNCTION"><PRE>
        <B>vdrawDIRTY_FUNCTION</B>
</PRE>
</A>
<A NAME="vdrawDIRTY_CAP"><PRE>
        <B>vdrawDIRTY_CAP</B>
</PRE>
</A>
<A NAME="vdrawDIRTY_JOIN"><PRE>
        <B>vdrawDIRTY_JOIN</B>
</PRE>
</A>
<A NAME="vdrawDIRTY_WIDTH"><PRE>
        <B>vdrawDIRTY_WIDTH</B>
</PRE>
</A>
<A NAME="vdrawDIRTY_MITER"><PRE>
        <B>vdrawDIRTY_MITER</B>
</PRE>
</A>
<A NAME="vdrawDIRTY_PHASE"><PRE>
        <B>vdrawDIRTY_PHASE</B>
</PRE>
</A>
<A NAME="vdrawDIRTY_RULE"><PRE>
        <B>vdrawDIRTY_RULE</B>
</PRE>
</A>

<DL><DD>
These constants are used by the Drawing class low-level
driver interface, which is not documented or exported at
this time.
</DD></DL>
<P>
<A NAME="vdrawDYNAMIC_FUNCS_ARC"><HR><H4>vdrawDYNAMIC_FUNCS_ARC</H4></A>
<PRE>
        <B>vdrawDYNAMIC_FUNCS_ARC</B>
</PRE>

<DL><DD>
Should be set in the <SAMP>flags</SAMP> field of a
<CODE><A HREF="vdraw-x.html#vdrawDynamicFuncs"><CODE>vdrawDynamicFuncs</CODE></A></CODE> structure if the following
functions are defined: <SAMP>RectArcsFill</SAMP>,
<SAMP>RectArcsFillSector</SAMP>,
<SAMP>RectArcsStroke</SAMP>, <SAMP>RoundRectsFill</SAMP>,
<SAMP>RoundRectsStroke</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawFUNC_AND"><HR><H4>vdrawFUNC_AND</H4></A>
<PRE>
        <B>vdrawFUNC_AND</B>
</PRE>
<A NAME="vdrawFUNC_CLEAR"><PRE>
        <B>vdrawFUNC_CLEAR</B>
</PRE>
</A>
<A NAME="vdrawFUNC_AND_REV"><PRE>
        <B>vdrawFUNC_AND_REV</B>
</PRE>
</A>
<A NAME="vdrawFUNC_COPY"><PRE>
        <B>vdrawFUNC_COPY</B>
</PRE>
</A>
<A NAME="vdrawFUNC_AND_INV"><PRE>
        <B>vdrawFUNC_AND_INV</B>
</PRE>
</A>
<A NAME="vdrawFUNC_NOP"><PRE>
        <B>vdrawFUNC_NOP</B>
</PRE>
</A>
<A NAME="vdrawFUNC_XOR"><PRE>
        <B>vdrawFUNC_XOR</B>
</PRE>
</A>
<A NAME="vdrawFUNC_OR"><PRE>
        <B>vdrawFUNC_OR</B>
</PRE>
</A>
<A NAME="vdrawFUNC_NOR"><PRE>
        <B>vdrawFUNC_NOR</B>
</PRE>
</A>
<A NAME="vdrawFUNC_EQUIV"><PRE>
        <B>vdrawFUNC_EQUIV</B>
</PRE>
</A>
<A NAME="vdrawFUNC_INVERT"><PRE>
        <B>vdrawFUNC_INVERT</B>
</PRE>
</A>
<A NAME="vdrawFUNC_OR_REV"><PRE>
        <B>vdrawFUNC_OR_REV</B>
</PRE>
</A>
<A NAME="vdrawFUNC_COPY_INV"><PRE>
        <B>vdrawFUNC_COPY_INV</B>
</PRE>
</A>
<A NAME="vdrawFUNC_OR_INV"><PRE>
        <B>vdrawFUNC_OR_INV</B>
</PRE>
</A>
<A NAME="vdrawFUNC_NAND"><PRE>
        <B>vdrawFUNC_NAND</B>
</PRE>
</A>
<A NAME="vdrawFUNC_SET"><PRE>
        <B>vdrawFUNC_SET</B>
</PRE>
</A>
<A NAME="vdrawFUNC_HILITE"><PRE>
        <B>vdrawFUNC_HILITE</B>
</PRE>
</A>

<DL><DD>
Integral constants that specify how the source and
destination pixels of a rendering operation interact. Use
of these constants, however, is inherently device-dependent
and is not recommended for most purposes. These constants
are passed as arguments to the function
<CODE><A HREF="vdraw-x.html#vdrawSetFunction"><CODE>vdrawSetFunction</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdrawFUNC_COMPLEMENT"><HR><H4>vdrawFUNC_COMPLEMENT</H4></A>
<PRE>
        <B>vdrawFUNC_COMPLEMENT</B>
</PRE>

<DL><DD>
``Complement'' the current color with the current
complement color. ``Complementing'' has the effect of
replacing the current color with the complement color and
vice-versa inside the shape being drawn. Note that
``complementing'' may unpredictably disrupt other colors
inside the shape being drawn, depending on the window
system and display type.
<CODE><A HREF="vwindow-x.html#vwindowComplementColors"><CODE>vwindowComplementColors</CODE></A></CODE> can be used to
minimize disruption for certain color combinations.
</DD></DL>
<P>
<A NAME="vdrawINCLUDED"><HR><H4>vdrawINCLUDED</H4></A>
<PRE>
        <B>vdrawINCLUDED</B>
</PRE>

<DL><DD>
Defined when the header file <SAMP>vdraw.h</SAMP> is
included.
</DD></DL>
<P>
<A NAME="vdrawJOIN_BEVEL"><HR><H4>vdrawJOIN_BEVEL</H4></A>
<PRE>
        <B>vdrawJOIN_BEVEL</B>
</PRE>
<A NAME="vdrawJOIN_MITER"><PRE>
        <B>vdrawJOIN_MITER</B>
</PRE>
</A>
<A NAME="vdrawJOIN_ROUND"><PRE>
        <B>vdrawJOIN_ROUND</B>
</PRE>
</A>

<DL><DD>
Integral constants that determine the appearance of the
segment joins of path outlines. These constants are passed
as arguments to the function <CODE><A HREF="vdraw-x.html#vdrawSetLineJoin"><CODE>vdrawSetLineJoin</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdrawNO_ADJUST"><HR><H4>vdrawNO_ADJUST</H4></A>
<PRE>
        <B>vdrawNO_ADJUST</B>
</PRE>
<A NAME="vdrawSTROKE_ADJUST"><PRE>
        <B>vdrawSTROKE_ADJUST</B>
</PRE>
</A>

<DL><DD>
Integral constants that determine whether or not path
outlines are adjusted for uniform appearance at low
resolutions. Stroke adjustment is generally performed on
display devices, but not on hard copy devices. These
constants are passed as arguments to the function
<CODE><A HREF="vdraw-x.html#vdrawSetStrokeAdjust"><CODE>vdrawSetStrokeAdjust</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdrawPATH_CLOSE"><HR><H4>vdrawPATH_CLOSE</H4></A>
<PRE>
        <B>vdrawPATH_CLOSE</B>
</PRE>
<A NAME="vdrawPATH_MOVE"><PRE>
        <B>vdrawPATH_MOVE</B>
</PRE>
</A>
<A NAME="vdrawPATH_LINE"><PRE>
        <B>vdrawPATH_LINE</B>
</PRE>
</A>
<A NAME="vdrawPATH_CURVE"><PRE>
        <B>vdrawPATH_CURVE</B>
</PRE>
</A>

<DL><DD>
Integral constants that specify the type of a path element
during path iteration. These constants are returned by the
function <CODE><A HREF="vdraw-x.html#vdrawGetPathIteratorType"><CODE>vdrawGetPathIteratorType</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdrawPATH_COMPLEX"><HR><H4>vdrawPATH_COMPLEX</H4></A>
<PRE>
        <B>vdrawPATH_COMPLEX</B>
</PRE>
<A NAME="vdrawPATH_CONVEX"><PRE>
        <B>vdrawPATH_CONVEX</B>
</PRE>
</A>
<A NAME="vdrawPATH_NONCONVEX"><PRE>
        <B>vdrawPATH_NONCONVEX</B>
</PRE>
</A>

<DL><DD>
Integral constants that can be used to tune the performance
of fill operations. Note however, that these hints are
ignored by many window systems. These constants are passed
as arguments to the function
<CODE><A HREF="vdraw-x.html#vdrawSetComplexity"><CODE>vdrawSetComplexity</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdrawRULE_EVEN_ODD"><HR><H4>vdrawRULE_EVEN_ODD</H4></A>
<PRE>
        <B>vdrawRULE_EVEN_ODD</B>
</PRE>

<DL><DD>
Integral constants that identify the insideness test used
by a path fill function. Path fill functions can use either
the even-odd rule or the non-zero winding number rule.
These constants are only needed by low-level drivers that
call <CODE><A HREF="vdraw-x.html#vdrawGetRule"><CODE>vdrawGetRule</CODE></A></CODE>; fill functions specify a
fill rule according to function name
(<CODE><A HREF="vdraw-x.html#vdrawFill"><CODE>vdrawFill</CODE></A></CODE> versus <CODE><A HREF="vdraw-x.html#vdrawEOFill"><CODE>vdrawEOFill</CODE></A></CODE>,
for example).
</DD></DL>
<P>
<A NAME="vdrawRULE_WINDING"><HR><H4>vdrawRULE_WINDING</H4></A>
<PRE>
        <B>vdrawRULE_WINDING</B>
</PRE>

<DL><DD>
Integral constants that identify the insideness test used
by a path fill function. Path fill functions can use either
the even-odd rule or the non-zero winding number rule.
These constants are only needed by low-level drivers that
call <CODE><A HREF="vdraw-x.html#vdrawGetRule"><CODE>vdrawGetRule</CODE></A></CODE>; fill functions specify a
fill rule according to function name
(<CODE><A HREF="vdraw-x.html#vdrawFill"><CODE>vdrawFill</CODE></A></CODE> versus <CODE><A HREF="vdraw-x.html#vdrawEOFill"><CODE>vdrawEOFill</CODE></A></CODE>,
for example).
</DD></DL>
<P>
<A NAME="vdrawSHOW_X"><HR><H4>vdrawSHOW_X</H4></A>
<PRE>
        <B>vdrawSHOW_X</B>
</PRE>

<DL><DD>
Integral constants that specify which character widths are
being passed to the functions <CODE>vdrawXShow</CODE>,
<CODE>vdrawXYShow</CODE>, and <CODE>vdrawXYShow</CODE>.
Only high-level drawing replacement functions will need
these constants to implement a generic form of the exported
entry points.
</DD></DL>
<P>
<A NAME="vdrawSHOW_Y"><HR><H4>vdrawSHOW_Y</H4></A>
<PRE>
        <B>vdrawSHOW_Y</B>
</PRE>

<DL><DD>
Integral constants that specify which character widths are
being passed to the functions <CODE>vdrawXShow</CODE>,
<CODE>vdrawXYShow</CODE>, and <CODE>vdrawXYShow</CODE>.
Only high-level drawing replacement functions will need
these constants to implement a generic form of the exported
entry points.
</DD></DL>
<P>
<A NAME="vdrawSTATIC_FUNCS_COMPLEMENT"><HR><H4>vdrawSTATIC_FUNCS_COMPLEMENT</H4></A>
<PRE>
        <B>vdrawSTATIC_FUNCS_COMPLEMENT</B>
</PRE>

<DL><DD>
Should be set in the flags field of a
<CODE><A HREF="vdraw-x.html#vdrawStaticFuncs"><CODE>vdrawStaticFuncs</CODE></A></CODE> structure if the function
<SAMP>SetComplement</SAMP> is defined.
</DD></DL>
<P>
<A NAME="vdrawSTATIC_FUNCS_PHASE"><HR><H4>vdrawSTATIC_FUNCS_PHASE</H4></A>
<PRE>
        <B>vdrawSTATIC_FUNCS_PHASE</B>
</PRE>

<DL><DD>
Should be set in the flags field of a
<CODE><A HREF="vdraw-x.html#vdrawStaticFuncs"><CODE>vdrawStaticFuncs</CODE></A></CODE> structure if the function
<SAMP>SetPhase</SAMP> is defined.
</DD></DL>
<P>

<P>
<!--[[/CONTENT]]-->

<HR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">
		<TD>
		<CENTER>
<!--[[NAVIGATE_ICONIC]]-->
<!--[[/NAVIGATE_ICONIC]]-->
		</CENTER>
		</TD>
		    
		<TD>
		<BR>
		<FONT SIZE=-1>
	        <A HREF="#Top">Top of This Page</A> <BR>
	        <A HREF="index.html">Table of Contents</A> <BR>
		<A HREF="../index.html">Switch to Another Document</A><BR>
		<BR>
		</FONT>
		</TD>

		<TD>
		<BR>
		<FONT SIZE=-1>
		Need help?
		<A HREF="../contact-visix.html">
		Contact Visix</A>.
		<BR> <BR>
	        <A HREF="../copyright.html">Copyright &#169; 1996-97</A>,
		<A HREF="http://www.visix.com/">Visix Software Inc.</A><BR>
		<BR>
		</FONT>
		</TD>

	</TR>

</TABLE>
		
</BODY>
</HTML>



