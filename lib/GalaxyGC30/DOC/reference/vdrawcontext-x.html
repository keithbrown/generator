<HTML>
  <HEAD>
<!--[[HEADING]]-->
<title>vdrawcontext prefix</title><!--[[/HEADING]]-->
  </HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<A NAME="Top"><IMG SRC="../graphics/trans.gif" WIDTH=2 HEIGHT=2></A><BR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">

		<TD>
		<CENTER>
		<A HREF="../index.html">
		<IMG SRC="../graphics/logo.gif" BORDER=0></A>
		</CENTER>
		</TD>

	        <TD VALIGN=TOP>
	        <BR><H1>
<!--[[TITLE]]-->
vdrawcontext prefix<!--[[/TITLE]]-->
	        </H1><BR>
		</TD>
      
	</TR>

</TABLE>

<HR>

<BR>

<!--[[PREAMBLE]]-->
<TABLE>
<TR>
<TD><A HREF="vdrawcontext-x.html#section_DataType">Types</A> [2]</TD>
<TD><A HREF="vdrawcontext-x.html#section_Function">Functions</A> [95]</TD>
<TD><A HREF="vdrawcontext-x.html#section_Message">Messages</A> [2]</TD>
<TD><A HREF="vdrawcontext-x.html#section_Constant">Constants</A> [1]</TD>
<TD><A HREF="vdrawcontext-x.html#section_Macro">Macros</A> [1]</TD>
</TR>
</TABLE>
<!--[[/PREAMBLE]]-->

<!--[[CONTENT]]-->

<P>
<A NAME="section_DataType"><HR>
<CENTER><H2>Types</H2></CENTER></A><P>
<A NAME="vdrawcontext"><HR><H4>vdrawcontext</H4></A>
<PRE>
        typedef ... <B>vdrawcontext</B>;
</PRE>

<DL><DD>
Drawing context objects render drawing operations onto specific drawing 
devices. Changing the state of a drawing context passed into a function 
may cause unpredictable behavior.  Always clone a drawing context 
before changing any of it properties or the properties of the Pen 
associated with it. Use the functions that do not change the state of 
the drawing context (i.e. <CODE><A HREF="vdrawcontext-x.html#vdrawcontextDrawPath"><CODE>vdrawcontextDrawPath</CODE></A></CODE> or 
<CODE>vdrawcontextFillRectangle</CODE>).
</DD></DL>
<P>
<A NAME="vdrawcontextClass"><HR><H4>vdrawcontextClass</H4></A>
<PRE>
        typedef ... <B>vdrawcontextClass</B>;
</PRE>

<DL><DD>
Contains method and variables bindings for objects of type 
<CODE>vdrawcontext</CODE>.
</DD></DL>
<P>
<A NAME="section_Function"><HR>
<CENTER><H2>Functions</H2></CENTER></A><P>
<A NAME="vdrawcontextClipPath"><HR><H4>vdrawcontextClipPath</H4></A>
<PRE>
        void <B>vdrawcontextClipPath</B>(
                vdrawcontext * context,
                vdrawpath * path);
</PRE>

<DL><DD>
Intersects the specified path with the clipping path of the drawing 
context. Always clone a drawing context passed in as a function parameter 
before altering the clipping path.
</DD></DL>
<P>
<A NAME="vdrawcontextClipPathEvenOdd"><HR><H4>vdrawcontextClipPathEvenOdd</H4></A>
<PRE>
        void <B>vdrawcontextClipPathEvenOdd</B>(
                vdrawcontext * context,
                vdrawpath * path);
</PRE>

<DL><DD>
Intersects the specified path with the clipping path of the drawing 
context and uses the even-odd rule to determine the shape of the new 
clipping path. Always clone a drawing context passed in as a function 
parameter before altering the clipping path.
</DD></DL>
<P>
<A NAME="vdrawcontextClipRectangles"><HR><H4>vdrawcontextClipRectangles</H4></A>
<PRE>
        void <B>vdrawcontextClipRectangles</B>(
                vdrawcontext * context,
                const vrect * rects,
                size_t count);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vdrawcontextClipRects"><HR><H4>vdrawcontextClipRects</H4></A>
<PRE>
        void <B>vdrawcontextClipRects</B>();
</PRE>

<DL><DD>
Intersects the specified rectangles with the clipping path of the drawing context. Always clone a drawing context passed in as a function parameter before altering the clipping path.
</DD></DL>
<P>
<A NAME="vdrawcontextClone"><HR><H4>vdrawcontextClone</H4></A>
<PRE>
        vdrawcontext * <B>vdrawcontextClone</B>(
                vdrawcontext * context);
</PRE>

<DL><DD>
Creates the copy of the drawing context <SAMP>context</SAMP> and returns a pointer to its contents. The Drawing Context Manager allocates storage for the drawing context object. The manager reclaims the storage occupied by the drawing context when it destroyed with <CODE>vrawcontextDestroy</CODE>. This function essentially allocates space for a new context and calls <CODE><A HREF="vdrawcontext-x.html#vdrawcontextCopyInit"><CODE>vdrawcontextCopyInit</CODE></A></CODE> on it. 
</DD></DL>
<P>
<A NAME="vdrawcontextCloneClipPath"><HR><H4>vdrawcontextCloneClipPath</H4></A>
<PRE>
        vdrawpath * <B>vdrawcontextCloneClipPath</B>(
                vdrawcontext * context);
</PRE>

<DL><DD>
Returns a copy of the clipping path in drawing context.
</DD></DL>
<P>
<A NAME="vdrawcontextCloneViewClipPath"><HR><H4>vdrawcontextCloneViewClipPath</H4></A>
<PRE>
        vdrawpath * <B>vdrawcontextCloneViewClipPath</B>(
                vdrawcontext * context);
</PRE>

<DL><DD>
Returns a copy of the view clipping path for the current thread.
</DD></DL>
<P>
<A NAME="vdrawcontextCopy"><HR><H4>vdrawcontextCopy</H4></A>
<PRE>
        void <B>vdrawcontextCopy</B>(
                vdrawcontext * context,
                vdrawcontext * target);
</PRE>

<DL><DD>
Copies the information in <SAMP>context</SAMP> into
<SAMP>target</SAMP> so that the two drawing contexts represent equivalent objects. <SAMP>target</SAMP> must have been created or initialized. <SAMP>context</SAMP> and <SAMP>target</SAMP> must have compatible classes for this to work correctly. This function copies all the attributes of the context except <CODE>Class</CODE> --- it clones a pen owned by the context. This function destroys any objects allocated internally by
<SAMP>target</SAMP>, but does <I>not</I> destroy <SAMP>target</SAMP> itself. The context to be copied can be dynamic or static. This function
is implemented by sending the message <CODE>vobjectCOPY</CODE> to <SAMP>context</SAMP>. 
</DD></DL>
<P>
<A NAME="vdrawcontextCopyInit"><HR><H4>vdrawcontextCopyInit</H4></A>
<PRE>
        void <B>vdrawcontextCopyInit</B>(
                vdrawcontext * context,
                vdrawcontext * target);
</PRE>

<DL><DD>
Copies the information in <SAMP>conetxt</SAMP> into
<SAMP>target</SAMP> so the memory addressed by
<SAMP>target</SAMP> is a drawing context equivalent to
<SAMP>context</SAMP>. <SAMP>target</SAMP> should be a pointer to uninitialized memory --- the Draw Manager initializes it as part of the copy. This function copies all the attributes of the context --- it clones any objects that are owned by the context. This function stores the class of <SAMP>context</SAMP> in <SAMP>target</SAMP> and sends the message
<CODE>vobjectCOPY_INIT</CODE> to <SAMP>context</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawcontextCreate"><HR><H4>vdrawcontextCreate</H4></A>
<PRE>
        vdrawcontext * <B>vdrawcontextCreate</B>();
</PRE>

<DL><DD>
Creates a new drawing context of the default drawing context class and returns a pointer to its contents. The Draw Manager allocates storage for the drawing context. The Draw Manager reclaims the storage occupied by the context when it is destroyed with <CODE><A HREF="vdrawcontext-x.html#vdrawcontextDestroy"><CODE>vdrawcontextDestroy</CODE></A></CODE>. The new context is created with a set of default attributes, as determined by the default drawing context class. This function essentially allocates space for a new context and calls <CODE><A HREF="vdrawcontext-x.html#vdrawcontextInit"><CODE>vdrawcontextInit</CODE></A></CODE> on it.
</DD></DL>
<P>
<A NAME="vdrawcontextCreateOfClass"><HR><H4>vdrawcontextCreateOfClass</H4></A>
<PRE>
        vdrawcontext * <B>vdrawcontextCreateOfClass</B>(
                vdrawcontextClass * clas);
</PRE>

<DL><DD>
Creates a new drawing context of the specified class and returns a pointer to its contents. The Draw Manager allocates storage for the drawing context. The Draw Manager reclaims the storage occupied by the context when it is destroyed with <CODE><A HREF="vdrawcontext-x.html#vdrawcontextDestroy"><CODE>vdrawcontextDestroy</CODE></A></CODE>. The new context is created with a set of default attributes, as determined by the class. This function essentially allocates space for a new context and calls <CODE><A HREF="vdrawcontext-x.html#vdrawcontextInit"><CODE>vdrawcontextInit</CODE></A></CODE> on it.
</DD></DL>
<P>
<A NAME="vdrawcontextDeltaTransformDimension"><HR><H4>vdrawcontextDeltaTransformDimension</H4></A>
<PRE>
        void <B>vdrawcontextDeltaTransformDimension</B>(
                vdrawcontext * context,
                double x,
                double y,
                double * xo,
                double * yo);
</PRE>

<DL><DD>
Transforms the distance vector in user space into the device space for 
the drawing context. Delta Transformation does not use the translation 
component of the current transform; only the rotation and scaling 
components.
</DD></DL>
<P>
<A NAME="vdrawcontextDestroy"><HR><H4>vdrawcontextDestroy</H4></A>
<PRE>
        void <B>vdrawcontextDestroy</B>(
                vdrawcontext * context);
</PRE>

<DL><DD>
Destroys the drawing context represented by <SAMP>context</SAMP>, which must have been created or initialized. Use this function to reclaim the storage occupied by a drawing context. The context should not be referenced by any other object when it is destroyed. This function only attempts to free the storage occupied by the context if it was allocated by
<CODE><A HREF="vdrawcontext-x.html#vdrawcontextCreate"><CODE>vdrawcontextCreate</CODE></A></CODE>, <CODE><A HREF="vdrawcontext-x.html#vdrawcontextClone"><CODE>vdrawcontextClone</CODE></A></CODE>,
<CODE><A HREF="vdrawcontext-x.html#vdrawcontextCreateOfClass"><CODE>vdrawcontextCreateOfClass</CODE></A></CODE> or <CODE>vdrawcontextLoad</CODE>
This function also destroys any objects that are owned by the context. This function is implemented by sending the message
<CODE>vobjectDESTROY</CODE> to <SAMP>context</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawcontextDestroyLater"><HR><H4>vdrawcontextDestroyLater</H4></A>
<PRE>
        void <B>vdrawcontextDestroyLater</B>(
                vdrawcontext * context);
</PRE>

<DL><DD>
Destroys the drawing context represented by <SAMP>conetxt</SAMP> in the same manner as <CODE>vdrawcontextDestroy</CODE>, except that the destruction does not actually occur until after handling of the current event is completed. This function is sometimes necessary when destroying a context from an event handler, and the context is referenced by the contents of the event. This function is implemented by sending the message <CODE>vobjectDESTROY</CODE> to <SAMP>context</SAMP> once the current event handler is finished.
</DD></DL>
<P>
<A NAME="vdrawcontextDispose"><HR><H4>vdrawcontextDispose</H4></A>
<PRE>
        void <B>vdrawcontextDispose</B>(
                vdrawcontext * context);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vdrawcontextDrawArcs"><HR><H4>vdrawcontextDrawArcs</H4></A>
<PRE>
        void <B>vdrawcontextDrawArcs</B>(
                vdrawcontext * context,
                const vrect * rects,
                size_t size,
                double startAngle,
                double endAngle);
</PRE>

<DL><DD>
Outlines in the current pen color <SAMP>size</SAMP> arcs such that each arc is tangent to the sides of the corresponding rectangle in the array 
<SAMP>rects</SAMP>. Each arc is constructed from <SAMP>startAngle</SAMP> to <SAMP>endAngle</SAMP> counterclockwise degrees. The arc is measured counterclockwise from the start angle to the end angle and is tangent to the sides of the rectangle. Angles are measured in degrees.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawArcsInside"><HR><H4>vdrawcontextDrawArcsInside</H4></A>
<PRE>
        void <B>vdrawcontextDrawArcsInside</B>(
                vdrawcontext * context,
                const vrect * rects,
                size_t size,
                double startAngle,
                double endAngle);
</PRE>

<DL><DD>
Outlines in the current pen color <SAMP>size</SAMP> arcs such that 
outline of each arc (as determined by the current line width) is tangent 
to the sides of the corresponding rectangle in the array 
<SAMP>rects</SAMP>. Each arc is constructed from <SAMP>startAngle</SAMP> 
to <SAMP>endAngle</SAMP> counterclockwise degrees.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawEllipses"><HR><H4>vdrawcontextDrawEllipses</H4></A>
<PRE>
        void <B>vdrawcontextDrawEllipses</B>(
                vdrawcontext * context,
                const vrect * rects,
                size_t size);
</PRE>

<DL><DD>
Outlines <SAMP>size</SAMP> arcs in the current pen color such that each 
arc is an ellipse tangent to the sides of the corresponding rectangle in 
the array <SAMP>rects</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawEllipsesInside"><HR><H4>vdrawcontextDrawEllipsesInside</H4></A>
<PRE>
        void <B>vdrawcontextDrawEllipsesInside</B>(
                vdrawcontext * context,
                const vrect * rects,
                size_t size);
</PRE>

<DL><DD>
Outlines <SAMP>size</SAMP> arcs such that the outline of
each arc (as determined by the current line width) is an
ellipse tangent to the sides of the corresponding rectangle
in the array <SAMP>rects</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawHilitedBox"><HR><H4>vdrawcontextDrawHilitedBox</H4></A>
<PRE>
        void <B>vdrawcontextDrawHilitedBox</B>(
                vdrawcontext * context,
                const vrect * rect,
                vcolor * interior,
                vcolor * top,
                vcolor * bottom);
</PRE>

<DL><DD>
Draws a highlighted box inside the rectangle <SAMP>rect</SAMP>, with 
interior color <SAMP>interior</SAMP>, and shadow colors <SAMP>top</SAMP> 
and <SAMP>bottom</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawHilitedDiamond"><HR><H4>vdrawcontextDrawHilitedDiamond</H4></A>
<PRE>
        void <B>vdrawcontextDrawHilitedDiamond</B>(
                vdrawcontext * context,
                const vrect * rect,
                vcolor * interior,
                vcolor * top,
                vcolor * bottom);
</PRE>

<DL><DD>
Draws a highlighted diamond inside the rectangle <SAMP>rect</SAMP>, with 
interior color <SAMP>interior</SAMP>, and shadow colors
<SAMP>top</SAMP> and <SAMP>bottom</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawHilitedRectangles"><HR><H4>vdrawcontextDrawHilitedRectangles</H4></A>
<PRE>
        void <B>vdrawcontextDrawHilitedRectangles</B>(
                vdrawcontext * context,
                const vrect * rects,
                size_t count,
                vcolor * topShadow,
                vcolor * bottomShadow);
</PRE>

<DL><DD>
Outlines "embossed" or "engraved" shaded rectangles. The top color should 
be darker than the bottom color for an "embossed" or raised effect.  
Switching the colors yields an "engraved" or lowered effect.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawHilitedRectanglesInside"><HR><H4>vdrawcontextDrawHilitedRectanglesInside</H4></A>
<PRE>
        void <B>vdrawcontextDrawHilitedRectanglesInside</B>(
                vdrawcontext * context,
                const vrect * rects,
                size_t count,
                vcolor * topShadow,
                vcolor * bottomShadow);
</PRE>

<DL><DD>
Outlines "embossed" or "engraved" shaded rectangles. The rendered 
rectangles are completely inside the bounds of the specified rectangle.
The top color should be darker than the bottom color for an "embossed" or 
raised effect.  Switching the colors yields an "engraved" or lowered 
effect.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawHorizontalHilitedArrow"><HR><H4>vdrawcontextDrawHorizontalHilitedArrow</H4></A>
<PRE>
        void <B>vdrawcontextDrawHorizontalHilitedArrow</B>(
                vdrawcontext * context,
                int x,
                int y,
                int length,
                int half,
                vcolor * interior,
                vcolor * straight,
                vcolor * bent);
</PRE>

<DL><DD>
Draws an arrow with a three-dimensional appearance, pointing in a 
horizontal direction. <SAMP>x</SAMP>, <SAMP>y</SAMP> is the location at 
which to draw the arrow and <SAMP>interior</SAMP>, <SAMP>straight</SAMP>, 
and <SAMP>bent</SAMP> are the shadow colors to use. <SAMP>length</SAMP> 
is the length of the arrow to draw and <SAMP>half</SAMP> is half the 
width of the arrow.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawImage"><HR><H4>vdrawcontextDrawImage</H4></A>
<PRE>
        void <B>vdrawcontextDrawImage</B>(
                vdrawcontext * context,
                vimage * image,
                vmatrix * mtx);
</PRE>

<DL><DD>
Renders the image <SAMP>image</SAMP>.
The transformation matrix <SAMP>mtx</SAMP> maps coordinates
in user space to coordinates in the source image space and
defines the region of user space that receives the image.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawImagePoint"><HR><H4>vdrawcontextDrawImagePoint</H4></A>
<PRE>
        void <B>vdrawcontextDrawImagePoint</B>(
                vdrawcontext * context,
                vimage * image,
                double x,
                double y);
</PRE>

<DL><DD>
Renders the specified image on the device represented by the drawing 
context. 
The origin of the image is located at the specified point with the 
coordinates <SAMP>x</SAMP> and <SAMP>y</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawImageRect"><HR><H4>vdrawcontextDrawImageRect</H4></A>
<PRE>
        void <B>vdrawcontextDrawImageRect</B>();
</PRE>

<DL><DD>
Renders the image into the rectangle on the device represented by the 
drawing 
context. The image is scaled to the size of the rectangle 
<SAMP>rect</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawImageRectangle"><HR><H4>vdrawcontextDrawImageRectangle</H4></A>
<PRE>
        void <B>vdrawcontextDrawImageRectangle</B>(
                vdrawcontext * context,
                vimage * image,
                const vrect * rect);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vdrawcontextDrawImageTiled"><HR><H4>vdrawcontextDrawImageTiled</H4></A>
<PRE>
        void <B>vdrawcontextDrawImageTiled</B>(
                vdrawcontext * context,
                vimage * image,
                const vrect * tileRect,
                const vrect * destRect);
</PRE>

<DL><DD>
Renders the portion of the image specified in <SAMP>tileRect</SAMP> into 
the rectangle <SAMP>destRect</SAMP> on the device represented by the 
drawing context. If the size of <SAMP>tileRect</SAMP> is greater than the 
size of the image, the image is tiled to fill it.  The position (x,y) of 
the tiling rectangle is the offset of the first "tile."  The tiled image 
is scaled to fit in <SAMP>destRect</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawKeyStroke"><HR><H4>vdrawcontextDrawKeyStroke</H4></A>
<PRE>
        void <B>vdrawcontextDrawKeyStroke</B>(
                vdrawcontext * context,
                vkeyStroke key);
</PRE>

<DL><DD>
Renders a human readable representation of the keystroke on the device 
represented by the drawing context.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawLineTo"><HR><H4>vdrawcontextDrawLineTo</H4></A>
<PRE>
        void <B>vdrawcontextDrawLineTo</B>(
                vdrawcontext * context,
                double x,
                double y);
</PRE>

<DL><DD>
Renders a line connecting the current point of the drawing context to the 
point <SAMP>x</SAMP>,<SAMP>y</SAMP>. The current point of the context is 
set to this point.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawLineToRelative"><HR><H4>vdrawcontextDrawLineToRelative</H4></A>
<PRE>
        void <B>vdrawcontextDrawLineToRelative</B>(
                vdrawcontext * context,
                double x,
                double y);
</PRE>

<DL><DD>
Renders a line connecting the current point of the drawing context to the 
specified point relative to the current point. The current point of the 
drawing context is offset by the <SAMP>x</SAMP> and <SAMP>y</SAMP> 
values.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawMask"><HR><H4>vdrawcontextDrawMask</H4></A>
<PRE>
        void <B>vdrawcontextDrawMask</B>(
                vdrawcontext * context,
                vimage * mask,
                vmatrix * mtx);
</PRE>

<DL><DD>
Renders the specified mask image on the device represented by the drawing 
context. The specified matrix maps image space to user space. The mask 
image must be a monochrome image (1 bit deep).
</DD></DL>
<P>
<A NAME="vdrawcontextDrawMaskPoint"><HR><H4>vdrawcontextDrawMaskPoint</H4></A>
<PRE>
        void <B>vdrawcontextDrawMaskPoint</B>(
                vdrawcontext * context,
                vimage * mask,
                double x,
                double y);
</PRE>

<DL><DD>
Renders the specified mask image on the device represented by the drawing 
context. The origin of the image is located at the specified point.
The mask image must be a monochrome image (1 bit deep).
</DD></DL>
<P>
<A NAME="vdrawcontextDrawMaskRect"><HR><H4>vdrawcontextDrawMaskRect</H4></A>
<PRE>
        void <B>vdrawcontextDrawMaskRect</B>();
</PRE>

<DL><DD>
Renders the mask image into the rectangle on the device represented by 
the drawing context. The image is scaled to the size of the rectangle.
The mask image must be a monochrome image (1 bit deep).
</DD></DL>
<P>
<A NAME="vdrawcontextDrawMaskRectangle"><HR><H4>vdrawcontextDrawMaskRectangle</H4></A>
<PRE>
        void <B>vdrawcontextDrawMaskRectangle</B>(
                vdrawcontext * context,
                vimage * mask,
                const vrect * rect);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vdrawcontextDrawMaskTiled"><HR><H4>vdrawcontextDrawMaskTiled</H4></A>
<PRE>
        void <B>vdrawcontextDrawMaskTiled</B>(
                vdrawcontext * context,
                vimage * mask,
                const vrect * tileRect,
                const vrect * destRect);
</PRE>

<DL><DD>
Renders the portion of the mask image specified in
<SAMP>tileRect</SAMP> into the rectangle <SAMP>destRect</SAMP> on the 
device represented by the drawing context. 
If the size of <SAMP>tileRect</SAMP> is greater than the size of the 
image, the image is tiled to fill it.  The position (x,y) of the tiling 
rectangle is the offset of the first "tile."  The tiled image is scaled 
to fit in <SAMP>destRect</SAMP>. The mask image must be a monochrome 
image (1 bit deep).
</DD></DL>
<P>
<A NAME="vdrawcontextDrawPath"><HR><H4>vdrawcontextDrawPath</H4></A>
<PRE>
        void <B>vdrawcontextDrawPath</B>(
                vdrawcontext * context,
                vdrawpath * path);
</PRE>

<DL><DD>
Renders the out line of the draw path on to the device represented by the 
drawing context.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawRectangles"><HR><H4>vdrawcontextDrawRectangles</H4></A>
<PRE>
        void <B>vdrawcontextDrawRectangles</B>(
                vdrawcontext * context,
                const vrect * rect,
                size_t count);
</PRE>

<DL><DD>
Renders <SAMP>count</SAMP> of the rectangles in the array 
<SAMP>rect</SAMP> on the device represented by the drawing context.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawRectanglesFloat"><HR><H4>vdrawcontextDrawRectanglesFloat</H4></A>
<PRE>
        void <B>vdrawcontextDrawRectanglesFloat</B>(
                vdrawcontext * context,
                const vrectFloat * rect,
                size_t count);
</PRE>

<DL><DD>
Renders <SAMP>count</SAMP> of the rectangles in the array 
<SAMP>rect</SAMP> on the device represented by the drawing context.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawRectanglesInside"><HR><H4>vdrawcontextDrawRectanglesInside</H4></A>
<PRE>
        void <B>vdrawcontextDrawRectanglesInside</B>(
                vdrawcontext * context,
                const vrect * rect,
                size_t count);
</PRE>

<DL><DD>
Outlines <SAMP>count</SAMP> of the rectangles in the array 
<SAMP>rect</SAMP> on the device represented by the drawing context.
All of the drawing will be inside the bounds of the rectangle, regardless 
of the current line width.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawRoundRectangles"><HR><H4>vdrawcontextDrawRoundRectangles</H4></A>
<PRE>
        void <B>vdrawcontextDrawRoundRectangles</B>(
                vdrawcontext * context,
                const vrect * rect,
                size_t count,
                double radius);
</PRE>

<DL><DD>
Outlines round-corner rectangles with sides that lay along the sides of 
each rectangle in the array <SAMP>rects</SAMP>. There are 
<SAMP>count</SAMP> rectangles in the array.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawRoundRectanglesInside"><HR><H4>vdrawcontextDrawRoundRectanglesInside</H4></A>
<PRE>
        void <B>vdrawcontextDrawRoundRectanglesInside</B>(
                vdrawcontext * context,
                const vrect * rect,
                size_t count,
                double radius);
</PRE>

<DL><DD>
Outlines <SAMP>count</SAMP> round-corner rectangles in the 
array<SAMP>rects</SAMP> with sides that lay parallel with sides of each 
rectangle in the array.  The outlines are constrained to inside of the 
rectangles in the set.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawString"><HR><H4>vdrawcontextDrawString</H4></A>
<PRE>
        void <B>vdrawcontextDrawString</B>(
                vdrawcontext * context,
                const vchar * string,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the string inside the rectangle.
The string is drawn in the current pen color using the current pen font. 
The origin of the first character is at the lower left corner of the 
rectangle. The string is clipped to the rectangle.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawStringCenter"><HR><H4>vdrawcontextDrawStringCenter</H4></A>
<PRE>
        void <B>vdrawcontextDrawStringCenter</B>(
                vdrawcontext * context,
                const vchar * string,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the string font centered in the rectangle.
The string is drawn in the current pen color using the current pen font. 
The string is centered both vertically and horizontally in the rectangle. 
The string is clipped to the rectangle.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawStringCenterHorizontally"><HR><H4>vdrawcontextDrawStringCenterHorizontally</H4></A>
<PRE>
        void <B>vdrawcontextDrawStringCenterHorizontally</B>(
                vdrawcontext * context,
                const vchar * string,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the string centered in the rectangle horizontally. The string is 
drawn in the current pen color using the current pen font. The string is 
centered horizontally in the rectangle and runs along the lower side. The 
string is clipped to the rectangle.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawStringCenterHorizontallyScribed"><HR><H4>vdrawcontextDrawStringCenterHorizontallyScribed</H4></A>
<PRE>
        void <B>vdrawcontextDrawStringCenterHorizontallyScribed</B>(
                vdrawcontext * context,
                vscribe * scribe,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> centered in the rectangle 
horizontally.
The scribe is drawn in the current pen color using the current pen font.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawStringCenterScribed"><HR><H4>vdrawcontextDrawStringCenterScribed</H4></A>
<PRE>
        void <B>vdrawcontextDrawStringCenterScribed</B>(
                vdrawcontext * context,
                vscribe * scribe,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> centered in the rectangle.
The scribe is drawn in the current pen color using the current pen font.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawStringCenterVertically"><HR><H4>vdrawcontextDrawStringCenterVertically</H4></A>
<PRE>
        void <B>vdrawcontextDrawStringCenterVertically</B>(
                vdrawcontext * context,
                const vchar * string,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the string centered in the rectangle vertically. The string is 
drawn in the current pen color using the current pen font.  The string is 
centered vertically in the rectangle and the first character is against 
the left side of the rectangle. The string is clipped to the rectangle.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawStringCenterVerticallyScribed"><HR><H4>vdrawcontextDrawStringCenterVerticallyScribed</H4></A>
<PRE>
        void <B>vdrawcontextDrawStringCenterVerticallyScribed</B>(
                vdrawcontext * context,
                vscribe * scribe,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> centered in the rectangle 
vertically. The scribe is drawn in the current pen color using the 
current pen font.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawStringScribed"><HR><H4>vdrawcontextDrawStringScribed</H4></A>
<PRE>
        void <B>vdrawcontextDrawStringScribed</B>(
                vdrawcontext * context,
                vscribe * scribe,
                const vrect * rect);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> inside the rectangle.
The scribe is drawn in the current pen color using the current pen font. 
The origin of the first character is at the lower left corner of the 
rectangle. The string is clipped to the rectangle.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawStringUnderlineMnemonic"><HR><H4>vdrawcontextDrawStringUnderlineMnemonic</H4></A>
<PRE>
        void <B>vdrawcontextDrawStringUnderlineMnemonic</B>(
                vdrawcontext * context,
                const vchar * title,
                int mnemonic,
                const vrect * rect,
                unsigned int flags);
</PRE>

<DL><DD>
Draws the string <SAMP>title</SAMP> in the current pen font inside the 
rectangle <SAMP>rect</SAMP> with the character <SAMP>mnemonic</SAMP>
underlined. <SAMP>flags</SAMP> indicates how the string
should be centered. Use the constant <SAMP>vdrawShow_X</SAMP> to center 
the string horizontally, <SAMP>vdrawShow_Y</SAMP> to center the string 
vertically, and <SAMP>vdrawShow_X | vdrawShow_Y</SAMP> to center the 
string both horizontally and vertically. If the <SAMP>rect</SAMP> is 
<CODE>NULL</CODE> then the string is drawn at the current point.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawStringUnderlineMnemonicScribed"><HR><H4>vdrawcontextDrawStringUnderlineMnemonicScribed</H4></A>
<PRE>
        void <B>vdrawcontextDrawStringUnderlineMnemonicScribed</B>(
                vdrawcontext * context,
                vscribe * scribe,
                int mnemonic,
                const vrect * rect,
                unsigned int flags);
</PRE>

<DL><DD>
Draws the scribe <SAMP>scribe</SAMP> in the current pen font inside the 
rectangle <SAMP>rect</SAMP> with the character <SAMP>mnemonic</SAMP> 
underlined. <SAMP>flags</SAMP> indicates how the string should be 
centered. Use the constant <SAMP>vdrawShow_X</SAMP> to center the string 
horizontally, <SAMP>vdrawShow_Y</SAMP> to center the string vertically, 
and <SAMP>vdrawShow_X | vdrawShow_Y</SAMP> to center the string both 
horizontally and vertically. If the <SAMP>rect</SAMP> is 
<CODE>NULL</CODE> then the string is drawn at the current point.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawStringUnderlined"><HR><H4>vdrawcontextDrawStringUnderlined</H4></A>
<PRE>
        void <B>vdrawcontextDrawStringUnderlined</B>(
                vdrawcontext * context,
                const vchar * string);
</PRE>

<DL><DD>
Draws the string at the current point in the current pen font and 
underlines it. The string is drawn in the current pen color using the 
current pen font. The origin of the first character is at the current 
point. The drawing context must have a current point set. The first 
occurrence of the mnemonic character is underlined.  The current point is 
moved to the end of the string.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawStringUnderlinedScribed"><HR><H4>vdrawcontextDrawStringUnderlinedScribed</H4></A>
<PRE>
        void <B>vdrawcontextDrawStringUnderlinedScribed</B>(
                vdrawcontext * context,
                vscribe * scribe);
</PRE>

<DL><DD>
Draws the scribe at the current point in the current pen font and 
underlines it. The string is drawn in the current pen color using the 
current pen font. The origin of the first character is at the current 
point. The drawing context must have a current point set. The first 
occurrence of the mnemonic character is underlined.  The current point is 
moved to the end of the string.
</DD></DL>
<P>
<A NAME="vdrawcontextDrawVerticalHilitedArrow"><HR><H4>vdrawcontextDrawVerticalHilitedArrow</H4></A>
<PRE>
        void <B>vdrawcontextDrawVerticalHilitedArrow</B>(
                vdrawcontext * context,
                int x,
                int y,
                int length,
                int half,
                vcolor * interior,
                vcolor * straight,
                vcolor * bent);
</PRE>

<DL><DD>
Draws an arrow with a three-dimensional appearance pointing in a vertical 
direction. <SAMP>x</SAMP>, <SAMP>y</SAMP> is the location at which to 
draw the arrow and <SAMP>interior</SAMP>, <SAMP>straight</SAMP>, and 
<SAMP>bent</SAMP> are the shadow colors to use. <SAMP>length</SAMP> is 
the length of the arrow to draw and <SAMP>half</SAMP> is half the width 
of the arrow.
</DD></DL>
<P>
<A NAME="vdrawcontextFillArcChords"><HR><H4>vdrawcontextFillArcChords</H4></A>
<PRE>
        void <B>vdrawcontextFillArcChords</B>(
                vdrawcontext * context,
                const vrect * rects,
                size_t count,
                double startAngle,
                double endAngle);
</PRE>

<DL><DD>
Fills <SAMP>count</SAMP> chords of arcs with the current pen color such 
that each arc is tangent to the sides of the corresponding rectangle in 
the array <SAMP>rects</SAMP>. Each arc is constructed from 
<SAMP>startAngle</SAMP> to <SAMP>endAngle</SAMP> counterclockwise 
degrees.
</DD></DL>
<P>
<A NAME="vdrawcontextFillArcSectors"><HR><H4>vdrawcontextFillArcSectors</H4></A>
<PRE>
        void <B>vdrawcontextFillArcSectors</B>(
                vdrawcontext * context,
                const vrect * rects,
                size_t count,
                double startAngle,
                double endAngle);
</PRE>

<DL><DD>
Fills <SAMP>count</SAMP> sectors of arcs with the current pen color such 
that each arc is tangent to the sides of the corresponding rectangle in 
the array <SAMP>rects</SAMP>. Each arc is constructed from 
<SAMP>startAngle</SAMP> to <SAMP>endAngle</SAMP> counterclockwise 
degrees.
</DD></DL>
<P>
<A NAME="vdrawcontextFillEllipses"><HR><H4>vdrawcontextFillEllipses</H4></A>
<PRE>
        void <B>vdrawcontextFillEllipses</B>(
                vdrawcontext * context,
                const vrect * rects,
                size_t count);
</PRE>

<DL><DD>
Fills each of the <SAMP>count</SAMP> ellipses that are tangent to the 
sides of the corresponding rectangle in the array with the current pen 
color.
</DD></DL>
<P>
<A NAME="vdrawcontextFillHilitedRectangles"><HR><H4>vdrawcontextFillHilitedRectangles</H4></A>
<PRE>
        void <B>vdrawcontextFillHilitedRectangles</B>(
                vdrawcontext * context,
                const vrect * rects,
                size_t count,
                vcolor * interior,
                vcolor * topShadow,
                vcolor * bottomShadow);
</PRE>

<DL><DD>
Fills <SAMP>count</SAMP> "embossed" or "engraved" shaded rectangles with 
the current pen color. The top color should be darker than the bottom 
color for an "embossed" or raised effect. Switching the colors yields an 
"engraved" or lowered effect.
</DD></DL>
<P>
<A NAME="vdrawcontextFillHilitedRectanglesInside"><HR><H4>vdrawcontextFillHilitedRectanglesInside</H4></A>
<PRE>
        void <B>vdrawcontextFillHilitedRectanglesInside</B>(
                vdrawcontext * context,
                const vrect * rects,
                size_t count,
                vcolor * interior,
                vcolor * topShadow,
                vcolor * bottomShadow);
</PRE>

<DL><DD>
Fills <SAMP>count</SAMP> "embossed" or "engraved" shaded rectangles with 
the current pen color. The drawing is constrained to inside the bounds of 
each rectangle. The top color should be darker than the bottom color for 
an "embossed" or raised effect. Switching the colors yields an "engraved" 
or lowered effect.
</DD></DL>
<P>
<A NAME="vdrawcontextFillPath"><HR><H4>vdrawcontextFillPath</H4></A>
<PRE>
        void <B>vdrawcontextFillPath</B>(
                vdrawcontext * context,
                vdrawpath * path);
</PRE>

<DL><DD>
Fills the path with the current pen color.
This function determines which pixels change using the nonzero winding 
rule. See the Programmer's Guide for a discussion of the nonzero winding 
rule.
</DD></DL>
<P>
<A NAME="vdrawcontextFillPathEvenOdd"><HR><H4>vdrawcontextFillPathEvenOdd</H4></A>
<PRE>
        void <B>vdrawcontextFillPathEvenOdd</B>(
                vdrawcontext * context,
                vdrawpath * path);
</PRE>

<DL><DD>
Fills the path with the current pen.
This function determines which pixels change using the even-odd rule. See 
the Programmer's Guide for a discussion of the even-odd rule.
</DD></DL>
<P>
<A NAME="vdrawcontextFillRectangles"><HR><H4>vdrawcontextFillRectangles</H4></A>
<PRE>
        void <B>vdrawcontextFillRectangles</B>(
                vdrawcontext * context,
                const vrect * rects,
                size_t count);
</PRE>

<DL><DD>
Fills <SAMP>count</SAMP> rectangles from the array <SAMP>rects</SAMP> 
with the current pen color.
</DD></DL>
<P>
<A NAME="vdrawcontextFillRectanglesFloat"><HR><H4>vdrawcontextFillRectanglesFloat</H4></A>
<PRE>
        void <B>vdrawcontextFillRectanglesFloat</B>(
                vdrawcontext * context,
                const vrectFloat * rects,
                size_t count);
</PRE>

<DL><DD>
Fills <SAMP>count</SAMP> rectangles from the array <SAMP>rects</SAMP> 
with the current pen color.
</DD></DL>
<P>
<A NAME="vdrawcontextFillRoundRectangles"><HR><H4>vdrawcontextFillRoundRectangles</H4></A>
<PRE>
        void <B>vdrawcontextFillRoundRectangles</B>(
                vdrawcontext * context,
                const vrect * rects,
                size_t count,
                double radius);
</PRE>

<DL><DD>
Fills <SAMP>count</SAMP> round-corner rectangles the with sides that lay 
along the sides of each rectangle in the array <SAMP>rects</SAMP> with 
the current pen color.
</DD></DL>
<P>
<A NAME="vdrawcontextForceDeviceResolutionScaling"><HR><H4>vdrawcontextForceDeviceResolutionScaling</H4></A>
<PRE>
        void <B>vdrawcontextForceDeviceResolutionScaling</B>(
                vdrawcontext * context);
</PRE>

<DL><DD>
Forces the drawing context to scale user space to exact device space 
coordinates. By default, devices with a resolution of 60 to 120 dots per 
inch are "rounded" to user space resolution (72 dots per inch).  The more 
precise rendering will noticeably impact drawing performance.
</DD></DL>
<P>
<A NAME="vdrawcontextGetClass"><HR><H4>vdrawcontextGetClass</H4></A>
<PRE>
        vdrawcontextClass * <B>vdrawcontextGetClass</B>(
                vdrawcontext * context);
</PRE>

<DL><DD>
Returns the class of the drawing context.
</DD></DL>
<P>
<A NAME="vdrawcontextGetClipBounds"><HR><H4>vdrawcontextGetClipBounds</H4></A>
<PRE>
        const vrect * <B>vdrawcontextGetClipBounds</B>(
                vdrawcontext * context,
                size_t * count);
</PRE>

<DL><DD>
Computes a set of bounding boxes that enclose the drawing context's 
current clipping path. This function then returns the box coordinates and 
the number of boxes in <SAMP>count</SAMP>. Depending on the window 
system, this function either returns a bounding box for each individual 
subpath or returns a single bounding box for the entire path. The 
bounding box of a subpath is the smallest rectangle that encloses all 
points along the subpath (see Figure). This function does not take line 
width into account. If the subpath contains curves, the bounding box is 
computed to enclose all control points of the curves.
This function computes the bounding box of the path in
device space and returns the user space bounding box of the
device space bounding box. The box may be larger than
expected if the user space coordinate axes are not aligned
with the device space coordinate axes. The pointer returned
by this call can be used until the next call to the Drawing
Manager. Use <CODE><A HREF="vrect-x.html#vrectCloneSet"><CODE>vrectCloneSet</CODE></A></CODE> (a Plane Geometry
Manager function) to copy the rectangles if persistence is
desired.
</DD></DL>
<P>
<A NAME="vdrawcontextGetClipBoundsFloat"><HR><H4>vdrawcontextGetClipBoundsFloat</H4></A>
<PRE>
        const vrectFloat * <B>vdrawcontextGetClipBoundsFloat</B>(
                vdrawcontext * context,
                size_t * count);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vdrawcontextGetCurrentPoint"><HR><H4>vdrawcontextGetCurrentPoint</H4></A>
<PRE>
        void <B>vdrawcontextGetCurrentPoint</B>(
                vdrawcontext * context,
                double * x,
                double * y);
</PRE>

<DL><DD>
Returns the current point of the drawing context in <SAMP>x,y</SAMP>.
</DD></DL>
<P>
<A NAME="vdrawcontextGetDefaultClass"><HR><H4>vdrawcontextGetDefaultClass</H4></A>
<PRE>
        vdrawcontextClass * <B>vdrawcontextGetDefaultClass</B>();
</PRE>

<DL><DD>
Returns the default class of the drawing context. 
This class is used to create drawing contexts by the
<CODE><A HREF="vdrawcontext-x.html#vdrawcontextCreate"><CODE>vdrawcontextCreate</CODE></A></CODE>. The default class is not very useful in and of itself, but it can be used as a superclass of new drawing context classes.
</DD></DL>
<P>
<A NAME="vdrawcontextGetDefaultMatrix"><HR><H4>vdrawcontextGetDefaultMatrix</H4></A>
<PRE>
        const vmatrix * <B>vdrawcontextGetDefaultMatrix</B>(
                vdrawcontext * context);
</PRE>

<DL><DD>
Returns the default transformation matrix for the drawing context.
</DD></DL>
<P>
<A NAME="vdrawcontextGetInstance"><HR><H4>vdrawcontextGetInstance</H4></A>
<PRE>
        vinstance * <B>vdrawcontextGetInstance</B>(
                vdrawcontext * context);
</PRE>

<DL><DD>
Returns the instance upon which a drawing context is constructed.
</DD></DL>
<P>
<A NAME="vdrawcontextGetLoadable"><HR><H4>vdrawcontextGetLoadable</H4></A>
<PRE>
        vloadable * <B>vdrawcontextGetLoadable</B>(
                vdrawcontext * context);
</PRE>

<DL><DD>
Returns the loadable upon which the drawing context is constructed.
</DD></DL>
<P>
<A NAME="vdrawcontextGetMatrix"><HR><H4>vdrawcontextGetMatrix</H4></A>
<PRE>
        vmatrix * <B>vdrawcontextGetMatrix</B>(
                vdrawcontext * context);
</PRE>

<DL><DD>
Returns the drawing context's current transformation matrix
</DD></DL>
<P>
<A NAME="vdrawcontextGetPen"><HR><H4>vdrawcontextGetPen</H4></A>
<PRE>
        vdrawpen * <B>vdrawcontextGetPen</B>(
                vdrawcontext * context);
</PRE>

<DL><DD>
Returns the pen used by the drawing context.
Changes to this pen are reflected in the drawing context. Never modify 
the pen of a drawing context passed into a function. Clone the drawing 
context and get the pen from the clone.
</DD></DL>
<P>
<A NAME="vdrawcontextGetStrokeAdjustmentRule"><HR><H4>vdrawcontextGetStrokeAdjustmentRule</H4></A>
<PRE>
        int <B>vdrawcontextGetStrokeAdjustmentRule</B>(
                vdrawcontext * context);
</PRE>

<DL><DD>
Returns a flag represented the Stroke Adjustment rule used by the drawing 
context. If stroke adjustment is on, lines with a small number of device 
pixels are adjusted for uniform width.
</DD></DL>
<P>
<A NAME="vdrawcontextGetViewClipBounds"><HR><H4>vdrawcontextGetViewClipBounds</H4></A>
<PRE>
        const vrect * <B>vdrawcontextGetViewClipBounds</B>(
                vdrawcontext * context,
                size_t * count);
</PRE>

<DL><DD>
Computes a set of bounding boxes that enclose the current view clipping 
path. This function then returns the box coordinates and the number of 
boxes in <SAMP>count</SAMP>. Depending on the window system, this 
function either returns a bounding box for each individual subpath or 
returns a single bounding box for the entire path. The bounding box of a 
subpath is the smallest rectangle that encloses all points along the 
subpath (see Figure). This function does not take line width into 
account. If the subpath contains curves, the bounding box is computed to 
enclose all control points of the curves.
This function computes the bounding box of the path in device space and 
returns the user space bounding box of the device space bounding box. The 
box may be larger than expected if the user space coordinate axes are not 
aligned with the device space coordinate axes. The pointer returned
by this call can be used until the next call to the Drawing Manager. Use 
<CODE><A HREF="vrect-x.html#vrectCloneSet"><CODE>vrectCloneSet</CODE></A></CODE> (a Plane Geometry Manager function) to copy 
the rectangles if persistence is desired.
</DD></DL>
<P>
<A NAME="vdrawcontextGetViewClipBoundsFloat"><HR><H4>vdrawcontextGetViewClipBoundsFloat</H4></A>
<PRE>
        const vrectFloat * <B>vdrawcontextGetViewClipBoundsFloat</B>(
                vdrawcontext * context,
                size_t * count);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vdrawcontextInit"><HR><H4>vdrawcontextInit</H4></A>
<PRE>
        void <B>vdrawcontextInit</B>(
                vdrawcontext * context);
</PRE>

<DL><DD>
Initializes the drawing context of the default drawing context class in the memory addressed by <SAMP>context</SAMP. The attributes of the drawing context are set to their default values, according to the default class. A call to <CODE>vdrawcontextDestroy</CODE> frees any internal objects allocated by the drawing context but does <I>not</I> free the structure itself. This function stores the default class in the class field of the drawing context and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vdrawcontextInitOfClass"><HR><H4>vdrawcontextInitOfClass</H4></A>
<PRE>
        void <B>vdrawcontextInitOfClass</B>(
                vdrawcontext * context,
                vdrawcontextClass * clas);
</PRE>

<DL><DD>
Initializes the drawing context of the default drawing context class in the memory addressed by <SAMP>context</SAMP. The attributes of the drawing context are set to their default values, according to the class. A call to <CODE>vdrawcontextDestroy</CODE> frees any internal objects allocated by the drawing context but does <I>not</I> free the structure itself. This function stores the default class in the class field of the drawing context and sends it the message <CODE>vobjectINIT</CODE>.
</DD></DL>
<P>
<A NAME="vdrawcontextIntersectsClip"><HR><H4>vdrawcontextIntersectsClip</H4></A>
<PRE>
        vbool <B>vdrawcontextIntersectsClip</B>(
                vdrawcontext * context,
                const vrect * rect);
</PRE>

<DL><DD>
Returns true if the rectangle intersects the current clipping path for 
the drawing context.
</DD></DL>
<P>
<A NAME="vdrawcontextIntersectsViewClip"><HR><H4>vdrawcontextIntersectsViewClip</H4></A>
<PRE>
        vbool <B>vdrawcontextIntersectsViewClip</B>(
                vdrawcontext * context,
                const vrect * rect);
</PRE>

<DL><DD>
Returns true if the rectangle intersects the current view clipping path for the thread. See the Programmer's Guide for a discussion of clipping paths and the view clip path.
</DD></DL>
<P>
<A NAME="vdrawcontextInverseDeltaTransformDimension"><HR><H4>vdrawcontextInverseDeltaTransformDimension</H4></A>
<PRE>
        void <B>vdrawcontextInverseDeltaTransformDimension</B>(
                vdrawcontext * context,
                double x,
                double y,
                double * xout,
                double * yout);
</PRE>

<DL><DD>
Computes the inverse transformation of <SAMP>x</SAMP> and
<SAMP>y</SAMP> without the current translation component and stores the result in <SAMP>xout</SAMP> and <SAMP>yout</SAMP>. The inverse delta transformation computes a user space vector for a given device space vector. This function is useful for determining the <I>size</I> of an object after transformation as opposed to its <I>location</I> in the coordinate system. It generates a
<CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE> if the current transformation matrix cannot be inverted.
</DD></DL>
<P>
<A NAME="vdrawcontextInverseTransformPoint"><HR><H4>vdrawcontextInverseTransformPoint</H4></A>
<PRE>
        void <B>vdrawcontextInverseTransformPoint</B>(
                vdrawcontext * context,
                double x,
                double y,
                double * xout,
                double * yout);
</PRE>

<DL><DD>
Computes the inverse transformation of <SAMP>x</SAMP> and
<SAMP>y</SAMP> and stores the result in <SAMP>xout</SAMP> and
<SAMP>yout</SAMP>. The inverse transformation computes a user
space coordinate for a given device space coordinate. It
generates <CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE> if the current
transformation matrix cannot be inverted.
</DD></DL>
<P>
<A NAME="vdrawcontextRotate"><HR><H4>vdrawcontextRotate</H4></A>
<PRE>
        void <B>vdrawcontextRotate</B>(
                vdrawcontext * context,
                double angle);
</PRE>

<DL><DD>
Rotates the current coordinate system by the specified angle.
Never modify the coordinate system of a drawing context passed into a function.  Clone the drawing context and modify the coordinate system of the clone.
</DD></DL>
<P>
<A NAME="vdrawcontextScale"><HR><H4>vdrawcontextScale</H4></A>
<PRE>
        void <B>vdrawcontextScale</B>(
                vdrawcontext * context,
                double x,
                double y);
</PRE>

<DL><DD>
Scales the current coordinate system by the specified <SAMP>x</SAMP> and <SAMP>y</SAMP> factors.
Never modify the coordinate system of a drawing context passed into a function. Clone the drawing context and modify the coordinate system of the clone.
</DD></DL>
<P>
<A NAME="vdrawcontextSetCurrentPoint"><HR><H4>vdrawcontextSetCurrentPoint</H4></A>
<PRE>
        void <B>vdrawcontextSetCurrentPoint</B>(
                vdrawcontext * context,
                double x,
                double y);
</PRE>

<DL><DD>
Sets the current point of the drawing context.
The current point of drawing contexts that passed into functions is not guaranteed to be located anywhere in particular.  Always set the current point to where you need it to be. It is not necessary to clone the drawing context if you are just setting the current point.
</DD></DL>
<P>
<A NAME="vdrawcontextSetCurrentPointRelative"><HR><H4>vdrawcontextSetCurrentPointRelative</H4></A>
<PRE>
        void <B>vdrawcontextSetCurrentPointRelative</B>(
                vdrawcontext * context,
                double dx,
                double dy);
</PRE>

<DL><DD>
Sets the current point of the drawing context relative to its current value. The current point of drawing contexts that passed into functions is not guaranteed to be located anywhere in particular. Always set the current point to where you need it to be. It is not necessary to clone the drawing context if you are just setting the current point.
</DD></DL>
<P>
<A NAME="vdrawcontextStartup"><HR><H4>vdrawcontextStartup</H4></A>
<PRE>
        void <B>vdrawcontextStartup</B>();
</PRE>

<DL><DD>
Initializes the Drawing Context Manager. Has no effect if the manager is already initialized. 
</DD></DL>
<P>
<A NAME="vdrawcontextTransform"><HR><H4>vdrawcontextTransform</H4></A>
<PRE>
        void <B>vdrawcontextTransform</B>(
                vdrawcontext * context,
                const vmatrix * mtx);
</PRE>

<DL><DD>
Concatenates <SAMP>mtx</SAMP> with the current transformation matrix and stores the result as the new current transformation matrix. This applies the transformation represented by <SAMP>mtx</SAMP> to the current transformation. For example, if <SAMP>mtx</SAMP> represents a rotation of 30 degrees, concatenating it with the current matrix produces a new current transformation rotated by 30 degrees with respect to the former transformation. <CODE><A HREF="vdraw-x.html#vdrawConcat"><CODE>vdrawConcat</CODE></A></CODE> is cumulative; that is, applying the rotation described above twice in succession results in a total rotation of 60 degrees.
</DD></DL>
<P>
<A NAME="vdrawcontextTransformPoint"><HR><H4>vdrawcontextTransformPoint</H4></A>
<PRE>
        void <B>vdrawcontextTransformPoint</B>(
                vdrawcontext * context,
                double x,
                double y,
                double * xout,
                double * yout);
</PRE>

<DL><DD>
Computes the transformation of <SAMP>x</SAMP> and
<SAMP>y</SAMP> and stores the result in <SAMP>xout</SAMP> and
<SAMP>yout</SAMP>. The standard transformation computes a device space coordinates for a given user space coordinate.
</DD></DL>
<P>
<A NAME="vdrawcontextTranslate"><HR><H4>vdrawcontextTranslate</H4></A>
<PRE>
        void <B>vdrawcontextTranslate</B>(
                vdrawcontext * context,
                double x,
                double y);
</PRE>

<DL><DD>
Translates the current coordinate system by <SAMP>x</SAMP> and <SAMP>y</SAMP> by modifying the current transformation matrix. Either parameter can be negative or zero. Translation effectively moves the origin to the specified coordinates in the <I>current</I> coordinate system.
Translation, like other coordinate system modifications, is cumulative:
<CODE>vdrawcontextTranslate</CODE><SAMP>(dc,10,10)</SAMP> has the same effect as calling <CODE>vdrawcontextTranslate</CODE><SAMP>(dc,5,5)</SAMP> twice in succession.
</DD></DL>
<P>
<A NAME="vdrawcontextUtilize"><HR><H4>vdrawcontextUtilize</H4></A>
<PRE>
        void <B>vdrawcontextUtilize</B>(
                vdrawcontext * context);
</PRE>

<DL><DD>
Installs the drawing context into the Drawing Manager current gstate. After this call is made it is possible to use vdraw functions to draw onto the drawing device represented by the drawing context.
</DD></DL>
<P>
<A NAME="section_Message"><HR>
<CENTER><H2>Messages</H2></CENTER></A><P>
<A NAME="vdrawcontextDISPOSE"><HR><H4>vdrawcontextDISPOSE</H4></A>
<PRE>
        &lt;<B>vdrawcontextDISPOSE</B>&gt;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vdrawcontextUTILIZE"><HR><H4>vdrawcontextUTILIZE</H4></A>
<PRE>
        &lt;<B>vdrawcontextUTILIZE</B>&gt;
</PRE>

<DL><DD>
Installs the drawing context into the Drawing Manager current gstate. After this call is made it is possible to use vdraw functions to draw onto the drawing device represented by the drawing context.
The function entry point <CODE><A HREF="vdrawcontext-x.html#vdrawcontextUtilize"><CODE>vdrawcontextUtilize</CODE></A>></CODE> is implemented by sending this message to the drawing context.
</DD></DL>
<P>
<A NAME="section_Constant"><HR>
<CENTER><H2>Constants</H2></CENTER></A><P>
<A NAME="vdrawcontextINCLUDED"><HR><H4>vdrawcontextINCLUDED</H4></A>
<PRE>
        <B>vdrawcontextINCLUDED</B>
</PRE>

<DL><DD>
Defined when the header file <SAMP>vdrawcontext.h</SAMP> is included.
</DD></DL>
<P>
<A NAME="section_Macro"><HR>
<CENTER><H2>Macros</H2></CENTER></A><P>
<A NAME="vdrawcontextCLASS"><HR><H4>vdrawcontextCLASS</H4></A>
<PRE>
        #define <B>vdrawcontextCLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for drawing context
classes. This macro expands to the contents of
<CODE><A HREF="vdrawcontext-x.html#vdrawcontextClass"><CODE>vdrawcontextClass</CODE></A></CODE>. <SAMP>CLASS</SAMP> is the type
identifier of the class being declared (for example,
<CODE><A HREF="vdrawcontext-x.html#vdrawcontextClass"><CODE>vdrawcontextClass</CODE></A></CODE>). This type is used by the class's 
subclasses to refer to it. <SAMP>CONTEXT</SAMP> is the type identifier of
instances of the class being declared (for example,
<CODE>vdrawcontext</CODE>). 
This macro should be used by drawing context subclasses to
declare the contents of the drawing context class. This macro should come
first in the subclass structure declaration.
</DD></DL>
<P>

<P>
<!--[[/CONTENT]]-->

<HR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">
		<TD>
		<CENTER>
<!--[[NAVIGATE_ICONIC]]-->
<!--[[/NAVIGATE_ICONIC]]-->
		</CENTER>
		</TD>
		    
		<TD>
		<BR>
		<FONT SIZE=-1>
	        <A HREF="#Top">Top of This Page</A> <BR>
	        <A HREF="index.html">Table of Contents</A> <BR>
		<A HREF="../index.html">Switch to Another Document</A><BR>
		<BR>
		</FONT>
		</TD>

		<TD>
		<BR>
		<FONT SIZE=-1>
		Need help?
		<A HREF="../contact-visix.html">
		Contact Visix</A>.
		<BR> <BR>
	        <A HREF="../copyright.html">Copyright &#169; 1996-97</A>,
		<A HREF="http://www.visix.com/">Visix Software Inc.</A><BR>
		<BR>
		</FONT>
		</TD>

	</TR>

</TABLE>
		
</BODY>
</HTML>



