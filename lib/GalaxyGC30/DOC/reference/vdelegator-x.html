<HTML>
  <HEAD>
<!--[[HEADING]]-->
<title>vdelegator prefix</title><!--[[/HEADING]]-->
  </HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<A NAME="Top"><IMG SRC="../graphics/trans.gif" WIDTH=2 HEIGHT=2></A><BR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">

		<TD>
		<CENTER>
		<A HREF="../index.html">
		<IMG SRC="../graphics/logo.gif" BORDER=0></A>
		</CENTER>
		</TD>

	        <TD VALIGN=TOP>
	        <BR><H1>
<!--[[TITLE]]-->
vdelegator prefix<!--[[/TITLE]]-->
	        </H1><BR>
		</TD>
      
	</TR>

</TABLE>

<HR>

<BR>

<!--[[PREAMBLE]]-->
<TABLE>
<TR>
<TD><A HREF="vdelegator-x.html#section_DataType">Types</A> [4]</TD>
<TD><A HREF="vdelegator-x.html#section_Function">Functions</A> [22]</TD>
<TD><A HREF="vdelegator-x.html#section_Message">Messages</A> [1]</TD>
<TD><A HREF="vdelegator-x.html#section_Constant">Constants</A> [1]</TD>
<TD><A HREF="vdelegator-x.html#section_Macro">Macros</A> [1]</TD>
</TR>
</TABLE>
<!--[[/PREAMBLE]]-->

<!--[[CONTENT]]-->

<P>
<A NAME="section_DataType"><HR>
<CENTER><H2>Types</H2></CENTER></A><P>
<A NAME="vdelegator"><HR><H4>vdelegator</H4></A>
<PRE>
        typedef ... <B>vdelegator</B>;
</PRE>

<DL><DD>
Contains the information needed to represent a single
delegator object; objects of this type have classes
derived from <CODE><A HREF="vdelegator-x.html#vdelegatorClass"><CODE>vdelegatorClass</CODE></A></CODE>. A delegator is
an object that can reference multiple objects and that
provides the means for dynamically inheriting and
dispatching methods among those objects.
<P>
Delegators are referenced by a pointer to this type.
Delegators can be created dynamically using the
<CODE><A HREF="vinstance-x.html#vinstanceCreateOfClass"><CODE>vinstanceCreateOfClass</CODE></A></CODE> function, or can be
initialized statically using the
<CODE><A HREF="vinstance-x.html#vinstanceInitOfClass"><CODE>vinstanceInitOfClass</CODE></A></CODE> function. All object
types and classes that directly inherit from
<CODE><A HREF="vdelegator-x.html#vdelegatorClass"><CODE>vdelegatorClass</CODE></A></CODE> must declare a
<CODE>vdelegator</CODE> as their first field so that
<CODE>vdelegator</CODE> pointers can be interchanged with
pointers to the new data type. Delegators inherit from the
<CODE><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></CODE> class.
</DD></DL>
<P>
<A NAME="vdelegatorClass"><HR><H4>vdelegatorClass</H4></A>
<PRE>
        typedef ... <B>vdelegatorClass</B>;
</PRE>

<DL><DD>
Contains method and variable bindings for objects of type
<SAMP>vdelegator</SAMP>. Classes declared with this type
contain the same set of methods and variables as the
default delegator class, but the behavior of methods and
the contents of variables may vary. This class type is
derived from <CODE><A HREF="vinstance-x.html#vinstanceClass"><CODE>vinstanceClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdelegatorClassNotFoundException"><HR><H4>vdelegatorClassNotFoundException</H4></A>
<PRE>
        typedef ... <B>vdelegatorClassNotFoundException</B>;
</PRE>

<DL><DD>
Generated by the <CODE><A HREF="vdelegator-x.html#vdelegatorMakeResendStack"><CODE>vdelegatorMakeResendStack</CODE></A></CODE> and
<CODE><A HREF="vdelegator-x.html#vdelegatorDirectStack"><CODE>vdelegatorDirectStack</CODE></A></CODE> functions when the
desired class for the resend or redirect operation is not
implemented by the delegator or its delegate objects.
</DD></DL>
<P>
<A NAME="vdelegatorStack"><HR><H4>vdelegatorStack</H4></A>
<PRE>
        typedef ... <B>vdelegatorStack</B>;
</PRE>

<DL><DD>
Contains information about the current chain of delegation.
A delegator and the objects it delegates form a <I>delegate
tree</I>. Since this tree is traversed in depth-first order
when methods are being dispatched, a delegator stack
contains the complete state of the tree traversal as the
method is being dispatched.
<P>
A delegator stack is used in addition to an object pointer
as a parameter for methods that can be dynamically
dispatched. This allows the implementation of such a method
to do two things: it can access the objects that delegate
to it directly, and it can resend a message to the next
object in the delegate tree by redirecting the delegator
stack.
<P>
Delegator stacks are nearly always declared as automatic
variables rather than being dynamically allocated. In
addition, they are sometimes passed by value rather than by
reference in certain situations; this is an implementation
trick to allow the sending of a dynamic method without
explicitly declaring a local <CODE>vdelegatorStack</CODE>
variable.
<P>
Delegator stacks can be initialized statically using the
<CODE><A HREF="vdelegator-x.html#vdelegatorMakeStack"><CODE>vdelegatorMakeStack</CODE></A></CODE> and
<CODE><A HREF="vdelegator-x.html#vdelegatorCopyStack"><CODE>vdelegatorCopyStack</CODE></A></CODE> functions.
</DD></DL>
<P>
<A NAME="section_Function"><HR>
<CENTER><H2>Functions</H2></CENTER></A><P>
<A NAME="vdelegatorAdvanceStack"><HR><H4>vdelegatorAdvanceStack</H4></A>
<PRE>
        vbool <B>vdelegatorAdvanceStack</B>(
                vdelegatorStack * stack,
                int seePrivates);
</PRE>

<DL><DD>
&&&Tries to advance <SAMP>stack</SAMP> to point to the next
object in the delegate tree and returns <SAMP>TRUE</SAMP>
if the stack advanced, <SAMP>FALSE</SAMP> if there are no
more objects in the delegate tree. 
<P>
If <SAMP>seePrivates</SAMP> is <SAMP>TRUE</SAMP>, all delegate
objects are traversed; if <SAMP>FALSE</SAMP>, only delegate
objects that are above the level of the object at the top
of <SAMP>stack</SAMP> in the delegate tree are traversed.
</DD></DL>
<P>
<A NAME="vdelegatorCopyStack"><HR><H4>vdelegatorCopyStack</H4></A>
<PRE>
        void <B>vdelegatorCopyStack</B>(
                const vdelegatorStack * from,
                vdelegatorStack * to);
</PRE>

<DL><DD>
Copies the <SAMP>from</SAMP> stack to the <SAMP>to</SAMP>
stack. Note that a structure is returned rather than a
pointer to a structure. This function is, in most cases, used
to make a stack to pass to a function that takes a stack as
an argument.
</DD></DL>
<P>
<A NAME="vdelegatorDirectStack"><HR><H4>vdelegatorDirectStack</H4></A>
<PRE>
        void <B>vdelegatorDirectStack</B>(
                vdelegatorStack * stack,
                void * methodClass);
</PRE>

<DL><DD>
Advances the stack to point to the next object in the
delegate tree whose class is a subclass of
<SAMP>methodClass</SAMP>. It generates a
<SAMP>Delegator/ClassNotFound</SAMP> exception if there is
no such object in the delegate tree.
</DD></DL>
<P>
<A NAME="vdelegatorDumpStack"><HR><H4>vdelegatorDumpStack</H4></A>
<PRE>
        void <B>vdelegatorDumpStack</B>(
                const vdelegatorStack * stack,
                FILE * fp);
</PRE>

<DL><DD>
Dumps the contents of <SAMP>stack</SAMP> to the file stream
<SAMP>fp</SAMP> in a human-readable form.
</DD></DL>
<P>
<A NAME="vdelegatorDumpStackShallow"><HR><H4>vdelegatorDumpStackShallow</H4></A>
<PRE>
        void <B>vdelegatorDumpStackShallow</B>(
                const vdelegatorStack * stack,
                FILE * fp);
</PRE>

<DL><DD>
Dumps the state of <SAMP>stack</SAMP> to the file stream
<SAMP>fp</SAMP> in a human-readable form.
</DD></DL>
<P>
<A NAME="vdelegatorGetClass"><HR><H4>vdelegatorGetClass</H4></A>
<PRE>
        vdelegatorClass * <B>vdelegatorGetClass</B>(
                vdelegator * object);
</PRE>

<DL><DD>
Returns the class of the given object <SAMP>delegator</SAMP>.
</DD></DL>
<P>
<A NAME="vdelegatorGetClassNotFoundException"><HR><H4>vdelegatorGetClassNotFoundException</H4></A>
<PRE>
        vdelegatorClassNotFoundException * <B>vdelegatorGetClassNotFoundException</B>();
</PRE>

<DL><DD>
Returns the current <SAMP>Delegator/ClassNotFound</SAMP>
exception in the exception chain, or <SAMP>NULL</SAMP> if
no such exception exists.
</DD></DL>
<P>
<A NAME="vdelegatorGetClassNotFoundExceptionClass"><HR><H4>vdelegatorGetClassNotFoundExceptionClass</H4></A>
<PRE>
        void * <B>vdelegatorGetClassNotFoundExceptionClass</B>(
                vdelegatorClassNotFoundException * e);
</PRE>

<DL><DD>
Returns the class of the Delegator/ClassNotFound exception <SAMP>e</SAMP>.
</DD></DL>
<P>
<A NAME="vdelegatorGetClassNotFoundExceptionStack"><HR><H4>vdelegatorGetClassNotFoundExceptionStack</H4></A>
<PRE>
        vdelegatorStack * <B>vdelegatorGetClassNotFoundExceptionStack</B>(
                vdelegatorClassNotFoundException * e);
</PRE>

<DL><DD>
Returns the delegate stack that existed at the time of the
Delegator/ClassNotFound exception <SAMP>e</SAMP>.
</DD></DL>
<P>
<A NAME="vdelegatorGetDefaultClass"><HR><H4>vdelegatorGetDefaultClass</H4></A>
<PRE>
        vdelegatorClass * <B>vdelegatorGetDefaultClass</B>();
</PRE>

<DL><DD>
Returns the class used to create delegators using the
<CODE><A HREF="vinstance-x.html#vinstanceCreateOfClass"><CODE>vinstanceCreateOfClass</CODE></A></CODE> function. This class
can be modified to alter the behavior of all scraps
subsequently created by this function. Changes to this
class are not visible to any other applications in the same
process or sharing the same display server. This function
can be called to explicitly register the default delegator
class with the Class class.
</DD></DL>
<P>
<A NAME="vdelegatorGetInstance"><HR><H4>vdelegatorGetInstance</H4></A>
<PRE>
        vinstance * <B>vdelegatorGetInstance</B>(
                vdelegator * object);
</PRE>

<DL><DD>
Returns the <SAMP><A HREF="vinstance-x.html#vinstance"><CODE>vinstance</CODE></A></SAMP> object that
<SAMP>object</SAMP> is built on.
</DD></DL>
<P>
<A NAME="vdelegatorGetStackBottom"><HR><H4>vdelegatorGetStackBottom</H4></A>
<PRE>
        void * <B>vdelegatorGetStackBottom</B>(
                const vdelegatorStack * stack);
</PRE>

<DL><DD>
Returns the object at the bottom of <SAMP>stack</SAMP>.
This object is the root of the delegate tree.
</DD></DL>
<P>
<A NAME="vdelegatorGetStackHeight"><HR><H4>vdelegatorGetStackHeight</H4></A>
<PRE>
        size_t <B>vdelegatorGetStackHeight</B>(
                const vdelegatorStack * stack);
</PRE>

<DL><DD>
Returns the number of delegate objects in <SAMP>stack</SAMP>.
</DD></DL>
<P>
<A NAME="vdelegatorGetStackNth"><HR><H4>vdelegatorGetStackNth</H4></A>
<PRE>
        void * <B>vdelegatorGetStackNth</B>(
                const vdelegatorStack * stack,
                size_t n);
</PRE>

<DL><DD>
Returns the object <SAMP>n</SAMP> elements from the top of
<SAMP>stack</SAMP>.
</DD></DL>
<P>
<A NAME="vdelegatorGetStackTop"><HR><H4>vdelegatorGetStackTop</H4></A>
<PRE>
        void * <B>vdelegatorGetStackTop</B>(
                const vdelegatorStack * stack);
</PRE>

<DL><DD>
Returns the object at the top of <SAMP>stack</SAMP>. This
is the object where the stack is currently directed.
</DD></DL>
<P>
<A NAME="vdelegatorIsKindOf"><HR><H4>vdelegatorIsKindOf</H4></A>
<PRE>
        vbool <B>vdelegatorIsKindOf</B>(
                vinstance * object,
                void * clas);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the delegator
<SAMP>object</SAMP> or any of its delegate objects
implements the class <SAMP>clas</SAMP>, <SAMP>FALSE</SAMP>
if not.
</DD></DL>
<P>
<A NAME="vdelegatorMakeBackupStack"><HR><H4>vdelegatorMakeBackupStack</H4></A>
<PRE>
        vdelegatorStack <B>vdelegatorMakeBackupStack</B>(
                const vdelegatorStack * stack,
                int levels);
</PRE>

<DL><DD>
Returns a delegate stack directed at a delegate object
located at the specified number of <SAMP>levels</SAMP>
above the object at the top of the stack. Note that a structure is returned
rather than a pointer to a structure; this function is
mostly used to make a stack to pass to a function that
takes a stack as an argument.
</DD></DL>
<P>
<A NAME="vdelegatorMakeObjectStack"><HR><H4>vdelegatorMakeObjectStack</H4></A>
<PRE>
        vdelegatorStack <B>vdelegatorMakeObjectStack</B>(
                vinstance * object);
</PRE>

<DL><DD>
Returns a delegator stack with exactly one object in it.
<SAMP>object</SAMP> is placed at the top of the stack. 
<P>
Note that a structure is returned rather than a pointer to a
structure. In most cases, this function is used to make a
stack to pass to a function that takes a stack as an
argument.
</DD></DL>
<P>
<A NAME="vdelegatorMakeResendStack"><HR><H4>vdelegatorMakeResendStack</H4></A>
<PRE>
        vdelegatorStack <B>vdelegatorMakeResendStack</B>(
                const vdelegatorStack * stack);
</PRE>

<DL><DD>
Returns a delegate stack suitable for use in resending a
method to the next object in <SAMP>stack</SAMP>. Note that
a structure is returned rather than a pointer to a
structure; this function is mostly used to make a
stack to pass to a function that takes a stack as an
argument.
</DD></DL>
<P>
<A NAME="vdelegatorMakeStack"><HR><H4>vdelegatorMakeStack</H4></A>
<PRE>
        vdelegatorStack <B>vdelegatorMakeStack</B>(
                const vdelegatorStack * stack);
</PRE>

<DL><DD>
Returns a copy of <SAMP>stack</SAMP>. Note that a structure
is returned rather than a pointer to a structure. In most cases,
this function is used to make stack to pass to a
function that takes a stack as an argument.
</DD></DL>
<P>
<A NAME="vdelegatorNextDelegate"><HR><H4>vdelegatorNextDelegate</H4></A>
<PRE>
        vinstance * <B>vdelegatorNextDelegate</B>(
                vdelegator * object,
                vinstance * prev,
                int seePrivate);
</PRE>

<DL><DD>
Returns the next object which <SAMP>object</SAMP> delegates
to. <SAMP>prev</SAMP> should be the last object returned by
this function call on <SAMP>object</SAMP>, or
<SAMP>NULL</SAMP> if this is the first such call.
Therefore, this function is used to iterate through the
delegates of a delegator.
<P>
If <SAMP>seePrivate</SAMP> is <SAMP>TRUE</SAMP>, all
delegate objects are traversed and can be returned; if
<SAMP>FALSE</SAMP>, only those delegate objects which are
not private are returned.
<P>
This function is implemented by sending the message
<CODE><A HREF="vdelegator-x.html#vdelegatorNEXT_DELEGATE"><CODE>vdelegatorNEXT_DELEGATE</CODE></A></CODE> to <SAMP>object</SAMP>.
</DD></DL>
<P>
<A NAME="vdelegatorStartup"><HR><H4>vdelegatorStartup</H4></A>
<PRE>
        void <B>vdelegatorStartup</B>();
</PRE>

<DL><DD>
Initializes the delegator module. This method has no effect if the
delegator module is already initialized.
</DD></DL>
<P>
<A NAME="section_Message"><HR>
<CENTER><H2>Messages</H2></CENTER></A><P>
<A NAME="vdelegatorNEXT_DELEGATE"><HR><H4>vdelegatorNEXT_DELEGATE</H4></A>
<PRE>
        &lt;<B>vdelegatorNEXT_DELEGATE</B>&gt;
</PRE>

<DL><DD>
Returns the next object that <SAMP>object</SAMP> delegates
to. <SAMP>prev</SAMP> is the object returned by the
previous call to this method, or <SAMP>NULL</SAMP> if this
is the first call in an iteration.
<P>
If <SAMP>seePrivates</SAMP> is <SAMP>TRUE</SAMP>, all
delegate objects should be returned; if <SAMP>FALSE</SAMP>,
only those objects that are not private are returned.
</DD></DL>
<P>
<A NAME="section_Constant"><HR>
<CENTER><H2>Constants</H2></CENTER></A><P>
<A NAME="vdelegatorINCLUDED"><HR><H4>vdelegatorINCLUDED</H4></A>
<PRE>
        <B>vdelegatorINCLUDED</B>
</PRE>

<DL><DD>
Defined when the header file <SAMP>vdelegator.h</SAMP> is included.
</DD></DL>
<P>
<A NAME="section_Macro"><HR>
<CENTER><H2>Macros</H2></CENTER></A><P>
<A NAME="vdelegatorCLASS"><HR><H4>vdelegatorCLASS</H4></A>
<PRE>
        #define <B>vdelegatorCLASS</B>(...) ...
</PRE>

<DL><DD>
Contains the method and variable declarations for delegator
classes-this macro expands to the contents of
<CODE><A HREF="vdelegator-x.html#vdelegatorClass"><CODE>vdelegatorClass</CODE></A></CODE>.
<CODE>OBJECT</CODE> is the type identifier of the class being declared (for
example, <CODE><A HREF="vdelegator-x.html#vdelegatorClass"><CODE>vdelegatorClass</CODE></A></CODE>). This type is used by the class's
subclasses to refer to it. <CODE>CLASS</CODE> is the type identifier of
instances of the class being declared (for example, <CODE>vdelegator</CODE>).
This macro should be used by the delegator subclasses to declare the
contents of the delegator class. This macro should come first in the
subclass structure declaration.
</DD></DL>
<P>

<P>
<!--[[/CONTENT]]-->

<HR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">
		<TD>
		<CENTER>
<!--[[NAVIGATE_ICONIC]]-->
<!--[[/NAVIGATE_ICONIC]]-->
		</CENTER>
		</TD>
		    
		<TD>
		<BR>
		<FONT SIZE=-1>
	        <A HREF="#Top">Top of This Page</A> <BR>
	        <A HREF="index.html">Table of Contents</A> <BR>
		<A HREF="../index.html">Switch to Another Document</A><BR>
		<BR>
		</FONT>
		</TD>

		<TD>
		<BR>
		<FONT SIZE=-1>
		Need help?
		<A HREF="../contact-visix.html">
		Contact Visix</A>.
		<BR> <BR>
	        <A HREF="../copyright.html">Copyright &#169; 1996-97</A>,
		<A HREF="http://www.visix.com/">Visix Software Inc.</A><BR>
		<BR>
		</FONT>
		</TD>

	</TR>

</TABLE>
		
</BODY>
</HTML>



