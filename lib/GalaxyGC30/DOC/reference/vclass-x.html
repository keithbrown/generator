<HTML>
  <HEAD>
<!--[[HEADING]]-->
<title>vclass prefix</title><!--[[/HEADING]]-->
  </HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<A NAME="Top"><IMG SRC="../graphics/trans.gif" WIDTH=2 HEIGHT=2></A><BR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">

		<TD>
		<CENTER>
		<A HREF="../index.html">
		<IMG SRC="../graphics/logo.gif" BORDER=0></A>
		</CENTER>
		</TD>

	        <TD VALIGN=TOP>
	        <BR><H1>
<!--[[TITLE]]-->
vclass prefix<!--[[/TITLE]]-->
	        </H1><BR>
		</TD>
      
	</TR>

</TABLE>

<HR>

<BR>

<!--[[PREAMBLE]]-->
<TABLE>
<TR>
<TD><A HREF="vclass-x.html#section_DataType">Types</A> [12]</TD>
<TD><A HREF="vclass-x.html#section_Function">Functions</A> [85]</TD>
<TD><A HREF="vclass-x.html#section_Message">Messages</A> [1]</TD>
<TD><A HREF="vclass-x.html#section_Constant">Constants</A> [5]</TD>
<TD><A HREF="vclass-x.html#section_Macro">Macros</A> [5]</TD>
</TR>
</TABLE>
<!--[[/PREAMBLE]]-->

<!--[[CONTENT]]-->

<P>
<A NAME="section_DataType"><HR>
<CENTER><H2>Types</H2></CENTER></A><P>
<A NAME="vclass"><HR><H4>vclass</H4></A>
<PRE>
        typedef ... <B>vclass</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassAliasLoader"><HR><H4>vclassAliasLoader</H4></A>
<PRE>
        typedef ... <B>vclassAliasLoader</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassAliasStorer"><HR><H4>vclassAliasStorer</H4></A>
<PRE>
        typedef ... <B>vclassAliasStorer</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassInterfaceIterator"><HR><H4>vclassInterfaceIterator</H4></A>
<PRE>
        typedef ... <B>vclassInterfaceIterator</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassLoadFunc"><HR><H4>vclassLoadFunc</H4></A>
<PRE>
        typedef ... <B>vclassLoadFunc</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassMethod"><HR><H4>vclassMethod</H4></A>
<PRE>
        typedef ... <B>vclassMethod</B>;
</PRE>

<DL><DD>
Denotes a method that implements a message sent during
dynamic binding. Methods defined using
<CODE><A HREF="vclass-x.html#vclassSetDynamic"><CODE>vclassSetDynamic</CODE></A></CODE> should fit this prototype.
</DD></DL>
<P>
<A NAME="vclassMismatchException"><HR><H4>vclassMismatchException</H4></A>
<PRE>
        typedef ... <B>vclassMismatchException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassNotFoundException"><HR><H4>vclassNotFoundException</H4></A>
<PRE>
        typedef ... <B>vclassNotFoundException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassNotUnderstoodException"><HR><H4>vclassNotUnderstoodException</H4></A>
<PRE>
        typedef ... <B>vclassNotUnderstoodException</B>;
</PRE>

<DL><DD>
Generated by dynamic binding functions when a message is
not understood. This exception contains the name of the
message that was not understood and is derived
from <CODE><A HREF="vex-x.html#vexException"><CODE>vexException</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vclassRoot"><HR><H4>vclassRoot</H4></A>
<PRE>
        typedef ... <B>vclassRoot</B>;
</PRE>

<DL><DD>
Contains a set of attributes that form the basis for
higher-level classes (subclasses). These attributes should
be useful to all polymorphic objects. Most new classes
should be subclassed from <CODE><A HREF="vobject-x.html#vobjectClass"><CODE>vobjectClass</CODE></A></CODE> rather
than <CODE>vclassRoot</CODE>, since it provides more
built-in functionality. This is the only class type that is
not derived from another class type.
</DD></DL>
<P>
<A NAME="vclassSubIterator"><HR><H4>vclassSubIterator</H4></A>
<PRE>
        typedef ... <B>vclassSubIterator</B>;
</PRE>

<DL><DD>
Denotes an abstract index variable used for enumerating all
the subclasses of a given class. Iterators are normally
declared as automatic variables of a function and are
initialized with <CODE><A HREF="vclass-x.html#vclassInitSubIterator"><CODE>vclassInitSubIterator</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vclassUnnamedException"><HR><H4>vclassUnnamedException</H4></A>
<PRE>
        typedef ... <B>vclassUnnamedException</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="section_Function"><HR>
<CENTER><H2>Functions</H2></CENTER></A><P>
<A NAME="vclassAddField"><HR><H4>vclassAddField</H4></A>
<PRE>
        void <B>vclassAddField</B>(
                vclass * clas,
                const char * fieldName,
                size_t fieldOffset,
                size_t fieldSize);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassAlloc"><HR><H4>vclassAlloc</H4></A>
<PRE>
        void * <B>vclassAlloc</B>(
                vclass * clas);
</PRE>

<DL><DD>
Allocates an instance of the class <SAMP>clas</SAMP> and
returns a pointer to it. The size of the object is
determined by the object-size of the class. Use
<CODE><A HREF="vclass-x.html#vclassSetObjectSize"><CODE>vclassSetObjectSize</CODE></A></CODE> to specify the object-size
of the class. 
<P>
The class manager provides a reasonably
efficient storage management mechanism for object
instances. This mechanism gives significantly better
performance than native storage management facilities, such
as <CODE><A HREF="vmem-x.html#vmemAlloc"><CODE>vmemAlloc</CODE></A></CODE>. The new instance is not
initialized in any way.
</DD></DL>
<P>
<A NAME="vclassAllocDebug"><HR><H4>vclassAllocDebug</H4></A>
<PRE>
        void * <B>vclassAllocDebug</B>(
                vclass * clas,
                const char * tag,
                const char * file,
                int line);
</PRE>

<DL><DD>
Allocates an instance of the class <SAMP>clas</SAMP> and
returns a pointer to it. Acts like <CODE>vclassAlloc</CODE>
but also passes information to the memory manager about
where the object was allocated from. 
<P>
<SAMP>tag</SAMP> is the abstract tag of the module 
allocating the instance. This is specified by the 
<SAMP>vdebugTAG</SAMP> mechanism, for
example, <SAMP><A HREF="vwindow-x.html#vwindow"><CODE>vwindow</CODE></A></SAMP>, <SAMP>file</SAMP> is the
name of the file in which the instance was allocated and,
<SAMP>line</SAMP> is the line number in the particular file. 
<P>
This information is reported on application 
exit if the instance is still
allocated and <CODE>vmemBALANCE</CODE> is
<SAMP>TRUE</SAMP>. This function is only available in
debugging libraries. <CODE>vclassAlloc</CODE> is
automatically mapped to this function when memory debugging
is enabled. Only modules that provide their own
storage-management functions should need to call this
function explicitly.
</DD></DL>
<P>
<A NAME="vclassBindDynamic"><HR><H4>vclassBindDynamic</H4></A>
<PRE>
        const void * <B>vclassBindDynamic</B>(
                vclass * clas,
                const vname * name);
</PRE>

<DL><DD>
Returns the dynamic binding of the global name
<SAMP>name</SAMP> in the class <SAMP>clas</SAMP> or in any
of its superclasses. It returns <SAMP>NULL</SAMP> if no
dynamic binding is found.
</DD></DL>
<P>
<A NAME="vclassBindToInterface"><HR><H4>vclassBindToInterface</H4></A>
<PRE>
        vinterface * <B>vclassBindToInterface</B>(
                vclass * implementor,
                vinterface * interfac);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassBindToInterfaceName"><HR><H4>vclassBindToInterfaceName</H4></A>
<PRE>
        vinterface * <B>vclassBindToInterfaceName</B>(
                vclass * implementor,
                const vname * interface_name);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassClone"><HR><H4>vclassClone</H4></A>
<PRE>
        vclass * <B>vclassClone</B>(
                vclass * clas);
</PRE>

<DL><DD>
Creates a new subclass of the superclass of
<SAMP>clas</SAMP>. The type of the new subclass is the same
as <SAMP>clas</SAMP>. The new class is a sibling of
<SAMP>clas</SAMP> but inherits all its methods from
the subclass, rather than from its superclass. The new
class is unnamed.
<P>
Once a class has been cloned, the new
class should be named with <CODE><A HREF="vclass-x.html#vclassSetName"><CODE>vclassSetName</CODE></A></CODE>, and
its instance size should be specified with
<CODE><A HREF="vclass-x.html#vclassSetObjectSize"><CODE>vclassSetObjectSize</CODE></A></CODE> 
if it has its own instance type.
</DD></DL>
<P>
<A NAME="vclassDestroy"><HR><H4>vclassDestroy</H4></A>
<PRE>
        void <B>vclassDestroy</B>(
                vclass * clas);
</PRE>

<DL><DD>
Destroys the class <SAMP>clas</SAMP> and removes it from
the class manager registry, if named. This function does
not destroy any instances of the class. If messages are
sent to outstanding instances once the class has been
destroyed, unpredictable behavior results. 
<P>
Note that you do not need to destroy classes explicitly;  
the class manager destroys all of your classes for you automatically during
shutdown. When debugging libraries are used, the class
manager warns about any subclasses that are ``orphaned'' by
their superclasses. A class is ``orphaned'' when its
superclass is destroyed before the class itself is
destroyed.
</DD></DL>
<P>
<A NAME="vclassDestroyInterfaceIterator"><HR><H4>vclassDestroyInterfaceIterator</H4></A>
<PRE>
        void <B>vclassDestroyInterfaceIterator</B>(
                vclassInterfaceIterator * iterator);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassDestroySubIterator"><HR><H4>vclassDestroySubIterator</H4></A>
<PRE>
        void <B>vclassDestroySubIterator</B>(
                vclassSubIterator * iterator);
</PRE>

<DL><DD>
Terminates the iteration represented by
<SAMP>iterator</SAMP>, even if it is not yet exhausted.
This function is necessary to reclaim internal iteration
objects allocated by the class manager.
</DD></DL>
<P>
<A NAME="vclassDump"><HR><H4>vclassDump</H4></A>
<PRE>
        void <B>vclassDump</B>(
                vclass * clas,
                FILE * stream);
</PRE>

<DL><DD>
Prints information about the class <SAMP>clas</SAMP> on the
file stream <SAMP>stream</SAMP>. This information is for
debugging purposes only. This function is enabled only in
debugging libraries.
</DD></DL>
<P>
<A NAME="vclassFree"><HR><H4>vclassFree</H4></A>
<PRE>
        void <B>vclassFree</B>(
                vclass * clas,
                void * elem);
</PRE>

<DL><DD>
Frees the object <SAMP>elem</SAMP>, which must be an
instance of the class <SAMP>clas</SAMP>. Does nothing if
<SAMP>elem</SAMP> was not allocated by <SAMP>clas</SAMP>
using <CODE><A HREF="vclass-x.html#vclassAlloc"><CODE>vclassAlloc</CODE></A></CODE>. This function does not
generate an exception in this case so that objects
initialized by static functions, such as
<SAMP>vobjectInit</SAMP>, can be seamlessly interchanged
with objects created by dynamic functions like
<CODE><A HREF="vobject-x.html#vobjectCreateOfClass"><CODE>vobjectCreateOfClass</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vclassFreeDebug"><HR><H4>vclassFreeDebug</H4></A>
<PRE>
        void <B>vclassFreeDebug</B>(
                vclass * clas,
                void * elem,
                const char * tag,
                const char * file,
                int line);
</PRE>

<DL><DD>
Frees the object <SAMP>elem</SAMP>, which must be an
instance of the class <SAMP>clas</SAMP>. Acts like
<CODE>vclassFree</CODE>, but also passes information to the
memory manager about where the object was freed from.
<SAMP>tag</SAMP> is the abstract tag of the module freeing
the instance specified by the <SAMP>vdebugTAG</SAMP>
mechanism. 
<P>
This function is only available in debugging
libraries. <CODE>vclassFree</CODE> is automatically mapped
to this function when memory debugging is enabled. Only
modules that provide their own storage-management functions
should need to call this function explicitly.
</DD></DL>
<P>
<A NAME="vclassGet"><HR><H4>vclassGet</H4></A>
<PRE>
        void * <B>vclassGet</B>(
                const vclass * clas,
                ... arg2);
</PRE>

<DL><DD>
Returns the method/variable bound to the identifier
<SAMP>id</SAMP> in the class <SAMP>clas</SAMP>. The exact
type of the returned value depends on the identifier being
read. <SAMP>id</SAMP> <I>must</I> be an identifier defined
by the class; it may have no meaning outside this
function. This function is usually implemented as a macro.
</DD></DL>
<P>
<A NAME="vclassGetAliasLoader"><HR><H4>vclassGetAliasLoader</H4></A>
<PRE>
        vclassAliasLoader <B>vclassGetAliasLoader</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetAliasStorer"><HR><H4>vclassGetAliasStorer</H4></A>
<PRE>
        vclassAliasStorer <B>vclassGetAliasStorer</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetAt"><HR><H4>vclassGetAt</H4></A>
<PRE>
        void * <B>vclassGetAt</B>(
                const vclass * clas,
                ... arg2);
</PRE>

<DL><DD>
Returns the element of the array bound to the identifier
<SAMP>id</SAMP> in the class <SAMP>clas</SAMP> at index
<SAMP>index</SAMP>. The exact type of the returned value
depends on the identifier being read. <SAMP>id</SAMP>
<I>must</I> be an identifier defined by the class; it may
have no meaning outside this function. This function is
usually implemented as a macro.
</DD></DL>
<P>
<A NAME="vclassGetCommon"><HR><H4>vclassGetCommon</H4></A>
<PRE>
        const vclass * <B>vclassGetCommon</B>(
                const vclass * clas1,
                const vclass * clas2);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetData"><HR><H4>vclassGetData</H4></A>
<PRE>
        void * <B>vclassGetData</B>(
                vclass * clas);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetDynamic"><HR><H4>vclassGetDynamic</H4></A>
<PRE>
        const void * <B>vclassGetDynamic</B>(
                vclass * clas,
                const vname * name);
</PRE>

<DL><DD>
Returns the dynamic binding of the name <SAMP>name</SAMP>
in the class <SAMP>clas</SAMP>, or <SAMP>NULL</SAMP> if
there is no dynamic binding.
</DD></DL>
<P>
<A NAME="vclassGetFieldOffset"><HR><H4>vclassGetFieldOffset</H4></A>
<PRE>
        size_t <B>vclassGetFieldOffset</B>(
                const vclass * clas,
                const char * fieldName);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetInterfaceImplementation"><HR><H4>vclassGetInterfaceImplementation</H4></A>
<PRE>
        vinterface * <B>vclassGetInterfaceImplementation</B>(
                vclass * implementor,
                vinterface * interfac);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetInterfaceIteratorImplementation"><HR><H4>vclassGetInterfaceIteratorImplementation</H4></A>
<PRE>
        vinterface * <B>vclassGetInterfaceIteratorImplementation</B>(
                vclassInterfaceIterator * iterator);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetInterfaceNameImplementation"><HR><H4>vclassGetInterfaceNameImplementation</H4></A>
<PRE>
        vinterface * <B>vclassGetInterfaceNameImplementation</B>(
                vclass * implementor,
                const vname * interface_name);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetLoadFunc"><HR><H4>vclassGetLoadFunc</H4></A>
<PRE>
        vclassLoadFunc <B>vclassGetLoadFunc</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetMismatchException"><HR><H4>vclassGetMismatchException</H4></A>
<PRE>
        vclassMismatchException * <B>vclassGetMismatchException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetMismatchExceptionClass"><HR><H4>vclassGetMismatchExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vclassGetMismatchExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetMismatchExceptionExpected"><HR><H4>vclassGetMismatchExceptionExpected</H4></A>
<PRE>
        const vname * <B>vclassGetMismatchExceptionExpected</B>(
                vclassMismatchException * exception);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetMismatchExceptionFound"><HR><H4>vclassGetMismatchExceptionFound</H4></A>
<PRE>
        const vname * <B>vclassGetMismatchExceptionFound</B>(
                vclassMismatchException * exception);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetName"><HR><H4>vclassGetName</H4></A>
<PRE>
        const vname * <B>vclassGetName</B>(
                const vclass * clas);
</PRE>

<DL><DD>
Returns the name of the class <SAMP>clas</SAMP>, or
<SAMP>NULL</SAMP> if the class is unnamed.
</DD></DL>
<P>
<A NAME="vclassGetNotFoundException"><HR><H4>vclassGetNotFoundException</H4></A>
<PRE>
        vclassNotFoundException * <B>vclassGetNotFoundException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetNotFoundExceptionClass"><HR><H4>vclassGetNotFoundExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vclassGetNotFoundExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetNotFoundExceptionName"><HR><H4>vclassGetNotFoundExceptionName</H4></A>
<PRE>
        const vname * <B>vclassGetNotFoundExceptionName</B>(
                vclassNotFoundException * exception);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetNotUnderstoodException"><HR><H4>vclassGetNotUnderstoodException</H4></A>
<PRE>
        vclassNotUnderstoodException * <B>vclassGetNotUnderstoodException</B>();
</PRE>

<DL><DD>
Returns a pointer to the current ``Not Understood''
exception, or <SAMP>NULL</SAMP> if the current exception is
not of this type.
</DD></DL>
<P>
<A NAME="vclassGetNotUnderstoodExceptionClass"><HR><H4>vclassGetNotUnderstoodExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vclassGetNotUnderstoodExceptionClass</B>();
</PRE>

<DL><DD>
Returns a pointer to the ``Not Understood'' exception
class.
</DD></DL>
<P>
<A NAME="vclassGetNotUnderstoodExceptionSelector"><HR><H4>vclassGetNotUnderstoodExceptionSelector</H4></A>
<PRE>
        const vname * <B>vclassGetNotUnderstoodExceptionSelector</B>(
                vclassNotUnderstoodException * exception);
</PRE>

<DL><DD>
Returns the selector which was not understood from the
``not understood'' exception <SAMP>exception</SAMP>.
</DD></DL>
<P>
<A NAME="vclassGetObjectHeaderSize"><HR><H4>vclassGetObjectHeaderSize</H4></A>
<PRE>
        size_t <B>vclassGetObjectHeaderSize</B>(
                const vclass * clas);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetObjectSize"><HR><H4>vclassGetObjectSize</H4></A>
<PRE>
        size_t <B>vclassGetObjectSize</B>(
                const vclass * clas);
</PRE>

<DL><DD>
Returns the object size of <SAMP>clas</SAMP> in bytes.
</DD></DL>
<P>
<A NAME="vclassGetRoot"><HR><H4>vclassGetRoot</H4></A>
<PRE>
        vclassRoot * <B>vclassGetRoot</B>();
</PRE>

<DL><DD>
Returns the root class. This class can be used to create
higher-level classes. Most ``new'' classes should subclass
from the result of <CODE><A HREF="vobject-x.html#vobjectGetDefaultClass"><CODE>vobjectGetDefaultClass</CODE></A></CODE>
instead of resulting from <CODE>vclassGetRoot</CODE>.
</DD></DL>
<P>
<A NAME="vclassGetSubIteratorClass"><HR><H4>vclassGetSubIteratorClass</H4></A>
<PRE>
        vclass * <B>vclassGetSubIteratorClass</B>(
                vclassSubIterator * iterator);
</PRE>

<DL><DD>
Returns the subclass indexed by the iterator
<SAMP>iterator</SAMP>. This function should only be called
after <CODE><A HREF="vclass-x.html#vclassNextSubIterator"><CODE>vclassNextSubIterator</CODE></A></CODE> has returned
<SAMP>TRUE</SAMP>. Note that the order in which subclasses
are iterated is arbitrary.
</DD></DL>
<P>
<A NAME="vclassGetSuper"><HR><H4>vclassGetSuper</H4></A>
<PRE>
        vclass * <B>vclassGetSuper</B>(
                vclass * clas);
</PRE>

<DL><DD>
Returns the superclass of <SAMP>clas</SAMP>, or
<SAMP>NULL</SAMP> if the class has no superclass. Only the
class returned by <CODE><A HREF="vclass-x.html#vclassGetRoot"><CODE>vclassGetRoot</CODE></A></CODE> has no
superclass.
</DD></DL>
<P>
<A NAME="vclassGetUnnamedException"><HR><H4>vclassGetUnnamedException</H4></A>
<PRE>
        vclassUnnamedException * <B>vclassGetUnnamedException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassGetUnnamedExceptionClass"><HR><H4>vclassGetUnnamedExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vclassGetUnnamedExceptionClass</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassImplementInterface"><HR><H4>vclassImplementInterface</H4></A>
<PRE>
        vinterface * <B>vclassImplementInterface</B>(
                vclass * implementor,
                vinterface * interfac);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassImplementsInterface"><HR><H4>vclassImplementsInterface</H4></A>
<PRE>
        vbool <B>vclassImplementsInterface</B>(
                vclass * implementor,
                vinterface * interfac);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassInitInterfaceIterator"><HR><H4>vclassInitInterfaceIterator</H4></A>
<PRE>
        void <B>vclassInitInterfaceIterator</B>(
                vclassInterfaceIterator * iterator,
                vclass * clas);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassInitSubIterator"><HR><H4>vclassInitSubIterator</H4></A>
<PRE>
        void <B>vclassInitSubIterator</B>(
                vclassSubIterator * iterator,
                vclass * clas);
</PRE>

<DL><DD>
Begins an iteration of all the subclasses of the class
<SAMP>clas</SAMP> using the iterator <SAMP>iterator</SAMP>.
The iterator initially contains no
subclass; <CODE><A HREF="vclass-x.html#vclassNextSubIterator"><CODE>vclassNextSubIterator</CODE></A></CODE> must be
called to obtain the first subclass. All local subclasses
created by the current application are included in the
iteration, as well as all global subclasses.
</DD></DL>
<P>
<A NAME="vclassIsGlobal"><HR><H4>vclassIsGlobal</H4></A>
<PRE>
        int <B>vclassIsGlobal</B>(
                const vclass * clas);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the class <SAMP>clas</SAMP> is
visible to all applications in the current process,
<SAMP>FALSE</SAMP> if it is visible only to the application
where it is named.
</DD></DL>
<P>
<A NAME="vclassIsKindOf"><HR><H4>vclassIsKindOf</H4></A>
<PRE>
        int <B>vclassIsKindOf</B>(
                const vclass * clas,
                const vclass * super);
</PRE>

<DL><DD>
Returns <SAMP>TRUE</SAMP> if the class <SAMP>super</SAMP>
is equal to the class <SAMP>clas</SAMP> or is equal to any
superclass of <SAMP>clas</SAMP>. It returns
<SAMP>FALSE</SAMP> if <SAMP>super</SAMP> is not equal to
either <SAMP>clas</SAMP> or any superclass of
<SAMP>clas</SAMP>.
</DD></DL>
<P>
<A NAME="vclassLoad"><HR><H4>vclassLoad</H4></A>
<PRE>
        vclass * <B>vclassLoad</B>(
                const vchar * name);
</PRE>

<DL><DD>
Returns the class named <SAMP>name</SAMP> from the class
manager registry. Returns <SAMP>NULL</SAMP> if no such
named class is found. This function is used for binding
classes to user-interface objects contained in resource
files.
</DD></DL>
<P>
<A NAME="vclassLoadAlias"><HR><H4>vclassLoadAlias</H4></A>
<PRE>
        const vname * <B>vclassLoadAlias</B>(
                const vclass * clas,
                const vname * type,
                int inst);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassLoadNamed"><HR><H4>vclassLoadNamed</H4></A>
<PRE>
        vclass * <B>vclassLoadNamed</B>(
                const vchar * name);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassLoadNamedScribed"><HR><H4>vclassLoadNamedScribed</H4></A>
<PRE>
        vclass * <B>vclassLoadNamedScribed</B>(
                vscribe * scribe);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassLoadScribed"><HR><H4>vclassLoadScribed</H4></A>
<PRE>
        vclass * <B>vclassLoadScribed</B>(
                vscribe * scribe);
</PRE>

<DL><DD>
Returns the class named <SAMP>name</SAMP> from the class
manager registry as specified through a string manager
scribe. It returns <SAMP>NULL</SAMP> if no such named
class is found. This function is used for binding classes
to user-interface objects contained in resource files.
</DD></DL>
<P>
<A NAME="vclassMarkFreed"><HR><H4>vclassMarkFreed</H4></A>
<PRE>
        void <B>vclassMarkFreed</B>(
                vclass * clas,
                void * elem);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassMarkFreedDebug"><HR><H4>vclassMarkFreedDebug</H4></A>
<PRE>
        void <B>vclassMarkFreedDebug</B>(
                vclass * clas,
                void * elem,
                const char * tag,
                const char * file,
                int line);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassMismatchExceptionEXPECTED"><HR><H4>vclassMismatchExceptionEXPECTED</H4></A>
<PRE>
        void <B>vclassMismatchExceptionEXPECTED</B>(
                void * exception,
                va_list * args);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassMismatchExceptionFOUND"><HR><H4>vclassMismatchExceptionFOUND</H4></A>
<PRE>
        void <B>vclassMismatchExceptionFOUND</B>(
                void * exception,
                va_list * args);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassNextInterfaceIterator"><HR><H4>vclassNextInterfaceIterator</H4></A>
<PRE>
        int <B>vclassNextInterfaceIterator</B>(
                vclassInterfaceIterator * iterator);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassNextSubIterator"><HR><H4>vclassNextSubIterator</H4></A>
<PRE>
        int <B>vclassNextSubIterator</B>(
                vclassSubIterator * iterator);
</PRE>

<DL><DD>
Performs the next step of the iteration represented by
<SAMP>iterator</SAMP> and returns <SAMP>TRUE</SAMP> if a
subclass is available, <SAMP>FALSE</SAMP> if not. The
particular subclass can be retrieved from the iterator with
<CODE><A HREF="vclass-x.html#vclassGetSubIteratorClass"><CODE>vclassGetSubIteratorClass</CODE></A></CODE>. All local
subclasses created by the current application are included
in the iteration, as well as all global subclasses.
</DD></DL>
<P>
<A NAME="vclassNotFoundExceptionNAME"><HR><H4>vclassNotFoundExceptionNAME</H4></A>
<PRE>
        void <B>vclassNotFoundExceptionNAME</B>(
                void * exception,
                va_list * args);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassNotUnderstoodExceptionSELECTOR"><HR><H4>vclassNotUnderstoodExceptionSELECTOR</H4></A>
<PRE>
        void <B>vclassNotUnderstoodExceptionSELECTOR</B>(
                void * exception,
                va_list * args);
</PRE>

<DL><DD>
Passed to the Exception Manager as an argument to a
<CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> call in order to specify the name
of a selector that was not understood by a class during
dynamic binding.
</DD></DL>
<P>
<A NAME="vclassNotifyName"><HR><H4>vclassNotifyName</H4></A>
<PRE>
        void <B>vclassNotifyName</B>(
                const vclass * clas);
</PRE>

<DL><DD>
Notifies the class <SAMP>clas</SAMP> that its name has been
changed and that it should update any internal state (such
as preferences) that depend on that name. This method is
overridden by user-interface classes that allow class
preferences to be automatically specified by name.
</DD></DL>
<P>
<A NAME="vclassReproduce"><HR><H4>vclassReproduce</H4></A>
<PRE>
        vclass * <B>vclassReproduce</B>(
                vclass * clas);
</PRE>

<DL><DD>
Creates a new subclass of <SAMP>clas</SAMP>. The type of
the new subclass is the same as <SAMP>clas</SAMP>. The new
class inherits all its methods from <SAMP>clas</SAMP> and
is unnamed. This function is the most commonly used
function for subclassing and should be used to change the
behavior of an existing class. 
<P>
Once a class has been reproduced, the new class should be named with
<CODE><A HREF="vclass-x.html#vclassSetName"><CODE>vclassSetName</CODE></A></CODE>, and its instance size should be
specified with <CODE><A HREF="vclass-x.html#vclassSetObjectSize"><CODE>vclassSetObjectSize</CODE></A></CODE>, if it has
its own instance type.
</DD></DL>
<P>
<A NAME="vclassSend"><HR><H4>vclassSend</H4></A>
<PRE>
        void <B>vclassSend</B>(
                const vclass * clas,
                ... arg2);
</PRE>

<DL><DD>
Invokes the behavior associated with the message identifier
<SAMP>id</SAMP> in class <SAMP>clas</SAMP>. Message
arguments are passed inside the parentheses of the third
argument. The arguments and return type depend on the value
of <SAMP>id</SAMP>. <SAMP>id</SAMP> must be a message
identifier declared by the class. This function is
implemented as a macro.
</DD></DL>
<P>
<A NAME="vclassSendDynamic"><HR><H4>vclassSendDynamic</H4></A>
<PRE>
        void <B>vclassSendDynamic</B>(
                const vclass * clas,
                const vname * selector,
                ... arg3);
</PRE>

<DL><DD>
Invokes the behavior associated with the dynamic method
<SAMP>selector</SAMP> in class <SAMP>clas</SAMP>. The
arguments are passed inside the parentheses of the third
argument. The arguments depend on the function bound to
<SAMP>selector</SAMP>. This function is implemented as a
macro. It generates a
<CODE><A HREF="vclass-x.html#vclassNotUnderstoodException"><CODE>vclassNotUnderstoodException</CODE></A></CODE> exception if the
message was not understood by the class.
</DD></DL>
<P>
<A NAME="vclassSendSuper"><HR><H4>vclassSendSuper</H4></A>
<PRE>
        void <B>vclassSendSuper</B>(
                const vclass * clas,
                ... arg2);
</PRE>

<DL><DD>
Similar to <CODE>vclassSend</CODE>, except that the message
is sent using the superclass of <SAMP>clas</SAMP>. Use this
function to send to your superclass inside a method
function definition. It is <I>very</I> important that the
message be sent to the superclass of the class where the
method is first defined, <I>not</I> to the superclass of
the class of the instance being operated on. 
If the message is sent to the instance superclass 
and the instance class is itself a subclass of the original class, 
infinite recursion results. 
<P>
Refer to the example module provided in
the section ``Using the Core Object Type'' in the ``Class
Manager'' chapter of the <I>Galaxy Application Environment
Programmer's Guide</I> for the correct way to send to the
superclass of an instance.
</DD></DL>
<P>
<A NAME="vclassSet"><HR><H4>vclassSet</H4></A>
<PRE>
        void <B>vclassSet</B>(
                vclass * clas,
                ... arg2);
</PRE>

<DL><DD>
Changes the binding of the message or variable identifier
<SAMP>id</SAMP> in the class <SAMP>clas</SAMP> to
<SAMP>value</SAMP>. If the identifier specifies a message,
<SAMP>value</SAMP> should be a pointer to the function to
call when an object of class <SAMP>clas</SAMP> receives the
message denoted by <SAMP>id</SAMP>. <SAMP>value</SAMP>
should be a variable value if <SAMP>id</SAMP> denotes a
class variable. <SAMP>id</SAMP> <I>must</I> be a message or
variable identifier defined by the class <SAMP>clas</SAMP>.
<P>
The exact type of <SAMP>value</SAMP> depends on the
identifier. The identifier <I>must</I> match the prototype of a method
function, or the type of a variable declaration. This
function is usually implemented as a macro, so the
identifier <SAMP>id</SAMP> may have no meaning outside the
macro expansion.
</DD></DL>
<P>
<A NAME="vclassSetAliasLoader"><HR><H4>vclassSetAliasLoader</H4></A>
<PRE>
        void <B>vclassSetAliasLoader</B>(
                vclassAliasLoader loader);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassSetAliasStorer"><HR><H4>vclassSetAliasStorer</H4></A>
<PRE>
        void <B>vclassSetAliasStorer</B>(
                vclassAliasStorer storer);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassSetAt"><HR><H4>vclassSetAt</H4></A>
<PRE>
        void <B>vclassSetAt</B>(
                vclass * clas,
                ... arg2);
</PRE>

<DL><DD>
Changes the element of the array bound to the identifier
<SAMP>id</SAMP> in the class <SAMP>clas</SAMP> at index
<SAMP>index</SAMP> to <SAMP>value</SAMP>.
<P>
<SAMP>value</SAMP> should be an array element value.
<SAMP>id</SAMP> <I>must</I> be a array variable identifier
defined by the class <SAMP>clas</SAMP>. The exact type of 
<SAMP>value</SAMP> depends on the identifier.
The identifier <I>must</I> match the element type of the array variable
declaration. 
<P>
This function is usually implemented as a
macro, so the identifier <SAMP>id</SAMP> may have no
meaning outside the macro expansion.
</DD></DL>
<P>
<A NAME="vclassSetData"><HR><H4>vclassSetData</H4></A>
<PRE>
        void <B>vclassSetData</B>(
                vclass * clas,
                void * data);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassSetDynamic"><HR><H4>vclassSetDynamic</H4></A>
<PRE>
        void <B>vclassSetDynamic</B>(
                vclass * clas,
                const vname * name,
                const void * value);
</PRE>

<DL><DD>
Defines a dynamic method or variable binding in the class
<SAMP>clas</SAMP>. <SAMP>name</SAMP> is a global name
(obtained from the name manager) that identifies the method
or variable, and <SAMP>value</SAMP> is its value. The
definition can be retrieved with
<CODE><A HREF="vclass-x.html#vclassGetDynamic"><CODE>vclassGetDynamic</CODE></A></CODE>, or be invoked with
<CODE><A HREF="vclass-x.html#vclassSendDynamic"><CODE>vclassSendDynamic</CODE></A></CODE>. In this case,
<SAMP>value</SAMP> must be a function pointer.
</DD></DL>
<P>
<A NAME="vclassSetGlobal"><HR><H4>vclassSetGlobal</H4></A>
<PRE>
        void <B>vclassSetGlobal</B>(
                vclass * clas,
                int flag);
</PRE>

<DL><DD>
Makes the class <SAMP>clas</SAMP> visible to all
applications in the current process if <SAMP>flag</SAMP> is
<SAMP>TRUE</SAMP>. If flag is <SAMP>FALSE</SAMP>, the class
is visible only to the current application. Classes are not
global by default: Use this function to make a local class
visible to all applications in the current process. 
<P>
Note that a global class cannot be a subclass of a local
class. The class manager generates an exception when this
is attempted.
</DD></DL>
<P>
<A NAME="vclassSetGlobalName"><HR><H4>vclassSetGlobalName</H4></A>
<PRE>
        void <B>vclassSetGlobalName</B>(
                vclass * clas,
                const vchar * name);
</PRE>

<DL><DD>
Essentially a combination of <CODE>vclassSetGlobal</CODE>
and <CODE><A HREF="vclass-x.html#vclassSetName"><CODE>vclassSetName</CODE></A></CODE>, this sets the name of the
class <SAMP>clas</SAMP> to be the name specified in
<SAMP>name</SAMP>. 
<P>
Classes named with <CODE>vclassSetGlobalName</CODE> are visible to all
applications in the current process. Application-specific
classes should should be named with
<CODE><A HREF="vclass-x.html#vclassSetName"><CODE>vclassSetName</CODE></A></CODE>. To specify a literal character
string as a global class name, use
<CODE><A HREF="vclass-x.html#vclassSetGlobalNameScribed"><CODE>vclassSetGlobalNameScribed</CODE></A></CODE>. Class names are
used by resource functions to identify classes in resource
files.
</DD></DL>
<P>
<A NAME="vclassSetGlobalNameScribed"><HR><H4>vclassSetGlobalNameScribed</H4></A>
<PRE>
        void <B>vclassSetGlobalNameScribed</B>(
                vclass * clas,
                vscribe * scribe);
</PRE>

<DL><DD>
Essentially a combination of <CODE>vclassSetGlobal</CODE>
and <CODE><A HREF="vclass-x.html#vclassSetNameScribed"><CODE>vclassSetNameScribed</CODE></A></CODE>, this sets the name
of the class <SAMP>clas</SAMP> to be the name specified,
using a string manager scribe, in <SAMP>name</SAMP>.
<P>
Classes named with <CODE>vclassSetGlobalNameScribed</CODE>
are visible to all applications in the current process.
Application specific classes should should be named with
<CODE><A HREF="vclass-x.html#vclassSetNameScribed"><CODE>vclassSetNameScribed</CODE></A></CODE>. To specify a literal
character string as a global class name, use the following
call.
<P>
<CODE>vclassSetGlobalNameScribed</CODE><SAMP>(clas,
<CODE><A HREF="vchar-x.html#vcharScribeLiteral"><CODE>vcharScribeLiteral</CODE></A></CODE> ("ClassName"))</SAMP>
<P>
Class names are used by resource functions to identify
classes in resource files.
</DD></DL>
<P>
<A NAME="vclassSetLoadFunc"><HR><H4>vclassSetLoadFunc</H4></A>
<PRE>
        void <B>vclassSetLoadFunc</B>(
                vclassLoadFunc loadFunc);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassSetName"><HR><H4>vclassSetName</H4></A>
<PRE>
        void <B>vclassSetName</B>(
                vclass * clas,
                const vchar * name);
</PRE>

<DL><DD>
Changes the name of the class <SAMP>clas</SAMP> to
<SAMP>name</SAMP>. Classes named with this function are
visible only to the current application, so only
application-specific classes should be named with this
function. Classes that need to be visible to all
applications should be named with
<CODE><A HREF="vclass-x.html#vclassSetGlobalName"><CODE>vclassSetGlobalName</CODE></A></CODE>). 
<P>
To specify a literal character string as a class name, use
<CODE><A HREF="vclass-x.html#vclassSetNameScribed"><CODE>vclassSetNameScribed</CODE></A></CODE>. Class names are used by
resource functions to identify classes in resource files.
</DD></DL>
<P>
<A NAME="vclassSetNameScribed"><HR><H4>vclassSetNameScribed</H4></A>
<PRE>
        void <B>vclassSetNameScribed</B>(
                vclass * clas,
                vscribe * scribe);
</PRE>

<DL><DD>
Changes the name of the class <SAMP>clas</SAMP> to
<SAMP>name</SAMP> using a string manager scribe. Classes
named with this function are visible only to the current
application, so only application-specific classes should be
named with this function. Classes that need to be
visible to all applications should be named with
<CODE><A HREF="vclass-x.html#vclassSetGlobalNameScribed"><CODE>vclassSetGlobalNameScribed</CODE></A></CODE>). 
<P>
To specify a literal character string as a class name, use
<CODE>vclassSetNameScribed</CODE><SAMP>(clas,
<CODE><A HREF="vchar-x.html#vcharScribeLiteral"><CODE>vcharScribeLiteral</CODE></A></CODE> ("ClassName"))</SAMP>.
Class names are used by resource functions to identify
classes in resource files.
</DD></DL>
<P>
<A NAME="vclassSetNameUnregistered"><HR><H4>vclassSetNameUnregistered</H4></A>
<PRE>
        void <B>vclassSetNameUnregistered</B>(
                vclass * clas,
                const vchar * name);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassSetNameUnregisteredScribed"><HR><H4>vclassSetNameUnregisteredScribed</H4></A>
<PRE>
        void <B>vclassSetNameUnregisteredScribed</B>(
                vclass * clas,
                vscribe * scribe);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassSetObjectHeaderSize"><HR><H4>vclassSetObjectHeaderSize</H4></A>
<PRE>
        void <B>vclassSetObjectHeaderSize</B>(
                vclass * clas,
                size_t objectHeaderSize);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassSetObjectSize"><HR><H4>vclassSetObjectSize</H4></A>
<PRE>
        void <B>vclassSetObjectSize</B>(
                vclass * clas,
                size_t objectSize);
</PRE>

<DL><DD>
Changes the <B><I>object size</I></B> of the class
<SAMP>clas</SAMP> to <SAMP>size</SAMP>. The object size is
the number of bytes occupied by instances of the class. The
object size is useful for implementing higher-level objects
that are larger than the objects they are based on. For
example, <CODE><A HREF="vcontrol-x.html#vcontrol"><CODE>vcontrol</CODE></A></CODE> is based on, and larger
than, <CODE><A HREF="vdialog-x.html#vdialogItem"><CODE>vdialogItem</CODE></A></CODE>. Class manager functions 
can then allocate space for these  objects without 
any explicit knowledge of their contents. 
<P>
The object size is used by the class manager allocation functions
<CODE><A HREF="vclass-x.html#vclassAlloc"><CODE>vclassAlloc</CODE></A></CODE> and <CODE><A HREF="vclass-x.html#vclassFree"><CODE>vclassFree</CODE></A></CODE>. The
object size <I>must</I> be set by a subclass if the
subclass defines instances that are larger than the
instances of its superclass.
</DD></DL>
<P>
<A NAME="vclassSpawn"><HR><H4>vclassSpawn</H4></A>
<PRE>
        vclass * <B>vclassSpawn</B>(
                vclass * clas,
                size_t size);
</PRE>

<DL><DD>
Creates a new class of size <SAMP>size</SAMP> whose
superclass is <SAMP>clas</SAMP>. The new class inherits all
the methods and variables defined by <SAMP>clas</SAMP>, but
any methods or variables that are defined solely by the new
class are left uninitialized. The new class is unnamed.
<P>
Obtain <SAMP>size</SAMP> by applying <SAMP>sizeof</SAMP> 
to the class type identifier (for example, 
<SAMP>sizeof(<CODE><A HREF="vwindow-x.html#vwindowClass"><CODE>vwindowClass</CODE></A></CODE>)</SAMP>).
This generates a <CODE><A HREF="vex-x.html#vexArgRangeException"><CODE>vexArgRangeException</CODE></A></CODE> exception
if <SAMP>size</SAMP> is less than the size of <SAMP>clas</SAMP>. 
<P>
Once a class has been spawned, the new
class should be named with <CODE><A HREF="vclass-x.html#vclassSetName"><CODE>vclassSetName</CODE></A></CODE>, and
its instance size should be specified with
<CODE><A HREF="vclass-x.html#vclassSetObjectSize"><CODE>vclassSetObjectSize</CODE></A></CODE>, if it has its own instance
type.
</DD></DL>
<P>
<A NAME="vclassStoreAlias"><HR><H4>vclassStoreAlias</H4></A>
<PRE>
        void <B>vclassStoreAlias</B>(
                const vclass * clas,
                const vname * type,
                const vname * name);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="section_Message"><HR>
<CENTER><H2>Messages</H2></CENTER></A><P>
<A NAME="vclassNOTIFY_NAME"><HR><H4>vclassNOTIFY_NAME</H4></A>
<PRE>
        &lt;<B>vclassNOTIFY_NAME</B>&gt;
</PRE>

<DL><DD>
Notifies the class <SAMP>clas</SAMP> that its name has been
changed and that it should update any internal state (such
as preferences) that depend on that name. This method is
overridden by user-interface classes that allow class
preferences to be automatically specified by name. The
function entry point <CODE><A HREF="vclass-x.html#vclassNotifyName"><CODE>vclassNotifyName</CODE></A></CODE> is
implemented by sending this message to the class.
<P>
The default method for the root class does nothing.
Subclasses that override this method should first update
their internal state according to the new class name, if
any, then call <CODE><A HREF="vclass-x.html#vclassSendSuper"><CODE>vclassSendSuper</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="section_Constant"><HR>
<CENTER><H2>Constants</H2></CENTER></A><P>
<A NAME="vclassFIELDS"><HR><H4>vclassFIELDS</H4></A>
<PRE>
        <B>vclassFIELDS</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassHEADER"><HR><H4>vclassHEADER</H4></A>
<PRE>
        <B>vclassHEADER</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassINCLUDED"><HR><H4>vclassINCLUDED</H4></A>
<PRE>
        <B>vclassINCLUDED</B>
</PRE>

<DL><DD>
Defined when the header file <SAMP>vclass.h</SAMP> is
included.
</DD></DL>
<P>
<A NAME="vclassInterfaceINCLUDED"><HR><H4>vclassInterfaceINCLUDED</H4></A>
<PRE>
        <B>vclassInterfaceINCLUDED</B>
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassREGISTER_CLASS_INFO"><HR><H4>vclassREGISTER_CLASS_INFO</H4></A>
<PRE>
        <B>vclassREGISTER_CLASS_INFO</B>
</PRE>

<DL><DD>
Set to <SAMP>TRUE</SAMP> when classes should register
information about themselves with a browser library.
</DD></DL>
<P>
<A NAME="section_Macro"><HR>
<CENTER><H2>Macros</H2></CENTER></A><P>
<A NAME="vclassMETHOD"><HR><H4>vclassMETHOD</H4></A>
<PRE>
        #define <B>vclassMETHOD</B>(...) ...
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassMETHOD_RET"><HR><H4>vclassMETHOD_RET</H4></A>
<PRE>
        #define <B>vclassMETHOD_RET</B>(...) ...
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassROOT"><HR><H4>vclassROOT</H4></A>
<PRE>
        #define <B>vclassROOT</B>(...) ...
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassVARIABLE"><HR><H4>vclassVARIABLE</H4></A>
<PRE>
        #define <B>vclassVARIABLE</B>(...) ...
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vclassVARIABLE_ARRAY"><HR><H4>vclassVARIABLE_ARRAY</H4></A>
<PRE>
        #define <B>vclassVARIABLE_ARRAY</B>(...) ...
</PRE>

<DL><DD>

</DD></DL>
<P>

<P>
<!--[[/CONTENT]]-->

<HR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">
		<TD>
		<CENTER>
<!--[[NAVIGATE_ICONIC]]-->
<!--[[/NAVIGATE_ICONIC]]-->
		</CENTER>
		</TD>
		    
		<TD>
		<BR>
		<FONT SIZE=-1>
	        <A HREF="#Top">Top of This Page</A> <BR>
	        <A HREF="index.html">Table of Contents</A> <BR>
		<A HREF="../index.html">Switch to Another Document</A><BR>
		<BR>
		</FONT>
		</TD>

		<TD>
		<BR>
		<FONT SIZE=-1>
		Need help?
		<A HREF="../contact-visix.html">
		Contact Visix</A>.
		<BR> <BR>
	        <A HREF="../copyright.html">Copyright &#169; 1996-97</A>,
		<A HREF="http://www.visix.com/">Visix Software Inc.</A><BR>
		<BR>
		</FONT>
		</TD>

	</TR>

</TABLE>
		
</BODY>
</HTML>



