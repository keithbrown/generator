<HTML>
  <HEAD>
<!--[[HEADING]]-->
<title>vmem prefix</title><!--[[/HEADING]]-->
  </HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<A NAME="Top"><IMG SRC="../graphics/trans.gif" WIDTH=2 HEIGHT=2></A><BR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">

		<TD>
		<CENTER>
		<A HREF="../index.html">
		<IMG SRC="../graphics/logo.gif" BORDER=0></A>
		</CENTER>
		</TD>

	        <TD VALIGN=TOP>
	        <BR><H1>
<!--[[TITLE]]-->
vmem prefix<!--[[/TITLE]]-->
	        </H1><BR>
		</TD>
      
	</TR>

</TABLE>

<HR>

<BR>

<!--[[PREAMBLE]]-->
<TABLE>
<TR>
<TD><A HREF="vmem-x.html#section_DataType">Types</A> [12]</TD>
<TD><A HREF="vmem-x.html#section_Function">Functions</A> [83]</TD>
<TD></TD>
<TD><A HREF="vmem-x.html#section_Constant">Constants</A> [26]</TD>
<TD><A HREF="vmem-x.html#section_Macro">Macros</A> [1]</TD>
</TR>
</TABLE>
<!--[[/PREAMBLE]]-->

<!--[[CONTENT]]-->

<P>
<A NAME="section_DataType"><HR>
<CENTER><H2>Types</H2></CENTER></A><P>
<A NAME="vmemAllocException"><HR><H4>vmemAllocException</H4></A>
<PRE>
        typedef ... <B>vmemAllocException</B>;
</PRE>

<DL><DD>
Generated by <CODE>vmemAlloc</CODE> and
<CODE><A HREF="vmem-x.html#vmemAllocAndClear"><CODE>vmemAllocAndClear</CODE></A></CODE> when a block of the
requested size cannot be allocated.
</DD></DL>
<P>
<A NAME="vmemBoundsException"><HR><H4>vmemBoundsException</H4></A>
<PRE>
        typedef ... <B>vmemBoundsException</B>;
</PRE>

<DL><DD>
Generated by <CODE><A HREF="vmem-x.html#vmemValidateBlock"><CODE>vmemValidateBlock</CODE></A></CODE> when it detects
that a block's boundaries have been overwritten.
<CODE><A HREF="vmem-x.html#vmemValidateBlock"><CODE>vmemValidateBlock</CODE></A></CODE> is called automatically by
<CODE><A HREF="vmem-x.html#vmemRealloc"><CODE>vmemRealloc</CODE></A></CODE> and <CODE><A HREF="vmem-x.html#vmemFree"><CODE>vmemFree</CODE></A></CODE> when
debugging is enabled. This exception is available only when
debugging is enabled.
</DD></DL>
<P>
<A NAME="vmemException"><HR><H4>vmemException</H4></A>
<PRE>
        typedef ... <B>vmemException</B>;
</PRE>

<DL><DD>
The root exception type for all Memory class exception
types. This exception is never directly generated.
</DD></DL>
<P>
<A NAME="vmemFreeFunction"><HR><H4>vmemFreeFunction</H4></A>
<PRE>
        typedef ... <B>vmemFreeFunction</B>;
</PRE>

<DL><DD>
This type is used as an argument to
<CODE><A HREF="vmem-x.html#vmemRegisterFreeFunction"><CODE>vmemRegisterFreeFunction</CODE></A></CODE>. The function is
called by the Memory class to try to free some memory
when not enough memory is available to satisfy a request.
The function returns <SAMP>TRUE</SAMP> if it was able to
free something and <SAMP>FALSE</SAMP> otherwise.
<P>
There is no obligation for the function to actually free
anything at all. It is unwise for the function to attempt
to do something that would cause another memory allocation.
</DD></DL>
<P>
<A NAME="vmemGroup"><HR><H4>vmemGroup</H4></A>
<PRE>
        typedef ... <B>vmemGroup</B>;
</PRE>

<DL><DD>
Used by the debugging Memory class to partition the
memory space into groups where different source modules can
use their own group. Groups are defined by the value of the
string in <CODE>vmemTAG</CODE>. Source files may
<SAMP>#define</SAMP> <CODE>vmemTAG</CODE> either before or
after including <SAMP>vmem.h</SAMP> to override the default
of <CODE>vdebugTAG</CODE>. This type is only used when
debugging is enabled.
<P>
This type is not used directly by applications.
</DD></DL>
<P>
<A NAME="vmemInvalidAlreadyFreedException"><HR><H4>vmemInvalidAlreadyFreedException</H4></A>
<PRE>
        typedef ... <B>vmemInvalidAlreadyFreedException</B>;
</PRE>

<DL><DD>
Generated by <CODE><A HREF="vmem-x.html#vmemValidateBlock"><CODE>vmemValidateBlock</CODE></A></CODE> when it is
passed a pointer to a block that has been freed.
<CODE><A HREF="vmem-x.html#vmemValidateBlock"><CODE>vmemValidateBlock</CODE></A></CODE> is called automatically by
<CODE><A HREF="vmem-x.html#vmemRealloc"><CODE>vmemRealloc</CODE></A></CODE> and <CODE><A HREF="vmem-x.html#vmemFree"><CODE>vmemFree</CODE></A></CODE> when
debugging is enabled. This exception is also generated by
<CODE><A HREF="vpool-x.html#vpoolFree"><CODE>vpoolFree</CODE></A></CODE> when the element pointer to free is
already free. This exception is only available when
debugging is enabled.
</DD></DL>
<P>
<A NAME="vmemInvalidException"><HR><H4>vmemInvalidException</H4></A>
<PRE>
        typedef ... <B>vmemInvalidException</B>;
</PRE>

<DL><DD>
Generated by <CODE><A HREF="vmem-x.html#vmemValidateBlock"><CODE>vmemValidateBlock</CODE></A></CODE> when it is
passed a pointer to a block that has not been allocated.
<CODE><A HREF="vmem-x.html#vmemValidateBlock"><CODE>vmemValidateBlock</CODE></A></CODE> is called automatically by
<CODE><A HREF="vmem-x.html#vmemRealloc"><CODE>vmemRealloc</CODE></A></CODE> and <CODE><A HREF="vmem-x.html#vmemFree"><CODE>vmemFree</CODE></A></CODE> when
debugging is enabled. This exception is also generated by
<CODE><A HREF="vpool-x.html#vpoolFree"><CODE>vpoolFree</CODE></A></CODE> when the element pointer to free is
not in the given pool. This exception is only available
when debugging is enabled.
</DD></DL>
<P>
<A NAME="vmemMonitorEvent"><HR><H4>vmemMonitorEvent</H4></A>
<PRE>
        typedef ... <B>vmemMonitorEvent</B>;
</PRE>

<DL><DD>
Describes the event sent to a <CODE><A HREF="vmem-x.html#vmemMonitorProc"><CODE>vmemMonitorProc</CODE></A></CODE>
when there is activity within the debugging Memory class.
This type is only defined when debugging is enabled.
</DD></DL>
<P>
<A NAME="vmemMonitorProc"><HR><H4>vmemMonitorProc</H4></A>
<PRE>
        typedef ... <B>vmemMonitorProc</B>;
</PRE>

<DL><DD>
Function used to monitor activity in the debugging Memory
class. This type is only defined when debugging is
enabled.
</DD></DL>
<P>
<A NAME="vmemMoveException"><HR><H4>vmemMoveException</H4></A>
<PRE>
        typedef ... <B>vmemMoveException</B>;
</PRE>

<DL><DD>
<I><B>(Deprecated)</B></I> This exception is never generated by the Memory class. It
is included for backward compatibility.
</DD></DL>
<P>
<A NAME="vmemReallocException"><HR><H4>vmemReallocException</H4></A>
<PRE>
        typedef ... <B>vmemReallocException</B>;
</PRE>

<DL><DD>
Generated by <CODE>vmemRealloc</CODE> when a block cannot
be reallocated to the requested size.
</DD></DL>
<P>
<A NAME="vmemValueException"><HR><H4>vmemValueException</H4></A>
<PRE>
        typedef ... <B>vmemValueException</B>;
</PRE>

<DL><DD>
Generated when the Memory class detects that the heap has
been corrupted.
</DD></DL>
<P>
<A NAME="section_Function"><HR>
<CENTER><H2>Functions</H2></CENTER></A><P>
<A NAME="vmemAlloc"><HR><H4>vmemAlloc</H4></A>
<PRE>
        void * <B>vmemAlloc</B>(
                size_t nBytes);
</PRE>

<DL><DD>
Allocates a block of dynamic memory of least
<SAMP>nBytes</SAMP> bytes and returns a pointer to the
beginning of the block. The pointer is aligned for any data
type. The contents of the block are deliberately randomized
by the Memory class if debugging is enabled and the
<CODE>vmemFLAG_RANDOMIZE_ALLOC</CODE> is set. Otherwise,
the block contents are not initialized in any way. The
block contains random garbage determined by the underlying
operating system.
<P>
If there is not enough memory available to satisfy the
request, the Memory class calls each registered
<CODE><A HREF="vmem-x.html#vmemFreeFunction"><CODE>vmemFreeFunction</CODE></A></CODE> to free memory until it can
satisfy the request. The order that the functions are
called is determined by the priority they were registered
with. If the request still cannot be satisfied, a
<CODE><A HREF="vmem-x.html#vmemAllocException"><CODE>vmemAllocException</CODE></A></CODE> is generated. When
debugging is enabled, calls to this function are replaced
with calls to <CODE><A HREF="vmem-x.html#vmemAllocDebug"><CODE>vmemAllocDebug</CODE></A></CODE>, passing it the
``site'' of the allocation.
</DD></DL>
<P>
<A NAME="vmemAllocAndClear"><HR><H4>vmemAllocAndClear</H4></A>
<PRE>
        void * <B>vmemAllocAndClear</B>(
                size_t nBytes);
</PRE>

<DL><DD>
Allocates a block of dynamic memory of least
<SAMP>nBytes</SAMP> bytes and returns a pointer to the
beginning of the block. The pointer is aligned for any data
type. The contents of the block are cleared to an all-zero
byte pattern.
<P>
If there is not enough memory available to satisfy the
request, the Memory class calls each registered
<CODE><A HREF="vmem-x.html#vmemFreeFunction"><CODE>vmemFreeFunction</CODE></A></CODE> to free memory until it can
satisfy the request. The order that the functions are
called is determined by the priority they were registered
with. If the request still cannot be satisfied, a
<CODE><A HREF="vmem-x.html#vmemAllocException"><CODE>vmemAllocException</CODE></A></CODE> is generated. When
debugging is enabled, calls to this function are replaced
with calls to <CODE><A HREF="vmem-x.html#vmemAllocAndClearDebug"><CODE>vmemAllocAndClearDebug</CODE></A></CODE> (passing
it the ``site'' of the allocation).
</DD></DL>
<P>
<A NAME="vmemAllocAndClearDebug"><HR><H4>vmemAllocAndClearDebug</H4></A>
<PRE>
        void * <B>vmemAllocAndClearDebug</B>(
                size_t nBytes,
                const char * tag,
                const char * file,
                int line);
</PRE>

<DL><DD>
Allocates a block of dynamic memory of least
<SAMP>nBytes</SAMP> bytes and returns a pointer to the
beginning of the block. The pointer is aligned for any data
type. The arguments <SAMP>tag</SAMP>, <SAMP>file</SAMP>,
and <SAMP>line</SAMP> specify the ``site'' of the
allocation for debugging purposes. <SAMP>tag</SAMP> is the
tag of the module allocating the block (a
<CODE>vmemTAG</CODE> from somewhere), <SAMP>file</SAMP> is
the source file that contains the allocation function call,
and <SAMP>line</SAMP> is the line number of the function
call within the source file. The contents of the block are
cleared to an all-zero byte pattern.
<P>
If there is not enough memory available to satisfy the
request, the Memory class calls each registered
<CODE><A HREF="vmem-x.html#vmemFreeFunction"><CODE>vmemFreeFunction</CODE></A></CODE> to free memory until it can
satisfy the request. The order that the functions are
called is determined by the priority they were registered
with. If the request still cannot be satisfied, a
<CODE><A HREF="vmem-x.html#vmemAllocException"><CODE>vmemAllocException</CODE></A></CODE> is generated. When
debugging is disabled, calls to this function are replaced
with calls to <CODE>vmemAllocAndClear</CODE> (discarding
the ``site'' of the allocation).
</DD></DL>
<P>
<A NAME="vmemAllocDebug"><HR><H4>vmemAllocDebug</H4></A>
<PRE>
        void * <B>vmemAllocDebug</B>(
                size_t nBytes,
                const char * tag,
                const char * file,
                int line);
</PRE>

<DL><DD>
Allocates a block of dynamic memory of least
<SAMP>nBytes</SAMP> bytes and returns a pointer to the
beginning of the block. The pointer is aligned for any data
type. The arguments <SAMP>tag</SAMP>, <SAMP>file</SAMP>,
and <SAMP>line</SAMP> specify the ``site'' of the
allocation for debugging purposes. <SAMP>tag</SAMP> is the
tag of the module allocating the block (a
<CODE>vmemTAG</CODE> from somewhere), <SAMP>file</SAMP> is
the source file that contains the allocation function call,
and <SAMP>line</SAMP> is the line number of the function
call within the source file. The contents of the block are
deliberately randomized by the Memory class if debugging
is enabled and the <CODE>vmemFLAG_RANDOMIZE_ALLOC</CODE> is
set; otherwise, the block contents are not initialized in
any way. The block contains random garbage determined by
the underlying operating system.
<P>
If there is not enough memory available to satisfy the
request, the Memory class calls each registered
<CODE><A HREF="vmem-x.html#vmemFreeFunction"><CODE>vmemFreeFunction</CODE></A></CODE> to free memory until it can
satisfy the request. The order that the functions are
called is determined by the priority they were registered
with. If the request still cannot be satisfied, a
<CODE><A HREF="vmem-x.html#vmemAllocException"><CODE>vmemAllocException</CODE></A></CODE> is generated. When
debugging is disabled, calls to this function are replaced
with calls to <CODE>vmemAlloc</CODE> (discarding the
``site'' of the allocation).
</DD></DL>
<P>
<A NAME="vmemAllocSIZE"><HR><H4>vmemAllocSIZE</H4></A>
<PRE>
        void <B>vmemAllocSIZE</B>(
                void * exception,
                va_list * ap);
</PRE>

<DL><DD>
An exception tag of type <CODE><A HREF="vex-x.html#vexTag"><CODE>vexTag</CODE></A></CODE>, indicating
that the next argument in an exception generation call is
an integer of type <SAMP>size_t</SAMP> that indicates the
size of a failed memory allocation. This tag can be used
with <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> or <CODE><A HREF="vex-x.html#vexPropagate"><CODE>vexPropagate</CODE></A></CODE>
to store the size of the attempted allocation in the
exception itself.
--end-



##########

<A HREF="vmem-x.html#vmemBoundsBLOCK"><CODE>vmemBoundsBLOCK</CODE></A> : Function
  : status released
  : declaration
--begin--
void <A HREF="vmem-x.html#vmemBoundsBLOCK"><CODE>vmemBoundsBLOCK</CODE></A>(void * exception, va_list * ap)
</DD></DL>
<P>
<A NAME="vmemBoundsBLOCK"><HR><H4>vmemBoundsBLOCK</H4></A>
<PRE>
        void <B>vmemBoundsBLOCK</B>(
                void * exception,
                va_list * ap);
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vmemBoundsBOUNDS"><HR><H4>vmemBoundsBOUNDS</H4></A>
<PRE>
        void <B>vmemBoundsBOUNDS</B>(
                void * exception,
                va_list * ap);
</PRE>

<DL><DD>
An exception tag of type <CODE><A HREF="vex-x.html#vexTag"><CODE>vexTag</CODE></A></CODE>, indicating
that the next argument in an exception generation call is
an integer that denotes the boundary of an overrun block.
This tag can be used with <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> or
<CODE><A HREF="vex-x.html#vexPropagate"><CODE>vexPropagate</CODE></A></CODE> to store the overrun block
boundary in the exception itself. Valid boundary constants
are not documented in this release of Galaxy. This constant
is only available when debugging is enabled.
</DD></DL>
<P>
<A NAME="vmemCompare"><HR><H4>vmemCompare</H4></A>
<PRE>
        int <B>vmemCompare</B>(
                const void * address1,
                const void * address2,
                size_t nBytes);
</PRE>

<DL><DD>
Compares the unsigned values of the bytes in the blocks of
memory addressed by <SAMP>address1</SAMP> and
<SAMP>address2</SAMP> and returns a number representing
their lexical ordering. This function returns an integer
less than zero if the block addressed by
<SAMP>address1</SAMP> is the lesser, an integer greater
than zero if the block addressed by <SAMP>address1</SAMP>
is the greater, or zero if the two blocks are equal. The
magnitude of the result should not be used.
</DD></DL>
<P>
<A NAME="vmemCopy"><HR><H4>vmemCopy</H4></A>
<PRE>
        void * <B>vmemCopy</B>(
                const void * addressSource,
                void * addressTarget,
                size_t nBytes);
</PRE>

<DL><DD>
Copies each byte of the block of memory addressed by
<SAMP>addressSource</SAMP> to the block
<SAMP>addressTarget</SAMP>. The blocks are
<SAMP>nBytes</SAMP> bytes long. Behavior is undefined if
the two areas overlap. Refer to <CODE><A HREF="vmem-x.html#vmemMove"><CODE>vmemMove</CODE></A></CODE> 
for more information. 
<P>
This function returns <SAMP>addressSource</SAMP> as its
result. The blocks need not have been allocated by the
Memory class.
</DD></DL>
<P>
<A NAME="vmemDefaultMonitorProc"><HR><H4>vmemDefaultMonitorProc</H4></A>
<PRE>
        void <B>vmemDefaultMonitorProc</B>(
                vmemMonitorEvent * event);
</PRE>

<DL><DD>
A monitor function that dumps a readable form of the events
to <CODE><A HREF="vdebug-x.html#vdebugGetTracingStream"><CODE>vdebugGetTracingStream</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vmemDumpBlocksWithTag"><HR><H4>vmemDumpBlocksWithTag</H4></A>
<PRE>
        void <B>vmemDumpBlocksWithTag</B>(
                const char * tag,
                FILE * fp);
</PRE>

<DL><DD>
Dumps block headers that were allocated for memory group
defined by <SAMP>tag</SAMP> but not yet freed to the file
specified by <SAMP>fp</SAMP>. If <SAMP>fp</SAMP> is
<SAMP>NULL</SAMP>, <CODE><A HREF="vdebug-x.html#vdebugGetInfoStream"><CODE>vdebugGetInfoStream</CODE></A></CODE> is
used. The block headers are only present if the
<CODE>vmemFLAG_USE_HEADER</CODE> debugging flag is set.
</DD></DL>
<P>
<A NAME="vmemDumpInvalidBlocks"><HR><H4>vmemDumpInvalidBlocks</H4></A>
<PRE>
        int <B>vmemDumpInvalidBlocks</B>(
                FILE * fp);
</PRE>

<DL><DD>
Dumps block headers for memory groups that were allocated
and are determined to be invalid (corrupted) to the file
specified by <SAMP>fp</SAMP>. If <SAMP>fp</SAMP> is
<SAMP>NULL</SAMP>, <CODE><A HREF="vdebug-x.html#vdebugGetInfoStream"><CODE>vdebugGetInfoStream</CODE></A></CODE> is
used. The block headers are only present if the
<CODE>vmemFLAG_USE_HEADER</CODE> debugging flag is set.
</DD></DL>
<P>
<A NAME="vmemDumpInvalidBlocksWithTag"><HR><H4>vmemDumpInvalidBlocksWithTag</H4></A>
<PRE>
        int <B>vmemDumpInvalidBlocksWithTag</B>(
                const char * tag,
                FILE * fp);
</PRE>

<DL><DD>
Dumps block headers that were allocated for the memory
group defined by <SAMP>tag</SAMP> and are determined to be
invalid (corrupted) to the file specified by
<SAMP>fp</SAMP>. If <SAMP>fp</SAMP> is <SAMP>NULL</SAMP>,
<CODE><A HREF="vdebug-x.html#vdebugGetInfoStream"><CODE>vdebugGetInfoStream</CODE></A></CODE> is used. The block headers
are only present if the <CODE>vmemFLAG_USE_HEADER</CODE>
debugging flag is set.
</DD></DL>
<P>
<A NAME="vmemDumpStatisticsWithTag"><HR><H4>vmemDumpStatisticsWithTag</H4></A>
<PRE>
        void <B>vmemDumpStatisticsWithTag</B>(
                const char * tag,
                FILE * fp);
</PRE>

<DL><DD>
Dumps memory statistics for memory group defined by
<SAMP>tag</SAMP> to the file specified by <SAMP>fp</SAMP>.
If <SAMP>fp</SAMP> is <SAMP>NULL</SAMP>,
<CODE><A HREF="vdebug-x.html#vdebugGetInfoStream"><CODE>vdebugGetInfoStream</CODE></A></CODE> is used. Statistics are
only meaningful if the <CODE>vmemFLAG_USE_HEADER</CODE>
debugging flag is set.
</DD></DL>
<P>
<A NAME="vmemFree"><HR><H4>vmemFree</H4></A>
<PRE>
        void <B>vmemFree</B>(
                void * address);
</PRE>

<DL><DD>
Reclaims the storage occupied by the dynamic memory block
<SAMP>address</SAMP>. The block contents are lost
immediately upon calling this function. The contents of the
block are deliberately randomized by the Memory class
before it is freed if debugging is enabled and the
<CODE>vmemFLAG_RANDOMIZE_ALLOC</CODE> is set. When
debugging is enabled, this function calls
<CODE><A HREF="vmem-x.html#vmemValidateBlock"><CODE>vmemValidateBlock</CODE></A></CODE> to validate the block
contents. <CODE><A HREF="vmem-x.html#vmemValidateBlock"><CODE>vmemValidateBlock</CODE></A></CODE> generates
<CODE><A HREF="vmem-x.html#vmemBoundsException"><CODE>vmemBoundsException</CODE></A></CODE> if the block bounds have
been overwritten, <CODE><A HREF="vmem-x.html#vmemInvalidException"><CODE>vmemInvalidException</CODE></A></CODE> if the
block has not been allocated, and
<CODE><A HREF="vmem-x.html#vmemInvalidAlreadyFreedException"><CODE>vmemInvalidAlreadyFreedException</CODE></A></CODE> if the block
has been allocated and freed. 
<P>
When debugging is disabled,
calls to this function are replaced with calls to
<CODE><A HREF="vmem-x.html#vmemFreeDebug"><CODE>vmemFreeDebug</CODE></A></CODE> (discarding the ``site'' of the
allocation).
</DD></DL>
<P>
<A NAME="vmemFreeDebug"><HR><H4>vmemFreeDebug</H4></A>
<PRE>
        void <B>vmemFreeDebug</B>(
                void * address,
                const char * tag,
                const char * file,
                int line);
</PRE>

<DL><DD>
Reclaims the storage occupied by the dynamic memory block
<SAMP>address</SAMP>. The block contents are lost
immediately on calling this function. The contents of the
block are deliberately randomized by the Memory class
before it is freed if the
<CODE>vmemFLAG_RANDOMIZE_ALLOC</CODE> is set. 
<P>
The arguments <SAMP>tag</SAMP>, <SAMP>file</SAMP>, and <SAMP>line</SAMP>
specify the ``site'' of the <CODE>vmemFreeDebug</CODE> for
debugging purposes. <SAMP>tag</SAMP> is the tag of the
module freeing the block (a <CODE>vmemTAG</CODE> from
somewhere), <SAMP>file</SAMP> is the source file that
contains the free function call, and <SAMP>line</SAMP> is
the line number of the function call within the source
file. This function calls <CODE><A HREF="vmem-x.html#vmemValidateBlock"><CODE>vmemValidateBlock</CODE></A></CODE> to
validate the block contents. <CODE><A HREF="vmem-x.html#vmemValidateBlock"><CODE>vmemValidateBlock</CODE></A></CODE>
generates <CODE><A HREF="vmem-x.html#vmemBoundsException"><CODE>vmemBoundsException</CODE></A></CODE> if the block
bounds have been overwritten,
<CODE><A HREF="vmem-x.html#vmemInvalidException"><CODE>vmemInvalidException</CODE></A></CODE> if the block has not been
allocated, and
<CODE><A HREF="vmem-x.html#vmemInvalidAlreadyFreedException"><CODE>vmemInvalidAlreadyFreedException</CODE></A></CODE> if the block
has been allocated and freed. 
<P>
When debugging is enabled,
calls to this function are replaced with calls to
<CODE>vmemFreeDebug</CODE> (passing the ``site'' of the
allocation).
</DD></DL>
<P>
<A NAME="vmemGetAllocException"><HR><H4>vmemGetAllocException</H4></A>
<PRE>
        vmemAllocException * <B>vmemGetAllocException</B>();
</PRE>

<DL><DD>
Returns a pointer to the first ``Memory Alloc'' exception
in the current exception chain, or <SAMP>NULL</SAMP> if the
current exception chain does not have an exception of this
type.
</DD></DL>
<P>
<A NAME="vmemGetAllocExceptionClass"><HR><H4>vmemGetAllocExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vmemGetAllocExceptionClass</B>();
</PRE>

<DL><DD>
Returns a pointer to the ``Memory Alloc'' exception class.
This class can be used to generate exceptions or define new
exception classes.
</DD></DL>
<P>
<A NAME="vmemGetAllocSize"><HR><H4>vmemGetAllocSize</H4></A>
<PRE>
        size_t <B>vmemGetAllocSize</B>(
                const vmemAllocException * exception);
</PRE>

<DL><DD>
Returns the size of the attempted allocation that caused
the given exception.
</DD></DL>
<P>
<A NAME="vmemGetBoundsBlock"><HR><H4>vmemGetBoundsBlock</H4></A>
<PRE>
        void * <B>vmemGetBoundsBlock</B>(
                const vmemBoundsException * exception);
</PRE>

<DL><DD>
Returns a pointer to the memory block whose bounds were
violated. This function is only available if debugging is
enabled.
</DD></DL>
<P>
<A NAME="vmemGetBoundsBounds"><HR><H4>vmemGetBoundsBounds</H4></A>
<PRE>
        int <B>vmemGetBoundsBounds</B>(
                const vmemBoundsException * exception);
</PRE>

<DL><DD>
Returns the violated bounds that caused the given
exception. This function is only available if debugging is
enabled.
</DD></DL>
<P>
<A NAME="vmemGetBoundsException"><HR><H4>vmemGetBoundsException</H4></A>
<PRE>
        vmemBoundsException * <B>vmemGetBoundsException</B>();
</PRE>

<DL><DD>
Returns a pointer to the first ``Memory Bounds'' exception
in the current exception chain, or <SAMP>NULL</SAMP> if the
current exception chain does not have an exception of this
type. This function is only available if debugging is
enabled.
</DD></DL>
<P>
<A NAME="vmemGetBoundsExceptionClass"><HR><H4>vmemGetBoundsExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vmemGetBoundsExceptionClass</B>();
</PRE>

<DL><DD>
Returns a pointer to the ``Memory Bounds'' exception class.
This class can be used to generate exceptions or define new
exception classes. This function is only available if
debugging is enabled.
</DD></DL>
<P>
<A NAME="vmemGetDefaultDebuggingFlags"><HR><H4>vmemGetDefaultDebuggingFlags</H4></A>
<PRE>
        unsigned int <B>vmemGetDefaultDebuggingFlags</B>();
</PRE>

<DL><DD>
Returns flags used by debugging Memory class. Refer to 
<CODE>vmemDEFAULT_DEBUGGING_FLAGS_ENVIRONMENT_VARIABLE</CODE>
for more information on the defaults.
</DD></DL>
<P>
<A NAME="vmemGetException"><HR><H4>vmemGetException</H4></A>
<PRE>
        vmemException * <B>vmemGetException</B>();
</PRE>

<DL><DD>
Returns a pointer to the first ``Memory'' exception in the
current exception chain, or <SAMP>NULL</SAMP> if the
current exception chain does not have an exception of this
type.
</DD></DL>
<P>
<A NAME="vmemGetExceptionClass"><HR><H4>vmemGetExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vmemGetExceptionClass</B>();
</PRE>

<DL><DD>
Returns a pointer to the ``Memory'' exception class. This
class can be used to generate exceptions or define new
exception classes. Refer to the ``Types'' section of this
chapter.
</DD></DL>
<P>
<A NAME="vmemGetGroupTag"><HR><H4>vmemGetGroupTag</H4></A>
<PRE>
        const char * <B>vmemGetGroupTag</B>(
                vmemGroup * group);
</PRE>

<DL><DD>
Returns the <CODE>vmemTAG</CODE> that defines the group
<SAMP>group</SAMP>.
</DD></DL>
<P>
<A NAME="vmemGetGroupWithTag"><HR><H4>vmemGetGroupWithTag</H4></A>
<PRE>
        vmemGroup * <B>vmemGetGroupWithTag</B>(
                const char * tag);
</PRE>

<DL><DD>
Returns the <CODE><A HREF="vmem-x.html#vmemGroup"><CODE>vmemGroup</CODE></A></CODE> for the given tag. There
is no use for this function outside a
<CODE><A HREF="vmem-x.html#vmemMonitorProc"><CODE>vmemMonitorProc</CODE></A></CODE>. This function should only be
called when debugging is enabled.
</DD></DL>
<P>
<A NAME="vmemGetInvalidAlreadyFreedException"><HR><H4>vmemGetInvalidAlreadyFreedException</H4></A>
<PRE>
        vmemInvalidAlreadyFreedException * <B>vmemGetInvalidAlreadyFreedException</B>();
</PRE>

<DL><DD>
Returns a pointer to the first ``Memory Invalid Already
Freed'' exception in the current exception chain, or
<SAMP>NULL</SAMP> if the current exception chain does not
have an exception of this type. This function is only
available if debugging is enabled.
</DD></DL>
<P>
<A NAME="vmemGetInvalidAlreadyFreedExceptionClass"><HR><H4>vmemGetInvalidAlreadyFreedExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vmemGetInvalidAlreadyFreedExceptionClass</B>();
</PRE>

<DL><DD>
Returns a pointer to the ``Memory Invalid Already Freed''
exception class. This class can be used to generate
exceptions or define new exception classes. This function
is only available if debugging is enabled.
</DD></DL>
<P>
<A NAME="vmemGetInvalidBlock"><HR><H4>vmemGetInvalidBlock</H4></A>
<PRE>
        void * <B>vmemGetInvalidBlock</B>(
                const vmemInvalidException * exception);
</PRE>

<DL><DD>
Returns the pointer that was supposed to be a memory block
that caused the given exception. This function is only
available if debugging is enabled.
</DD></DL>
<P>
<A NAME="vmemGetInvalidException"><HR><H4>vmemGetInvalidException</H4></A>
<PRE>
        vmemInvalidException * <B>vmemGetInvalidException</B>();
</PRE>

<DL><DD>
Returns a pointer to the first ``Memory Invalid'' exception
in the current exception chain, or <SAMP>NULL</SAMP> if the
current exception chain does not have an exception of this
type. This function is only available if debugging is
enabled.
</DD></DL>
<P>
<A NAME="vmemGetInvalidExceptionClass"><HR><H4>vmemGetInvalidExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vmemGetInvalidExceptionClass</B>();
</PRE>

<DL><DD>
Returns a pointer to the ``Memory Invalid'' exception
class. This class can be used to generate exceptions or
define new exception classes. This function is only
available if debugging is enabled.
</DD></DL>
<P>
<A NAME="vmemGetMonitorEventBlock"><HR><H4>vmemGetMonitorEventBlock</H4></A>
<PRE>
        void * <B>vmemGetMonitorEventBlock</B>(
                vmemMonitorEvent * event);
</PRE>

<DL><DD>
Returns a pointer to the block that the event
<SAMP>event</SAMP> operated on, if the event code is one of:

<ul>
<li><CODE>vmemMONITOR_EVENT_ALLOC</CODE>
<li><CODE>vmemMONITOR_EVENT_FREE</CODE>
<li><CODE>vmemMONITOR_EVENT_REALLOC</CODE>. 
</ul>

<P>
If the event code
is <CODE>vmemMONITOR_EVENT_REALLOC</CODE>, the original
block can be retrieved with <CODE><A HREF="vmem-x.html#vmemGetMonitorEventOldBlock"><CODE>vmemGetMonitorEventOldBlock</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vmemGetMonitorEventCode"><HR><H4>vmemGetMonitorEventCode</H4></A>
<PRE>
        int <B>vmemGetMonitorEventCode</B>(
                vmemMonitorEvent * event);
</PRE>

<DL><DD>
Returns the <SAMP>MONITOR_EVENT</SAMP> constant for
<SAMP>event</SAMP>.
</DD></DL>
<P>
<A NAME="vmemGetMonitorEventFile"><HR><H4>vmemGetMonitorEventFile</H4></A>
<PRE>
        const char * <B>vmemGetMonitorEventFile</B>(
                vmemMonitorEvent * event);
</PRE>

<DL><DD>
--beReturnsthe
<P>
name
<P>
of
<P>
source
<P>
file
<P>
that
<P>
called
<P>
into
<P>
the
<P>
Memory
<P>

</DD></DL>
<P>
<A NAME="vmemGetMonitorEventGroup"><HR><H4>vmemGetMonitorEventGroup</H4></A>
<PRE>
        vmemGroup * <B>vmemGetMonitorEventGroup</B>(
                vmemMonitorEvent * event);
</PRE>

<DL><DD>
Returns the group that owns the memory acted on, if the
event code is one of:
 
<ul>
<li><CODE>vmemMONITOR_EVENT_ALLOC</CODE>,
<li><CODE>vmemMONITOR_EVENT_FREE</CODE>,
<li><CODE>vmemMONITOR_EVENT_REALLOC</CODE>, or the newly created group if the event code is
<CODE>vmemMONITOR_EVENT_NEW_GROUP</CODE>.
</ul>
</DD></DL>
<P>
<A NAME="vmemGetMonitorEventLine"><HR><H4>vmemGetMonitorEventLine</H4></A>
<PRE>
        int <B>vmemGetMonitorEventLine</B>(
                vmemMonitorEvent * event);
</PRE>

<DL><DD>
Returns the line in source file that called into the Memory class, 
if the event code is one of:

<ul>
<CODE>vmemMONITOR_EVENT_ALLOC</CODE>,
<CODE>vmemMONITOR_EVENT_FREE</CODE>,
<CODE>vmemMONITOR_EVENT_REALLOC</CODE>.
</UL>
</DD></DL>
<P>
<A NAME="vmemGetMonitorEventOldBlock"><HR><H4>vmemGetMonitorEventOldBlock</H4></A>
<PRE>
        void * <B>vmemGetMonitorEventOldBlock</B>(
                vmemMonitorEvent * event);
</PRE>

<DL><DD>
Returns a pointer to the block that was passed to
<CODE><A HREF="vmem-x.html#vmemRealloc"><CODE>vmemRealloc</CODE></A></CODE>, if the event code is
<CODE>vmemMONITOR_EVENT_REALLOC</CODE>. The new block
address can be found with
<CODE><A HREF="vmem-x.html#vmemGetMonitorEventBlock"><CODE>vmemGetMonitorEventBlock</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vmemGetMonitorEventOldSize"><HR><H4>vmemGetMonitorEventOldSize</H4></A>
<PRE>
        size_t <B>vmemGetMonitorEventOldSize</B>(
                vmemMonitorEvent * event);
</PRE>

<DL><DD>
Returns the size of the block that was passed to
<CODE><A HREF="vmem-x.html#vmemRealloc"><CODE>vmemRealloc</CODE></A></CODE>, if the event code is
<CODE>vmemMONITOR_EVENT_REALLOC</CODE>. This value is only
meaningful if the debugging flag
<CODE>vmemFLAG_USE_HEADER</CODE> is set. The new size of
the block passed to <CODE><A HREF="vmem-x.html#vmemRealloc"><CODE>vmemRealloc</CODE></A></CODE> can be found
with <CODE><A HREF="vmem-x.html#vmemGetMonitorEventSize"><CODE>vmemGetMonitorEventSize</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vmemGetMonitorEventSize"><HR><H4>vmemGetMonitorEventSize</H4></A>
<PRE>
        size_t <B>vmemGetMonitorEventSize</B>(
                vmemMonitorEvent * event);
</PRE>

<DL><DD>
Returns the size of the block that the event
<SAMP>event</SAMP> operated on, if the event code is one of:

<ul>
<li><CODE>vmemMONITOR_EVENT_ALLOC</CODE>
<li><CODE>vmemMONITOR_EVENT_FREE</CODE>
<li><CODE>vmemMONITOR_EVENT_REALLOC</CODE>. 
</ul>

<P>
If the debugging flag <CODE>vmemFLAG_USE_HEADER</CODE> is not set, 
then this value is not meaningful on the
<CODE>vmemMONITOR_EVENT_FREE</CODE> event. If the event
code is <CODE>vmemMONITOR_EVENT_REALLOC</CODE>, the
original size of the block passed to
<CODE><A HREF="vmem-x.html#vmemRealloc"><CODE>vmemRealloc</CODE></A></CODE> can be found with
<CODE><A HREF="vmem-x.html#vmemGetMonitorEventOldSize"><CODE>vmemGetMonitorEventOldSize</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vmemGetMoveException"><HR><H4>vmemGetMoveException</H4></A>
<PRE>
        vmemMoveException * <B>vmemGetMoveException</B>();
</PRE>

<DL><DD>
Returns a pointer to the first ``Memory Move'' exception in
the current exception chain, or <SAMP>NULL</SAMP> if the
current exception chain does not have an exception of this
type.
</DD></DL>
<P>
<A NAME="vmemGetMoveExceptionClass"><HR><H4>vmemGetMoveExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vmemGetMoveExceptionClass</B>();
</PRE>

<DL><DD>
Returns a pointer to the ``Memory Move'' exception class.
This class can be used to generate exceptions or define new
exception classes.
</DD></DL>
<P>
<A NAME="vmemGetMoveFrom"><HR><H4>vmemGetMoveFrom</H4></A>
<PRE>
        void * <B>vmemGetMoveFrom</B>(
                const vmemMoveException * exception);
</PRE>

<DL><DD>
Returns the source of the memory move that caused the given
exception.
</DD></DL>
<P>
<A NAME="vmemGetMoveSize"><HR><H4>vmemGetMoveSize</H4></A>
<PRE>
        size_t <B>vmemGetMoveSize</B>(
                const vmemMoveException * exception);
</PRE>

<DL><DD>
Returns the size of the memory move that caused the given
exception.
</DD></DL>
<P>
<A NAME="vmemGetMoveTo"><HR><H4>vmemGetMoveTo</H4></A>
<PRE>
        void * <B>vmemGetMoveTo</B>(
                const vmemMoveException * exception);
</PRE>

<DL><DD>
Returns the destination of the memory move that caused the
given exception.
</DD></DL>
<P>
<A NAME="vmemGetReallocBlock"><HR><H4>vmemGetReallocBlock</H4></A>
<PRE>
        void * <B>vmemGetReallocBlock</B>(
                const vmemReallocException * exception);
</PRE>

<DL><DD>
Returns the block being reallocated that caused the given
exception.
</DD></DL>
<P>
<A NAME="vmemGetReallocException"><HR><H4>vmemGetReallocException</H4></A>
<PRE>
        vmemReallocException * <B>vmemGetReallocException</B>();
</PRE>

<DL><DD>
Returns a pointer to the first ``Memory Realloc'' exception
in the current exception chain, or <SAMP>NULL</SAMP> if the
current exception chain does not have an exception of this
type.
</DD></DL>
<P>
<A NAME="vmemGetReallocExceptionClass"><HR><H4>vmemGetReallocExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vmemGetReallocExceptionClass</B>();
</PRE>

<DL><DD>
Returns a pointer to the ``Memory Realloc'' exception
class. This class can be used to generate exceptions or
define new exception classes.
</DD></DL>
<P>
<A NAME="vmemGetReallocSize"><HR><H4>vmemGetReallocSize</H4></A>
<PRE>
        size_t <B>vmemGetReallocSize</B>(
                const vmemReallocException * exception);
</PRE>

<DL><DD>
Returns the size of the attempted reallocation that caused
the given exception.
</DD></DL>
<P>
<A NAME="vmemGetValueAddress"><HR><H4>vmemGetValueAddress</H4></A>
<PRE>
        void * <B>vmemGetValueAddress</B>(
                const vmemValueException * exception);
</PRE>

<DL><DD>
Returns the corrupted address on the heap that caused the
exception.
</DD></DL>
<P>
<A NAME="vmemGetValueException"><HR><H4>vmemGetValueException</H4></A>
<PRE>
        vmemValueException * <B>vmemGetValueException</B>();
</PRE>

<DL><DD>
Returns a pointer to the first ``Memory Value'' exception
in the current exception chain, or <SAMP>NULL</SAMP> if the
current exception chain does not have an exception of this
type. This function is only available if debugging is
enabled.
</DD></DL>
<P>
<A NAME="vmemGetValueExceptionClass"><HR><H4>vmemGetValueExceptionClass</H4></A>
<PRE>
        const vexClass * <B>vmemGetValueExceptionClass</B>();
</PRE>

<DL><DD>
Returns a pointer to the ``Memory Value'' exception class.
This class can be used to generate exceptions or define new
exception classes. This function is only available if
debugging is enabled.
</DD></DL>
<P>
<A NAME="vmemGetValueSize"><HR><H4>vmemGetValueSize</H4></A>
<PRE>
        size_t <B>vmemGetValueSize</B>(
                const vmemValueException * exception);
</PRE>

<DL><DD>
Returns the size of the corrupted heap address that caused
a given exception.
</DD></DL>
<P>
<A NAME="vmemInvalidBLOCK"><HR><H4>vmemInvalidBLOCK</H4></A>
<PRE>
        void <B>vmemInvalidBLOCK</B>(
                void * exception,
                va_list * ap);
</PRE>

<DL><DD>
An exception tag of type <CODE><A HREF="vex-x.html#vexTag"><CODE>vexTag</CODE></A></CODE>, indicating
that the next argument in an exception generation call is a
pointer that addresses the base of an invalid block. This
tag can be used with <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> or
<CODE><A HREF="vex-x.html#vexPropagate"><CODE>vexPropagate</CODE></A></CODE> to store the invalid pointer in
the exception itself. This constant is only available when
debugging is enabled.
</DD></DL>
<P>
<A NAME="vmemIsValidBlock"><HR><H4>vmemIsValidBlock</H4></A>
<PRE>
        int <B>vmemIsValidBlock</B>(
                const void * address);
</PRE>

<DL><DD>
Returns <SAMP>FALSE</SAMP> if <SAMP>address</SAMP> is not a
valid block in the debugging Memory class. This function
is similar to <CODE><A HREF="vmem-x.html#vmemValidateBlock"><CODE>vmemValidateBlock</CODE></A></CODE>, but returns
the status rather than generating an exception.
</DD></DL>
<P>
<A NAME="vmemMonitorEvent"><HR><H4>vmemMonitorEvent</H4></A>
<PRE>
        void <B>vmemMonitorEvent</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vmemMove"><HR><H4>vmemMove</H4></A>
<PRE>
        void * <B>vmemMove</B>(
                const void * addressSource,
                void * addressTarget,
                size_t nBytes);
</PRE>

<DL><DD>
Copies each byte of the block of memory addressed by
<SAMP>addressSource</SAMP> to the block
<SAMP>addressTarget</SAMP>. The blocks are
<SAMP>nBytes</SAMP> bytes long. This function returns
<SAMP>addressSource</SAMP> as its result. The blocks need
not have been allocated by the Memory class. Calling this
function may be slower than calling <CODE><A HREF="vmem-x.html#vmemCopy"><CODE>vmemCopy</CODE></A></CODE>,
however correct behavior is guaranteed when the two blocks
overlap.
</DD></DL>
<P>
<A NAME="vmemMoveFROM"><HR><H4>vmemMoveFROM</H4></A>
<PRE>
        void <B>vmemMoveFROM</B>(
                void * exception,
                va_list * ap);
</PRE>

<DL><DD>
An exception tag of type <CODE><A HREF="vex-x.html#vexTag"><CODE>vexTag</CODE></A></CODE>, indicating
that the next argument in an exception generation call is a
pointer that addresses the source region of a failed memory
move. This tag can be used with <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> or
<CODE><A HREF="vex-x.html#vexPropagate"><CODE>vexPropagate</CODE></A></CODE> to store the source pointer of
the attempted move in the exception itself.
</DD></DL>
<P>
<A NAME="vmemMoveSIZE"><HR><H4>vmemMoveSIZE</H4></A>
<PRE>
        void <B>vmemMoveSIZE</B>(
                void * exception,
                va_list * ap);
</PRE>

<DL><DD>
An exception tag of type <CODE><A HREF="vex-x.html#vexTag"><CODE>vexTag</CODE></A></CODE>, indicating
that the next argument in an exception generation call is
an integer of type <SAMP>size_t</SAMP> that indicates the
size of a failed memory move. This tag can be used with
<CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> or <CODE><A HREF="vex-x.html#vexPropagate"><CODE>vexPropagate</CODE></A></CODE> to
store the size of the attempted move in the exception
itself.
</DD></DL>
<P>
<A NAME="vmemMoveTO"><HR><H4>vmemMoveTO</H4></A>
<PRE>
        void <B>vmemMoveTO</B>(
                void * exception,
                va_list * ap);
</PRE>

<DL><DD>
An exception tag of type <CODE><A HREF="vex-x.html#vexTag"><CODE>vexTag</CODE></A></CODE>, indicating
that the next argument in an exception generation call is a
pointer that addresses the destination region of a failed
memory move. This tag can be used with
<CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> or <CODE><A HREF="vex-x.html#vexPropagate"><CODE>vexPropagate</CODE></A></CODE> to
store the destination pointer of the attempted move in the
exception itself.
</DD></DL>
<P>
<A NAME="vmemRealloc"><HR><H4>vmemRealloc</H4></A>
<PRE>
        void * <B>vmemRealloc</B>(
                void * address,
                size_t nBytes);
</PRE>

<DL><DD>
Changes the size of the existing block of dynamic memory
addressed by <SAMP>address</SAMP> to <SAMP>nBytes</SAMP>
bytes and returns a pointer to the beginning of the block.
The pointer returned is different from <SAMP>address</SAMP>
if the block cannot be resized in place. When debugging is
enabled and the <CODE>vmemFLAG_MOVE_REALLOC</CODE>
debugging flag is set, the block never reallocates in
place. The block contents are preserved up to the smaller
of the old and new sizes.
<P>
If there is not enough memory available to satisfy the
request, the Memory class calls each registered
<CODE><A HREF="vmem-x.html#vmemFreeFunction"><CODE>vmemFreeFunction</CODE></A></CODE> to free memory until it can
satisfy the request. The order that the functions are
called is determined by the priority they were registered
with. If the request still cannot be satisfied, a
<CODE><A HREF="vmem-x.html#vmemReallocException"><CODE>vmemReallocException</CODE></A></CODE> is generated.
<P>
When debugging is enabled, this function calls
<CODE><A HREF="vmem-x.html#vmemValidateBlock"><CODE>vmemValidateBlock</CODE></A></CODE> to validate the block
contents. <CODE><A HREF="vmem-x.html#vmemValidateBlock"><CODE>vmemValidateBlock</CODE></A></CODE> generates
<CODE><A HREF="vmem-x.html#vmemBoundsException"><CODE>vmemBoundsException</CODE></A></CODE> if the block bounds have
been overwritten, <CODE><A HREF="vmem-x.html#vmemInvalidException"><CODE>vmemInvalidException</CODE></A></CODE> if the
block has not been allocated, and
<CODE><A HREF="vmem-x.html#vmemInvalidAlreadyFreedException"><CODE>vmemInvalidAlreadyFreedException</CODE></A></CODE> if the block
has been allocated and freed. When debugging is enabled,
calls to this function are replaced with calls to
<CODE><A HREF="vmem-x.html#vmemReallocDebug"><CODE>vmemReallocDebug</CODE></A></CODE> (passing it the ``site'' of
the allocation).
</DD></DL>
<P>
<A NAME="vmemReallocBLOCK"><HR><H4>vmemReallocBLOCK</H4></A>
<PRE>
        void <B>vmemReallocBLOCK</B>(
                void * exception,
                va_list * ap);
</PRE>

<DL><DD>
An exception tag of type <CODE><A HREF="vex-x.html#vexTag"><CODE>vexTag</CODE></A></CODE>, indicating
that the next argument in an exception generation call is a
pointer that addresses the original block of a failed
memory reallocation. This tag can be used with
<CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> or <CODE><A HREF="vex-x.html#vexPropagate"><CODE>vexPropagate</CODE></A></CODE> to
store the original pointer of the attempted reallocation in
the exception itself.
</DD></DL>
<P>
<A NAME="vmemReallocDebug"><HR><H4>vmemReallocDebug</H4></A>
<PRE>
        void * <B>vmemReallocDebug</B>(
                void * address,
                size_t nBytes,
                const char * tag,
                const char * file,
                int line);
</PRE>

<DL><DD>
Changes the size of the existing block of dynamic memory
addressed by <SAMP>address</SAMP> to <SAMP>nBytes</SAMP>
bytes and returns a pointer to the beginning of the block.
The arguments <SAMP>tag</SAMP>, <SAMP>file</SAMP>, and
<SAMP>line</SAMP> specify the ``site'' of the reallocation
for debugging purposes. <SAMP>tag</SAMP> is the tag of the
module reallocating the block (a <CODE>vmemTAG</CODE> from
somewhere), <SAMP>file</SAMP> is the source file that
contains the reallocation function call, and
<SAMP>line</SAMP> is the line number of the function call
within the source file.
<P>
The pointer returned is different from <SAMP>address</SAMP>
if the block cannot be resized in place. When the
<CODE>vmemFLAG_MOVE_REALLOC</CODE> debugging flag is set,
the block never reallocates in place. The block contents
are preserved up to the smaller of the old and new sizes.
<P>
If there is not enough memory available to satisfy the
request, the Memory class calls each registered
<CODE><A HREF="vmem-x.html#vmemFreeFunction"><CODE>vmemFreeFunction</CODE></A></CODE> to free memory until it can
satisfy the request. The order that the functions are
called is determined by the priority they were registered
with. If the request still cannot be satisfied, a
<CODE><A HREF="vmem-x.html#vmemReallocException"><CODE>vmemReallocException</CODE></A></CODE> is generated.
<P>
When debugging is enabled, this function calls
<CODE><A HREF="vmem-x.html#vmemValidateBlock"><CODE>vmemValidateBlock</CODE></A></CODE> to validate the block
contents. <CODE><A HREF="vmem-x.html#vmemValidateBlock"><CODE>vmemValidateBlock</CODE></A></CODE> generates
<CODE><A HREF="vmem-x.html#vmemBoundsException"><CODE>vmemBoundsException</CODE></A></CODE> if the block bounds have
been overwritten, <CODE><A HREF="vmem-x.html#vmemInvalidException"><CODE>vmemInvalidException</CODE></A></CODE> if the
block has not been allocated, and
<CODE><A HREF="vmem-x.html#vmemInvalidAlreadyFreedException"><CODE>vmemInvalidAlreadyFreedException</CODE></A></CODE> if the block
has been allocated and freed. When debugging is disabled,
calls to this function are replaced with calls to
<CODE>vmemRealloc</CODE> (discarding the ``site'' of the
allocation).
</DD></DL>
<P>
<A NAME="vmemReallocPtr"><HR><H4>vmemReallocPtr</H4></A>
<PRE>
        void <B>vmemReallocPtr</B>(
                void ** paddress,
                size_t nBytes);
</PRE>

<DL><DD>
Changes the size of the existing block of dynamic memory
specified by <SAMP>paddress</SAMP> to <SAMP>nBytes</SAMP>
bytes and modifies the address of the pointer if the address changes.
The address returned in <SAMP>padress</SAMP> is different
if the block cannot be resized in place.  This function is similar to
<CODE>vmemRealloc</CODE> except the address of the dynamic memory is
contained and returned in <SAMP>paddress</SAMP>.
</DD></DL>
<P>
<A NAME="vmemReallocPtrDebug"><HR><H4>vmemReallocPtrDebug</H4></A>
<PRE>
        void <B>vmemReallocPtrDebug</B>(
                void ** address,
                size_t nBytes,
                const char * tag,
                const char * file,
                int line);
</PRE>

<DL><DD>
Changes the size of the existing block of dynamic memory
specified by <SAMP>paddress</SAMP> to <SAMP>nBytes</SAMP>
bytes and modifies the address of the pointer if the address changes.
The address returned in <SAMP>padress</SAMP> is different
if the block cannot be resized in place.  This function is similar to
<CODE><A HREF="vmem-x.html#vmemReallocDebug"><CODE>vmemReallocDebug</CODE></A></CODE> except the address of the dynamic memory is
contained and returned in <SAMP>paddress</SAMP>.  The arguments 
<SAMP>tag</SAMP>, <SAMP>file</SAMP>, and
<SAMP>line</SAMP> specify the ``site'' of the reallocation
for debugging purposes. <SAMP>tag</SAMP> is the tag of the
module reallocating the block (a <CODE>vmemTAG</CODE> from
somewhere), <SAMP>file</SAMP> is the source file that
contains the reallocation function call, and
<SAMP>line</SAMP> is the line number of the function call
within the source file.
</DD></DL>
<P>
<A NAME="vmemReallocSIZE"><HR><H4>vmemReallocSIZE</H4></A>
<PRE>
        void <B>vmemReallocSIZE</B>(
                void * exception,
                va_list * ap);
</PRE>

<DL><DD>
An exception tag of type <CODE><A HREF="vex-x.html#vexTag"><CODE>vexTag</CODE></A></CODE>, indicating
that the next argument in an exception generation call is
an integer of type <SAMP>size_t</SAMP> that indicates the
size of a failed memory reallocation. This tag can be used
with <CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> or <CODE><A HREF="vex-x.html#vexPropagate"><CODE>vexPropagate</CODE></A></CODE>
to store the size of the attempted reallocation in the
exception itself.
</DD></DL>
<P>
<A NAME="vmemRegisterFreeFunction"><HR><H4>vmemRegisterFreeFunction</H4></A>
<PRE>
        void <B>vmemRegisterFreeFunction</B>(
                vmemFreeFunction fn,
                int priority);
</PRE>

<DL><DD>
Adds the function <SAMP>fn</SAMP> to the list of functions
to call when there is not enough available memory to
satisfy an allocation request. <SAMP>priority</SAMP> is one
of the PRIORITY constants.
</DD></DL>
<P>
<A NAME="vmemRegisterMonitorProc"><HR><H4>vmemRegisterMonitorProc</H4></A>
<PRE>
        void <B>vmemRegisterMonitorProc</B>(
                vmemMonitorProc monitorProc);
</PRE>

<DL><DD>
Adds <SAMP>monitorProc</SAMP> to a list of monitor
functions to be called when there is activity within the
Debugging Pool class.
</DD></DL>
<P>
<A NAME="vmemSet"><HR><H4>vmemSet</H4></A>
<PRE>
        void * <B>vmemSet</B>(
                void * address,
                int value,
                size_t nBytes);
</PRE>

<DL><DD>
Sets each byte in the block of memory addressed by
<SAMP>address</SAMP> to <SAMP>value</SAMP>. The block is
<SAMP>nBytes</SAMP> bytes long. This function returns
<SAMP>address</SAMP> as its result. The block need not have
been allocated by the Memory class.
</DD></DL>
<P>
<A NAME="vmemSetBlockFlag"><HR><H4>vmemSetBlockFlag</H4></A>
<PRE>
        void <B>vmemSetBlockFlag</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vmemSetDefaultDebuggingFlags"><HR><H4>vmemSetDefaultDebuggingFlags</H4></A>
<PRE>
        void <B>vmemSetDefaultDebuggingFlags</B>(
                unsigned int flags);
</PRE>

<DL><DD>
Changes the flags used by the debugging Memory class. If
<CODE>vmemFLAG_USE_HEADER</CODE> has already been added, it
must be included in flags, if it has not already been
added, it must not be included in flags. If flags are
inconsistent, this function makes them all consistent
(based on the existing value of
<CODE>vmemFLAG_USE_HEADER</CODE>). Refer to the section 
<CODE>vmemFLAG</CODE> for a list of constants.
</DD></DL>
<P>
<A NAME="vmemTryAlloc"><HR><H4>vmemTryAlloc</H4></A>
<PRE>
        void * <B>vmemTryAlloc</B>(
                size_t nBytes);
</PRE>

<DL><DD>
Tries to Allocate a block of dynamic memory of least
<SAMP>nBytes</SAMP> bytes and returns a pointer to the
beginning of the block. If space is not available to allocate the
requested number of bytes <SAMP>NULL</SAMP> is returned.
The pointer is aligned for any data
type. The contents of the block are deliberately randomized
by the Memory class if debugging is enabled and the
<CODE>vmemFLAG_RANDOMIZE_ALLOC</CODE> is set. Otherwise,
the block contents are not initialized in any way. The
block contains random garbage determined by the underlying
operating system.  This function is similar to <CODE><A HREF="vmem-x.html#vmemAlloc"><CODE>vmemAlloc</CODE></A></CODE>
except that this function will return <SAMP>NULL</SAMP> instead of
throwing an exception if adequate space is not available.
</DD></DL>
<P>
<A NAME="vmemTryAllocDebug"><HR><H4>vmemTryAllocDebug</H4></A>
<PRE>
        void * <B>vmemTryAllocDebug</B>(
                size_t nBytes,
                const char * tag,
                const char * file,
                int line);
</PRE>

<DL><DD>
Tries to Allocate a block of dynamic memory of least
<SAMP>nBytes</SAMP> bytes and returns a pointer to the
beginning of the block. If space is not available to allocate the
requested number of bytes <SAMP>NULL</SAMP> is returned.
The arguments <SAMP>tag</SAMP>, <SAMP>file</SAMP>,
and <SAMP>line</SAMP> specify the ``site'' of the
allocation for debugging purposes. <SAMP>tag</SAMP> is the
tag of the module allocating the block (a
<CODE>vmemTAG</CODE> from somewhere), <SAMP>file</SAMP> is
the source file that contains the allocation function call,
and <SAMP>line</SAMP> is the line number of the function
call within the source file. The pointer is aligned for any data
type. The contents of the block are deliberately randomized
by the Memory class if debugging is enabled and the
<CODE>vmemFLAG_RANDOMIZE_ALLOC</CODE> is set. Otherwise,
the block contents are not initialized in any way. The
block contains random garbage determined by the underlying
operating system.  This function is similar to <CODE><A HREF="vmem-x.html#vmemAllocDebug"><CODE>vmemAllocDebug</CODE></A></CODE>
except that this function will return <SAMP>NULL</SAMP> instead of
throwing an exception if adequate space is not available.
</DD></DL>
<P>
<A NAME="vmemTryRealloc"><HR><H4>vmemTryRealloc</H4></A>
<PRE>
        void * <B>vmemTryRealloc</B>(
                void * address,
                size_t nBytes);
</PRE>

<DL><DD>
Tries to change the size of the existing block of dynamic memory
addressed by <SAMP>address</SAMP> to <SAMP>nBytes</SAMP>
bytes and returns a pointer to the beginning of the block.  If space
is not available to return the requested number of bytes,
<SAMP>NULL</SAMP> is returned.
The pointer returned is different from <SAMP>address</SAMP>
if the block cannot be resized in place. When debugging is
enabled and the <CODE>vmemFLAG_MOVE_REALLOC</CODE>
debugging flag is set, the block never reallocates in
place. The block contents are preserved up to the smaller
of the old and new sizes.
</DD></DL>
<P>
<A NAME="vmemTryReallocDebug"><HR><H4>vmemTryReallocDebug</H4></A>
<PRE>
        void * <B>vmemTryReallocDebug</B>(
                void * address,
                size_t nBytes,
                const char * tag,
                const char * file,
                int line);
</PRE>

<DL><DD>
Tries to change the size of the existing block of dynamic memory
addressed by <SAMP>address</SAMP> to <SAMP>nBytes</SAMP>
bytes and returns a pointer to the beginning of the block.  If space
is not available to return the requested number of bytes,
<SAMP>NULL</SAMP> is returned.  The arguments <SAMP>tag</SAMP>, 
<SAMP>file</SAMP>, and <SAMP>line</SAMP> specify the ``site'' 
of the reallocation for debugging purposes. <SAMP>tag</SAMP> is the tag of the
module reallocating the block (a <CODE>vmemTAG</CODE> from
somewhere), <SAMP>file</SAMP> is the source file that
contains the reallocation function call, and
<SAMP>line</SAMP> is the line number of the function call
within the source file. The pointer returned is different 
from <SAMP>address</SAMP> if the block cannot be resized 
in place. When debugging is enabled and the <CODE>vmemFLAG_MOVE_REALLOC</CODE>
debugging flag is set, the block never reallocates in
place. The block contents are preserved up to the smaller
of the old and new sizes.
</DD></DL>
<P>
<A NAME="vmemUnregisterFreeFunction"><HR><H4>vmemUnregisterFreeFunction</H4></A>
<PRE>
        void <B>vmemUnregisterFreeFunction</B>(
                vmemFreeFunction fn,
                int priority);
</PRE>

<DL><DD>
Removes the function <SAMP>fn</SAMP> from the list of
functions to call if it occurs with the given priority.
<SAMP>priority</SAMP> is a <CODE>vmemPRIORITY</CODE>
constant, possibly bitwise ORed with a
<SAMP>PRIORITY_MODIFIER</SAMP> constant.
</DD></DL>
<P>
<A NAME="vmemUnregisterMonitorProc"><HR><H4>vmemUnregisterMonitorProc</H4></A>
<PRE>
        void <B>vmemUnregisterMonitorProc</B>(
                vmemMonitorProc monitorProc);
</PRE>

<DL><DD>
Removes the function <SAMP>monitorProc</SAMP> from list of
monitor functions to be called when there is activity
within the debugging Memory class.
</DD></DL>
<P>
<A NAME="vmemValidateBlock"><HR><H4>vmemValidateBlock</H4></A>
<PRE>
        void <B>vmemValidateBlock</B>(
                const void * address);
</PRE>

<DL><DD>
Verifies that the block of memory addressed by
<SAMP>address</SAMP> is a pointer to the block of dynamic
memory allocated by the Memory clas. This function does
nothing if the block is indeed valid. This function
generates <CODE><A HREF="vmem-x.html#vmemBoundsException"><CODE>vmemBoundsException</CODE></A></CODE> if the block
bounds have been overwritten,
<CODE><A HREF="vmem-x.html#vmemInvalidException"><CODE>vmemInvalidException</CODE></A></CODE> if the block has not been
allocated, and
<CODE><A HREF="vmem-x.html#vmemInvalidAlreadyFreedException"><CODE>vmemInvalidAlreadyFreedException</CODE></A></CODE> if the block
has been allocated and freed. This function is not
available if debugging is disabled.
</DD></DL>
<P>
<A NAME="vmemValidateBlockDebug"><HR><H4>vmemValidateBlockDebug</H4></A>
<PRE>
        void <B>vmemValidateBlockDebug</B>(
                const void * address,
                const char * tag,
                const char * file,
                int line);
</PRE>

<DL><DD>
Another form of <CODE>vmemValidateBlock</CODE>, which uses
file/line in the exception generated (if any exception is
generated). <SAMP>tag</SAMP> should be the same tag that
allocated the block.
</DD></DL>
<P>
<A NAME="vmemValueADDRESS"><HR><H4>vmemValueADDRESS</H4></A>
<PRE>
        void <B>vmemValueADDRESS</B>(
                void * exception,
                va_list * ap);
</PRE>

<DL><DD>
An exception tag of type <CODE><A HREF="vex-x.html#vexTag"><CODE>vexTag</CODE></A></CODE>, indicating
that the next argument in an exception generation call is a
pointer of type <SAMP>void</SAMP> that indicates a pointer
to the corrupted heap value. This tag can be used with
<CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> or <CODE><A HREF="vex-x.html#vexPropagate"><CODE>vexPropagate</CODE></A></CODE> to
store the size of the attempted reallocation in the
exception itself.
</DD></DL>
<P>
<A NAME="vmemValueException"><HR><H4>vmemValueException</H4></A>
<PRE>
        void <B>vmemValueException</B>();
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vmemValueSIZE"><HR><H4>vmemValueSIZE</H4></A>
<PRE>
        void <B>vmemValueSIZE</B>(
                void * exception,
                va_list * ap);
</PRE>

<DL><DD>
An exception tag of type <CODE><A HREF="vex-x.html#vexTag"><CODE>vexTag</CODE></A></CODE>, indicating
that the next argument in an exception generation call is
an integer of type <SAMP>size_t</SAMP> that indicates the
size of the corrupted heap value. This tag can be used with
<CODE><A HREF="vex-x.html#vexGenerate"><CODE>vexGenerate</CODE></A></CODE> or <CODE><A HREF="vex-x.html#vexPropagate"><CODE>vexPropagate</CODE></A></CODE> to
store the size of the attempted reallocation in the
exception itself.
</DD></DL>
<P>
<A NAME="section_Constant"><HR>
<CENTER><H2>Constants</H2></CENTER></A><P>
<A NAME="vmemALL_TAG"><HR><H4>vmemALL_TAG</H4></A>
<PRE>
        <B>vmemALL_TAG</B>
</PRE>

<DL><DD>
A string literal constant that is the <CODE>vmemTAG</CODE>
to the group that represents the application as a whole. It
should not be used as a tag to the Memory class debug
functions.
</DD></DL>
<P>
<A NAME="vmemBALANCE"><HR><H4>vmemBALANCE</H4></A>
<PRE>
        <B>vmemBALANCE</B>
</PRE>

<DL><DD>
A preprocessor directive that is <SAMP>TRUE</SAMP> when
memory balancing is enabled by compile-time switches, or
<SAMP>FALSE</SAMP> when memory balancing is disabled. This
constant is set by default to the value of
<CODE>vmemDEBUG</CODE>. 
<P>
Memory balancing is typically
useful for cleaning up global memory after the application
exists so that those values do not appear in the leak
reports generated by the debugging Memory class. This is
often done within libraries by registering a shutdown
function with the Client class, such as
<CODE><A HREF="vclient-x.html#vclientRegisterShutdown"><CODE>vclientRegisterShutdown</CODE></A></CODE>. 
<P>

Take care to <I>not</I> call into other modules from within the shutdown
function that may have already shutdown themselves.
Applications typically clean up between returning from
<CODE><A HREF="vevent-x.html#veventProcess"><CODE>veventProcess</CODE></A></CODE> and calling <SAMP>exit</SAMP>.
Since the operating system normally reclaims the memory
when the application exists, this cleanup code is not
needed for non-debugging execution and is not compiled. You
should test this flag to determine if you need to free
blocks just to satisfy memory balancing.
</DD></DL>
<P>
<A NAME="vmemDEBUG"><HR><H4>vmemDEBUG</H4></A>
<PRE>
        <B>vmemDEBUG</B>
</PRE>

<DL><DD>
Preprocessor directive that is <SAMP>TRUE</SAMP> when
memory debugging is enabled, or <SAMP>FALSE</SAMP> when
memory debugging is disabled. Many Memory class functions
have debugging as well as non-debugging forms. This flag
indicates whether to use the debugging forms as the
standard entry points or not. For example,
<CODE><A HREF="vmem-x.html#vmemAlloc"><CODE>vmemAlloc</CODE></A></CODE> calls <CODE><A HREF="vmem-x.html#vmemAllocDebug"><CODE>vmemAllocDebug</CODE></A></CODE>
when this flag is <SAMP>TRUE</SAMP>. This flag is also
checked by higher-level modules (String class and Class
class, for example) that have memory debugging functions.
<P>
The value of this flag is set by default to the value of
<CODE>vdebugDEBUG</CODE>. It should not be modified.
</DD></DL>
<P>
<A NAME="vmemDEFAULT_DEBUGGING_FLAGS_ENVIRONMENT_VARIABLE"><HR><H4>vmemDEFAULT_DEBUGGING_FLAGS_ENVIRONMENT_VARIABLE</H4></A>
<PRE>
        <B>vmemDEFAULT_DEBUGGING_FLAGS_ENVIRONMENT_VARIABLE</B>
</PRE>

<DL><DD>
Environment variable checked for default <SAMP>FLAG</SAMP>
constants used by the debugging Memory class. If the
environment variable is not found, all the flags are
assumed to be set. The actual environment variable is the
string literal <SAMP>vmemFLAGS</SAMP>. The value of this
environment variable can be specified in decimal, octal, or
hexadecimal. This value can be overridden by
<CODE><A HREF="vmem-x.html#vmemSetDefaultDebuggingFlags"><CODE>vmemSetDefaultDebuggingFlags</CODE></A></CODE>. If overridden,
the <CODE>vmemFLAG_USE_HEADER</CODE> and
<CODE>vmemFLAG_USE_OVERWRITE</CODE> flags cannot change if
any memory has been allocated.
</DD></DL>
<P>
<A NAME="vmemFLAG_MONITOR_LEAKS"><HR><H4>vmemFLAG_MONITOR_LEAKS</H4></A>
<PRE>
        <B>vmemFLAG_MONITOR_LEAKS</B>
</PRE>

<DL><DD>
When this flag is set in
<CODE><A HREF="vmem-x.html#vmemSetDefaultDebuggingFlags"><CODE>vmemSetDefaultDebuggingFlags</CODE></A></CODE>, the debugging
Memory class outputs memory blocks still allocated after
the shutdown hooks are called when the program terminates.
Refer to the section <CODE><A HREF="vclient-x.html#vclientRegisterShutdown"><CODE>vclientRegisterShutdown</CODE></A></CODE> for information
about registering a shutdown hook. This flag can only be
set if <CODE>vmemFLAG_USE_HEADER</CODE> is also set.
</DD></DL>
<P>
<A NAME="vmemFLAG_MOVE_REALLOC"><HR><H4>vmemFLAG_MOVE_REALLOC</H4></A>
<PRE>
        <B>vmemFLAG_MOVE_REALLOC</B>
</PRE>

<DL><DD>
When this flag is set in
<CODE><A HREF="vmem-x.html#vmemSetDefaultDebuggingFlags"><CODE>vmemSetDefaultDebuggingFlags</CODE></A></CODE>, the debugging
Memory class always moves memory when reallocating in
<CODE><A HREF="vmem-x.html#vmemRealloc"><CODE>vmemRealloc</CODE></A></CODE>. This flag can only be set if
<CODE>vmemFLAG_USE_HEADER</CODE> is also set.
</DD></DL>
<P>
<A NAME="vmemFLAG_RANDOMIZE_ALLOC"><HR><H4>vmemFLAG_RANDOMIZE_ALLOC</H4></A>
<PRE>
        <B>vmemFLAG_RANDOMIZE_ALLOC</B>
</PRE>

<DL><DD>
When this flag is set in
<CODE><A HREF="vmem-x.html#vmemSetDefaultDebuggingFlags"><CODE>vmemSetDefaultDebuggingFlags</CODE></A></CODE>, the debugging
Memory class initializes memory with random values.
</DD></DL>
<P>
<A NAME="vmemFLAG_RANDOMIZE_FREE"><HR><H4>vmemFLAG_RANDOMIZE_FREE</H4></A>
<PRE>
        <B>vmemFLAG_RANDOMIZE_FREE</B>
</PRE>

<DL><DD>
When this flag is set in
<CODE><A HREF="vmem-x.html#vmemSetDefaultDebuggingFlags"><CODE>vmemSetDefaultDebuggingFlags</CODE></A></CODE>, the debugging
Memory class clears memory with random values before
freeing. This flag can only be set if
<CODE>vmemFLAG_USE_HEADER</CODE> is also set.
</DD></DL>
<P>
<A NAME="vmemFLAG_USE_HEADER"><HR><H4>vmemFLAG_USE_HEADER</H4></A>
<PRE>
        <B>vmemFLAG_USE_HEADER</B>
</PRE>

<DL><DD>
When this flag is set in
<CODE><A HREF="vmem-x.html#vmemSetDefaultDebuggingFlags"><CODE>vmemSetDefaultDebuggingFlags</CODE></A></CODE>, the debugging
Memory class associates a header with each block that is
allocated. This header is necessary for much of the
debugging functionality. The main reason to choose to omit
the header is to disable interference with other tools
(such as Purify) that might view the header as part of the
allocated block and disregard any errors that might occur
from accidently accessing the memory within the header.
</DD></DL>
<P>
<A NAME="vmemFLAG_USE_OVERWRITE"><HR><H4>vmemFLAG_USE_OVERWRITE</H4></A>
<PRE>
        <B>vmemFLAG_USE_OVERWRITE</B>
</PRE>

<DL><DD>
When this flag is set in
<CODE><A HREF="vmem-x.html#vmemSetDefaultDebuggingFlags"><CODE>vmemSetDefaultDebuggingFlags</CODE></A></CODE>, the debugging
Memory class maintains a buffer immediately before and
after the blocks it allocates to check for accidental
memory writes beyond the allocated bounds. The buffer is
checked in calls to <CODE><A HREF="vmem-x.html#vmemRealloc"><CODE>vmemRealloc</CODE></A></CODE> and
<CODE><A HREF="vmem-x.html#vmemFree"><CODE>vmemFree</CODE></A></CODE>. This flag can only be set if
<CODE>vmemFLAG_USE_HEADER</CODE> is also set.
<P>
When this flag is not set, and block headers are used, the
underwrite buffer is still allocated but not written or
cleared. The effect of this is that products that check for
writes into unallocated memory will not detect a problem,
but products that check for uninitialized reads will
(unless the write occurs first).
</DD></DL>
<P>
<A NAME="vmemHEADER"><HR><H4>vmemHEADER</H4></A>
<PRE>
        <B>vmemHEADER</B>
</PRE>

<DL><DD>
Defined when the header file vmem.h is included.
</DD></DL>
<P>
<A NAME="vmemINCLUDED"><HR><H4>vmemINCLUDED</H4></A>
<PRE>
        <B>vmemINCLUDED</B>
</PRE>

<DL><DD>
Defined when the header file <SAMP>vmem.h</SAMP> is
included.
</DD></DL>
<P>
<A NAME="vmemMONITOR_EVENT_ALLOC"><HR><H4>vmemMONITOR_EVENT_ALLOC</H4></A>
<PRE>
        <B>vmemMONITOR_EVENT_ALLOC</B>
</PRE>

<DL><DD>
Denotes the code of the event sent to
<CODE><A HREF="vmem-x.html#vmemMonitorProc"><CODE>vmemMonitorProc</CODE></A></CODE> after an allocation occurs
within <CODE><A HREF="vmem-x.html#vmemAlloc"><CODE>vmemAlloc</CODE></A></CODE> or
<CODE><A HREF="vmem-x.html#vmemAllocAndClear"><CODE>vmemAllocAndClear</CODE></A></CODE> and debugging is enabled, or
the allocation in <CODE><A HREF="vmem-x.html#vmemRealloc"><CODE>vmemRealloc</CODE></A></CODE> when it is
passed a <SAMP>NULL</SAMP> pointer and debugging is
enabled.
</DD></DL>
<P>
<A NAME="vmemMONITOR_EVENT_FREE"><HR><H4>vmemMONITOR_EVENT_FREE</H4></A>
<PRE>
        <B>vmemMONITOR_EVENT_FREE</B>
</PRE>

<DL><DD>
Denotes the code of the event sent to
<CODE><A HREF="vmem-x.html#vmemMonitorProc"><CODE>vmemMonitorProc</CODE></A></CODE> before memory is freed in
<CODE><A HREF="vmem-x.html#vmemFree"><CODE>vmemFree</CODE></A></CODE> and debugging is enabled.
</DD></DL>
<P>
<A NAME="vmemMONITOR_EVENT_NEW_GROUP"><HR><H4>vmemMONITOR_EVENT_NEW_GROUP</H4></A>
<PRE>
        <B>vmemMONITOR_EVENT_NEW_GROUP</B>
</PRE>

<DL><DD>
Denotes the code of the event sent to
<CODE><A HREF="vmem-x.html#vmemMonitorProc"><CODE>vmemMonitorProc</CODE></A></CODE> when a new
<CODE><A HREF="vmem-x.html#vmemGroup"><CODE>vmemGroup</CODE></A></CODE> is created. New groups are created
each time a <CODE>vmemTAG</CODE> is seen for the first
time.
</DD></DL>
<P>
<A NAME="vmemMONITOR_EVENT_REALLOC"><HR><H4>vmemMONITOR_EVENT_REALLOC</H4></A>
<PRE>
        <B>vmemMONITOR_EVENT_REALLOC</B>
</PRE>

<DL><DD>
Denotes the code of the event sent to
<CODE><A HREF="vmem-x.html#vmemMonitorProc"><CODE>vmemMonitorProc</CODE></A></CODE> after the <SAMP>realloc</SAMP>
occurs and debugging is enabled.
</DD></DL>
<P>
<A NAME="vmemMONITOR_EVENT_START"><HR><H4>vmemMONITOR_EVENT_START</H4></A>
<PRE>
        <B>vmemMONITOR_EVENT_START</B>
</PRE>

<DL><DD>
Denotes the code of the event sent to
<CODE><A HREF="vmem-x.html#vmemMonitorProc"><CODE>vmemMonitorProc</CODE></A></CODE> when the monitor is registered
with <CODE><A HREF="vmem-x.html#vmemRegisterMonitorProc"><CODE>vmemRegisterMonitorProc</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vmemMONITOR_EVENT_STOP"><HR><H4>vmemMONITOR_EVENT_STOP</H4></A>
<PRE>
        <B>vmemMONITOR_EVENT_STOP</B>
</PRE>

<DL><DD>
Denotes the code of the event sent to
<CODE><A HREF="vmem-x.html#vmemMonitorProc"><CODE>vmemMonitorProc</CODE></A></CODE> when the monitoring is
unregistered with <CODE><A HREF="vmem-x.html#vmemUnregisterMonitorProc"><CODE>vmemUnregisterMonitorProc</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vmemPRIORITY_EMERGENCY"><HR><H4>vmemPRIORITY_EMERGENCY</H4></A>
<PRE>
        <B>vmemPRIORITY_EMERGENCY</B>
</PRE>

<DL><DD>
Denotes the priority of a <CODE><A HREF="vmem-x.html#vmemFreeFunction"><CODE>vmemFreeFunction</CODE></A></CODE>.
This is the highest priority, appropriate for making
desperate attempts to make more memory available. It is the
last group of functions to be called when the Memory
class asks the application to free memory.
</DD></DL>
<P>
<A NAME="vmemPRIORITY_GARBAGE"><HR><H4>vmemPRIORITY_GARBAGE</H4></A>
<PRE>
        <B>vmemPRIORITY_GARBAGE</B>
</PRE>

<DL><DD>
Denotes the priority of a <CODE><A HREF="vmem-x.html#vmemFreeFunction"><CODE>vmemFreeFunction</CODE></A></CODE>.
This is the lowest priority, appropriate for garbage
collection. It is the first group of functions to be called
when the Memory class asks the application to free
memory.
</DD></DL>
<P>
<A NAME="vmemPRIORITY_MAJOR_USER_VISIBLE"><HR><H4>vmemPRIORITY_MAJOR_USER_VISIBLE</H4></A>
<PRE>
        <B>vmemPRIORITY_MAJOR_USER_VISIBLE</B>
</PRE>

<DL><DD>
Denotes the priority of a <CODE><A HREF="vmem-x.html#vmemFreeFunction"><CODE>vmemFreeFunction</CODE></A></CODE>.
This is higher than
<CODE>vmemPRIORITY_MINOR_USER_VISIBLE</CODE> but lower than
<CODE>vmemPRIORITY_EMERGENCY</CODE>.
</DD></DL>
<P>
<A NAME="vmemPRIORITY_MINOR_USER_VISIBLE"><HR><H4>vmemPRIORITY_MINOR_USER_VISIBLE</H4></A>
<PRE>
        <B>vmemPRIORITY_MINOR_USER_VISIBLE</B>
</PRE>

<DL><DD>
Denotes the priority of a <CODE><A HREF="vmem-x.html#vmemFreeFunction"><CODE>vmemFreeFunction</CODE></A></CODE>.
This is higher than <CODE>vmemPRIORITY_PERFORMANCE</CODE>
but lower than
<CODE>vmemPRIORITY_MAJOR_USER_VISIBLE</CODE>.
</DD></DL>
<P>
<A NAME="vmemPRIORITY_MODIFIER_HIGH"><HR><H4>vmemPRIORITY_MODIFIER_HIGH</H4></A>
<PRE>
        <B>vmemPRIORITY_MODIFIER_HIGH</B>
</PRE>

<DL><DD>
When bitwise-ORed with a <CODE><A HREF="vmem-x.html#vmemFreeFunction"><CODE>vmemFreeFunction</CODE></A></CODE>
priority value, the priority is raised by one-third of a
level.
</DD></DL>
<P>
<A NAME="vmemPRIORITY_MODIFIER_LOW"><HR><H4>vmemPRIORITY_MODIFIER_LOW</H4></A>
<PRE>
        <B>vmemPRIORITY_MODIFIER_LOW</B>
</PRE>

<DL><DD>
When bitwise-ORed with a <CODE><A HREF="vmem-x.html#vmemFreeFunction"><CODE>vmemFreeFunction</CODE></A></CODE>
priority value, the priority is lowered by one third of a
level.
</DD></DL>
<P>
<A NAME="vmemPRIORITY_PERFORMANCE"><HR><H4>vmemPRIORITY_PERFORMANCE</H4></A>
<PRE>
        <B>vmemPRIORITY_PERFORMANCE</B>
</PRE>

<DL><DD>
Denotes the priority of a <CODE><A HREF="vmem-x.html#vmemFreeFunction"><CODE>vmemFreeFunction</CODE></A></CODE>.
This is higher than <CODE>vmemPRIORITY_GARBAGE</CODE> but
lower than <CODE>vmemPRIORITY_MINOR_USER_VISIBLE</CODE>. It
is appropriate for caches that were created for performance
tradeoffs.
</DD></DL>
<P>
<A NAME="vmemTAG"><HR><H4>vmemTAG</H4></A>
<PRE>
        <B>vmemTAG</B>
</PRE>

<DL><DD>
Denotes a string literal constant that contains the name of
the module being compiled when memory debugging is enabled
(see <CODE>vmemDEBUG</CODE>). Calls to debugging versions
of memory allocation functions pass this tag as an implicit
argument. The memory debugging function then records the
tag of the module that allocated the block in the block
header. This information may be used later if a problem is
encountered with the block (a corruption or leak, for
example). <CODE>vmemTAG</CODE> is set by default to
<CODE>vdebugTAG</CODE>. 
<P>
The default value can be changed
using <SAMP>#define</SAMP> <CODE>vmemTAG</CODE> either
before or after including <SAMP>vmem.h</SAMP>.
</DD></DL>
<P>
<A NAME="section_Macro"><HR>
<CENTER><H2>Macros</H2></CENTER></A><P>
<A NAME="vmemSetBlockFlag"><HR><H4>vmemSetBlockFlag</H4></A>
<PRE>
        #define <B>vmemSetBlockFlag</B>(...) ...
</PRE>

<DL><DD>

</DD></DL>
<P>

<P>
<!--[[/CONTENT]]-->

<HR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">
		<TD>
		<CENTER>
<!--[[NAVIGATE_ICONIC]]-->
<!--[[/NAVIGATE_ICONIC]]-->
		</CENTER>
		</TD>
		    
		<TD>
		<BR>
		<FONT SIZE=-1>
	        <A HREF="#Top">Top of This Page</A> <BR>
	        <A HREF="index.html">Table of Contents</A> <BR>
		<A HREF="../index.html">Switch to Another Document</A><BR>
		<BR>
		</FONT>
		</TD>

		<TD>
		<BR>
		<FONT SIZE=-1>
		Need help?
		<A HREF="../contact-visix.html">
		Contact Visix</A>.
		<BR> <BR>
	        <A HREF="../copyright.html">Copyright &#169; 1996-97</A>,
		<A HREF="http://www.visix.com/">Visix Software Inc.</A><BR>
		<BR>
		</FONT>
		</TD>

	</TR>

</TABLE>
		
</BODY>
</HTML>



