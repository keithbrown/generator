<HTML>
  <HEAD>
<!--[[HEADING]]-->
<title>vdict prefix</title><!--[[/HEADING]]-->
  </HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<A NAME="Top"><IMG SRC="../graphics/trans.gif" WIDTH=2 HEIGHT=2></A><BR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">

		<TD>
		<CENTER>
		<A HREF="../index.html">
		<IMG SRC="../graphics/logo.gif" BORDER=0></A>
		</CENTER>
		</TD>

	        <TD VALIGN=TOP>
	        <BR><H1>
<!--[[TITLE]]-->
vdict prefix<!--[[/TITLE]]-->
	        </H1><BR>
		</TD>
      
	</TR>

</TABLE>

<HR>

<BR>

<!--[[PREAMBLE]]-->
<TABLE>
<TR>
<TD><A HREF="vdict-x.html#section_DataType">Types</A> [4]</TD>
<TD><A HREF="vdict-x.html#section_Function">Functions</A> [55]</TD>
<TD></TD>
<TD><A HREF="vdict-x.html#section_Constant">Constants</A> [3]</TD>
<TD></TD>
</TR>
</TABLE>
<!--[[/PREAMBLE]]-->

<!--[[CONTENT]]-->

<P>
<A NAME="section_DataType"><HR>
<CENTER><H2>Types</H2></CENTER></A><P>
<A NAME="vdict"><HR><H4>vdict</H4></A>
<PRE>
        typedef ... <B>vdict</B>;
</PRE>

<DL><DD>
Represents a single dictionary object. Dictionaries are
referenced by a pointer to this type. Dictionaries can be
created dynamically with <CODE><A HREF="vdict-x.html#vdictCreate"><CODE>vdictCreate</CODE></A></CODE> or
initialized statically with <CODE><A HREF="vdict-x.html#vdictInit"><CODE>vdictInit</CODE></A></CODE>. A
<CODE>vdict</CODE> contains a set of key/value pairs and a
set of attributes that control the size and key
distribution of its hash table.
</DD></DL>
<P>
<A NAME="vdictIterator"><HR><H4>vdictIterator</H4></A>
<PRE>
        typedef ... <B>vdictIterator</B>;
</PRE>

<DL><DD>
Denotes an abstract pointer variable used to enumerate the
contents of a dictionary. Any given iterator refers to a
particular key/value pair in a particular dictionary. An
iterator will behave correctly only if it is used with the
dictionary that it was initialized with. An iterator
becomes invalid if the dictionary that it references is
modified in any way; for example, removing an element from
a dictionary will modify the dictionary and thus should not
be done during iteration. Iterators are normally declared
as automatic variables of a function and are initialized
with <CODE><A HREF="vdict-x.html#vdictInitIterator"><CODE>vdictInitIterator</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdictKeyIterator"><HR><H4>vdictKeyIterator</H4></A>
<PRE>
        typedef ... <B>vdictKeyIterator</B>;
</PRE>

<DL><DD>

</DD></DL>
<P>
<A NAME="vdictSafe"><HR><H4>vdictSafe</H4></A>
<PRE>
        typedef ... <B>vdictSafe</B>;
</PRE>

<DL><DD>
Threadsafe version of <CODE>vdict</CODE>.  If the a mutex is assigned to a
<CODE>vdictSafe</CODE> with <CODE><A HREF="vdict-x.html#vdictSetSafeMutex"><CODE>vdictSetSafeMutex</CODE></A></CODE>, it can be 
safely accessed and modified simultaneously from multiple threads.  
    <P>
NOTE: if no mutex is assigned to the dictionary, it is _not_ threadsafe.
</DD></DL>
<P>
<A NAME="section_Function"><HR>
<CENTER><H2>Functions</H2></CENTER></A><P>
<A NAME="vdictAdd"><HR><H4>vdictAdd</H4></A>
<PRE>
        void <B>vdictAdd</B>(
                vdict * dict,
                const void * key,
                const void * value);
</PRE>

<DL><DD>

Adds a value in a dictionary under a key pointer, without replacing
any previous values stored under the key.  To retrieve multiple values
stored under the same key, use a <CODE><A HREF="vdict-x.html#vdictKeyIterator"><CODE>vdictKeyIterator</CODE></A></CODE>.  If
there are multiple values stored under the same key, using
<CODE><A HREF="vdict-x.html#vdictLoad"><CODE>vdictLoad</CODE></A></CODE> on the key will return one of the values;
however it is unspecified which one it will be.

</DD></DL>
<P>
<A NAME="vdictAddFloat"><HR><H4>vdictAddFloat</H4></A>
<PRE>
        void <B>vdictAddFloat</B>(
                vdict * dict,
                const void * key,
                double value);
</PRE>

<DL><DD>

Adds a value in a dictionary under a key pointer, without replacing
any previous values stored under the key.  To retrieve multiple values
stored under the same key, use a <CODE><A HREF="vdict-x.html#vdictKeyIterator"><CODE>vdictKeyIterator</CODE></A></CODE>.  If
there are multiple values stored under the same key, using
<CODE><A HREF="vdict-x.html#vdictLoad"><CODE>vdictLoad</CODE></A></CODE> on the key will return one of the values;
however it is unspecified which one it will be.

</DD></DL>
<P>
<A NAME="vdictAddScalar"><HR><H4>vdictAddScalar</H4></A>
<PRE>
        void <B>vdictAddScalar</B>(
                vdict * dict,
                const void * key,
                long value);
</PRE>

<DL><DD>

Adds a value in a dictionary under a key pointer, without replacing
any previous values stored under the key.  To retrieve multiple values
stored under the same key, use a <CODE><A HREF="vdict-x.html#vdictKeyIterator"><CODE>vdictKeyIterator</CODE></A></CODE>.  If
there are multiple values stored under the same key, using
<CODE><A HREF="vdict-x.html#vdictLoad"><CODE>vdictLoad</CODE></A></CODE> on the key will return one of the values;
however it is unspecified which one it will be.

</DD></DL>
<P>
<A NAME="vdictClone"><HR><H4>vdictClone</H4></A>
<PRE>
        vdict * <B>vdictClone</B>(
                vdict * dict);
</PRE>

<DL><DD>
Creates a copy of the dictionary <SAMP>dict</SAMP> and
returns a pointer to its contents. The Dictionary Manager
allocates space to store the dictionary structure; this
space will be freed when the dictionary is destroyed with
<CODE><A HREF="vdict-x.html#vdictDestroy"><CODE>vdictDestroy</CODE></A></CODE>. This function copies references
to all the key/value pairs in <SAMP>dict</SAMP>, but the
contents addressed by the key/value pointers are <I>not</I>
copied. This function copies the <CODE>HashFunc</CODE>,
<CODE>HashSize</CODE>, and <CODE>HashDensity</CODE>
attributes of <SAMP>dict</SAMP>. This function essentially
allocates space for a new dictionary and calls
<CODE><A HREF="vdict-x.html#vdictCopyInit"><CODE>vdictCopyInit</CODE></A></CODE> on it.
</DD></DL>
<P>
<A NAME="vdictCopy"><HR><H4>vdictCopy</H4></A>
<PRE>
        void <B>vdictCopy</B>(
                vdict * dict,
                vdict * target);
</PRE>

<DL><DD>
Copies all the key/value pointers from the dictionary
<SAMP>dict</SAMP> into the dictionary <SAMP>target</SAMP>.
<SAMP>target</SAMP> is expanded, if necessary. No keys in
<SAMP>target</SAMP> are removed, but value pointers in
<SAMP>target</SAMP> are replaced by value pointers from
<SAMP>dict</SAMP> if their keys are the same.
<SAMP>target</SAMP> must have been created or initialized
by a Dictionary Manager function. The dictionaries can be
dynamic or static. This function does <I>not</I> copy the
<CODE>HashFunc</CODE>, <CODE>HashSize</CODE>, or
<CODE>HashDensity</CODE> attributes of <SAMP>dict</SAMP>.
</DD></DL>
<P>
<A NAME="vdictCopyInit"><HR><H4>vdictCopyInit</H4></A>
<PRE>
        void <B>vdictCopyInit</B>(
                vdict * dict,
                vdict * target);
</PRE>

<DL><DD>
Initializes a copy of the dictionary <SAMP>dict</SAMP> in
the uninitialized memory addressed by <SAMP>target</SAMP>.
If <SAMP>target</SAMP> is destroyed with
<CODE><A HREF="vdict-x.html#vdictDestroy"><CODE>vdictDestroy</CODE></A></CODE>, the Dictionary Manager frees any
storage it allocated internally, but it does not attempt to
free <SAMP>target</SAMP> itself. You must ensure that
<SAMP>target</SAMP> addresses valid storage throughout the
lifetime of the dictionary. This function copies references
to all the key/value pairs in <SAMP>dict</SAMP>, but the
contents addressed by the key/value pointers are <I>not</I>
copied. This function also copies the
<CODE>HashFunc</CODE>, <CODE>HashSize</CODE>, and
<CODE>HashDensity</CODE> attributes of <SAMP>dict</SAMP>.
</DD></DL>
<P>
<A NAME="vdictCreate"><HR><H4>vdictCreate</H4></A>
<PRE>
        vdict * <B>vdictCreate</B>(
                vnameHashFunc hashFunc);
</PRE>

<DL><DD>
Creates a new dictionary with the default hash size and the
hash function <SAMP>hashFunc</SAMP> and returns a pointer
to its contents.The Dictionary Manager allocates space to
store the dictionary structure, this space is freed when
the dictionary is destroyed with <CODE><A HREF="vdict-x.html#vdictDestroy"><CODE>vdictDestroy</CODE></A></CODE>.
<SAMP>hashFunc</SAMP> should be <CODE><A HREF="vname-x.html#vnameHash"><CODE>vnameHash</CODE></A></CODE> if
the keys of the dictionary are all Name Manager
identifiers, or <CODE><A HREF="vname-x.html#vnameHashString"><CODE>vnameHashString</CODE></A></CODE> if the keys
are all character strings. Use
<CODE><A HREF="vdict-x.html#vdictSetHashSize"><CODE>vdictSetHashSize</CODE></A></CODE> to expand the dictionary if a
hash size larger than the default size is desired.
Expanding the dictionary before adding a large number of
keys may result in better performance. This function
essentially allocates space for a new dictionary and calls
<CODE><A HREF="vdict-x.html#vdictInit"><CODE>vdictInit</CODE></A></CODE> on it.
</DD></DL>
<P>
<A NAME="vdictCreateSafe"><HR><H4>vdictCreateSafe</H4></A>
<PRE>
        vdictSafe * <B>vdictCreateSafe</B>(
                vnameHashFunc hashFunc);
</PRE>

<DL><DD>
Creates a potentially threadsafe dictionary.  A mutex may be attached to 
the dictionary with <CODE><A HREF="vdict-x.html#vdictSetSafeMutex"><CODE>vdictSetSafeMutex</CODE></A></CODE> so that mutiple 
threads may safely access and modify the dictionary simulaneously. See 
<CODE>vdictCreate</CODE> for more details.
</DD></DL>
<P>
<A NAME="vdictDestroy"><HR><H4>vdictDestroy</H4></A>
<PRE>
        void <B>vdictDestroy</B>(
                vdict * dict);
</PRE>

<DL><DD>
Destroys the dictionary represented by <SAMP>dict</SAMP>,
which must have been created or initialized by a Dictionary
Manager function. Use this function to reclaim the storage
occupied by a dictionary. The dictionary should not be
referenced by any other object when it is destroyed. This
function attempts to free the storage occupied by
<SAMP>dict</SAMP> only if it was created by
<CODE><A HREF="vdict-x.html#vdictCreate"><CODE>vdictCreate</CODE></A></CODE> or <CODE><A HREF="vdict-x.html#vdictClone"><CODE>vdictClone</CODE></A></CODE>. This
function does not destroy any of the objects addressed by
the dictionary's key/value pointers.
    <P>
</DD></DL>
<P>
<A NAME="vdictDestroyIterator"><HR><H4>vdictDestroyIterator</H4></A>
<PRE>
        void <B>vdictDestroyIterator</B>(
                vdictIterator * iterator);
</PRE>

<DL><DD>
Terminates the iteration represented by
<SAMP>iterator</SAMP>, even if it is not yet exhausted.
This function is necessary to reclaim internal iteration
objects allocated by the Dictionary Manager.
</DD></DL>
<P>
<A NAME="vdictDestroyKeyIterator"><HR><H4>vdictDestroyKeyIterator</H4></A>
<PRE>
        void <B>vdictDestroyKeyIterator</B>(
                vdictKeyIterator * iterator);
</PRE>

<DL><DD>

Destroys a key iterator.  Call this after you are finished iterating
over the values stored under a particular key.

</DD></DL>
<P>
<A NAME="vdictDestroySafe"><HR><H4>vdictDestroySafe</H4></A>
<PRE>
        void <B>vdictDestroySafe</B>(
                vdictSafe * dict);
</PRE>

<DL><DD>
Destroys a threadsafe dictionary.  See <CODE>vdictDestroy</CODE> for more 
information. 
</DD></DL>
<P>
<A NAME="vdictDump"><HR><H4>vdictDump</H4></A>
<PRE>
        void <B>vdictDump</B>(
                vdict * dict,
                FILE * stream);
</PRE>

<DL><DD>
Prints the contents of the dictionary <SAMP>dict</SAMP> on
the file <SAMP>stream</SAMP> in user-readable form. This
function is intended for debugging and should not be used
to store the contents of the dictionary in recoverable
form. This function has effect only if debugging is
enabled.
    <P>
</DD></DL>
<P>
<A NAME="vdictGetHashDensity"><HR><H4>vdictGetHashDensity</H4></A>
<PRE>
        unsigned <B>vdictGetHashDensity</B>(
                vdict * dict);
</PRE>

<DL><DD>
Returns the hash density for the dictionary
<SAMP>dict</SAMP>. This value is never less than one.
</DD></DL>
<P>
<A NAME="vdictGetHashFunc"><HR><H4>vdictGetHashFunc</H4></A>
<PRE>
        vnameHashFunc <B>vdictGetHashFunc</B>(
                vdict * dict);
</PRE>

<DL><DD>
Returns the hash function for the dictionary
<SAMP>dict</SAMP>. This function is specified when a
dictionary is created and remains invariant throughout its
lifetime. To change a dictionary hash function, you must
create a new dictionary with the new hash function and copy
the contents of the existing dictionary into it (refer to
<CODE><A HREF="vdict-x.html#vdictCopy"><CODE>vdictCopy</CODE></A></CODE>).
</DD></DL>
<P>
<A NAME="vdictGetHashSize"><HR><H4>vdictGetHashSize</H4></A>
<PRE>
        unsigned long <B>vdictGetHashSize</B>(
                vdict * dict);
</PRE>

<DL><DD>
Returns the hash size of the dictionary <SAMP>dict</SAMP>.
This is the number of spaces allocated for the hash table,
regardless of how many items it actually contains. This
value may be larger than a hash size set by
<CODE><A HREF="vdict-x.html#vdictSetHashSize"><CODE>vdictSetHashSize</CODE></A></CODE> if the requested hash size is
not large enough to contain the contents of the dictionary.
</DD></DL>
<P>
<A NAME="vdictGetIteratorFloat"><HR><H4>vdictGetIteratorFloat</H4></A>
<PRE>
        double <B>vdictGetIteratorFloat</B>(
                vdictIterator * iterator);
</PRE>

<DL><DD>
Returns the value of the key/value pair indexed by the
iterator <SAMP>iterator</SAMP> as a floating-point value.
This function should be called only after
<CODE><A HREF="vdict-x.html#vdictNextIterator"><CODE>vdictNextIterator</CODE></A></CODE> has returned
<SAMP>TRUE</SAMP>. Note that the order in which key/value
pairs are iterated is arbitrary. The value returned by this
function is meaningless if the value was stored by
<CODE><A HREF="vdict-x.html#vdictStore"><CODE>vdictStore</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdictGetIteratorKey"><HR><H4>vdictGetIteratorKey</H4></A>
<PRE>
        const void * <B>vdictGetIteratorKey</B>(
                vdictIterator * iterator);
</PRE>

<DL><DD>
Returns the key of the key/value pair indexed by the
iterator <SAMP>iterator</SAMP>. This function should be
called only after <CODE><A HREF="vdict-x.html#vdictNextIterator"><CODE>vdictNextIterator</CODE></A></CODE> has
returned <SAMP>TRUE</SAMP>. Note that the order in which
key/value pairs are iterated is arbitrary.
</DD></DL>
<P>
<A NAME="vdictGetIteratorScalar"><HR><H4>vdictGetIteratorScalar</H4></A>
<PRE>
        long <B>vdictGetIteratorScalar</B>(
                vdictIterator * iterator);
</PRE>

<DL><DD>
Returns the value of the key/value pair indexed by the
iterator <SAMP>iterator</SAMP> as a scalar. This function
should be called only after <CODE><A HREF="vdict-x.html#vdictNextIterator"><CODE>vdictNextIterator</CODE></A></CODE>
has returned <SAMP>TRUE</SAMP>. Note that the order in
which key/value pairs are iterated is arbitrary. The value
returned by this function is meaningless if the value was
stored by <CODE><A HREF="vdict-x.html#vdictStore"><CODE>vdictStore</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdictGetIteratorValue"><HR><H4>vdictGetIteratorValue</H4></A>
<PRE>
        const void * <B>vdictGetIteratorValue</B>(
                vdictIterator * iterator);
</PRE>

<DL><DD>
Returns the value of the key/value pair indexed by the
iterator <SAMP>iterator</SAMP> as a pointer. This function
should be called only after <CODE><A HREF="vdict-x.html#vdictNextIterator"><CODE>vdictNextIterator</CODE></A></CODE>
has returned <SAMP>TRUE</SAMP>. Note that the order in
which key/value pairs are iterated is arbitrary. The value
returned by this function is meaningless if the value was
stored by <CODE><A HREF="vdict-x.html#vdictStoreScalar"><CODE>vdictStoreScalar</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdictGetKeyIteratorFloat"><HR><H4>vdictGetKeyIteratorFloat</H4></A>
<PRE>
        double <B>vdictGetKeyIteratorFloat</B>(
                vdictKeyIterator * iterator);
</PRE>

<DL><DD>
Returns a floating point value stored under the key iterator's key.  This
should only be called if the values in the dictionary were stored with 
<CODE><A HREF="vdict-x.html#vdictAddFloat"><CODE>vdictAddFloat</CODE></A></CODE> or <CODE><A HREF="vdict-x.html#vdictStoreFloat"><CODE>vdictStoreFloat</CODE></A></CODE>. 
</DD></DL>
<P>
<A NAME="vdictGetKeyIteratorScalar"><HR><H4>vdictGetKeyIteratorScalar</H4></A>
<PRE>
        long <B>vdictGetKeyIteratorScalar</B>(
                vdictKeyIterator * iterator);
</PRE>

<DL><DD>
Returns a scalar value stored under the key iterator's key.  This
should only be called if the values in the dictionary were stored with 
<CODE><A HREF="vdict-x.html#vdictAddScalar"><CODE>vdictAddScalar</CODE></A></CODE> or <CODE><A HREF="vdict-x.html#vdictStoreScalar"><CODE>vdictStoreScalar</CODE></A></CODE>. 
</DD></DL>
<P>
<A NAME="vdictGetKeyIteratorValue"><HR><H4>vdictGetKeyIteratorValue</H4></A>
<PRE>
        const void * <B>vdictGetKeyIteratorValue</B>(
                vdictKeyIterator * iterator);
</PRE>

<DL><DD>
Returns a value stored under the key iterator's key.  This
should only be called if the values in the dictionary were stored with 
<CODE><A HREF="vdict-x.html#vdictAdd"><CODE>vdictAdd</CODE></A></CODE> or <CODE><A HREF="vdict-x.html#vdictStore"><CODE>vdictStore</CODE></A></CODE>. 
</DD></DL>
<P>
<A NAME="vdictGetSafeMutex"><HR><H4>vdictGetSafeMutex</H4></A>
<PRE>
        vmutex * <B>vdictGetSafeMutex</B>(
                vdictSafe * dict);
</PRE>

<DL><DD>
Returns the locking mutex associated with threadsafe dictionary.  Returns
<CODE>NULL</CODE> if no mutex is associated with the dictionary.
</DD></DL>
<P>
<A NAME="vdictGetSafeUnsafe"><HR><H4>vdictGetSafeUnsafe</H4></A>
<PRE>
        vdict * <B>vdictGetSafeUnsafe</B>(
                vdictSafe * dict);
</PRE>

<DL><DD>
Returns the non-threadsafe dictionary which is used as the basis of the given
threadsafe dictionary.
</DD></DL>
<P>
<A NAME="vdictGetSize"><HR><H4>vdictGetSize</H4></A>
<PRE>
        unsigned long <B>vdictGetSize</B>(
                vdict * dict);
</PRE>

<DL><DD>
Returns the number of key/value pairs in the dictionary
<SAMP>dict</SAMP>. This value may be zero.
</DD></DL>
<P>
<A NAME="vdictHashGeneric"><HR><H4>vdictHashGeneric</H4></A>
<PRE>
        unsigned long <B>vdictHashGeneric</B>(
                const void * p);
</PRE>

<DL><DD>
Returns an integer hash value for the generic pointer
<SAMP>p</SAMP>.
</DD></DL>
<P>
<A NAME="vdictInit"><HR><H4>vdictInit</H4></A>
<PRE>
        void <B>vdictInit</B>(
                vdict * dict,
                vnameHashFunc hashFunc);
</PRE>

<DL><DD>
Initializes a dictionary with the default hash size and the
hash function <SAMP>hashFunc</SAMP> in the uninitialized
memory addressed by <SAMP>dict</SAMP>. If <SAMP>dict</SAMP>
is destroyed with <CODE><A HREF="vdict-x.html#vdictDestroy"><CODE>vdictDestroy</CODE></A></CODE>, the Dictionary
Manager frees any storage it allocated internally, but it
does not attempt to free <SAMP>dict</SAMP> itself. You must
ensure that <SAMP>dict</SAMP> addresses valid storage
throughout the lifetime of the dictionary. 
<SAMP>hashFunc</SAMP> should be <CODE><A HREF="vname-x.html#vnameHash"><CODE>vnameHash</CODE></A></CODE> if
the keys of the dictionary are all Name Manager identifiers
or <CODE><A HREF="vname-x.html#vnameHashString"><CODE>vnameHashString</CODE></A></CODE> if the keys are all
character strings. Use <CODE><A HREF="vdict-x.html#vdictSetHashSize"><CODE>vdictSetHashSize</CODE></A></CODE> to
expand the dictionary if a hash size larger than the
default size is desired. Expanding the dictionary before
adding a large number of keys may result in better
performance.
</DD></DL>
<P>
<A NAME="vdictInitIterator"><HR><H4>vdictInitIterator</H4></A>
<PRE>
        void <B>vdictInitIterator</B>(
                vdictIterator * iterator,
                vdict * dict);
</PRE>

<DL><DD>
Begins an iteration of all the key/value pairs in the
dictionary <SAMP>dict</SAMP> by initializing the iterator
object <SAMP>iterator</SAMP>. The iterator initially
contains no key/value pair. <CODE><A HREF="vdict-x.html#vdictNextIterator"><CODE>vdictNextIterator</CODE></A></CODE>
must be called to obtain the first key/value pair. Note
that the order in which pairs are iterated is arbitrary.
</DD></DL>
<P>
<A NAME="vdictInitKeyIterator"><HR><H4>vdictInitKeyIterator</H4></A>
<PRE>
        void <B>vdictInitKeyIterator</B>(
                vdictKeyIterator * iterator,
                vdict * dict,
                const void * value);
</PRE>

<DL><DD>
Initializes a key iterator to iterate over all of the values stored under the
given key. Use this if you are storing multiple values under the same key,
with <CODE><A HREF="vdict-x.html#vdictAdd"><CODE>vdictAdd</CODE></A></CODE>, <CODE><A HREF="vdict-x.html#vdictAddScalar"><CODE>vdictAddScalar</CODE></A></CODE>, 
or <CODE><A HREF="vdict-x.html#vdictAddFloat"><CODE>vdictAddFloat</CODE></A></CODE>
</DD></DL>
<P>
<A NAME="vdictInitSafe"><HR><H4>vdictInitSafe</H4></A>
<PRE>
        void <B>vdictInitSafe</B>(
                vdictSafe * dict,
                vnameHashFunc hashFunc);
</PRE>

<DL><DD>
Initializes a potentially threadsafe dictionary.  A mutex may be attached to 
the dictionary with <CODE><A HREF="vdict-x.html#vdictSetSafeMutex"><CODE>vdictSetSafeMutex</CODE></A></CODE> so that mutiple 
threads may safely access and modify the dictionary simulaneously. See 
<CODE>vdictInit</CODE> for more details.
</DD></DL>
<P>
<A NAME="vdictLoad"><HR><H4>vdictLoad</H4></A>
<PRE>
        const void * <B>vdictLoad</B>(
                vdict * dict,
                const void * key);
</PRE>

<DL><DD>
Returns the value associated with the key <SAMP>key</SAMP>
in the dictionary <SAMP>dict</SAMP>. The address of each
key must be unique, because the pointers are compared
directly (use the Name Manager to get unique pointers for
character strings). <CODE>vdictLoad</CODE> loads a pointer
value and <CODE><A HREF="vdict-x.html#vdictLoadScalar"><CODE>vdictLoadScalar</CODE></A></CODE> loads a scalar (long
integer) value. Returns <SAMP>NULL</SAMP> (pointer) or
<SAMP>LONG_MIN</SAMP> (scalar) if the key cannot be found
in the dictionary. Values stored with
<CODE><A HREF="vdict-x.html#vdictStoreScalar"><CODE>vdictStoreScalar</CODE></A></CODE> are meaningless if read with
<CODE>vdictLoad</CODE> and vice versa. This function
generates <CODE><A HREF="vex-x.html#vexArgNullException"><CODE>vexArgNullException</CODE></A></CODE> if key is
<SAMP>NULL</SAMP>.
    <P>
If multiple values were stored under the given key with 
<CODE><A HREF="vdict-x.html#vdictAdd"><CODE>vdictAdd</CODE></A></CODE>, an arbitrary member of the set of such values is
returned. 
</DD></DL>
<P>
<A NAME="vdictLoadFloat"><HR><H4>vdictLoadFloat</H4></A>
<PRE>
        double <B>vdictLoadFloat</B>(
                vdict * dict,
                const void * key);
</PRE>

<DL><DD>
Returns the value associated with the key <SAMP>key</SAMP>
in the dictionary <SAMP>dict</SAMP>. The address of each
key must be unique, because the pointers are compared
directly (use the Name Manager to get unique pointers for
character strings). <CODE>vdictLoad</CODE> reads a pointer
value and <CODE>vdictLoadFloat</CODE> loads a
floating-point value. It returns <SAMP>NULL</SAMP>
(pointer) or <SAMP>vdictNULL_FLOAT</SAMP> (floating-point)
if the key cannot be found in the dictionary. Values stored
with <CODE><A HREF="vdict-x.html#vdictStoreFloat"><CODE>vdictStoreFloat</CODE></A></CODE> are meaningless if read
with <CODE>vdictLoad</CODE> and vice versa. This function
generates <CODE><A HREF="vex-x.html#vexArgNullException"><CODE>vexArgNullException</CODE></A></CODE> if key is
<SAMP>NULL</SAMP>.
    <P>
If multiple values were stored under the given key with 
<CODE><A HREF="vdict-x.html#vdictAddFloat"><CODE>vdictAddFloat</CODE></A></CODE>, an arbitrary member of the set of such values is
returned. 
</DD></DL>
<P>
<A NAME="vdictLoadSafe"><HR><H4>vdictLoadSafe</H4></A>
<PRE>
        const void * <B>vdictLoadSafe</B>(
                vdictSafe * dict,
                const void * key);
</PRE>

<DL><DD>
Returns the value associated with a key in a threadsafe dictionary. See
<CODE>vdictLoad</CODE> for more information.
</DD></DL>
<P>
<A NAME="vdictLoadSafeFloat"><HR><H4>vdictLoadSafeFloat</H4></A>
<PRE>
        double <B>vdictLoadSafeFloat</B>(
                vdictSafe * dict,
                const void * key);
</PRE>

<DL><DD>
Returns the value associated with a key in a threadsafe dictionary. See
<CODE><A HREF="vdict-x.html#vdictLoadFloat"><CODE>vdictLoadFloat</CODE></A></CODE> for more information.
</DD></DL>
<P>
<A NAME="vdictLoadSafeScalar"><HR><H4>vdictLoadSafeScalar</H4></A>
<PRE>
        long <B>vdictLoadSafeScalar</B>(
                vdictSafe * dict,
                const void * key);
</PRE>

<DL><DD>
Returns the scalar value associated with a key in a 
threadsafe dictionary. See <CODE><A HREF="vdict-x.html#vdictLoadScalar"><CODE>vdictLoadScalar</CODE></A></CODE> for 
more information.
</DD></DL>
<P>
<A NAME="vdictLoadScalar"><HR><H4>vdictLoadScalar</H4></A>
<PRE>
        long <B>vdictLoadScalar</B>(
                vdict * dict,
                const void * key);
</PRE>

<DL><DD>
Returns the value associated with the key <SAMP>key</SAMP>
in the dictionary <SAMP>dict</SAMP>. The address of each
key must be unique, because the pointers are compared
directly (use the Name Manager to get unique pointers for
character strings). <CODE>vdictLoad</CODE> loads a pointer
value and <CODE>vdictLoadScalar</CODE> loads a scalar (long
integer) value. Returns <SAMP>NULL</SAMP> (pointer) or
<SAMP>vdictNULL_SCALAR</SAMP> (scalar) if the key cannot be
found in the dictionary. Values stored with
<CODE><A HREF="vdict-x.html#vdictStoreScalar"><CODE>vdictStoreScalar</CODE></A></CODE> are meaningless if read with
<CODE>vdictLoad</CODE> and vice versa. This function
generates <CODE><A HREF="vex-x.html#vexArgNullException"><CODE>vexArgNullException</CODE></A></CODE> if key is
<SAMP>NULL</SAMP>.
    <P>
If multiple values were stored under the given key with 
<CODE><A HREF="vdict-x.html#vdictAddScalar"><CODE>vdictAddScalar</CODE></A></CODE>, an arbitrary member of the set of such values is
returned. 
</DD></DL>
<P>
<A NAME="vdictLockSafeAndGetUnsafe"><HR><H4>vdictLockSafeAndGetUnsafe</H4></A>
<PRE>
        vdict * <B>vdictLockSafeAndGetUnsafe</B>(
                vdictSafe * dict);
</PRE>

<DL><DD>
Locks the safe dictionary's mutex (if any), and returns the unsafe 
dictionary contained within.
This entry point, paired with <CODE><A HREF="vdict-x.html#vdictUnlockSafe"><CODE>vdictUnlockSafe</CODE></A></CODE>, is used as the 
implementation basis of many of the <CODE><A HREF="vdict-x.html#vdictSafe"><CODE>vdictSafe</CODE></A></CODE> entry points.
</DD></DL>
<P>
<A NAME="vdictNextIterator"><HR><H4>vdictNextIterator</H4></A>
<PRE>
        int <B>vdictNextIterator</B>(
                vdictIterator * iterator);
</PRE>

<DL><DD>
Performs the next step of the iteration represented by
<SAMP>iterator</SAMP> and returns <SAMP>TRUE</SAMP> if a
key/value pair is available, <SAMP>FALSE</SAMP> if not. The
particular key and value can be read from the iterator with
<CODE><A HREF="vdict-x.html#vdictGetIteratorKey"><CODE>vdictGetIteratorKey</CODE></A></CODE> and
<CODE><A HREF="vdict-x.html#vdictGetIteratorValue"><CODE>vdictGetIteratorValue</CODE></A></CODE>, respectively. For
example, the following code fragment prints all the
key/value pointers in a dictionary.
    <P>
<BLOCKQUOTE>


<PRE>

vdict        *dict;    /* contains a dictionary */
<A HREF="vdict-x.html#vdictIterator"><CODE>vdictIterator</CODE></A> iterator;

<A HREF="vdict-x.html#vdictInitIterator"><CODE>vdictInitIterator</CODE></A>(&iterator, dict);

while (vdictNextIterator(&iterator))
    printf(key(%p) value(%p)\n, <A HREF="vdict-x.html#vdictGetIteratorKey"><CODE>vdictGetIteratorKey</CODE></A>(&iterator),
           <A HREF="vdict-x.html#vdictGetIteratorValue"><CODE>vdictGetIteratorValue</CODE></A>(&iterator));

<A HREF="vdict-x.html#vdictDestroyIterator"><CODE>vdictDestroyIterator</CODE></A>(&iterator);

</PRE>
</BLOCKQUOTE>
</DD></DL>
<P>
<A NAME="vdictNextKeyIterator"><HR><H4>vdictNextKeyIterator</H4></A>
<PRE>
        int <B>vdictNextKeyIterator</B>(
                vdictKeyIterator * iterator);
</PRE>

<DL><DD>
Advances the key iterator to the next value stored under the key.  Returns
<CODE>FALSE</CODE> if there are no more value.
</DD></DL>
<P>
<A NAME="vdictRemove"><HR><H4>vdictRemove</H4></A>
<PRE>
        void <B>vdictRemove</B>(
                vdict * dict,
                const void * key);
</PRE>

<DL><DD>
Removes the key pointer <SAMP>key</SAMP> from the
dictionary <SAMP>dict</SAMP> along with its associated
value (pointer or scalar). This function frees the space
occupied by the key and value pointers in the dictionary,
but it does <I>not</I> free  the objects they are pointing
to. Other values may have to be relocated to preserve the
integrity of the hash table (the time required to do this
is significantly longer than storing or loading a key). It
is also possible to store the value <SAMP>NULL</SAMP>
(pointer) or <SAMP>LONG_MIN</SAMP> (scalar) under the key.
This has an effect similar to <CODE>vdictRemove</CODE> and
is faster, but the space occupied by the key is not
recovered. This function generates
<CODE><A HREF="vex-x.html#vexArgNullException"><CODE>vexArgNullException</CODE></A></CODE> if key is
<SAMP>NULL</SAMP> and <CODE><A HREF="vex-x.html#vexArgException"><CODE>vexArgException</CODE></A></CODE> if
<SAMP>key</SAMP> is not present in <SAMP>dict</SAMP>. This
routine should not be used while iterating over a
dictionary, the iterator may become corrupted.
    <P>
If multiple values were stored under the given key with 
<CODE><A HREF="vdict-x.html#vdictAdd"><CODE>vdictAdd</CODE></A></CODE>, an arbitrary member of the set of such values is
removed. Use <CODE><A HREF="vdict-x.html#vdictRemoveValue"><CODE>vdictRemoveValue</CODE></A></CODE> to remove a particular value.
</DD></DL>
<P>
<A NAME="vdictRemoveFloat"><HR><H4>vdictRemoveFloat</H4></A>
<PRE>
        void <B>vdictRemoveFloat</B>(
                vdict * dict,
                const void * key,
                double value);
</PRE>

<DL><DD>
Removes the given floating point value stored under the given key. Generates
an <CODE>vexArg</CODE> exception if no such value is stored under the given
key.  This entry point is useful when you have stored multiple values under
the same key in the dictionary with <CODE><A HREF="vdict-x.html#vdictAddFloat"><CODE>vdictAddFloat</CODE></A></CODE>.
    <P>
If multiple values were stored under the given key with 
<CODE><A HREF="vdict-x.html#vdictAddFloat"><CODE>vdictAddFloat</CODE></A></CODE>, an arbitrary member of the set of such values is
removed. Use <CODE>vdictRemoveFloat</CODE> to remove a particular value.
</DD></DL>
<P>
<A NAME="vdictRemoveSafe"><HR><H4>vdictRemoveSafe</H4></A>
<PRE>
        void <B>vdictRemoveSafe</B>(
                vdictSafe * dict,
                const void * key);
</PRE>

<DL><DD>
Removes a value from a threadsafe dictionary. See
<CODE>vdictRemove</CODE> for more information. 
</DD></DL>
<P>
<A NAME="vdictRemoveScalar"><HR><H4>vdictRemoveScalar</H4></A>
<PRE>
        void <B>vdictRemoveScalar</B>(
                vdict * dict,
                const void * key,
                long value);
</PRE>

<DL><DD>
Removes the given scalar value stored under the given key. Generates
an <CODE>vexArg</CODE> exception if no such value is stored under the given
key.  This entry point is useful when you have stored multiple values under
the same key in the dictionary with <CODE><A HREF="vdict-x.html#vdictAddScalar"><CODE>vdictAddScalar</CODE></A></CODE>.
    <P>
If multiple values were stored under the given key with 
<CODE><A HREF="vdict-x.html#vdictAddScalar"><CODE>vdictAddScalar</CODE></A></CODE>, an arbitrary member of the set of such values is
removed. Use <CODE>vdictRemoveScalar</CODE> to remove a particular value.
</DD></DL>
<P>
<A NAME="vdictRemoveValue"><HR><H4>vdictRemoveValue</H4></A>
<PRE>
        void <B>vdictRemoveValue</B>(
                vdict * dict,
                const void * key,
                const void * value);
</PRE>

<DL><DD>
Removes the given value stored under the given key. Generates
an <CODE>vexArg</CODE> exception if no such value is stored under the given
key.  This entry point is useful when you have stored multiple values under
the same key in the dictionary with <CODE><A HREF="vdict-x.html#vdictAdd"><CODE>vdictAdd</CODE></A></CODE>.
</DD></DL>
<P>
<A NAME="vdictSetHashDensity"><HR><H4>vdictSetHashDensity</H4></A>
<PRE>
        void <B>vdictSetHashDensity</B>(
                vdict * dict,
                unsigned hashDensity);
</PRE>

<DL><DD>
Changes the hash density of the dictionary
<SAMP>dict</SAMP> to <SAMP>hashDensity</SAMP>. The hash
density is the ratio of non-null keys in a dictionary to
null keys. Null keys are stored in a dictionary to place an
upper bound on the number of comparisons required to match
a given key. High density dictionaries are more compact,
but low density dictionaries require fewer comparisons to
load or store a value. A <CODE><A HREF="vex-x.html#vexArgRangeException"><CODE>vexArgRangeException</CODE></A></CODE>
is generated if <SAMP>hashDensity</SAMP> is less than one.
</DD></DL>
<P>
<A NAME="vdictSetHashSize"><HR><H4>vdictSetHashSize</H4></A>
<PRE>
        void <B>vdictSetHashSize</B>(
                vdict * dict,
                unsigned long hashSize);
</PRE>

<DL><DD>
Changes the hash size of the dictionary <SAMP>dict</SAMP>
to at least <SAMP>hashSize</SAMP> key/value pairs. The hash
size of the dictionary is set to a value larger than
<SAMP>hashSize</SAMP> if <SAMP>hashSize</SAMP> is not large
enough to hold all the dictionary key/value pairs, plus an
amount of empty space inversely proportional to the hash
density of the dictionary.
</DD></DL>
<P>
<A NAME="vdictSetSafeMutex"><HR><H4>vdictSetSafeMutex</H4></A>
<PRE>
        void <B>vdictSetSafeMutex</B>(
                vdictSafe * dict,
                vmutex * mutex);
</PRE>

<DL><DD>
Sets the mutex to lock when accessing the given threadsafe dictionary.  No
ownership of the mutex is taken -- the caller is responsible for destroying
the mutex when the dictionary is destroyed.  Note that the mutex may be shared
with other data structures, including other instances of
<CODE><A HREF="vdict-x.html#vdictSafe"><CODE>vdictSafe</CODE></A></CODE>, if desired.  May be called with <CODE>NULL</CODE> if
no locking is desired.
</DD></DL>
<P>
<A NAME="vdictStore"><HR><H4>vdictStore</H4></A>
<PRE>
        void <B>vdictStore</B>(
                vdict * dict,
                const void * key,
                const void * value);
</PRE>

<DL><DD>
Stores <SAMP>value</SAMP> in the dictionary
<SAMP>dict</SAMP> under the key pointer <SAMP>key</SAMP>.
The address of each key must be unique, because the
pointers are compared directly (use the Name Manager to get
unique pointers for character strings).
<CODE>vdictStore</CODE> stores a pointer value and
<CODE><A HREF="vdict-x.html#vdictStoreScalar"><CODE>vdictStoreScalar</CODE></A></CODE> stores a scalar (long
integer) value. If <SAMP>value</SAMP> is <SAMP>NULL</SAMP>
(pointer) or <SAMP>LONG_MIN</SAMP> (scalar), the Dictionary
Manager makes it appear as if the key was removed, but the
key still occupies space in the dictionary. This is faster,
but less space-efficient, than actually removing the key
(use <CODE><A HREF="vdict-x.html#vdictRemove"><CODE>vdictRemove</CODE></A></CODE> to actually remove the key
and value pointers). This function expands
<SAMP>dict</SAMP> if the ratio of non-null keys to null
keys exceeds the hash density of the dictionary (refer to
<CODE><A HREF="vdict-x.html#vdictSetHashDensity"><CODE>vdictSetHashDensity</CODE></A></CODE>). Values stored with
<CODE>vdictStore</CODE> are meaningless if read with
<CODE><A HREF="vdict-x.html#vdictLoadScalar"><CODE>vdictLoadScalar</CODE></A></CODE> and vice versa. This function
generates <CODE><A HREF="vex-x.html#vexArgNullException"><CODE>vexArgNullException</CODE></A></CODE> if key is
<SAMP>NULL</SAMP>.
</DD></DL>
<P>
<A NAME="vdictStoreFloat"><HR><H4>vdictStoreFloat</H4></A>
<PRE>
        void <B>vdictStoreFloat</B>(
                vdict * dict,
                const void * key,
                double value);
</PRE>

<DL><DD>
Stores <SAMP>value</SAMP> in the dictionary
<SAMP>dict</SAMP> under the key pointer <SAMP>key</SAMP>.
The address of each key must be unique, because the
pointers are compared directly (use the Name Manager to get
unique pointers for character strings).
<CODE>vdictStore</CODE> stores a pointer value and
<CODE>vdictStoreFloat</CODE> stores a floating-point value.
If <SAMP>value</SAMP> is <SAMP>NULL</SAMP> (pointer) or
<SAMP>vdictNULL_FLOAT</SAMP> (floating-point), the
Dictionary Manager makes it appear as if the key was
removed, but the key still occupies space in the
dictionary. This is faster, but less space-efficient, than
actually removing the key (use <CODE><A HREF="vdict-x.html#vdictRemove"><CODE>vdictRemove</CODE></A></CODE> to
actually remove the key and value pointers). This function
expands <SAMP>dict</SAMP> if the ratio of non-null keys to
null keys exceeds the hash density of the dictionary (refer
to <CODE><A HREF="vdict-x.html#vdictSetHashDensity"><CODE>vdictSetHashDensity</CODE></A></CODE>). Values stored with
<CODE>vdictStore</CODE> are meaningless if read with
<CODE><A HREF="vdict-x.html#vdictLoadFloat"><CODE>vdictLoadFloat</CODE></A></CODE> and vice versa. This function
generates <CODE><A HREF="vex-x.html#vexArgNullException"><CODE>vexArgNullException</CODE></A></CODE> if key is
<SAMP>NULL</SAMP>.
</DD></DL>
<P>
<A NAME="vdictStoreSafe"><HR><H4>vdictStoreSafe</H4></A>
<PRE>
        void <B>vdictStoreSafe</B>(
                vdictSafe * dict,
                const void * key,
                const void * value);
</PRE>

<DL><DD>
Stores a value into a threadsafe dictionary.  Set
<CODE>vdictStore<CODE> for more information.
</DD></DL>
<P>
<A NAME="vdictStoreSafeFloat"><HR><H4>vdictStoreSafeFloat</H4></A>
<PRE>
        void <B>vdictStoreSafeFloat</B>(
                vdictSafe * dict,
                const void * key,
                double value);
</PRE>

<DL><DD>
Stores a value into a threadsafe dictionary.  Set
<CODE><A HREF="vdict-x.html#vdictStoreFloat"><CODE>vdictStoreFloat</CODE></A><CODE> for more information.
</DD></DL>
<P>
<A NAME="vdictStoreSafeScalar"><HR><H4>vdictStoreSafeScalar</H4></A>
<PRE>
        void <B>vdictStoreSafeScalar</B>(
                vdictSafe * dict,
                const void * key,
                long value);
</PRE>

<DL><DD>
Stores a scalar value into a threadsafe dictionary.  Set
<CODE><A HREF="vdict-x.html#vdictStoreScalar"><CODE>vdictStoreScalar</CODE></A><CODE> for more information.
</DD></DL>
<P>
<A NAME="vdictStoreScalar"><HR><H4>vdictStoreScalar</H4></A>
<PRE>
        void <B>vdictStoreScalar</B>(
                vdict * dict,
                const void * key,
                long value);
</PRE>

<DL><DD>
Stores <SAMP>value</SAMP> in the dictionary
<SAMP>dict</SAMP> under the key pointer <SAMP>key</SAMP>.
The address of each key must be unique, because the
pointers are compared directly (use the Name Manager to get
unique pointers for character strings).
<CODE>vdictStore</CODE> stores a pointer value and
<CODE>vdictStoreScalar</CODE> stores a scalar (long
integer) value. If <SAMP>value</SAMP> is <SAMP>NULL</SAMP>
(pointer) or <SAMP>vdictNULL_SCALAR</SAMP> (scalar), the
Dictionary Manager makes it appear as if the key was
removed, but the key still occupies space in the
dictionary. This is faster, but less space-efficient, than
actually removing the key (use <CODE><A HREF="vdict-x.html#vdictRemove"><CODE>vdictRemove</CODE></A></CODE> to
actually remove the key and value pointers). This function
expands <SAMP>dict</SAMP> if the ratio of non-null keys to
null keys exceeds the hash density of the dictionary (refer
to <CODE><A HREF="vdict-x.html#vdictSetHashDensity"><CODE>vdictSetHashDensity</CODE></A></CODE>). Values stored with
<CODE>vdictStore</CODE> are meaningless if read with
<CODE><A HREF="vdict-x.html#vdictLoadScalar"><CODE>vdictLoadScalar</CODE></A></CODE> and vice versa. This function
generates <CODE><A HREF="vex-x.html#vexArgNullException"><CODE>vexArgNullException</CODE></A></CODE> if key is
<SAMP>NULL</SAMP>.
</DD></DL>
<P>
<A NAME="vdictUnlockSafe"><HR><H4>vdictUnlockSafe</H4></A>
<PRE>
        void <B>vdictUnlockSafe</B>(
                vdictSafe * dict);
</PRE>

<DL><DD>
Unlocks the safe dictionary's mutex (if any).  This entry point, paired 
with <CODE><A HREF="vdict-x.html#vdictLockSafeAndGetUnsafe"><CODE>vdictLockSafeAndGetUnsafe</CODE></A></CODE>, is used as the 
implementation basis of many of the <CODE><A HREF="vdict-x.html#vdictSafe"><CODE>vdictSafe</CODE></A></CODE> entry points.
</DD></DL>
<P>
<A NAME="section_Constant"><HR>
<CENTER><H2>Constants</H2></CENTER></A><P>
<A NAME="vdictINCLUDED"><HR><H4>vdictINCLUDED</H4></A>
<PRE>
        <B>vdictINCLUDED</B>
</PRE>

<DL><DD>
Defined when the header file <SAMP>vdict.h</SAMP> is
included.
</DD></DL>
<P>
<A NAME="vdictNULL_FLOAT"><HR><H4>vdictNULL_FLOAT</H4></A>
<PRE>
        <B>vdictNULL_FLOAT</B>
</PRE>

<DL><DD>
Returned by <CODE><A HREF="vdict-x.html#vdictLoadFloat"><CODE>vdictLoadFloat</CODE></A></CODE> if the desired key
is not in the dictionary.
</DD></DL>
<P>
<A NAME="vdictNULL_SCALAR"><HR><H4>vdictNULL_SCALAR</H4></A>
<PRE>
        <B>vdictNULL_SCALAR</B>
</PRE>

<DL><DD>
Returned by <CODE><A HREF="vdict-x.html#vdictLoadScalar"><CODE>vdictLoadScalar</CODE></A></CODE> if the desired key
is not in the dictionary.
</DD></DL>
<P>

<P>
<!--[[/CONTENT]]-->

<HR>

<TABLE WIDTH=100% BORDER="0" CELLPADDING="0" CELLSPACING="0">

	<TR BGCOLOR="#996666">
		<TD>
		<CENTER>
<!--[[NAVIGATE_ICONIC]]-->
<!--[[/NAVIGATE_ICONIC]]-->
		</CENTER>
		</TD>
		    
		<TD>
		<BR>
		<FONT SIZE=-1>
	        <A HREF="#Top">Top of This Page</A> <BR>
	        <A HREF="index.html">Table of Contents</A> <BR>
		<A HREF="../index.html">Switch to Another Document</A><BR>
		<BR>
		</FONT>
		</TD>

		<TD>
		<BR>
		<FONT SIZE=-1>
		Need help?
		<A HREF="../contact-visix.html">
		Contact Visix</A>.
		<BR> <BR>
	        <A HREF="../copyright.html">Copyright &#169; 1996-97</A>,
		<A HREF="http://www.visix.com/">Visix Software Inc.</A><BR>
		<BR>
		</FONT>
		</TD>

	</TR>

</TABLE>
		
</BODY>
</HTML>



